// The Module object: Our interface to the outside world. We import
// and export values on it, and do the work to get that through
// closure compiler if necessary. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to do an eval in order to handle the closure compiler
// case, where this code here is minified but Module was defined
// elsewhere (e.g. case 4 above). We also need to check if Module
// already exists (e.g. case 3 above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var i = 0;
var Module;

function newModule()
{
  Module = {
    'noInitialRun' : true,
    'noFSInit': true,
    'noExitRuntime': true,
    arguments : ['input.html'],
    currentStatus : '',
    preRun: function()
    {
	  // shouldRunNow = true;
    },
    postRun: function()
    {
       Module['calledRun'] = false;
       ABORT = false;
    },
    setStatus: function(text) {
      console.log( 'Module.currentStatus='+text );
      Module.currentStatus =  text;
    },
    totalDependencies: 0,
    monitorRunDependencies: function(left) {
      this.totalDependencies = Math.max(this.totalDependencies, left);
      Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
    }
  };
};

newModule();

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
for (var key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;

// Three configurations we can be running in:
// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)
// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)
// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)

if (Module['ENVIRONMENT']) {
  if (Module['ENVIRONMENT'] === 'WEB') {
    ENVIRONMENT_IS_WEB = true;
  } else if (Module['ENVIRONMENT'] === 'WORKER') {
    ENVIRONMENT_IS_WORKER = true;
  } else if (Module['ENVIRONMENT'] === 'NODE') {
    ENVIRONMENT_IS_NODE = true;
  } else if (Module['ENVIRONMENT'] === 'SHELL') {
    ENVIRONMENT_IS_SHELL = true;
  } else {
    throw new Error('The provided Module[\'ENVIRONMENT\'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.');
  }
} else {
  ENVIRONMENT_IS_WEB = typeof window === 'object';
  ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
  ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
  ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
}


if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  if (!Module['print']) Module['print'] = console.log;
  if (!Module['printErr']) Module['printErr'] = console.warn;

  var nodeFS;
  var nodePath;

  Module['read'] = function read(filename, binary) {
    if (!nodeFS) nodeFS = require('fs');
    if (!nodePath) nodePath = require('path');

    filename = nodePath['normalize'](filename);
    var ret = nodeFS['readFileSync'](filename);
    // The path is absolute if the normalized version is the same as the resolved.
    if (!ret && filename != nodePath['resolve'](filename)) {
      filename = path.join(__dirname, '..', 'src', filename);
      ret = nodeFS['readFileSync'](filename);
    }
    if (ret && !binary) ret = ret.toString();
    return ret;
  };

  Module['readBinary'] = function readBinary(filename) {
    var ret = Module['read'](filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };

  Module['load'] = function load(f) {
    globalEval(read(f));
  };

  if (!Module['thisProgram']) {
    if (process['argv'].length > 1) {
      Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
    } else {
      Module['thisProgram'] = 'unknown-program';
    }
  }

  Module['arguments'] = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  Module['inspect'] = function () { return '[Emscripten Module object]'; };
}
else if (ENVIRONMENT_IS_SHELL) {
  if (!Module['print']) Module['print'] = print;
  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm

  if (typeof read != 'undefined') {
    Module['read'] = read;
  } else {
    Module['read'] = function read() { throw 'no read() available (jsc?)' };
  }

  Module['readBinary'] = function readBinary(f) {
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    var data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    Module['arguments'] = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

}
else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  Module['read'] = function read(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  };

  Module['readAsync'] = function readAsync(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function xhr_onload() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
      } else {
        onerror();
      }
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };

  if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  if (typeof console !== 'undefined') {
    if (!Module['print']) Module['print'] = function print(x) {
      console.log(x);
    };
    if (!Module['printErr']) Module['printErr'] = function printErr(x) {
      console.warn(x);
    };
  } else {
    // Probably a worker, and without console.log. We can do very little here...
    var TRY_USE_DUMP = false;
    if (!Module['print']) Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postMessage(x); // enable this if you want stdout to be sent as messages
    }));
  }

  if (ENVIRONMENT_IS_WORKER) {
    Module['load'] = importScripts;
  }

  if (typeof Module['setWindowTitle'] === 'undefined') {
    Module['setWindowTitle'] = function(title) { document.title = title };
  }
}
else {
  // Unreachable because SHELL is dependant on the others
  throw 'Unknown runtime environment. Where are we?';
}

function globalEval(x) {
  eval.call(null, x);
}
if (!Module['load'] && Module['read']) {
  Module['load'] = function load(f) {
    globalEval(Module['read'](f));
  };
}
if (!Module['print']) {
  Module['print'] = function(){};
}
if (!Module['printErr']) {
  Module['printErr'] = Module['print'];
}
if (!Module['arguments']) {
  Module['arguments'] = [];
}
if (!Module['thisProgram']) {
  Module['thisProgram'] = './this.program';
}

// *** Environment setup code ***

// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];

// Callbacks
Module['preRun'] = [];
Module['postRun'] = [];

// Merge back in the overrides
for (var key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = undefined;



// {{PREAMBLE_ADDITIONS}}

// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

//========================================
// Runtime code shared with compiler
//========================================

var Runtime = {
  setTempRet0: function (value) {
    tempRet0 = value;
  },
  getTempRet0: function () {
    return tempRet0;
  },
  stackSave: function () {
    return STACKTOP;
  },
  stackRestore: function (stackTop) {
    STACKTOP = stackTop;
  },
  getNativeTypeSize: function (type) {
    switch (type) {
      case 'i1': case 'i8': return 1;
      case 'i16': return 2;
      case 'i32': return 4;
      case 'i64': return 8;
      case 'float': return 4;
      case 'double': return 8;
      default: {
        if (type[type.length-1] === '*') {
          return Runtime.QUANTUM_SIZE; // A pointer
        } else if (type[0] === 'i') {
          var bits = parseInt(type.substr(1));
          assert(bits % 8 === 0);
          return bits/8;
        } else {
          return 0;
        }
      }
    }
  },
  getNativeFieldSize: function (type) {
    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
  },
  STACK_ALIGN: 16,
  prepVararg: function (ptr, type) {
    if (type === 'double' || type === 'i64') {
      // move so the load is aligned
      if (ptr & 7) {
        assert((ptr & 7) === 4);
        ptr += 4;
      }
    } else {
      assert((ptr & 3) === 0);
    }
    return ptr;
  },
  getAlignSize: function (type, size, vararg) {
    // we align i64s and doubles on 64-bit boundaries, unlike x86
    if (!vararg && (type == 'i64' || type == 'double')) return 8;
    if (!type) return Math.min(size, 8); // align structures internally to 64 bits
    return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE);
  },
  dynCall: function (sig, ptr, args) {
    if (args && args.length) {
      if (!args.splice) args = Array.prototype.slice.call(args);
      args.splice(0, 0, ptr);
      return Module['dynCall_' + sig].apply(null, args);
    } else {
      return Module['dynCall_' + sig].call(null, ptr);
    }
  },
  functionPointers: [],
  addFunction: function (func) {
    for (var i = 0; i < Runtime.functionPointers.length; i++) {
      if (!Runtime.functionPointers[i]) {
        Runtime.functionPointers[i] = func;
        return 2*(1 + i);
      }
    }
    throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';
  },
  removeFunction: function (index) {
    Runtime.functionPointers[(index-2)/2] = null;
  },
  warnOnce: function (text) {
    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
    if (!Runtime.warnOnce.shown[text]) {
      Runtime.warnOnce.shown[text] = 1;
      Module.printErr(text);
    }
  },
  funcWrappers: {},
  getFuncWrapper: function (func, sig) {
    assert(sig);
    if (!Runtime.funcWrappers[sig]) {
      Runtime.funcWrappers[sig] = {};
    }
    var sigCache = Runtime.funcWrappers[sig];
    if (!sigCache[func]) {
      sigCache[func] = function dynCall_wrapper() {
        return Runtime.dynCall(sig, func, arguments);
      };
    }
    return sigCache[func];
  },
  getCompilerSetting: function (name) {
    throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work';
  },
  stackAlloc: function (size) { var ret = STACKTOP;STACKTOP = (STACKTOP + size)|0;STACKTOP = (((STACKTOP)+15)&-16); return ret; },
  staticAlloc: function (size) { var ret = STATICTOP;STATICTOP = (STATICTOP + size)|0;STATICTOP = (((STATICTOP)+15)&-16); return ret; },
  dynamicAlloc: function (size) { var ret = DYNAMICTOP;DYNAMICTOP = (DYNAMICTOP + size)|0;DYNAMICTOP = (((DYNAMICTOP)+15)&-16); if (DYNAMICTOP >= TOTAL_MEMORY) { var success = enlargeMemory(); if (!success) { DYNAMICTOP = ret;  return 0; } }; return ret; },
  alignMemory: function (size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 16))*(quantum ? quantum : 16); return ret; },
  makeBigInt: function (low,high,unsigned) { var ret = (unsigned ? ((+((low>>>0)))+((+((high>>>0)))*(+4294967296))) : ((+((low>>>0)))+((+((high|0)))*(+4294967296)))); return ret; },
  GLOBAL_BASE: 8,
  QUANTUM_SIZE: 4,
  __dummy__: 0
}



Module["Runtime"] = Runtime;



//========================================
// Runtime essentials
//========================================

var ABORT = false; // whether we are quitting the application. no code should run after this. set in exit() and abort()
var EXITSTATUS = 0;

function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

var globalScope = this;

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  if (!func) {
    try { func = eval('_' + ident); } catch(e) {}
  }
  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');
  return func;
}

var cwrap, ccall;
(function(){
  var JSfuncs = {
    // Helpers for cwrap -- it can't refer to Runtime directly because it might
    // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find
    // out what the minified function name is.
    'stackSave': function() {
      Runtime.stackSave()
    },
    'stackRestore': function() {
      Runtime.stackRestore()
    },
    // type conversion from js to c
    'arrayToC' : function(arr) {
      var ret = Runtime.stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    },
    'stringToC' : function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        ret = Runtime.stackAlloc((str.length << 2) + 1);
        writeStringToMemory(str, ret);
      }
      return ret;
    }
  };
  // For fast lookup of conversion functions
  var toC = {'string' : JSfuncs['stringToC'], 'array' : JSfuncs['arrayToC']};

  // C calling interface.
  ccall = function ccallFunc(ident, returnType, argTypes, args, opts) {
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0) stack = Runtime.stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func.apply(null, cArgs);
    if (returnType === 'string') ret = Pointer_stringify(ret);
    if (stack !== 0) {
      if (opts && opts.async) {
        EmterpreterAsync.asyncFinalizers.push(function() {
          Runtime.stackRestore(stack);
        });
        return;
      }
      Runtime.stackRestore(stack);
    }
    return ret;
  }

  var sourceRegex = /^function\s*[a-zA-Z$_0-9]*\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;
  function parseJSFunc(jsfunc) {
    // Match the body and the return value of a javascript function source
    var parsed = jsfunc.toString().match(sourceRegex).slice(1);
    return {arguments : parsed[0], body : parsed[1], returnValue: parsed[2]}
  }

  // sources of useful functions. we create this lazily as it can trigger a source decompression on this entire file
  var JSsource = null;
  function ensureJSsource() {
    if (!JSsource) {
      JSsource = {};
      for (var fun in JSfuncs) {
        if (JSfuncs.hasOwnProperty(fun)) {
          // Elements of toCsource are arrays of three items:
          // the code, and the return value
          JSsource[fun] = parseJSFunc(JSfuncs[fun]);
        }
      }
    }
  }

  cwrap = function cwrap(ident, returnType, argTypes) {
    argTypes = argTypes || [];
    var cfunc = getCFunc(ident);
    // When the function takes numbers and returns a number, we can just return
    // the original function
    var numericArgs = argTypes.every(function(type){ return type === 'number'});
    var numericRet = (returnType !== 'string');
    if ( numericRet && numericArgs) {
      return cfunc;
    }
    // Creation of the arguments list (["$1","$2",...,"$nargs"])
    var argNames = argTypes.map(function(x,i){return '$'+i});
    var funcstr = "(function(" + argNames.join(',') + ") {";
    var nargs = argTypes.length;
    if (!numericArgs) {
      // Generate the code needed to convert the arguments from javascript
      // values to pointers
      ensureJSsource();
      funcstr += 'var stack = ' + JSsource['stackSave'].body + ';';
      for (var i = 0; i < nargs; i++) {
        var arg = argNames[i], type = argTypes[i];
        if (type === 'number') continue;
        var convertCode = JSsource[type + 'ToC']; // [code, return]
        funcstr += 'var ' + convertCode.arguments + ' = ' + arg + ';';
        funcstr += convertCode.body + ';';
        funcstr += arg + '=(' + convertCode.returnValue + ');';
      }
    }

    // When the code is compressed, the name of cfunc is not literally 'cfunc' anymore
    var cfuncname = parseJSFunc(function(){return cfunc}).returnValue;
    // Call the function
    funcstr += 'var ret = ' + cfuncname + '(' + argNames.join(',') + ');';
    if (!numericRet) { // Return type can only by 'string' or 'number'
      // Convert the result to a string
      var strgfy = parseJSFunc(function(){return Pointer_stringify}).returnValue;
      funcstr += 'ret = ' + strgfy + '(ret);';
    }
    if (!numericArgs) {
      // If we had a stack, restore it
      ensureJSsource();
      funcstr += JSsource['stackRestore'].body.replace('()', '(stack)') + ';';
    }
    funcstr += 'return ret})';
    return eval(funcstr);
  };
})();
Module["ccall"] = ccall;
Module["cwrap"] = cwrap;

function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= (+1) ? (tempDouble > (+0) ? ((Math_min((+(Math_floor((tempDouble)/(+4294967296)))), (+4294967295)))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/(+4294967296))))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}
Module["setValue"] = setValue;


function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for setValue: ' + type);
    }
  return null;
}
Module["getValue"] = getValue;

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk
var ALLOC_NONE = 4; // Do not allocate
Module["ALLOC_NORMAL"] = ALLOC_NORMAL;
Module["ALLOC_STACK"] = ALLOC_STACK;
Module["ALLOC_STATIC"] = ALLOC_STATIC;
Module["ALLOC_DYNAMIC"] = ALLOC_DYNAMIC;
Module["ALLOC_NONE"] = ALLOC_NONE;

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [typeof _malloc === 'function' ? _malloc : Runtime.staticAlloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var ptr = ret, stop;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(slab, ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    if (typeof curr === 'function') {
      curr = Runtime.getFunctionIndex(curr);
    }

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = Runtime.getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}
Module["allocate"] = allocate;

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!staticSealed) return Runtime.staticAlloc(size);
  if ((typeof _sbrk !== 'undefined' && !_sbrk.called) || !runtimeInitialized) return Runtime.dynamicAlloc(size);
  return _malloc(size);
}
Module["getMemory"] = getMemory;

function Pointer_stringify(ptr, /* optional */ length) {
  if (length === 0 || !ptr) return '';
  // TODO: use TextDecoder
  // Find the length, and check for UTF while doing so
  var hasUtf = 0;
  var t;
  var i = 0;
  while (1) {
    t = HEAPU8[(((ptr)+(i))>>0)];
    hasUtf |= t;
    if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = '';

  if (hasUtf < 128) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }
  return Module['UTF8ToString'](ptr);
}
Module["Pointer_stringify"] = Pointer_stringify;

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAP8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}
Module["AsciiToString"] = AsciiToString;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}
Module["stringToAscii"] = stringToAscii;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

function UTF8ArrayToString(u8Array, idx) {
  var u0, u1, u2, u3, u4, u5;

  var str = '';
  while (1) {
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    u0 = u8Array[idx++];
    if (!u0) return str;
    if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
    u1 = u8Array[idx++] & 63;
    if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
    u2 = u8Array[idx++] & 63;
    if ((u0 & 0xF0) == 0xE0) {
      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
    } else {
      u3 = u8Array[idx++] & 63;
      if ((u0 & 0xF8) == 0xF0) {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;
      } else {
        u4 = u8Array[idx++] & 63;
        if ((u0 & 0xFC) == 0xF8) {
          u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;
        } else {
          u5 = u8Array[idx++] & 63;
          u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;
        }
      }
    }
    if (u0 < 0x10000) {
      str += String.fromCharCode(u0);
    } else {
      var ch = u0 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    }
  }
}
Module["UTF8ArrayToString"] = UTF8ArrayToString;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function UTF8ToString(ptr) {
  return UTF8ArrayToString(HEAPU8,ptr);
}
Module["UTF8ToString"] = UTF8ToString;

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x1FFFFF) {
      if (outIdx + 3 >= endIdx) break;
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x3FFFFFF) {
      if (outIdx + 4 >= endIdx) break;
      outU8Array[outIdx++] = 0xF8 | (u >> 24);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 5 >= endIdx) break;
      outU8Array[outIdx++] = 0xFC | (u >> 30);
      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}
Module["stringToUTF8Array"] = stringToUTF8Array;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}
Module["stringToUTF8"] = stringToUTF8;

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      ++len;
    } else if (u <= 0x7FF) {
      len += 2;
    } else if (u <= 0xFFFF) {
      len += 3;
    } else if (u <= 0x1FFFFF) {
      len += 4;
    } else if (u <= 0x3FFFFFF) {
      len += 5;
    } else {
      len += 6;
    }
  }
  return len;
}
Module["lengthBytesUTF8"] = lengthBytesUTF8;

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function UTF16ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
    if (codeUnit == 0)
      return str;
    ++i;
    // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
    str += String.fromCharCode(codeUnit);
  }
}


// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}


// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}


function UTF32ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}


// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}


// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}


function demangle(func) {
  var hasLibcxxabi = !!Module['___cxa_demangle'];
  if (hasLibcxxabi) {
    try {
      var buf = _malloc(func.length);
      writeStringToMemory(func.substr(1), buf);
      var status = _malloc(4);
      var ret = Module['___cxa_demangle'](buf, 0, 0, status);
      if (getValue(status, 'i32') === 0 && ret) {
        return Pointer_stringify(ret);
      }
      // otherwise, libcxxabi failed, we can try ours which may return a partial result
    } catch(e) {
      // failure when using libcxxabi, we can try ours which may return a partial result
      return func;
    } finally {
      if (buf) _free(buf);
      if (status) _free(status);
      if (ret) _free(ret);
    }
  }
  Runtime.warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
  return func;
}

function demangleAll(text) {
  return text.replace(/__Z[\w\d_]+/g, function(x) { var y = demangle(x); return x === y ? x : (x + ' [' + y + ']') });
}

function jsStackTrace() {
  var err = new Error();
  if (!err.stack) {
    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
    // so try that as a special-case.
    try {
      throw new Error(0);
    } catch(e) {
      err = e;
    }
    if (!err.stack) {
      return '(no stack trace available)';
    }
  }
  return err.stack.toString();
}

function stackTrace() {
  return demangleAll(jsStackTrace());
}
Module["stackTrace"] = stackTrace;

// Memory management

var PAGE_SIZE = 4096;

function alignMemoryPage(x) {
  if (x % 4096 > 0) {
    x += (4096 - (x % 4096));
  }
  return x;
}

var HEAP;
var buffer;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

function updateGlobalBuffer(buf) {
  Module['buffer'] = buffer = buf;
}

function updateGlobalBufferViews() {
  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);
  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);
  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);
}

var STATIC_BASE = 0, STATICTOP = 0, staticSealed = false; // static area
var STACK_BASE = 0, STACKTOP = 0, STACK_MAX = 0; // stack area
var DYNAMIC_BASE = 0, DYNAMICTOP = 0; // dynamic area handled by sbrk


function abortOnCannotGrowMemory() {
  abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which adjusts the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
}

function enlargeMemory() {
  abortOnCannotGrowMemory();
}


var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;

var totalMemory = 64*1024;
while (totalMemory < TOTAL_MEMORY || totalMemory < 2*TOTAL_STACK) {
  if (totalMemory < 16*1024*1024) {
    totalMemory *= 2;
  } else {
    totalMemory += 16*1024*1024
  }
}
if (totalMemory !== TOTAL_MEMORY) {
  TOTAL_MEMORY = totalMemory;
}

// Initialize the runtime's memory



// Use a provided buffer, if there is one, or else allocate a new one
if (Module['buffer']) {
  buffer = Module['buffer'];
} else {
  buffer = new ArrayBuffer(TOTAL_MEMORY);
}
updateGlobalBufferViews();


// Endianness check (note: assumes compiler arch was little-endian)
HEAP32[0] = 255;
if (HEAPU8[0] !== 255 || HEAPU8[3] !== 0) throw 'Typed arrays 2 must be run on a little-endian system';

Module['HEAP'] = HEAP;
Module['buffer'] = buffer;
Module['HEAP8'] = HEAP8;
Module['HEAP16'] = HEAP16;
Module['HEAP32'] = HEAP32;
Module['HEAPU8'] = HEAPU8;
Module['HEAPU16'] = HEAPU16;
Module['HEAPU32'] = HEAPU32;
Module['HEAPF32'] = HEAPF32;
Module['HEAPF64'] = HEAPF64;

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Runtime.dynCall('v', func);
      } else {
        Runtime.dynCall('vi', func, [callback.arg]);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the runtime has exited

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {
  // compatibility - merge in anything from Module['preRun'] at this time
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function ensureInitRuntime() {
  if (runtimeInitialized) return;
  runtimeInitialized = true;
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);
  runtimeExited = true;
}

function postRun() {
  // compatibility - merge in anything from Module['postRun'] at this time
  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}
Module["addOnPreRun"] = addOnPreRun;

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}
Module["addOnInit"] = addOnInit;

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}
Module["addOnPreMain"] = addOnPreMain;

function addOnExit(cb) {
  __ATEXIT__.unshift(cb);
}
Module["addOnExit"] = addOnExit;

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}
Module["addOnPostRun"] = addOnPostRun;

// Tools


function intArrayFromString(stringy, dontAddNull, length /* optional */) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}
Module["intArrayFromString"] = intArrayFromString;

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}
Module["intArrayToString"] = intArrayToString;

function writeStringToMemory(string, buffer, dontAddNull) {
  var array = intArrayFromString(string, dontAddNull);
  var i = 0;
  while (i < array.length) {
    var chr = array[i];
    HEAP8[(((buffer)+(i))>>0)]=chr;
    i = i + 1;
  }
}
Module["writeStringToMemory"] = writeStringToMemory;

function writeArrayToMemory(array, buffer) {
  for (var i = 0; i < array.length; i++) {
    HEAP8[((buffer++)>>0)]=array[i];
  }
}
Module["writeArrayToMemory"] = writeArrayToMemory;

function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}
Module["writeAsciiToMemory"] = writeAsciiToMemory;

function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}


// check for imul support, and also for correctness ( https://bugs.webkit.org/show_bug.cgi?id=126345 )
if (!Math['imul'] || Math['imul'](0xffffffff, 5) !== -5) Math['imul'] = function imul(a, b) {
  var ah  = a >>> 16;
  var al = a & 0xffff;
  var bh  = b >>> 16;
  var bl = b & 0xffff;
  return (al*bl + ((ah*bl + al*bh) << 16))|0;
};
Math.imul = Math['imul'];


if (!Math['clz32']) Math['clz32'] = function(x) {
  x = x >>> 0;
  for (var i = 0; i < 32; i++) {
    if (x & (1 << (31 - i))) return i;
  }
  return 32;
};
Math.clz32 = Math['clz32']

var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_min = Math.min;
var Math_clz32 = Math.clz32;

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
}
Module["addRunDependency"] = addRunDependency;

function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}
Module["removeRunDependency"] = removeRunDependency;

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data



var memoryInitializer = null;




// === Body ===

var ASM_CONSTS = [];




STATIC_BASE = 8;

STATICTOP = STATIC_BASE + 319648;
  /* global initializers */  __ATINIT__.push();


memoryInitializer = "tidy.js.mem";





/* no memory initializer */
var tempDoublePtr = STATICTOP; STATICTOP += 16;

function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

}

function copyTempDouble(ptr) {

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];

  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];

  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];

  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];

}

// {{PRE_LIBRARY}}



  Module["_i64Subtract"] = _i64Subtract;

  function ___assert_fail(condition, filename, line, func) {
      ABORT = true;
      throw 'Assertion failed: ' + Pointer_stringify(condition) + ', at: ' + [filename ? Pointer_stringify(filename) : 'unknown filename', line, func ? Pointer_stringify(func) : 'unknown function'] + ' at ' + stackTrace();
    }


  Module["_memset"] = _memset;

  function _atexit(func, arg) {
      __ATEXIT__.unshift({ func: func, arg: arg });
    }




  var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};

  var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};

  function ___setErrNo(value) {
      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;
      return value;
    }

  var PATH={splitPath:function (filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function (parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up--; up) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function (path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function (path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function (path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function (path) {
        return PATH.splitPath(path)[3];
      },join:function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function (l, r) {
        return PATH.normalize(l + '/' + r);
      },resolve:function () {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function (from, to) {
        from = PATH.resolve(from).substr(1);
        to = PATH.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};

  var TTY={ttys:[],init:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function (dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function (stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function (stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function (stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function (stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          for (var i = 0; i < length; i++) {
            try {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              // we will read data by chunks of BUFSIZE
              var BUFSIZE = 256;
              var buf = new Buffer(BUFSIZE);
              var bytesRead = 0;

              var fd = process.stdin.fd;
              // Linux and Mac cannot use process.stdin.fd (which isn't set up as sync)
              var usingDevice = false;
              try {
                fd = fs.openSync('/dev/stdin', 'r');
                usingDevice = true;
              } catch (e) {}

              bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);

              if (usingDevice) { fs.closeSync(fd); }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }

            } else if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['print'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function (tty) {
          if (tty.output && tty.output.length > 0) {
            Module['print'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['printErr'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function (tty) {
          if (tty.output && tty.output.length > 0) {
            Module['printErr'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};

  var MEMFS={ops_table:null,mount:function (mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.buffer.byteLength which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },getFileDataAsRegularArray:function (node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
          return arr; // Returns a copy of the original data.
        }
        return node.contents; // No-op, the file contents are already in a JS array. Return as-is.
      },getFileDataAsTypedArray:function (node) {
        if (!node.contents) return new Uint8Array;
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function (node, newCapacity) {
        // If we are asked to expand the size of a file that already exists, revert to using a standard JS array to store the file
        // instead of a typed array. This makes resizing the array more flexible because we can just .push() elements at the back to
        // increase the size.
        if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {
          node.contents = MEMFS.getFileDataAsRegularArray(node);
          node.usedBytes = node.contents.length; // We might be writing to a lazy-loaded file which had overridden this property, so force-reset it.
        }

        if (!node.contents || node.contents.subarray) { // Keep using a typed array if creating a new storage, or if old one was a typed array as well.
          var prevCapacity = node.contents ? node.contents.buffer.byteLength : 0;
          if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
          // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
          // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
          // avoid overshooting the allocation cap by a very large margin.
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) | 0);
          if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity); // Allocate new storage.
          if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
          return;
        }
        // Not using a typed array to back the file storage. Use a standard JS array instead.
        if (!node.contents && newCapacity > 0) node.contents = [];
        while (node.contents.length < newCapacity) node.contents.push(0);
      },resizeFileStorage:function (node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
          return;
        }
        if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.
          var oldContents = node.contents;
          node.contents = new Uint8Array(new ArrayBuffer(newSize)); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
          return;
        }
        // Backing with a JS array.
        if (!node.contents) node.contents = [];
        if (node.contents.length > newSize) node.contents.length = newSize;
        else while (node.contents.length < newSize) node.contents.push(0);
        node.usedBytes = newSize;
      },node_ops:{getattr:function (node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function (parent, name) {
          throw FS.genericErrors[ERRNO_CODES.ENOENT];
        },mknod:function (parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function (old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },unlink:function (parent, name) {
          delete parent.contents[name];
        },rmdir:function (parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
          }
          delete parent.contents[name];
        },readdir:function (node) {
          var entries = ['.', '..']
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function (parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return node.link;
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function (stream, buffer, offset, length, position, canOwn) {
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();

          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) { // Can we just reuse the buffer we are given?
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = new Uint8Array(buffer.subarray(offset, offset + length));
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }

          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.
          else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position+length);
          return length;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return position;
        },allocate:function (stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function (stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if ( !(flags & 2) &&
                (contents.buffer === buffer || contents.buffer === buffer.buffer) ) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < stream.node.usedBytes) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);
            }
            buffer.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function (stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }

          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};

  var IDBFS={dbs:{},indexedDB:function () {
        if (typeof indexedDB !== 'undefined') return indexedDB;
        var ret = null;
        if (typeof window === 'object') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        assert(ret, 'IDBFS used, but indexedDB not supported');
        return ret;
      },DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:function (mount) {
        // reuse all of the core MEMFS functionality
        return MEMFS.mount.apply(null, arguments);
      },syncfs:function (mount, populate, callback) {
        IDBFS.getLocalSet(mount, function(err, local) {
          if (err) return callback(err);

          IDBFS.getRemoteSet(mount, function(err, remote) {
            if (err) return callback(err);

            var src = populate ? remote : local;
            var dst = populate ? local : remote;

            IDBFS.reconcile(src, dst, callback);
          });
        });
      },getDB:function (name, callback) {
        // check the cache first
        var db = IDBFS.dbs[name];
        if (db) {
          return callback(null, db);
        }

        var req;
        try {
          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
        } catch (e) {
          return callback(e);
        }
        req.onupgradeneeded = function(e) {
          var db = e.target.result;
          var transaction = e.target.transaction;

          var fileStore;

          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
          } else {
            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
          }

          if (!fileStore.indexNames.contains('timestamp')) {
            fileStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
        req.onsuccess = function() {
          db = req.result;

          // add to the cache
          IDBFS.dbs[name] = db;
          callback(null, db);
        };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },getLocalSet:function (mount, callback) {
        var entries = {};

        function isRealDir(p) {
          return p !== '.' && p !== '..';
        };
        function toAbsolute(root) {
          return function(p) {
            return PATH.join2(root, p);
          }
        };

        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));

        while (check.length) {
          var path = check.pop();
          var stat;

          try {
            stat = FS.stat(path);
          } catch (e) {
            return callback(e);
          }

          if (FS.isDir(stat.mode)) {
            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
          }

          entries[path] = { timestamp: stat.mtime };
        }

        return callback(null, { type: 'local', entries: entries });
      },getRemoteSet:function (mount, callback) {
        var entries = {};

        IDBFS.getDB(mount.mountpoint, function(err, db) {
          if (err) return callback(err);

          var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');
          transaction.onerror = function(e) {
            callback(this.error);
            e.preventDefault();
          };

          var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
          var index = store.index('timestamp');

          index.openKeyCursor().onsuccess = function(event) {
            var cursor = event.target.result;

            if (!cursor) {
              return callback(null, { type: 'remote', db: db, entries: entries });
            }

            entries[cursor.primaryKey] = { timestamp: cursor.key };

            cursor.continue();
          };
        });
      },loadLocalEntry:function (path, callback) {
        var stat, node;

        try {
          var lookup = FS.lookupPath(path);
          node = lookup.node;
          stat = FS.stat(path);
        } catch (e) {
          return callback(e);
        }

        if (FS.isDir(stat.mode)) {
          return callback(null, { timestamp: stat.mtime, mode: stat.mode });
        } else if (FS.isFile(stat.mode)) {
          // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.
          // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.
          node.contents = MEMFS.getFileDataAsTypedArray(node);
          return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents });
        } else {
          return callback(new Error('node type not supported'));
        }
      },storeLocalEntry:function (path, entry, callback) {
        try {
          if (FS.isDir(entry.mode)) {
            FS.mkdir(path, entry.mode);
          } else if (FS.isFile(entry.mode)) {
            FS.writeFile(path, entry.contents, { encoding: 'binary', canOwn: true });
          } else {
            return callback(new Error('node type not supported'));
          }

          FS.chmod(path, entry.mode);
          FS.utime(path, entry.timestamp, entry.timestamp);
        } catch (e) {
          return callback(e);
        }

        callback(null);
      },removeLocalEntry:function (path, callback) {
        try {
          var lookup = FS.lookupPath(path);
          var stat = FS.stat(path);

          if (FS.isDir(stat.mode)) {
            FS.rmdir(path);
          } else if (FS.isFile(stat.mode)) {
            FS.unlink(path);
          }
        } catch (e) {
          return callback(e);
        }

        callback(null);
      },loadRemoteEntry:function (store, path, callback) {
        var req = store.get(path);
        req.onsuccess = function(event) { callback(null, event.target.result); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },storeRemoteEntry:function (store, path, entry, callback) {
        var req = store.put(entry, path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },removeRemoteEntry:function (store, path, callback) {
        var req = store.delete(path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },reconcile:function (src, dst, callback) {
        var total = 0;

        var create = [];
        Object.keys(src.entries).forEach(function (key) {
          var e = src.entries[key];
          var e2 = dst.entries[key];
          if (!e2 || e.timestamp > e2.timestamp) {
            create.push(key);
            total++;
          }
        });

        var remove = [];
        Object.keys(dst.entries).forEach(function (key) {
          var e = dst.entries[key];
          var e2 = src.entries[key];
          if (!e2) {
            remove.push(key);
            total++;
          }
        });

        if (!total) {
          return callback(null);
        }

        var errored = false;
        var completed = 0;
        var db = src.type === 'remote' ? src.db : dst.db;
        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');
        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);

        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err);
            }
            return;
          }
          if (++completed >= total) {
            return callback(null);
          }
        };

        transaction.onerror = function(e) {
          done(this.error);
          e.preventDefault();
        };

        // sort paths in ascending order so directory entries are created
        // before the files inside them
        create.sort().forEach(function (path) {
          if (dst.type === 'local') {
            IDBFS.loadRemoteEntry(store, path, function (err, entry) {
              if (err) return done(err);
              IDBFS.storeLocalEntry(path, entry, done);
            });
          } else {
            IDBFS.loadLocalEntry(path, function (err, entry) {
              if (err) return done(err);
              IDBFS.storeRemoteEntry(store, path, entry, done);
            });
          }
        });

        // sort paths in descending order so files are deleted before their
        // parent directories
        remove.sort().reverse().forEach(function(path) {
          if (dst.type === 'local') {
            IDBFS.removeLocalEntry(path, done);
          } else {
            IDBFS.removeRemoteEntry(store, path, done);
          }
        });
      }};

  var NODEFS={isWindows:false,staticInit:function () {
        NODEFS.isWindows = !!process.platform.match(/^win/);
      },mount:function (mount) {
        assert(ENVIRONMENT_IS_NODE);
        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);
      },createNode:function (parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },getMode:function (path) {
        var stat;
        try {
          stat = fs.lstatSync(path);
          if (NODEFS.isWindows) {
            // On Windows, directories return permission bits 'rw-rw-rw-', even though they have 'rwxrwxrwx', so
            // propagate write bits to execute bits.
            stat.mode = stat.mode | ((stat.mode & 146) >> 1);
          }
        } catch (e) {
          if (!e.code) throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return stat.mode;
      },realPath:function (node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts);
      },flagsToPermissionStringMap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagsToPermissionString:function (flags) {
        flags &= ~0100000 /*O_LARGEFILE*/; // Ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~02000000 /*O_CLOEXEC*/; // Some applications may pass it; it makes no sense for a single process.
        if (flags in NODEFS.flagsToPermissionStringMap) {
          return NODEFS.flagsToPermissionStringMap[flags];
        } else {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
      },node_ops:{getattr:function (node) {
          var path = NODEFS.realPath(node);
          var stat;
          try {
            stat = fs.lstatSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.
          // See http://support.microsoft.com/kb/140365
          if (NODEFS.isWindows && !stat.blksize) {
            stat.blksize = 4096;
          }
          if (NODEFS.isWindows && !stat.blocks) {
            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },setattr:function (node, attr) {
          var path = NODEFS.realPath(node);
          try {
            if (attr.mode !== undefined) {
              fs.chmodSync(path, attr.mode);
              // update the common node structure mode as well
              node.mode = attr.mode;
            }
            if (attr.timestamp !== undefined) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path, date, date);
            }
            if (attr.size !== undefined) {
              fs.truncateSync(path, attr.size);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },lookup:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path);
          return NODEFS.createNode(parent, name, mode);
        },mknod:function (parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          // create the backing node for this in the fs root as well
          var path = NODEFS.realPath(node);
          try {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path, node.mode);
            } else {
              fs.writeFileSync(path, '', { mode: node.mode });
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return node;
        },rename:function (oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          try {
            fs.renameSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },unlink:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.unlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },rmdir:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.rmdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readdir:function (node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },symlink:function (parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          try {
            fs.symlinkSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readlink:function (node) {
          var path = NODEFS.realPath(node);
          try {
            path = fs.readlinkSync(path);
            path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);
            return path;
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        }},stream_ops:{open:function (stream) {
          var path = NODEFS.realPath(stream.node);
          try {
            if (FS.isFile(stream.node.mode)) {
              stream.nfd = fs.openSync(path, NODEFS.flagsToPermissionString(stream.flags));
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },close:function (stream) {
          try {
            if (FS.isFile(stream.node.mode) && stream.nfd) {
              fs.closeSync(stream.nfd);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },read:function (stream, buffer, offset, length, position) {
          if (length === 0) return 0; // node errors on 0 length reads
          // FIXME this is terrible.
          var nbuffer = new Buffer(length);
          var res;
          try {
            res = fs.readSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          if (res > 0) {
            for (var i = 0; i < res; i++) {
              buffer[offset + i] = nbuffer[i];
            }
          }
          return res;
        },write:function (stream, buffer, offset, length, position) {
          // FIXME this is terrible.
          var nbuffer = new Buffer(buffer.subarray(offset, offset + length));
          var res;
          try {
            res = fs.writeSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return res;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              try {
                var stat = fs.fstatSync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES[e.code]);
              }
            }
          }

          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }

          return position;
        }}};

  var WORKERFS={DIR_MODE:16895,FILE_MODE:33279,reader:null,mount:function (mount) {
        assert(ENVIRONMENT_IS_WORKER);
        if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync();
        var root = WORKERFS.createNode(null, '/', WORKERFS.DIR_MODE, 0);
        var createdParents = {};
        function ensureParent(path) {
          // return the parent node, creating subdirs as necessary
          var parts = path.split('/');
          var parent = root;
          for (var i = 0; i < parts.length-1; i++) {
            var curr = parts.slice(0, i+1).join('/');
            if (!createdParents[curr]) {
              createdParents[curr] = WORKERFS.createNode(parent, curr, WORKERFS.DIR_MODE, 0);
            }
            parent = createdParents[curr];
          }
          return parent;
        }
        function base(path) {
          var parts = path.split('/');
          return parts[parts.length-1];
        }
        // We also accept FileList here, by using Array.prototype
        Array.prototype.forEach.call(mount.opts["files"] || [], function(file) {
          WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);
        });
        (mount.opts["blobs"] || []).forEach(function(obj) {
          WORKERFS.createNode(ensureParent(obj["name"]), base(obj["name"]), WORKERFS.FILE_MODE, 0, obj["data"]);
        });
        (mount.opts["packages"] || []).forEach(function(pack) {
          pack['metadata'].files.forEach(function(file) {
            var name = file.filename.substr(1); // remove initial slash
            WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack['blob'].slice(file.start, file.end));
          });
        });
        return root;
      },createNode:function (parent, name, mode, dev, contents, mtime) {
        var node = FS.createNode(parent, name, mode);
        node.mode = mode;
        node.node_ops = WORKERFS.node_ops;
        node.stream_ops = WORKERFS.stream_ops;
        node.timestamp = (mtime || new Date).getTime();
        assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);
        if (mode === WORKERFS.FILE_MODE) {
          node.size = contents.size;
          node.contents = contents;
        } else {
          node.size = 4096;
          node.contents = {};
        }
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },node_ops:{getattr:function (node) {
          return {
            dev: 1,
            ino: undefined,
            mode: node.mode,
            nlink: 1,
            uid: 0,
            gid: 0,
            rdev: undefined,
            size: node.size,
            atime: new Date(node.timestamp),
            mtime: new Date(node.timestamp),
            ctime: new Date(node.timestamp),
            blksize: 4096,
            blocks: Math.ceil(node.size / 4096),
          };
        },setattr:function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
        },lookup:function (parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        },mknod:function (parent, name, mode, dev) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },rename:function (oldNode, newDir, newName) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },unlink:function (parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },rmdir:function (parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },readdir:function (node) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },symlink:function (parent, newName, oldPath) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },readlink:function (node) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          if (position >= stream.node.size) return 0;
          var chunk = stream.node.contents.slice(position, position + length);
          var ab = WORKERFS.reader.readAsArrayBuffer(chunk);
          buffer.set(new Uint8Array(ab), offset);
          return chunk.size;
        },write:function (stream, buffer, offset, length, position) {
          throw new FS.ErrnoError(ERRNO_CODES.EIO);
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.size;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return position;
        }}};

  var _stdin=STATICTOP; STATICTOP += 16;;

  var _stdout=STATICTOP; STATICTOP += 16;;

  var _stderr=STATICTOP; STATICTOP += 16;;var FS={root:null,mounts:[],devices:[null],streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function (e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();
        return ___setErrNo(e.errno);
      },lookupPath:function (path, opts) {
        path = PATH.resolve(FS.cwd(), path);
        opts = opts || {};

        if (!path) return { path: '', node: null };

        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }

        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
        }

        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);

        // start at the root
        var current = FS.root;
        var current_path = '/';

        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }

          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);

          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }

          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH.resolve(PATH.dirname(current_path), link);

              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;

              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
              }
            }
          }
        }

        return { path: current_path, node: current };
      },getPath:function (node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function (parentid, name) {
        var hash = 0;


        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function (parent, name) {
        var err = FS.mayLookup(parent);
        if (err) {
          throw new FS.ErrnoError(err, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function (parent, name, mode, rdev) {
        if (!FS.FSNode) {
          FS.FSNode = function(parent, name, mode, rdev) {
            if (!parent) {
              parent = this;  // root node sets parent to itself
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };

          FS.FSNode.prototype = {};

          // compatibility
          var readMode = 292 | 73;
          var writeMode = 146;

          // NOTE we must use Object.defineProperties instead of individual calls to
          // Object.defineProperty in order to make closure compiler happy
          Object.defineProperties(FS.FSNode.prototype, {
            read: {
              get: function() { return (this.mode & readMode) === readMode; },
              set: function(val) { val ? this.mode |= readMode : this.mode &= ~readMode; }
            },
            write: {
              get: function() { return (this.mode & writeMode) === writeMode; },
              set: function(val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; }
            },
            isFolder: {
              get: function() { return FS.isDir(this.mode); }
            },
            isDevice: {
              get: function() { return FS.isChrdev(this.mode); }
            }
          });
        }

        var node = new FS.FSNode(parent, name, mode, rdev);

        FS.hashAddNode(node);

        return node;
      },destroyNode:function (node) {
        FS.hashRemoveNode(node);
      },isRoot:function (node) {
        return node === node.parent;
      },isMountpoint:function (node) {
        return !!node.mounted;
      },isFile:function (mode) {
        return (mode & 61440) === 32768;
      },isDir:function (mode) {
        return (mode & 61440) === 16384;
      },isLink:function (mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function (mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function (mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function (mode) {
        return (mode & 61440) === 4096;
      },isSocket:function (mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function (str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function (flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function (node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return ERRNO_CODES.EACCES;
        }
        return 0;
      },mayLookup:function (dir) {
        var err = FS.nodePermissions(dir, 'x');
        if (err) return err;
        if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;
        return 0;
      },mayCreate:function (dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return ERRNO_CODES.EEXIST;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function (dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var err = FS.nodePermissions(dir, 'wx');
        if (err) {
          return err;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return ERRNO_CODES.ENOTDIR;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return ERRNO_CODES.EBUSY;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return 0;
      },mayOpen:function (node, flags) {
        if (!node) {
          return ERRNO_CODES.ENOENT;
        }
        if (FS.isLink(node.mode)) {
          return ERRNO_CODES.ELOOP;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return ERRNO_CODES.EISDIR;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function (fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(ERRNO_CODES.EMFILE);
      },getStream:function (fd) {
        return FS.streams[fd];
      },createStream:function (stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = function(){};
          FS.FSStream.prototype = {};
          // compatibility
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          });
        }
        // clone it, so we can return an instance of FSStream
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function (fd) {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:function (stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function () {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }},major:function (dev) {
        return ((dev) >> 8);
      },minor:function (dev) {
        return ((dev) & 0xff);
      },makedev:function (ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function (dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function (dev) {
        return FS.devices[dev];
      },getMounts:function (mount) {
        var mounts = [];
        var check = [mount];

        while (check.length) {
          var m = check.pop();

          mounts.push(m);

          check.push.apply(check, m.mounts);
        }

        return mounts;
      },syncfs:function (populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }

        FS.syncFSRequests++;

        if (FS.syncFSRequests > 1) {
          console.log('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }

        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;

        function doCallback(err) {
          assert(FS.syncFSRequests > 0);
          FS.syncFSRequests--;
          return callback(err);
        }

        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(err);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };

        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function (type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;

        if (root && FS.root) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;

          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
          }

          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
          }
        }

        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };

        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;

        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;

          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }

        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }

        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);

        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];

          while (current) {
            var next = current.name_next;

            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }

            current = next;
          }
        });

        // no longer a mountpoint
        node.mounted = null;

        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:function (parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function (path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.mayCreate(parent, name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function (path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function (path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdev:function (path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function (oldpath, newpath) {
        if (!PATH.resolve(oldpath)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        var newname = PATH.basename(newpath);
        var err = FS.mayCreate(parent, newname);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function (old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(ERRNO_CODES.EXDEV);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        // new path should not be an ancestor of the old path
        relative = PATH.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var err = FS.mayDelete(old_dir, old_name, isdir);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        err = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          err = FS.nodePermissions(old_dir, 'w');
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        try {
          if (FS.trackingDelegate['willMovePath']) {
            FS.trackingDelegate['willMovePath'](old_path, new_path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
        } catch(e) {
          console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
      },rmdir:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, true);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        return node.node_ops.readdir(node);
      },unlink:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, false);
        if (err) {
          // POSIX says unlink should set EPERM, not EISDIR
          if (err === ERRNO_CODES.EISDIR) err = ERRNO_CODES.EPERM;
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readlink:function (path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:function (path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return node.node_ops.getattr(node);
      },lstat:function (path) {
        return FS.stat(path, true);
      },chmod:function (path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function (path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function (fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chmod(stream.node, mode);
      },chown:function (path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function (path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function (fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function (path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.nodePermissions(node, 'w');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function (fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        FS.truncate(stream.node, len);
      },utime:function (path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function (path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(ERRNO_CODES.EEXIST);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var err = FS.mayOpen(node, flags);
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512);

        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            Module['printErr']('read file: ' + path);
          }
        }
        try {
          if (FS.trackingDelegate['onOpenFile']) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate['onOpenFile'](path, trackingFlags);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: " + e.message);
        }
        return stream;
      },close:function (stream) {
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
      },llseek:function (stream, offset, whence) {
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function (stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if (stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
        } catch(e) {
          console.log("FS.trackingDelegate['onWriteToFile']('"+path+"') threw an exception: " + e.message);
        }
        return bytesWritten;
      },allocate:function (stream, offset, length) {
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function (stream, buffer, offset, length, position, prot, flags) {
        // TODO if PROT is PROT_WRITE, make sure we have write access
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EACCES);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },msync:function (stream, buffer, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:function (stream) {
        return 0;
      },ioctl:function (stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function (path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function (path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        opts.encoding = opts.encoding || 'utf8';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var stream = FS.open(path, opts.flags, opts.mode);
        if (opts.encoding === 'utf8') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, 0, opts.canOwn);
        } else if (opts.encoding === 'binary') {
          FS.write(stream, data, 0, data.length, 0, opts.canOwn);
        }
        FS.close(stream);
      },cwd:function () {
        return FS.currentPath;
      },chdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        var err = FS.nodePermissions(lookup.node, 'x');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function () {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:function () {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function(stream, buffer, offset, length, pos) { return length; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device;
        if (typeof crypto !== 'undefined') {
          // for modern web browsers
          var randomBuffer = new Uint8Array(1);
          random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
        } else if (ENVIRONMENT_IS_NODE) {
          // for nodejs
          random_device = function() { return require('crypto').randomBytes(1)[0]; };
        } else {
          // default for ES5 platforms
          random_device = function() { return (Math.random()*256)|0; };
        }
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:function () {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: function() {
            var node = FS.createNode('/proc/self', 'fd', 16384 | 0777, 73);
            node.node_ops = {
              lookup: function(parent, name) {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: function() { return stream.path } }
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:function () {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops

        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }

        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');

        var stdout = FS.open('/dev/stdout', 'w');
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');

        var stderr = FS.open('/dev/stderr', 'w');
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:function () {
        if (FS.ErrnoError) return;
        FS.ErrnoError = function ErrnoError(errno, node) {
          //Module.printErr(stackTrace()); // useful for debugging
          this.node = node;
          this.setErrno = function(errno) {
            this.errno = errno;
            for (var key in ERRNO_CODES) {
              if (ERRNO_CODES[key] === errno) {
                this.code = key;
                break;
              }
            }
          };
          this.setErrno(errno);
          this.message = ERRNO_MESSAGES[errno];
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [ERRNO_CODES.ENOENT].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function () {
        FS.ensureErrnoError();

        FS.nameTable = new Array(4096);

        FS.mount(MEMFS, {}, '/');

        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();

        FS.filesystems = {
          'MEMFS': MEMFS,
          'IDBFS': IDBFS,
          'NODEFS': NODEFS,
          'WORKERFS': WORKERFS,
        };
      },init:function (input, output, error) {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;

        FS.ensureErrnoError();

        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];

        FS.createStandardStreams();
      },quit:function () {
        FS.init.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        var fflush = Module['_fflush'];
        if (fflush) fflush(0);
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function (canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function (parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function (relative, base) {
        return PATH.resolve(base, relative);
      },standardizePath:function (path) {
        return PATH.normalize(path);
      },findObject:function (path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___setErrNo(ret.error);
          return null;
        }
      },analyzePath:function (path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function (parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function (parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function (parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function (parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function (parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function (parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (Module['read']) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success;
      },createLazyFile:function (parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        }
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        }
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";

          var chunkSize = 1024*1024; // Chunk size in bytes

          if (!hasByteServing) chunkSize = datalength;

          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");

            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);

            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }

            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(xhr.response || []);
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
          var lazyArray = this;
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });

          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            console.log("LazyFiles on gzip forces download of the whole file when length is accessed");
          }

          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: function() {
                if(!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: function() {
                if(!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });

          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }

        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EIO);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init(); // XXX perhaps this method should move onto Browser?
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency(dep);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function () {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function () {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          console.log('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};var SYSCALLS={DEFAULT_POLLMASK:5,mappings:{},umask:511,calculateAt:function (dirfd, path) {
        if (path[0] !== '/') {
          // relative path
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
            dir = dirstream.path;
          }
          path = PATH.join2(dir, path);
        }
        return path;
      },doStat:function (func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -ERRNO_CODES.ENOTDIR;
          }
          throw e;
        }
        HEAP32[((buf)>>2)]=stat.dev;
        HEAP32[(((buf)+(4))>>2)]=0;
        HEAP32[(((buf)+(8))>>2)]=stat.ino;
        HEAP32[(((buf)+(12))>>2)]=stat.mode;
        HEAP32[(((buf)+(16))>>2)]=stat.nlink;
        HEAP32[(((buf)+(20))>>2)]=stat.uid;
        HEAP32[(((buf)+(24))>>2)]=stat.gid;
        HEAP32[(((buf)+(28))>>2)]=stat.rdev;
        HEAP32[(((buf)+(32))>>2)]=0;
        HEAP32[(((buf)+(36))>>2)]=stat.size;
        HEAP32[(((buf)+(40))>>2)]=4096;
        HEAP32[(((buf)+(44))>>2)]=stat.blocks;
        HEAP32[(((buf)+(48))>>2)]=(stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(52))>>2)]=0;
        HEAP32[(((buf)+(56))>>2)]=(stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)]=0;
        HEAP32[(((buf)+(64))>>2)]=(stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)]=0;
        HEAP32[(((buf)+(72))>>2)]=stat.ino;
        return 0;
      },doMsync:function (addr, stream, len, flags) {
        var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));
        FS.msync(stream, buffer, 0, len, flags);
      },doMkdir:function (path, mode) {
        // remove a trailing slash, if one - /a/b/ has basename of '', but
        // we want to create b in the context of this function
        path = PATH.normalize(path);
        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
        FS.mkdir(path, mode, 0);
        return 0;
      },doMknod:function (path, mode, dev) {
        // we don't want this in the JS API as it uses mknod to create all nodes.
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default: return -ERRNO_CODES.EINVAL;
        }
        FS.mknod(path, mode, dev);
        return 0;
      },doReadlink:function (path, buf, bufsize) {
        if (bufsize <= 0) return -ERRNO_CODES.EINVAL;
        var ret = FS.readlink(path);
        ret = ret.slice(0, Math.max(0, bufsize));
        writeStringToMemory(ret, buf, true);
        return ret.length;
      },doAccess:function (path, amode) {
        if (amode & ~7) {
          // need a valid mode
          return -ERRNO_CODES.EINVAL;
        }
        var node;
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
          return -ERRNO_CODES.EACCES;
        }
        return 0;
      },doDup:function (path, flags, suggestFD) {
        var suggest = FS.getStream(suggestFD);
        if (suggest) FS.close(suggest);
        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
      },doReadv:function (stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.read(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break; // nothing more to read
        }
        return ret;
      },doWritev:function (stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.write(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }
        return ret;
      },varargs:0,get:function (varargs) {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function () {
        var ret = Pointer_stringify(SYSCALLS.get());
        return ret;
      },getStreamFromFD:function () {
        var stream = FS.getStream(SYSCALLS.get());
        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        return stream;
      },getSocketFromFD:function () {
        var socket = SOCKFS.getSocket(SYSCALLS.get());
        if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        return socket;
      },getSocketAddress:function (allowNull) {
        var addrp = SYSCALLS.get(), addrlen = SYSCALLS.get();
        if (allowNull && addrp === 0) return null;
        var info = __read_sockaddr(addrp, addrlen);
        if (info.errno) throw new FS.ErrnoError(info.errno);
        info.addr = DNS.lookup_addr(info.addr) || info.addr;
        return info;
      },get64:function () {
        var low = SYSCALLS.get(), high = SYSCALLS.get();
        if (low >= 0) assert(high === 0);
        else assert(high === -1);
        return low;
      },getZero:function () {
        assert(SYSCALLS.get() === 0);
      }};function ___syscall192(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // mmap2
      var addr = SYSCALLS.get(), len = SYSCALLS.get(), prot = SYSCALLS.get(), flags = SYSCALLS.get(), fd = SYSCALLS.get(), off = SYSCALLS.get()
      off <<= 12; // undo pgoffset
      var ptr;
      var allocated = false;
      if (fd === -1) {
        ptr = _malloc(len);
        if (!ptr) return -ERRNO_CODES.ENOMEM;
        _memset(ptr, 0, len);
        allocated = true;
      } else {
        var info = FS.getStream(fd);
        if (!info) return -ERRNO_CODES.EBADF;
        var res = FS.mmap(info, HEAPU8, addr, len, off, prot, flags);
        ptr = res.ptr;
        allocated = res.allocated;
      }
      SYSCALLS.mappings[ptr] = { malloc: ptr, len: len, allocated: allocated, fd: fd, flags: flags };
      return ptr;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall195(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // SYS_stat64
      var path = SYSCALLS.getStr(), buf = SYSCALLS.get();
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall197(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // SYS_fstat64
      var stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get();
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___lock() {}

  function ___unlock() {}

  var _llvm_fabs_f64=Math_abs;


  Module["_i64Add"] = _i64Add;


  function __exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      Module['exit'](status);
    }function _exit(status) {
      __exit(status);
    }

  function ___syscall91(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // munmap
      var addr = SYSCALLS.get(), len = SYSCALLS.get();
      // TODO: support unmmap'ing parts of allocations
      var info = SYSCALLS.mappings[addr];
      if (!info) return 0;
      if (len === info.len) {
        var stream = FS.getStream(info.fd);
        SYSCALLS.doMsync(addr, stream, len, info.flags)
        FS.munmap(stream);
        SYSCALLS.mappings[addr] = null;
        if (info.allocated) {
          _free(info.malloc);
        }
      }
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall54(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // ioctl
      var stream = SYSCALLS.getStreamFromFD(), op = SYSCALLS.get();
      switch (op) {
        case 21505: {
          if (!stream.tty) return -ERRNO_CODES.ENOTTY;
          return 0;
        }
        case 21506: {
          if (!stream.tty) return -ERRNO_CODES.ENOTTY;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -ERRNO_CODES.ENOTTY;
          var argp = SYSCALLS.get();
          HEAP32[((argp)>>2)]=0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -ERRNO_CODES.ENOTTY;
          return -ERRNO_CODES.EINVAL; // not supported
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        default: abort('bad ioctl syscall ' + op);
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 30: return PAGE_SIZE;
        case 85: return totalMemory / PAGE_SIZE;
        case 132:
        case 133:
        case 12:
        case 137:
        case 138:
        case 15:
        case 235:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 149:
        case 13:
        case 10:
        case 236:
        case 153:
        case 9:
        case 21:
        case 22:
        case 159:
        case 154:
        case 14:
        case 77:
        case 78:
        case 139:
        case 80:
        case 81:
        case 82:
        case 68:
        case 67:
        case 164:
        case 11:
        case 29:
        case 47:
        case 48:
        case 95:
        case 52:
        case 51:
        case 46:
          return 200809;
        case 79:
          return 0;
        case 27:
        case 246:
        case 127:
        case 128:
        case 23:
        case 24:
        case 160:
        case 161:
        case 181:
        case 182:
        case 242:
        case 183:
        case 184:
        case 243:
        case 244:
        case 245:
        case 165:
        case 178:
        case 179:
        case 49:
        case 50:
        case 168:
        case 169:
        case 175:
        case 170:
        case 171:
        case 172:
        case 97:
        case 76:
        case 32:
        case 173:
        case 35:
          return -1;
        case 176:
        case 177:
        case 7:
        case 155:
        case 8:
        case 157:
        case 125:
        case 126:
        case 92:
        case 93:
        case 129:
        case 130:
        case 131:
        case 94:
        case 91:
          return 1;
        case 74:
        case 60:
        case 69:
        case 70:
        case 4:
          return 1024;
        case 31:
        case 42:
        case 72:
          return 32;
        case 87:
        case 26:
        case 33:
          return 2147483647;
        case 34:
        case 1:
          return 47839;
        case 38:
        case 36:
          return 99;
        case 43:
        case 37:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 28: return 32768;
        case 44: return 32767;
        case 75: return 16384;
        case 39: return 1000;
        case 89: return 700;
        case 71: return 256;
        case 40: return 255;
        case 2: return 100;
        case 180: return 64;
        case 25: return 20;
        case 5: return 16;
        case 6: return 6;
        case 73: return 4;
        case 84: {
          if (typeof navigator === 'object') return navigator['hardwareConcurrency'] || 1;
          return 1;
        }
      }
      ___setErrNo(ERRNO_CODES.EINVAL);
      return -1;
    }


  Module["_bitshift64Lshr"] = _bitshift64Lshr;

  function _pthread_cleanup_push(routine, arg) {
      __ATEXIT__.push(function() { Runtime.dynCall('vi', routine, [arg]) })
      _pthread_cleanup_push.level = __ATEXIT__.length;
    }





  var _environ=STATICTOP; STATICTOP += 16;;var ___environ=_environ;function ___buildEnvironment(env) {
      // WARNING: Arbitrary limit!
      var MAX_ENV_VALUES = 64;
      var TOTAL_ENV_SIZE = 1024;

      // Statically allocate memory for the environment.
      var poolPtr;
      var envPtr;
      if (!___buildEnvironment.called) {
        ___buildEnvironment.called = true;
        // Set default values. Use string keys for Closure Compiler compatibility.
        ENV['USER'] = ENV['LOGNAME'] = 'web_user';
        ENV['PATH'] = '/';
        ENV['PWD'] = '/';
        ENV['HOME'] = '/home/web_user';
        ENV['LANG'] = 'C';
        ENV['_'] = Module['thisProgram'];
        // Allocate memory.
        poolPtr = allocate(TOTAL_ENV_SIZE, 'i8', ALLOC_STATIC);
        envPtr = allocate(MAX_ENV_VALUES * 4,
                          'i8*', ALLOC_STATIC);
        HEAP32[((envPtr)>>2)]=poolPtr;
        HEAP32[((_environ)>>2)]=envPtr;
      } else {
        envPtr = HEAP32[((_environ)>>2)];
        poolPtr = HEAP32[((envPtr)>>2)];
      }

      // Collect key=value lines.
      var strings = [];
      var totalSize = 0;
      for (var key in env) {
        if (typeof env[key] === 'string') {
          var line = key + '=' + env[key];
          strings.push(line);
          totalSize += line.length;
        }
      }
      if (totalSize > TOTAL_ENV_SIZE) {
        throw new Error('Environment size exceeded TOTAL_ENV_SIZE!');
      }

      // Make new.
      var ptrSize = 4;
      for (var i = 0; i < strings.length; i++) {
        var line = strings[i];
        writeAsciiToMemory(line, poolPtr);
        HEAP32[(((envPtr)+(i * ptrSize))>>2)]=poolPtr;
        poolPtr += line.length + 1;
      }
      HEAP32[(((envPtr)+(strings.length * ptrSize))>>2)]=0;
    }var ENV={};function _getenv(name) {
      // char *getenv(const char *name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/getenv.html
      if (name === 0) return 0;
      name = Pointer_stringify(name);
      if (!ENV.hasOwnProperty(name)) return 0;

      if (_getenv.ret) _free(_getenv.ret);
      _getenv.ret = allocate(intArrayFromString(ENV[name]), 'i8', ALLOC_NORMAL);
      return _getenv.ret;
    }

  function _pthread_cleanup_pop() {
      assert(_pthread_cleanup_push.level == __ATEXIT__.length, 'cannot pop if something else added meanwhile!');
      __ATEXIT__.pop();
      _pthread_cleanup_push.level = __ATEXIT__.length;
    }

  function ___syscall5(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // open
      var pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get() // optional TODO
      var stream = FS.open(pathname, flags, mode);
      return stream.fd;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }


  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
      return dest;
    }
  Module["_memcpy"] = _memcpy;

  function ___syscall6(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // close
      var stream = SYSCALLS.getStreamFromFD();
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function _sbrk(bytes) {
      // Implement a Linux-like 'memory area' for our 'process'.
      // Changes the size of the memory area by |bytes|; returns the
      // address of the previous top ('break') of the memory area
      // We control the "dynamic" memory - DYNAMIC_BASE to DYNAMICTOP
      var self = _sbrk;
      if (!self.called) {
        DYNAMICTOP = alignMemoryPage(DYNAMICTOP); // make sure we start out aligned
        self.called = true;
        assert(Runtime.dynamicAlloc);
        self.alloc = Runtime.dynamicAlloc;
        Runtime.dynamicAlloc = function() { abort('cannot dynamically allocate, sbrk now has control') };
      }
      var ret = DYNAMICTOP;
      if (bytes != 0) {
        var success = self.alloc(bytes);
        if (!success) return -1 >>> 0; // sbrk failure code
      }
      return ret;  // Previous break location.
    }


  Module["_bitshift64Shl"] = _bitshift64Shl;

  function _abort() {
      Module['abort']();
    }

  function _time(ptr) {
      var ret = (Date.now()/1000)|0;
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret;
      }
      return ret;
    }

  function _pthread_self() {
      //FIXME: assumes only a single thread
      return 0;
    }

  function ___syscall140(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // llseek
      var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();
      var offset = offset_low;
      assert(offset_high === 0);
      FS.llseek(stream, offset, whence);
      HEAP32[((result)>>2)]=stream.position;
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall146(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // writev
      var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
      return SYSCALLS.doWritev(stream, iov, iovcnt);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall221(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // fcntl64
      var stream = SYSCALLS.getStreamFromFD(), cmd = SYSCALLS.get();
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -ERRNO_CODES.EINVAL;
          }
          var newStream;
          newStream = FS.open(stream.path, stream.flags, 0, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 12:
        case 12: {
          var arg = SYSCALLS.get();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)]=2;
          return 0;
        }
        case 13:
        case 14:
        case 13:
        case 14:
          return 0; // Pretend that the locking is successful.
        case 16:
        case 8:
          return -ERRNO_CODES.EINVAL; // These are for sockets. We don't have them fully implemented yet.
        case 9:
          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.
          ___setErrNo(ERRNO_CODES.EINVAL);
          return -1;
        default: {
          return -ERRNO_CODES.EINVAL;
        }
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall145(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // readv
      var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
      return SYSCALLS.doReadv(stream, iov, iovcnt);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }
FS.staticInit();__ATINIT__.unshift(function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() });__ATMAIN__.push(function() { FS.ignorePermissions = false });__ATEXIT__.push(function() { FS.quit() });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;Module["FS_unlink"] = FS.unlink;;
__ATINIT__.unshift(function() { TTY.init() });__ATEXIT__.push(function() { TTY.shutdown() });;
if (ENVIRONMENT_IS_NODE) { var fs = require("fs"); var NODEJS_PATH = require("path"); NODEFS.staticInit(); };
___buildEnvironment(ENV);;
STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);

staticSealed = true; // seal the static portion of memory

STACK_MAX = STACK_BASE + TOTAL_STACK;

DYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX);

 var cttz_i8 = allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0], "i8", ALLOC_DYNAMIC);


function invoke_iiii(index,a1,a2,a3) {
  try {
    return Module["dynCall_iiii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_vi(index,a1) {
  try {
    Module["dynCall_vi"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  try {
    Module["dynCall_vii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6) {
  try {
    return Module["dynCall_iiiiiii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_ii(index,a1) {
  try {
    return Module["dynCall_ii"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_viii(index,a1,a2,a3) {
  try {
    Module["dynCall_viii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_v(index) {
  try {
    Module["dynCall_v"](index);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  try {
    return Module["dynCall_iii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iiiiii(index,a1,a2,a3,a4,a5) {
  try {
    return Module["dynCall_iiiiii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_viiii(index,a1,a2,a3,a4) {
  try {
    Module["dynCall_viiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

Module.asmGlobalArg = { "Math": Math, "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array, "Uint32Array": Uint32Array, "Float32Array": Float32Array, "Float64Array": Float64Array, "NaN": NaN, "Infinity": Infinity };

Module.asmLibraryArg = { "abort": abort, "assert": assert, "invoke_iiii": invoke_iiii, "invoke_vi": invoke_vi, "invoke_vii": invoke_vii, "invoke_iiiiiii": invoke_iiiiiii, "invoke_ii": invoke_ii, "invoke_viii": invoke_viii, "invoke_v": invoke_v, "invoke_iii": invoke_iii, "invoke_iiiiii": invoke_iiiiii, "invoke_viiii": invoke_viiii, "_pthread_cleanup_pop": _pthread_cleanup_pop, "___syscall221": ___syscall221, "___syscall6": ___syscall6, "_llvm_fabs_f64": _llvm_fabs_f64, "_pthread_cleanup_push": _pthread_cleanup_push, "___assert_fail": ___assert_fail, "___buildEnvironment": ___buildEnvironment, "___setErrNo": ___setErrNo, "_sbrk": _sbrk, "___syscall192": ___syscall192, "___syscall197": ___syscall197, "_emscripten_memcpy_big": _emscripten_memcpy_big, "__exit": __exit, "___syscall195": ___syscall195, "___syscall91": ___syscall91, "_pthread_self": _pthread_self, "_getenv": _getenv, "___syscall54": ___syscall54, "___unlock": ___unlock, "_sysconf": _sysconf, "___lock": ___lock, "_abort": _abort, "___syscall5": ___syscall5, "_time": _time, "_atexit": _atexit, "___syscall140": ___syscall140, "_exit": _exit, "___syscall145": ___syscall145, "___syscall146": ___syscall146, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "cttz_i8": cttz_i8 };
// EMSCRIPTEN_START_ASM
var asm = (function(global, env, buffer) {
  'use asm';


  var HEAP8 = new global.Int8Array(buffer);
  var HEAP16 = new global.Int16Array(buffer);
  var HEAP32 = new global.Int32Array(buffer);
  var HEAPU8 = new global.Uint8Array(buffer);
  var HEAPU16 = new global.Uint16Array(buffer);
  var HEAPU32 = new global.Uint32Array(buffer);
  var HEAPF32 = new global.Float32Array(buffer);
  var HEAPF64 = new global.Float64Array(buffer);


  var STACKTOP=env.STACKTOP|0;
  var STACK_MAX=env.STACK_MAX|0;
  var tempDoublePtr=env.tempDoublePtr|0;
  var ABORT=env.ABORT|0;
  var cttz_i8=env.cttz_i8|0;

  var __THREW__ = 0;
  var threwValue = 0;
  var setjmpId = 0;
  var undef = 0;
  var nan = global.NaN, inf = global.Infinity;
  var tempInt = 0, tempBigInt = 0, tempBigIntP = 0, tempBigIntS = 0, tempBigIntR = 0.0, tempBigIntI = 0, tempBigIntD = 0, tempValue = 0, tempDouble = 0.0;

  var tempRet0 = 0;
  var tempRet1 = 0;
  var tempRet2 = 0;
  var tempRet3 = 0;
  var tempRet4 = 0;
  var tempRet5 = 0;
  var tempRet6 = 0;
  var tempRet7 = 0;
  var tempRet8 = 0;
  var tempRet9 = 0;
  var Math_floor=global.Math.floor;
  var Math_abs=global.Math.abs;
  var Math_sqrt=global.Math.sqrt;
  var Math_pow=global.Math.pow;
  var Math_cos=global.Math.cos;
  var Math_sin=global.Math.sin;
  var Math_tan=global.Math.tan;
  var Math_acos=global.Math.acos;
  var Math_asin=global.Math.asin;
  var Math_atan=global.Math.atan;
  var Math_atan2=global.Math.atan2;
  var Math_exp=global.Math.exp;
  var Math_log=global.Math.log;
  var Math_ceil=global.Math.ceil;
  var Math_imul=global.Math.imul;
  var Math_min=global.Math.min;
  var Math_clz32=global.Math.clz32;
  var abort=env.abort;
  var assert=env.assert;
  var invoke_iiii=env.invoke_iiii;
  var invoke_vi=env.invoke_vi;
  var invoke_vii=env.invoke_vii;
  var invoke_iiiiiii=env.invoke_iiiiiii;
  var invoke_ii=env.invoke_ii;
  var invoke_viii=env.invoke_viii;
  var invoke_v=env.invoke_v;
  var invoke_iii=env.invoke_iii;
  var invoke_iiiiii=env.invoke_iiiiii;
  var invoke_viiii=env.invoke_viiii;
  var _pthread_cleanup_pop=env._pthread_cleanup_pop;
  var ___syscall221=env.___syscall221;
  var ___syscall6=env.___syscall6;
  var _llvm_fabs_f64=env._llvm_fabs_f64;
  var _pthread_cleanup_push=env._pthread_cleanup_push;
  var ___assert_fail=env.___assert_fail;
  var ___buildEnvironment=env.___buildEnvironment;
  var ___setErrNo=env.___setErrNo;
  var _sbrk=env._sbrk;
  var ___syscall192=env.___syscall192;
  var ___syscall197=env.___syscall197;
  var _emscripten_memcpy_big=env._emscripten_memcpy_big;
  var __exit=env.__exit;
  var ___syscall195=env.___syscall195;
  var ___syscall91=env.___syscall91;
  var _pthread_self=env._pthread_self;
  var _getenv=env._getenv;
  var ___syscall54=env.___syscall54;
  var ___unlock=env.___unlock;
  var _sysconf=env._sysconf;
  var ___lock=env.___lock;
  var _abort=env._abort;
  var ___syscall5=env.___syscall5;
  var _time=env._time;
  var _atexit=env._atexit;
  var ___syscall140=env.___syscall140;
  var _exit=env._exit;
  var ___syscall145=env.___syscall145;
  var ___syscall146=env.___syscall146;
  var tempFloat = 0.0;

// EMSCRIPTEN_START_FUNCS

function _AccessibilityCheckNode($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0$i = 0, $$1$i = 0, $$lcssa = 0, $$lcssa$i = 0, $$lcssa919 = 0, $$lcssa921 = 0, $$lcssa923 = 0, $$newLines$0$i = 0, $$newLines$0$i$lcssa927 = 0, $$numWords$0$i = 0, $$numWords$0$i$lcssa = 0, $$pr$i = 0, $$pr$i352 = 0, $$pr$i569 = 0, $$pr$i612 = 0, $$pr$i649 = 0, $$pr$i706 = 0, $$pr2$pr$pre$i = 0, $$pr39$pr$i = 0, $$pre = 0, $$pre834 = 0, $0 = 0, $1 = 0, $1006 = 0, $1008 = 0, $1010 = 0, $1013 = 0, $1019 = 0, $1020 = 0, $1024 = 0, $1025 = 0, $1027 = 0, $1034 = 0, $1037 = 0, $1042 = 0, $1044 = 0, $1055 = 0, $1063 = 0, $1064 = 0, $1066 = 0, $107 = 0, $1071 = 0, $1074 = 0, $1077 = 0, $108 = 0, $1081 = 0, $1085 = 0, $1088 = 0, $1089 = 0, $11 = 0, $1100 = 0, $1107 = 0, $1108 = 0, $1119 = 0, $1123 = 0, $113 = 0, $1137 = 0, $1142 = 0, $1144 = 0, $1145 = 0, $1146 = 0, $115 = 0, $1157 = 0, $116 = 0, $117 = 0, $1172 = 0, $1173 = 0, $1175 = 0, $1179 = 0, $1180 = 0, $1182 = 0, $1185 = 0, $1186 = 0, $1189 = 0, $12 = 0, $1204 = 0, $1207 = 0, $1210 = 0, $1212 = 0, $1220 = 0, $1224 = 0, $1225 = 0, $1228 = 0, $1229 = 0, $1230 = 0, $1241 = 0, $1245 = 0, $1256 = 0, $1257 = 0, $1260 = 0, $1261 = 0, $1262 = 0, $1273 = 0, $1277 = 0, $128 = 0, $1286 = 0, $1287 = 0, $1291 = 0, $1292 = 0, $1294 = 0, $13 = 0, $1300 = 0, $1303 = 0, $1308 = 0, $1310 = 0, $132 = 0, $1322 = 0, $1324 = 0, $1325 = 0, $1327 = 0, $1337 = 0, $1339 = 0, $1345 = 0, $1347 = 0, $1367 = 0, $1371 = 0, $1372 = 0, $1374 = 0, $1384 = 0, $1386 = 0, $139 = 0, $1393 = 0, $1398 = 0, $1399 = 0, $1402 = 0, $1403 = 0, $1404 = 0, $1415 = 0, $1419 = 0, $1432 = 0, $1435 = 0, $1442 = 0, $1445 = 0, $1447 = 0, $1453 = 0, $1459 = 0, $150 = 0, $152 = 0, $154 = 0, $155 = 0, $156 = 0, $16 = 0, $160 = 0, $167 = 0, $182 = 0, $187 = 0, $193 = 0, $194 = 0, $196 = 0, $2 = 0, $20 = 0, $203 = 0, $206 = 0, $207 = 0, $209 = 0, $21 = 0, $217 = 0, $218 = 0, $219 = 0, $221 = 0, $229 = 0, $23 = 0, $231 = 0, $233 = 0, $242 = 0, $245 = 0, $250 = 0, $255 = 0, $257 = 0, $258 = 0, $259 = 0, $270 = 0, $279 = 0, $285 = 0, $288 = 0, $29 = 0, $293 = 0, $298 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $31 = 0, $313 = 0, $325 = 0, $336 = 0, $340 = 0, $342 = 0, $343 = 0, $345 = 0, $358 = 0, $360 = 0, $370 = 0, $374 = 0, $375 = 0, $383 = 0, $388 = 0, $390 = 0, $396 = 0, $398 = 0, $403 = 0, $405 = 0, $41 = 0, $414 = 0, $42 = 0, $423 = 0, $424 = 0, $429 = 0, $43 = 0, $431 = 0, $432 = 0, $433 = 0, $444 = 0, $449 = 0, $450 = 0, $455 = 0, $457 = 0, $458 = 0, $459 = 0, $470 = 0, $475 = 0, $486 = 0, $488 = 0, $493 = 0, $495 = 0, $501 = 0, $502 = 0, $510 = 0, $516 = 0, $517 = 0, $518 = 0, $521 = 0, $522 = 0, $523 = 0, $531 = 0, $534 = 0, $544 = 0, $545 = 0, $548 = 0, $549 = 0, $550 = 0, $561 = 0, $565 = 0, $574 = 0, $580 = 0, $582 = 0, $585 = 0, $586 = 0, $588 = 0, $59 = 0, $599 = 0, $60 = 0, $600 = 0, $602 = 0, $611 = 0, $612 = 0, $614 = 0, $622 = 0, $626 = 0, $628 = 0, $634 = 0, $645 = 0, $647 = 0, $648 = 0, $650 = 0, $66 = 0, $661 = 0, $663 = 0, $669 = 0, $67 = 0, $671 = 0, $678 = 0, $681 = 0, $689 = 0, $693 = 0, $694 = 0, $696 = 0, $702 = 0, $706 = 0, $713 = 0, $715 = 0, $721 = 0, $729 = 0, $730 = 0, $733 = 0, $738 = 0, $741 = 0, $748 = 0, $754 = 0, $758 = 0, $770 = 0, $773 = 0, $777 = 0, $778 = 0, $78 = 0, $786 = 0, $792 = 0, $795 = 0, $799 = 0, $802 = 0, $806 = 0, $809 = 0, $812 = 0, $816 = 0, $819 = 0, $82 = 0, $827 = 0, $830 = 0, $846 = 0, $851 = 0, $866 = 0, $869 = 0, $871 = 0, $876 = 0, $878 = 0, $890 = 0, $893 = 0, $898 = 0, $902 = 0, $903 = 0, $905 = 0, $918 = 0, $92 = 0, $921 = 0, $928 = 0, $932 = 0, $933 = 0, $935 = 0, $96 = 0, $962 = 0, $965 = 0, $967 = 0, $97 = 0, $974 = 0, $976 = 0, $978 = 0, $981 = 0, $988 = 0, $990 = 0, $992 = 0, $997 = 0, $999 = 0, $HasAbbr$0$lcssa$i = 0, $HasAbbr$016$i = 0, $HasAbbr$2$i = 0, $HasAbbr$3$i = 0, $HasAlt$0$lcssa$i = 0, $HasAlt$0$lcssa$i356 = 0, $HasAlt$0$lcssa12$i = 0, $HasAlt$010$i = 0, $HasAlt$010$i385 = 0, $HasAlt$012$i = 0, $HasAlt$059$i = 0, $HasAlt$1$i = 0, $HasAlt$1$i351 = 0, $HasAlt$1$i388 = 0, $HasAlt$1$i388$lcssa = 0, $HasAlt$1$i572 = 0, $HasAlt$1$i572$lcssa = 0, $HasAlt$2$i = 0, $HasDLINK$1$i = 0, $HasDLINK$3$i = 0, $HasDescription$023$i = 0, $HasDescription$1$i = 0, $HasDescription$1$i446 = 0, $HasDescription$4$i = 0, $HasDescription$5$i = 0, $HasIsMap$0$lcssa$i = 0, $HasIsMap$058$i = 0, $HasIsMap$1$i = 0, $HasLongDesc$0$lcssa$i = 0, $HasLongDesc$054$i = 0, $HasLongDesc$1$i = 0, $HasNoFrames$08$i = 0, $HasNoFrames$1$i = 0, $HasNoFrames$1$i$lcssa = 0, $HasRel$012$i = 0, $HasRel$1$ph$i = 0, $HasRel$110$i = 0, $HasRel$110$i$lcssa = 0, $HasSkipOverLink$022$i = 0, $HasSkipOverLink$1$i = 0, $HasSkipOverLink$1$i$lcssa = 0, $HasSkipOverLink$2$i = 0, $HasSkipOverLink$318$i = 0, $HasSkipOverLink$4$i = 0, $HasSkipOverLink$5$i = 0, $HasSummary$0$lcssa$i = 0, $HasSummary$026$i = 0, $HasSummary$1$ph$ph$i = 0, $HasSummary$2$i = 0, $HasSummary$3$i = 0, $HasTitle$0$$i = 0, $HasTitle$016$i = 0, $HasTitle$2$i = 0, $HasTitle$2$i$lcssa = 0, $HasType$013$i = 0, $HasType$1$i = 0, $HasType$1$i$lcssa = 0, $HasValidHeight$0$lcssa$i = 0, $HasValidHeight$055$i = 0, $HasValidHeight$1$i = 0, $HasValidWidthBullet$0$lcssa$i = 0, $HasValidWidthBullet$056$i = 0, $HasValidWidthBullet$2$i = 0, $HasValidWidthHR$0$lcssa$i = 0, $HasValidWidthHR$057$i = 0, $HasValidWidthHR$2$i = 0, $IsAscii$1$i = 0, $MustHaveAlt$013$i = 0, $MustHaveAlt$1$ph$i = 0, $MustHaveAlt$110$i = 0, $MustHaveAlt$110$i$lcssa = 0, $NeedsDescription$1$i = 0, $TNode$016$i$i = 0, $av$01$i = 0, $av$011$i = 0, $av$011$i384 = 0, $av$011$i561 = 0, $av$011$i643 = 0, $av$014$i = 0, $av$014$i644 = 0, $av$015$i = 0, $av$015$i702 = 0, $av$016$i = 0, $av$017$i = 0, $av$017$i451 = 0, $av$017$i703 = 0, $av$02$i = 0, $av$021$i = 0, $av$021$i520 = 0, $av$024$i = 0, $av$024$i521 = 0, $av$025$i = 0, $av$027$i = 0, $av$04$i$i = 0, $av$053$i = 0, $av$060$i = 0, $av$07$i = 0, $av$07$i$i = 0, $av$09$i = 0, $av$117$i = 0, $av$119$i = 0, $child$01$i = 0, $child$02$i = 0, $content$0790 = 0, $content$0791 = 0, $cp$03$i$i = 0, $cp$03$i$i$i = 0, $cp$03$i$i$i332 = 0, $cp$03$i$i$i345 = 0, $cp$03$i$i$i452 = 0, $cp$03$i$i$i466 = 0, $cp$03$i$i$i499 = 0, $cp$03$i$i$i526 = 0, $cp$03$i$i$i534 = 0, $cp$03$i$i$i545 = 0, $cp$03$i$i$i564 = 0, $cp$03$i$i$i616 = 0, $cp$03$i$i$i650 = 0, $cp$03$i$i$i664 = 0, $cp$03$i$i1$i = 0, $cp$03$i$i25$i = 0, $cp$03$i$i31$i = 0, $cp$03$i$i37$i = 0, $cp$03$i$i396 = 0, $cp$03$i$i4$i = 0, $cp$03$i$i4$i646 = 0, $cp$03$i$i440 = 0, $cp$03$i$i455 = 0, $cp$03$i$i504 = 0, $cp$03$i$i587 = 0, $cp$03$i$i6$i = 0, $cp$03$i$i627 = 0, $cp$03$i$i637 = 0, $cp$03$i$i7$i = 0, $cp$03$i$i718 = 0, $cp$03$i14$i = 0, $cp$03$i2$i = 0, $cp$03$i7$i = 0, $cp$03$i7$i708 = 0, $doc$idx$i326 = 0, $doc$idx$i358 = 0, $doc$idx$i399 = 0, $doc$idx$i470 = 0, $doc$idx$i542 = 0, $doc$idx$i661 = 0, $doc$idx$val$i$i = 0, $doc$idx$val$i327 = 0, $doc$idx$val$i349 = 0, $doc$idx$val$i359 = 0, $doc$idx$val$i363 = 0, $doc$idx$val$i369 = 0, $doc$idx$val$i374 = 0, $doc$idx$val$i400 = 0, $doc$idx$val$i409 = 0, $doc$idx$val$i417 = 0, $doc$idx$val$i471 = 0, $doc$idx$val$i479 = 0, $doc$idx$val$i488 = 0, $doc$idx$val$i512 = 0, $doc$idx$val$i524 = 0, $doc$idx$val$i669 = 0, $doc$idx$val$i678 = 0, $doc$idx$val$lcssa$i = 0, $doc$idx$val22$i = 0, $doc$idx$val26$i = 0, $doc$idx10$val$i = 0, $doc$idx11$i = 0, $doc$idx11$val$i = 0, $doc$idx4$i = 0, $doc$idx4$val$i516 = 0, $doc$idx6$i = 0, $doc$idx6$val8$i = 0, $ext$i = 0, $ext$i$i = 0, $i$0$i = 0, $i$0$i794 = 0, $i$0$i797 = 0, $i$0$in$i$i = 0, $i$0$in$i$i$i = 0, $i$0$in$i795 = 0, $i$0$in$i795$phi = 0, $i$02$i = 0, $i$02$i$i = 0, $i$02$i$i337 = 0, $i$02$i$i391 = 0, $i$02$i$i430 = 0, $i$02$i$i582 = 0, $i$02$i$i595 = 0, $i$02$i$i622 = 0, $i$02$i$i632 = 0, $i$02$i$i714 = 0, $i$02$i12$i = 0, $i$02$i18$i = 0, $i$02$i2$i = 0, $i$02$i3$i = 0, $i$02$i3$i436 = 0, $i$03$lcssa$i$i = 0, $isWht$0$lcssa$i$i = 0, $isWht$0$lcssa$i$i$i = 0, $isWht$0$lcssa$i$i10$i = 0, $isWht$0$lcssa$i$i443 = 0, $isWht$0$lcssa$i$i7$i = 0, $isWht$0$lcssa$i5$i = 0, $isWht$02$i$i = 0, $isWht$02$i$i$i = 0, $isWht$02$i$i441 = 0, $isWht$02$i$i5$i = 0, $isWht$02$i$i8$i = 0, $isWht$02$i3$i = 0, $isWht$02$i8$i = 0, $isWht$02$i8$i$lcssa = 0, $msgcode$015$i = 0, $msgcode$015$i379 = 0, $msgcode$015$i422 = 0, $msgcode$015$i484 = 0, $msgcode$015$i493 = 0, $msgcode$015$i674 = 0, $msgcode$015$i683 = 0, $msgcode$02$i = 0, $msgcode$078$i697 = 0, $msgcode$08$i = 0, $msgcode$08$i413 = 0, $newLines$0$i796 = 0, $node$pn$i = 0, $numTR$024$i = 0, $numTR$1$i = 0, $numTR$1$i$lcssa = 0, $numWords$0$lcssa$i = 0, $numWords$01$i = 0, $skipOver$023$i = 0, $skipOver$1$i = 0, $skipOver$1$i$lcssa = 0, $skipOver$2$i = 0, $temp$010$i$i = 0, $temp$023$i = 0, $temp$04$i792 = 0, $temp$07$i = 0, $temp$09$i = 0, $validColSpanColumns$018$i$i = 0, $validColSpanColumns$112$i$i = 0, $validColSpanColumns$26$i$i = 0, $validColSpanColumns$31$i$i = 0, $validColSpanColumns$4$i$i = 0, $validColSpanColumns$5$i$i = 0, $validColSpanColumns$5$i$i$lcssa = 0, $validColSpanRows$017$i$i = 0, $validColSpanRows$111$i$i = 0, $validColSpanRows$25$i$i = 0, $validColSpanRows$3$i$i = 0, $validColSpanRows$4$i$i = 0, $validColSpanRows$5$i$i = 0, $validColSpanRows$5$i$i$lcssa = 0, $word$0$i = 0, $x$01$i$i = 0, $x$01$i$i338 = 0, $x$01$i$i392 = 0, $x$01$i$i431 = 0, $x$01$i$i583 = 0, $x$01$i$i596 = 0, $x$01$i$i623 = 0, $x$01$i$i633 = 0, $x$01$i$i715 = 0, $x$01$i13$i = 0, $x$01$i19$i = 0, $x$01$i3$i = 0, $x$01$i4$i = 0, $x$01$i4$i437 = 0, $x$1$i$i = 0, $x$1$i$i340 = 0, $x$1$i$i393 = 0, $x$1$i$i433 = 0, $x$1$i$i584 = 0, $x$1$i$i598 = 0, $x$1$i$i625 = 0, $x$1$i$i635 = 0, $x$1$i$i716 = 0, $x$1$i15$i = 0, $x$1$i21$i = 0, $x$1$i5$i = 0, $x$1$i6$i = 0, $x$1$i6$i439 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $ext$i$i = sp + 20 | 0;
 $ext$i = sp;
 $0 = ($node | 0) != 0;
 L1 : do if ($0) {
  $1 = $node + 28 | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  if (!$2) label = 541; else do switch (HEAP32[$2 >> 2] | 0) {
  case 16:
   {
    _CheckColorContrast($doc, $node);
    break L1;
    break;
   }
  case 46:
   {
    if (_CheckMetaData($doc, $node, 0) | 0) break L1;
    if ((HEAP32[$doc + 6396 >> 2] | 1 | 0) != 3) break L1;
    _prvTidyReportAccessError($doc, $node, 427);
    break L1;
    break;
   }
  case 1:
   {
    $av$021$i = HEAP32[$node + 20 >> 2] | 0;
    $doc$idx$i326 = $doc + 6396 | 0;
    $doc$idx$val22$i = HEAP32[$doc$idx$i326 >> 2] | 0;
    if (!$av$021$i) $doc$idx$val$lcssa$i = $doc$idx$val22$i; else {
     $11 = $node + 8 | 0;
     $12 = $doc + 6532 | 0;
     $13 = $doc + 68 | 0;
     $HasDescription$023$i = 0;
     $av$024$i = $av$021$i;
     $doc$idx$val26$i = $doc$idx$val22$i;
     while (1) {
      L14 : do if (($doc$idx$val26$i + -1 | 0) >>> 0 < 3) {
       $16 = HEAP32[$av$024$i + 4 >> 2] | 0;
       if (!$16) $HasDescription$5$i = $HasDescription$023$i; else if ((HEAP32[$16 >> 2] | 0) == 59) {
        $20 = $av$024$i + 24 | 0;
        $21 = HEAP32[$20 >> 2] | 0;
        if (!$21) $HasDescription$5$i = $HasDescription$023$i; else {
         $cp$03$i$i$i = $21;
         while (1) {
          $23 = HEAP8[$cp$03$i$i$i >> 0] | 0;
          if (!($23 << 24 >> 24)) {
           $HasDescription$5$i = $HasDescription$023$i;
           break L14;
          }
          if (!(_prvTidyIsWhite($23 << 24 >> 24) | 0)) break; else $cp$03$i$i$i = $cp$03$i$i$i + 1 | 0;
         }
         $29 = HEAP32[$20 >> 2] | 0;
         $30 = _prvTidytmbstrlen($29) | 0;
         HEAP8[$ext$i >> 0] = 0;
         $i$0$in$i$i = $30;
         L22 : do {
          $i$0$in$i$i = $i$0$in$i$i + -1 | 0;
          $31 = $29 + $i$0$in$i$i | 0;
          switch (HEAP8[$31 >> 0] | 0) {
          case 92:
          case 47:
           {
            break L22;
            break;
           }
          case 46:
           {
            $$lcssa919 = $31;
            label = 18;
            break L22;
            break;
           }
          default:
           {}
          }
         } while (($i$0$in$i$i | 0) > 1);
         if ((label | 0) == 18) {
          label = 0;
          _prvTidytmbstrncpy($ext$i, $$lcssa919, 20) | 0;
         }
         if (_IsValidMediaExtension(HEAP32[$20 >> 2] | 0) | 0) _prvTidyReportAccessError($doc, $node, 325);
         L31 : do if ((_prvTidytmbstrlen($ext$i) | 0) >>> 0 < 6) if (!(_prvTidytmbstrlen($ext$i) | 0)) $HasDescription$4$i = $HasDescription$023$i; else {
          $41 = HEAP32[$20 >> 2] | 0;
          $42 = _prvTidytmbstrlen($41) | 0;
          HEAP8[$ext$i$i >> 0] = 0;
          $i$0$in$i$i$i = $42;
          L34 : do {
           $i$0$in$i$i$i = $i$0$in$i$i$i + -1 | 0;
           $43 = $41 + $i$0$in$i$i$i | 0;
           switch (HEAP8[$43 >> 0] | 0) {
           case 92:
           case 47:
            {
             break L34;
             break;
            }
           case 46:
            {
             $$lcssa921 = $43;
             label = 26;
             break L34;
             break;
            }
           default:
            {}
           }
          } while (($i$0$in$i$i$i | 0) > 1);
          if ((label | 0) == 26) {
           label = 0;
           _prvTidytmbstrncpy($ext$i$i, $$lcssa921, 20) | 0;
          }
          do if (!(_prvTidytmbstrcasecmp($ext$i$i, 311930) | 0)) $i$03$lcssa$i$i = 0; else if (!(_prvTidytmbstrcasecmp($ext$i$i, 311935) | 0)) $i$03$lcssa$i$i = 1; else if (!(_prvTidytmbstrcasecmp($ext$i$i, 311939) | 0)) $i$03$lcssa$i$i = 2; else {
           if (!(_prvTidytmbstrcasecmp($ext$i$i, 311945) | 0)) {
            $i$03$lcssa$i$i = 3;
            break;
           }
           if (!(_prvTidytmbstrcasecmp($ext$i$i, 311950) | 0)) {
            $i$03$lcssa$i$i = 4;
            break;
           }
           if (!(_prvTidytmbstrcasecmp($ext$i$i, 311954) | 0)) {
            $i$03$lcssa$i$i = 5;
            break;
           }
           $HasDescription$4$i = $HasDescription$023$i;
           break L31;
          } while (0);
          $59 = HEAP32[217036 + ($i$03$lcssa$i$i << 2) >> 2] | 0;
          $60 = HEAP32[$11 >> 2] | 0;
          L48 : do if ($60 | 0) if (!(HEAP32[$60 + 28 >> 2] | 0)) {
           $66 = HEAP32[$60 + 36 >> 2] | 0;
           $67 = $60 + 40 | 0;
           L51 : do if ($66 >>> 0 < (HEAP32[$67 >> 2] | 0) >>> 0) {
            $i$02$i$i = $66;
            $x$01$i$i = 0;
            while (1) {
             HEAP8[$doc + 6532 + $x$01$i$i >> 0] = HEAP8[(HEAP32[(HEAP32[$13 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i$i >> 0] | 0;
             if ($x$01$i$i >>> 0 > 126) {
              $x$1$i$i = $x$01$i$i;
              break L51;
             }
             $i$02$i$i = $i$02$i$i + 1 | 0;
             $78 = $x$01$i$i + 1 | 0;
             if ($i$02$i$i >>> 0 >= (HEAP32[$67 >> 2] | 0) >>> 0) {
              $x$1$i$i = $78;
              break;
             } else $x$01$i$i = $78;
            }
           } else $x$1$i$i = 0; while (0);
           HEAP8[$doc + 6532 + $x$1$i$i >> 0] = 0;
           $cp$03$i7$i = $12;
           while (1) {
            $82 = HEAP8[$cp$03$i7$i >> 0] | 0;
            if (!($82 << 24 >> 24)) break L48;
            if (!(_prvTidyIsWhite($82 << 24 >> 24) | 0)) {
             $HasDescription$4$i = 1;
             break L31;
            } else $cp$03$i7$i = $cp$03$i7$i + 1 | 0;
           }
          } while (0);
          if (!$HasDescription$023$i) {
           _prvTidyReportAccessError($doc, $node, $59);
           $HasDescription$4$i = 0;
          } else $HasDescription$4$i = $HasDescription$023$i;
         } else $HasDescription$4$i = $HasDescription$023$i; while (0);
         $HasDescription$5$i = $HasDescription$4$i;
        }
       } else $HasDescription$5$i = $HasDescription$023$i;
      } else $HasDescription$5$i = $HasDescription$023$i; while (0);
      do if ((HEAP32[$doc$idx$i326 >> 2] | 1 | 0) == 3) {
       $92 = HEAP32[$av$024$i + 4 >> 2] | 0;
       if ($92 | 0) if ((HEAP32[$92 >> 2] | 0) == 146) {
        $96 = $av$024$i + 24 | 0;
        $97 = HEAP32[$96 >> 2] | 0;
        if ($97 | 0) {
         if (!(_prvTidytmbstrcasecmp($97, 311958) | 0)) {
          _prvTidyReportAccessWarning($doc, $node, 398);
          break;
         }
         $$pr$i = HEAP32[$96 >> 2] | 0;
         if ($$pr$i | 0) if (!(_prvTidytmbstrcasecmp($$pr$i, 311963) | 0)) _prvTidyReportAccessWarning($doc, $node, 399);
        }
       }
      } while (0);
      $av$024$i = HEAP32[$av$024$i >> 2] | 0;
      $doc$idx$val$i327 = HEAP32[$doc$idx$i326 >> 2] | 0;
      if (!$av$024$i) {
       $doc$idx$val$lcssa$i = $doc$idx$val$i327;
       break;
      } else {
       $HasDescription$023$i = $HasDescription$5$i;
       $doc$idx$val26$i = $doc$idx$val$i327;
      }
     }
    }
    if (($doc$idx$val$lcssa$i | 1 | 0) != 3) break L1;
    $107 = $node + 12 | 0;
    $108 = HEAP32[$107 >> 2] | 0;
    if ($108 | 0) {
     L78 : do if (!(HEAP32[$108 + 28 >> 2] | 0)) {
      $113 = $doc + 6532 | 0;
      $115 = HEAP32[$108 + 36 >> 2] | 0;
      $116 = $doc + 68 | 0;
      $117 = $108 + 40 | 0;
      L80 : do if ($115 >>> 0 < (HEAP32[$117 >> 2] | 0) >>> 0) {
       $i$02$i12$i = $115;
       $x$01$i13$i = 0;
       while (1) {
        HEAP8[$doc + 6532 + $x$01$i13$i >> 0] = HEAP8[(HEAP32[(HEAP32[$116 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i12$i >> 0] | 0;
        if ($x$01$i13$i >>> 0 > 126) {
         $x$1$i15$i = $x$01$i13$i;
         break L80;
        }
        $i$02$i12$i = $i$02$i12$i + 1 | 0;
        $128 = $x$01$i13$i + 1 | 0;
        if ($i$02$i12$i >>> 0 >= (HEAP32[$117 >> 2] | 0) >>> 0) {
         $x$1$i15$i = $128;
         break;
        } else $x$01$i13$i = $128;
       }
      } else $x$1$i15$i = 0; while (0);
      HEAP8[$doc + 6532 + $x$1$i15$i >> 0] = 0;
      $cp$03$i$i = $113;
      while (1) {
       $132 = HEAP8[$cp$03$i$i >> 0] | 0;
       if (!($132 << 24 >> 24)) break L78;
       if (!(_prvTidyIsWhite($132 << 24 >> 24) | 0)) break; else $cp$03$i$i = $cp$03$i$i + 1 | 0;
      }
      $139 = (_prvTidytmbstrcmp($113, 311970) | 0) == 0;
      if (!(_prvTidytmbstrcmp($113, 311975) | 0)) _prvTidyReportAccessWarning($doc, $node, 424);
      if (!$139) if ((_prvTidytmbstrlen($113) | 0) >>> 0 < 6) _prvTidyReportAccessWarning($doc, $node, 421);
      if ((_prvTidytmbstrlen($113) | 0) >>> 0 > 60) _prvTidyReportAccessWarning($doc, $node, 423);
     } while (0);
     if (HEAP32[$107 >> 2] | 0) break L1;
    }
    _prvTidyReportAccessWarning($doc, $node, 422);
    break L1;
    break;
   }
  case 52:
   {
    _CheckFlicker($doc, $node);
    _CheckColorAvailable($doc, $node);
    if (((HEAP32[$doc + 6396 >> 2] | 0) + -1 | 0) >>> 0 >= 3) break L1;
    $av$053$i = HEAP32[$node + 20 >> 2] | 0;
    if (!$av$053$i) {
     $HasAlt$0$lcssa$i = 0;
     $HasIsMap$0$lcssa$i = 0;
     $HasLongDesc$0$lcssa$i = 0;
     $HasValidHeight$0$lcssa$i = 0;
     $HasValidWidthBullet$0$lcssa$i = 0;
     $HasValidWidthHR$0$lcssa$i = 0;
    } else {
     $150 = $doc + 6680 | 0;
     $HasAlt$059$i = 0;
     $HasIsMap$058$i = 0;
     $HasLongDesc$054$i = 0;
     $HasValidHeight$055$i = 0;
     $HasValidWidthBullet$056$i = 0;
     $HasValidWidthHR$057$i = 0;
     $av$060$i = $av$053$i;
     while (1) {
      $152 = HEAP32[$av$060$i + 4 >> 2] | 0;
      L105 : do if (!$152) {
       $HasAlt$1$i = $HasAlt$059$i;
       $HasIsMap$1$i = $HasIsMap$058$i;
       $HasLongDesc$1$i = $HasLongDesc$054$i;
       $HasValidHeight$1$i = $HasValidHeight$055$i;
       $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
       $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
      } else {
       $154 = HEAP32[$152 >> 2] | 0;
       switch ($154 | 0) {
       case 10:
        {
         $155 = $av$060$i + 24 | 0;
         $156 = HEAP32[$155 >> 2] | 0;
         if (!$156) {
          $HasAlt$1$i = $HasAlt$059$i;
          $HasIsMap$1$i = $HasIsMap$058$i;
          $HasLongDesc$1$i = $HasLongDesc$054$i;
          $HasValidHeight$1$i = $HasValidHeight$055$i;
          $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
          $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
          break L105;
         }
         do if ((_prvTidytmbstrlen($156) | 0) >>> 0 < 150) {
          $160 = HEAP32[$155 >> 2] | 0;
          if (!(_strstr($160, 313236) | 0)) if (!(_strstr($160, 311991) | 0)) if (!(_strstr($160, 311997) | 0)) {
           $167 = _prvTidytmbstrlen($160) | 0;
           if ($167 >>> 0 > 4) if (!(_prvTidytmbstrcmp($160 + $167 + -5 | 0, 312004) | 0)) break;
           if (!(_IsImage(HEAP32[$155 >> 2] | 0) | 0)) {
            $HasAlt$1$i = 1;
            $HasIsMap$1$i = $HasIsMap$058$i;
            $HasLongDesc$1$i = $HasLongDesc$054$i;
            $HasValidHeight$1$i = $HasValidHeight$055$i;
            $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
            $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
            break L105;
           }
          }
         } while (0);
         if ((_prvTidytmbstrlen(HEAP32[$155 >> 2] | 0) | 0) >>> 0 > 150) {
          _prvTidyReportAccessWarning($doc, $node, 304);
          $HasAlt$1$i = 1;
          $HasIsMap$1$i = $HasIsMap$058$i;
          $HasLongDesc$1$i = $HasLongDesc$054$i;
          $HasValidHeight$1$i = $HasValidHeight$055$i;
          $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
          $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
          break L105;
         }
         if ((_IsImage(HEAP32[$155 >> 2] | 0) | 0) == 1) {
          _prvTidyReportAccessWarning($doc, $node, 301);
          $HasAlt$1$i = 1;
          $HasIsMap$1$i = $HasIsMap$058$i;
          $HasLongDesc$1$i = $HasLongDesc$054$i;
          $HasValidHeight$1$i = $HasValidHeight$055$i;
          $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
          $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
          break L105;
         }
         $182 = HEAP32[$155 >> 2] | 0;
         if (!(_strstr($182, 313236) | 0)) if (!(_strstr($182, 311991) | 0)) {
          $187 = _prvTidytmbstrlen($182) | 0;
          if ($187 >>> 0 <= 4) {
           $HasAlt$1$i = $HasAlt$059$i;
           $HasIsMap$1$i = $HasIsMap$058$i;
           $HasLongDesc$1$i = $HasLongDesc$054$i;
           $HasValidHeight$1$i = $HasValidHeight$055$i;
           $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
           $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
           break L105;
          }
          if (_prvTidytmbstrcmp($182 + $187 + -5 | 0, 312004) | 0) {
           $HasAlt$1$i = $HasAlt$059$i;
           $HasIsMap$1$i = $HasIsMap$058$i;
           $HasLongDesc$1$i = $HasLongDesc$054$i;
           $HasValidHeight$1$i = $HasValidHeight$055$i;
           $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
           $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
           break L105;
          }
          _prvTidyReportAccessWarning($doc, $node, 302);
          $HasAlt$1$i = 1;
          $HasIsMap$1$i = $HasIsMap$058$i;
          $HasLongDesc$1$i = $HasLongDesc$054$i;
          $HasValidHeight$1$i = $HasValidHeight$055$i;
          $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
          $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
          break L105;
         }
         _prvTidyReportAccessWarning($doc, $node, 303);
         $HasAlt$1$i = 1;
         $HasIsMap$1$i = $HasIsMap$058$i;
         $HasLongDesc$1$i = $HasLongDesc$054$i;
         $HasValidHeight$1$i = $HasValidHeight$055$i;
         $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
         $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
         break L105;
         break;
        }
       case 159:
        {
         $193 = $av$060$i + 24 | 0;
         $194 = HEAP32[$193 >> 2] | 0;
         if (!$194) {
          $HasAlt$1$i = $HasAlt$059$i;
          $HasIsMap$1$i = $HasIsMap$058$i;
          $HasLongDesc$1$i = $HasLongDesc$054$i;
          $HasValidHeight$1$i = $HasValidHeight$055$i;
          $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
          $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
          break L105;
         } else $cp$03$i$i25$i = $194;
         while (1) {
          $196 = HEAP8[$cp$03$i$i25$i >> 0] | 0;
          if (!($196 << 24 >> 24)) {
           $HasAlt$1$i = $HasAlt$059$i;
           $HasIsMap$1$i = $HasIsMap$058$i;
           $HasLongDesc$1$i = $HasLongDesc$054$i;
           $HasValidHeight$1$i = $HasValidHeight$055$i;
           $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
           $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
           break L105;
          }
          if (!(_prvTidyIsWhite($196 << 24 >> 24) | 0)) break; else $cp$03$i$i25$i = $cp$03$i$i25$i + 1 | 0;
         }
         $203 = _atoi(HEAP32[$193 >> 2] | 0) | 0;
         $HasAlt$1$i = $HasAlt$059$i;
         $HasIsMap$1$i = $HasIsMap$058$i;
         $HasLongDesc$1$i = $HasLongDesc$054$i;
         $HasValidHeight$1$i = $HasValidHeight$055$i;
         $HasValidWidthBullet$2$i = ($203 | 0) < 30 ? 1 : $HasValidWidthBullet$056$i;
         $HasValidWidthHR$2$i = ($203 | 0) > 150 ? 1 : $HasValidWidthHR$057$i;
         break L105;
         break;
        }
       case 58:
        {
         $206 = $av$060$i + 24 | 0;
         $207 = HEAP32[$206 >> 2] | 0;
         if (!$207) {
          $HasAlt$1$i = $HasAlt$059$i;
          $HasIsMap$1$i = $HasIsMap$058$i;
          $HasLongDesc$1$i = $HasLongDesc$054$i;
          $HasValidHeight$1$i = $HasValidHeight$055$i;
          $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
          $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
          break L105;
         } else $cp$03$i$i31$i = $207;
         while (1) {
          $209 = HEAP8[$cp$03$i$i31$i >> 0] | 0;
          if (!($209 << 24 >> 24)) {
           $HasAlt$1$i = $HasAlt$059$i;
           $HasIsMap$1$i = $HasIsMap$058$i;
           $HasLongDesc$1$i = $HasLongDesc$054$i;
           $HasValidHeight$1$i = $HasValidHeight$055$i;
           $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
           $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
           break L105;
          }
          if (!(_prvTidyIsWhite($209 << 24 >> 24) | 0)) break; else $cp$03$i$i31$i = $cp$03$i$i31$i + 1 | 0;
         }
         $217 = (_atoi(HEAP32[$206 >> 2] | 0) | 0) < 30;
         $HasAlt$1$i = $HasAlt$059$i;
         $HasIsMap$1$i = $HasIsMap$058$i;
         $HasLongDesc$1$i = $HasLongDesc$054$i;
         $HasValidHeight$1$i = $217 ? 1 : $HasValidHeight$055$i;
         $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
         $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
         break L105;
         break;
        }
       case 77:
        {
         $218 = $av$060$i + 24 | 0;
         $219 = HEAP32[$218 >> 2] | 0;
         if (!$219) {
          $HasAlt$1$i = $HasAlt$059$i;
          $HasIsMap$1$i = $HasIsMap$058$i;
          $HasLongDesc$1$i = $HasLongDesc$054$i;
          $HasValidHeight$1$i = $HasValidHeight$055$i;
          $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
          $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
          break L105;
         } else $cp$03$i$i37$i = $219;
         while (1) {
          $221 = HEAP8[$cp$03$i$i37$i >> 0] | 0;
          if (!($221 << 24 >> 24)) {
           $HasAlt$1$i = $HasAlt$059$i;
           $HasIsMap$1$i = $HasIsMap$058$i;
           $HasLongDesc$1$i = $HasLongDesc$054$i;
           $HasValidHeight$1$i = $HasValidHeight$055$i;
           $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
           $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
           break L105;
          }
          if (!(_prvTidyIsWhite($221 << 24 >> 24) | 0)) break; else $cp$03$i$i37$i = $cp$03$i$i37$i + 1 | 0;
         }
         $229 = (_prvTidytmbstrlen(HEAP32[$218 >> 2] | 0) | 0) >>> 0 > 1;
         $HasAlt$1$i = $HasAlt$059$i;
         $HasIsMap$1$i = $HasIsMap$058$i;
         $HasLongDesc$1$i = $229 ? 1 : $HasLongDesc$054$i;
         $HasValidHeight$1$i = $HasValidHeight$055$i;
         $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
         $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
         break L105;
         break;
        }
       case 152:
        {
         $231 = HEAP32[$av$060$i + 24 >> 2] | 0;
         if (!$231) {
          $HasAlt$1$i = $HasAlt$059$i;
          $HasIsMap$1$i = $HasIsMap$058$i;
          $HasLongDesc$1$i = $HasLongDesc$054$i;
          $HasValidHeight$1$i = $HasValidHeight$055$i;
          $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
          $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
          break L105;
         } else $cp$03$i$i$i332 = $231;
         while (1) {
          $233 = HEAP8[$cp$03$i$i$i332 >> 0] | 0;
          if (!($233 << 24 >> 24)) {
           $HasAlt$1$i = $HasAlt$059$i;
           $HasIsMap$1$i = $HasIsMap$058$i;
           $HasLongDesc$1$i = $HasLongDesc$054$i;
           $HasValidHeight$1$i = $HasValidHeight$055$i;
           $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
           $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
           break L105;
          }
          if (!(_prvTidyIsWhite($233 << 24 >> 24) | 0)) break; else $cp$03$i$i$i332 = $cp$03$i$i$i332 + 1 | 0;
         }
         HEAP32[$150 >> 2] = 1;
         $HasAlt$1$i = $HasAlt$059$i;
         $HasIsMap$1$i = $HasIsMap$058$i;
         $HasLongDesc$1$i = $HasLongDesc$054$i;
         $HasValidHeight$1$i = $HasValidHeight$055$i;
         $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
         $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
         break L105;
         break;
        }
       default:
        {
         $HasAlt$1$i = $HasAlt$059$i;
         $HasIsMap$1$i = ($154 | 0) == 64 ? 1 : $HasIsMap$058$i;
         $HasLongDesc$1$i = $HasLongDesc$054$i;
         $HasValidHeight$1$i = $HasValidHeight$055$i;
         $HasValidWidthBullet$2$i = $HasValidWidthBullet$056$i;
         $HasValidWidthHR$2$i = $HasValidWidthHR$057$i;
         break L105;
        }
       }
      } while (0);
      $av$060$i = HEAP32[$av$060$i >> 2] | 0;
      if (!$av$060$i) {
       $HasAlt$0$lcssa$i = $HasAlt$1$i;
       $HasIsMap$0$lcssa$i = $HasIsMap$1$i;
       $HasLongDesc$0$lcssa$i = $HasLongDesc$1$i;
       $HasValidHeight$0$lcssa$i = $HasValidHeight$1$i;
       $HasValidWidthBullet$0$lcssa$i = $HasValidWidthBullet$2$i;
       $HasValidWidthHR$0$lcssa$i = $HasValidWidthHR$2$i;
       break;
      } else {
       $HasAlt$059$i = $HasAlt$1$i;
       $HasIsMap$058$i = $HasIsMap$1$i;
       $HasLongDesc$054$i = $HasLongDesc$1$i;
       $HasValidHeight$055$i = $HasValidHeight$1$i;
       $HasValidWidthBullet$056$i = $HasValidWidthBullet$2$i;
       $HasValidWidthHR$057$i = $HasValidWidthHR$2$i;
      }
     }
    }
    $242 = HEAP32[$node + 8 >> 2] | 0;
    do if (!$242) {
     $$0$i = $node;
     $HasDLINK$1$i = 0;
    } else {
     $245 = HEAP32[$242 + 28 >> 2] | 0;
     if (!$245) {
      $$0$i = $node;
      $HasDLINK$1$i = 0;
     } else if ((HEAP32[$245 >> 2] | 0) == 1) {
      $250 = HEAP32[$242 + 12 >> 2] | 0;
      if (!$250) {
       $$0$i = $242;
       $HasDLINK$1$i = 0;
      } else if (!(HEAP32[$250 + 28 >> 2] | 0)) {
       $255 = $doc + 6532 | 0;
       $257 = HEAP32[$250 + 36 >> 2] | 0;
       $258 = $doc + 68 | 0;
       $259 = $250 + 40 | 0;
       L160 : do if ($257 >>> 0 < (HEAP32[$259 >> 2] | 0) >>> 0) {
        $i$02$i18$i = $257;
        $x$01$i19$i = 0;
        while (1) {
         HEAP8[$doc + 6532 + $x$01$i19$i >> 0] = HEAP8[(HEAP32[(HEAP32[$258 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i18$i >> 0] | 0;
         if ($x$01$i19$i >>> 0 > 126) {
          $x$1$i21$i = $x$01$i19$i;
          break L160;
         }
         $i$02$i18$i = $i$02$i18$i + 1 | 0;
         $270 = $x$01$i19$i + 1 | 0;
         if ($i$02$i18$i >>> 0 >= (HEAP32[$259 >> 2] | 0) >>> 0) {
          $x$1$i21$i = $270;
          break;
         } else $x$01$i19$i = $270;
        }
       } else $x$1$i21$i = 0; while (0);
       HEAP8[$doc + 6532 + $x$1$i21$i >> 0] = 0;
       if (_prvTidytmbstrcmp($255, 312072) | 0) if (_prvTidytmbstrcmp($255, 312074) | 0) {
        $$0$i = $242;
        $HasDLINK$1$i = 0;
        break;
       }
       $$0$i = $242;
       $HasDLINK$1$i = 1;
      } else {
       $$0$i = $242;
       $HasDLINK$1$i = 0;
      }
     } else {
      $$0$i = $node;
      $HasDLINK$1$i = 0;
     }
    } while (0);
    $279 = HEAP32[$$0$i + 8 >> 2] | 0;
    do if (!$279) {
     $$1$i = $$0$i;
     $HasDLINK$3$i = $HasDLINK$1$i;
    } else if (!(HEAP32[$279 + 28 >> 2] | 0)) {
     $285 = HEAP32[$279 + 8 >> 2] | 0;
     if (!$285) {
      $$1$i = $279;
      $HasDLINK$3$i = $HasDLINK$1$i;
     } else {
      $288 = HEAP32[$285 + 28 >> 2] | 0;
      if (!$288) {
       $$1$i = $279;
       $HasDLINK$3$i = $HasDLINK$1$i;
      } else if ((HEAP32[$288 >> 2] | 0) == 1) {
       $293 = HEAP32[$285 + 12 >> 2] | 0;
       if (!$293) {
        $$1$i = $285;
        $HasDLINK$3$i = $HasDLINK$1$i;
       } else if (!(HEAP32[$293 + 28 >> 2] | 0)) {
        $298 = $doc + 6532 | 0;
        $300 = HEAP32[$293 + 36 >> 2] | 0;
        $301 = $doc + 68 | 0;
        $302 = $293 + 40 | 0;
        L177 : do if ($300 >>> 0 < (HEAP32[$302 >> 2] | 0) >>> 0) {
         $i$02$i$i337 = $300;
         $x$01$i$i338 = 0;
         while (1) {
          HEAP8[$doc + 6532 + $x$01$i$i338 >> 0] = HEAP8[(HEAP32[(HEAP32[$301 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i$i337 >> 0] | 0;
          if ($x$01$i$i338 >>> 0 > 126) {
           $x$1$i$i340 = $x$01$i$i338;
           break L177;
          }
          $i$02$i$i337 = $i$02$i$i337 + 1 | 0;
          $313 = $x$01$i$i338 + 1 | 0;
          if ($i$02$i$i337 >>> 0 >= (HEAP32[$302 >> 2] | 0) >>> 0) {
           $x$1$i$i340 = $313;
           break;
          } else $x$01$i$i338 = $313;
         }
        } else $x$1$i$i340 = 0; while (0);
        HEAP8[$doc + 6532 + $x$1$i$i340 >> 0] = 0;
        if (_prvTidytmbstrcmp($298, 312072) | 0) if (_prvTidytmbstrcmp($298, 312074) | 0) {
         $$1$i = $285;
         $HasDLINK$3$i = $HasDLINK$1$i;
         break;
        }
        $$1$i = $285;
        $HasDLINK$3$i = 1;
       } else {
        $$1$i = $285;
        $HasDLINK$3$i = $HasDLINK$1$i;
       }
      } else {
       $$1$i = $279;
       $HasDLINK$3$i = $HasDLINK$1$i;
      }
     }
    } else {
     $$1$i = $$0$i;
     $HasDLINK$3$i = $HasDLINK$1$i;
    } while (0);
    if (!$HasAlt$0$lcssa$i) _prvTidyReportAccessError($doc, $$1$i, 300);
    $325 = ($HasLongDesc$0$lcssa$i | 0) == 0;
    if (!((($HasValidWidthHR$0$lcssa$i | 0) == 1 | ($HasValidWidthBullet$0$lcssa$i | 0) == 1) & (($HasValidHeight$0$lcssa$i | 0) == 1 & $325))) {
     if ($325 & ($HasDLINK$3$i | 0) == 1) _prvTidyReportAccessWarning($doc, $$1$i, 309);
     if (($HasLongDesc$0$lcssa$i | 0) == 1 & ($HasDLINK$3$i | 0) == 0) _prvTidyReportAccessWarning($doc, $$1$i, 308);
     if (!($HasDLINK$3$i | $HasLongDesc$0$lcssa$i)) _prvTidyReportAccessWarning($doc, $$1$i, 307);
    }
    if (($HasIsMap$0$lcssa$i | 0) != 1) break L1;
    _prvTidyReportAccessError($doc, $$1$i, 391);
    _prvTidyReportAccessWarning($doc, $$1$i, 324);
    break L1;
    break;
   }
  case 64:
   {
    if ((HEAP32[$doc + 6396 >> 2] | 0) != 3) break L1;
    $child$01$i = HEAP32[$node + 12 >> 2] | 0;
    if (!$child$01$i) break L1;
    $child$02$i = $child$01$i;
    do {
     $336 = HEAP32[$child$02$i + 28 >> 2] | 0;
     L205 : do if ($336 | 0) if ((HEAP32[$336 >> 2] | 0) == 7) {
      $340 = _prvTidyAttrGetById($child$02$i, 59) | 0;
      if ($340 | 0) {
       $342 = $340 + 24 | 0;
       $343 = HEAP32[$342 >> 2] | 0;
       if ($343 | 0) {
        $cp$03$i$i$i345 = $343;
        while (1) {
         $345 = HEAP8[$cp$03$i$i$i345 >> 0] | 0;
         if (!($345 << 24 >> 24)) break L205;
         if (!(_prvTidyIsWhite($345 << 24 >> 24) | 0)) break; else $cp$03$i$i$i345 = $cp$03$i$i$i345 + 1 | 0;
        }
        if (!(_FindLinkA($doc, HEAP32[$342 >> 2] | 0) | 0)) _prvTidyReportAccessError($doc, $node, 326);
       }
      }
     } while (0);
     $child$02$i = HEAP32[$child$02$i + 8 >> 2] | 0;
    } while (($child$02$i | 0) != 0);
    break;
   }
  case 7:
   {
    $av$07$i = HEAP32[$node + 20 >> 2] | 0;
    $doc$idx6$i = $doc + 6396 | 0;
    $doc$idx6$val8$i = HEAP32[$doc$idx6$i >> 2] | 0;
    $358 = ($doc$idx6$val8$i + -1 | 0) >>> 0 < 3;
    if (!$av$07$i) {
     $$lcssa$i = $358;
     $HasAlt$0$lcssa$i356 = 0;
    } else {
     $1459 = $358;
     $HasAlt$010$i = 0;
     $av$011$i = $av$07$i;
     $doc$idx$val$i349 = $doc$idx6$val8$i;
     while (1) {
      if ($1459) {
       $360 = HEAP32[$av$011$i + 4 >> 2] | 0;
       if (!$360) $HasAlt$1$i351 = $HasAlt$010$i; else if ((HEAP32[$360 >> 2] | 0) == 10) $HasAlt$1$i351 = (HEAP32[$av$011$i + 24 >> 2] | 0) == 0 ? $HasAlt$010$i : 1; else $HasAlt$1$i351 = $HasAlt$010$i;
      } else $HasAlt$1$i351 = $HasAlt$010$i;
      do if (($doc$idx$val$i349 | 1 | 0) == 3) {
       $370 = HEAP32[$av$011$i + 4 >> 2] | 0;
       if ($370 | 0) if ((HEAP32[$370 >> 2] | 0) == 146) {
        $374 = $av$011$i + 24 | 0;
        $375 = HEAP32[$374 >> 2] | 0;
        if ($375 | 0) {
         if (!(_prvTidytmbstrcasecmp($375, 311958) | 0)) {
          _prvTidyReportAccessWarning($doc, $node, 398);
          break;
         }
         $$pr$i352 = HEAP32[$374 >> 2] | 0;
         if ($$pr$i352 | 0) if (!(_prvTidytmbstrcasecmp($$pr$i352, 311963) | 0)) _prvTidyReportAccessWarning($doc, $node, 399);
        }
       }
      } while (0);
      $av$011$i = HEAP32[$av$011$i >> 2] | 0;
      $doc$idx$val$i349 = HEAP32[$doc$idx6$i >> 2] | 0;
      $383 = ($doc$idx$val$i349 + -1 | 0) >>> 0 < 3;
      if (!$av$011$i) {
       $$lcssa$i = $383;
       $HasAlt$0$lcssa$i356 = $HasAlt$1$i351;
       break;
      } else {
       $1459 = $383;
       $HasAlt$010$i = $HasAlt$1$i351;
      }
     }
    }
    if (!($$lcssa$i & ($HasAlt$0$lcssa$i356 | 0) == 0)) break L1;
    _prvTidyReportAccessError($doc, $node, 321);
    break L1;
    break;
   }
  case 6:
   {
    $doc$idx$i358 = $doc + 6396 | 0;
    $doc$idx$val$i359 = HEAP32[$doc$idx$i358 >> 2] | 0;
    if (($doc$idx$val$i359 | 1 | 0) == 3) {
     _prvTidyReportAccessError($doc, $node, 405);
     $doc$idx$val$i363 = HEAP32[$doc$idx$i358 >> 2] | 0;
    } else $doc$idx$val$i363 = $doc$idx$val$i359;
    do if (($doc$idx$val$i363 + -1 | 0) >>> 0 < 3) {
     $388 = HEAP32[$1 >> 2] | 0;
     if (!$388) $doc$idx$val$i369 = $doc$idx$val$i363; else {
      $390 = HEAP32[$388 >> 2] | 0;
      if (($390 | 0) == 94) $msgcode$015$i = 371; else if (($390 | 0) == 76) $msgcode$015$i = 372; else if (($390 | 0) == 34) $msgcode$015$i = 373; else if (($390 | 0) == 6) $msgcode$015$i = 374; else {
       $doc$idx$val$i369 = $doc$idx$val$i363;
       break;
      }
      _prvTidyReportAccessWarning($doc, $node, $msgcode$015$i);
      $doc$idx$val$i369 = HEAP32[$doc$idx$i358 >> 2] | 0;
     }
    } else $doc$idx$val$i369 = $doc$idx$val$i363; while (0);
    do if (($doc$idx$val$i369 + -1 | 0) >>> 0 < 3) {
     $396 = HEAP32[$1 >> 2] | 0;
     if (!$396) $doc$idx$val$i374 = $doc$idx$val$i369; else {
      $398 = HEAP32[$396 >> 2] | 0;
      if (($398 | 0) == 6) $msgcode$08$i = 368; else if (($398 | 0) == 94) $msgcode$08$i = 369; else if (($398 | 0) == 76) $msgcode$08$i = 370; else {
       $doc$idx$val$i374 = $doc$idx$val$i369;
       break;
      }
      _prvTidyReportAccessWarning($doc, $node, $msgcode$08$i);
      $doc$idx$val$i374 = HEAP32[$doc$idx$i358 >> 2] | 0;
     }
    } else $doc$idx$val$i374 = $doc$idx$val$i369; while (0);
    do if (($doc$idx$val$i374 + -1 | 0) >>> 0 < 3) {
     $403 = HEAP32[$1 >> 2] | 0;
     if ($403 | 0) {
      $405 = HEAP32[$403 >> 2] | 0;
      if (($405 | 0) == 94) $msgcode$015$i379 = 387; else if (($405 | 0) == 76) $msgcode$015$i379 = 388; else if (($405 | 0) == 34) $msgcode$015$i379 = 390; else if (($405 | 0) == 6) $msgcode$015$i379 = 389; else break;
      _prvTidyReportAccessWarning($doc, $node, $msgcode$015$i379);
     }
    } while (0);
    _CheckFlicker($doc, $node);
    _CheckColorAvailable($doc, $node);
    if (((HEAP32[$doc$idx$i358 >> 2] | 0) + -1 | 0) >>> 0 >= 3) break L1;
    $av$09$i = HEAP32[$node + 20 >> 2] | 0;
    if (!$av$09$i) label = 208; else {
     $HasAlt$010$i385 = 0;
     $av$011$i384 = $av$09$i;
     while (1) {
      $414 = HEAP32[$av$011$i384 + 4 >> 2] | 0;
      if (!$414) $HasAlt$1$i388 = $HasAlt$010$i385; else if ((HEAP32[$414 >> 2] | 0) == 10) $HasAlt$1$i388 = (HEAP32[$av$011$i384 + 24 >> 2] | 0) == 0 ? $HasAlt$010$i385 : 1; else $HasAlt$1$i388 = $HasAlt$010$i385;
      $av$011$i384 = HEAP32[$av$011$i384 >> 2] | 0;
      if (!$av$011$i384) {
       $HasAlt$1$i388$lcssa = $HasAlt$1$i388;
       break;
      } else $HasAlt$010$i385 = $HasAlt$1$i388;
     }
     if (!$HasAlt$1$i388$lcssa) label = 208; else {
      $HasAlt$0$lcssa12$i = $HasAlt$1$i388$lcssa;
      $HasDescription$1$i = 0;
     }
    }
    do if ((label | 0) == 208) {
     $423 = $node + 12 | 0;
     $424 = HEAP32[$423 >> 2] | 0;
     if (!$424) {
      $HasAlt$0$lcssa12$i = 0;
      $HasDescription$1$i = 0;
     } else {
      if (!(HEAP32[$424 + 28 >> 2] | 0)) {
       $429 = $doc + 6532 | 0;
       $431 = HEAP32[$424 + 36 >> 2] | 0;
       $432 = $doc + 68 | 0;
       $433 = $424 + 40 | 0;
       L281 : do if ($431 >>> 0 < (HEAP32[$433 >> 2] | 0) >>> 0) {
        $i$02$i$i391 = $431;
        $x$01$i$i392 = 0;
        while (1) {
         HEAP8[$doc + 6532 + $x$01$i$i392 >> 0] = HEAP8[(HEAP32[(HEAP32[$432 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i$i391 >> 0] | 0;
         if ($x$01$i$i392 >>> 0 > 126) {
          $x$1$i$i393 = $x$01$i$i392;
          break L281;
         }
         $i$02$i$i391 = $i$02$i$i391 + 1 | 0;
         $444 = $x$01$i$i392 + 1 | 0;
         if ($i$02$i$i391 >>> 0 >= (HEAP32[$433 >> 2] | 0) >>> 0) {
          $x$1$i$i393 = $444;
          break;
         } else $x$01$i$i392 = $444;
        }
       } else $x$1$i$i393 = 0; while (0);
       HEAP8[$doc + 6532 + $x$1$i$i393 >> 0] = 0;
       $449 = HEAP32[$423 >> 2] | 0;
       $word$0$i = $429;
      } else {
       $449 = $424;
       $word$0$i = 0;
      }
      $450 = HEAP32[$449 + 12 >> 2] | 0;
      if (!$450) label = 220; else if (!(HEAP32[$450 + 28 >> 2] | 0)) {
       $455 = $doc + 6532 | 0;
       $457 = HEAP32[$450 + 36 >> 2] | 0;
       $458 = $doc + 68 | 0;
       $459 = $450 + 40 | 0;
       L290 : do if ($457 >>> 0 < (HEAP32[$459 >> 2] | 0) >>> 0) {
        $i$02$i3$i = $457;
        $x$01$i4$i = 0;
        while (1) {
         HEAP8[$doc + 6532 + $x$01$i4$i >> 0] = HEAP8[(HEAP32[(HEAP32[$458 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i3$i >> 0] | 0;
         if ($x$01$i4$i >>> 0 > 126) {
          $x$1$i6$i = $x$01$i4$i;
          break L290;
         }
         $i$02$i3$i = $i$02$i3$i + 1 | 0;
         $470 = $x$01$i4$i + 1 | 0;
         if ($i$02$i3$i >>> 0 >= (HEAP32[$459 >> 2] | 0) >>> 0) {
          $x$1$i6$i = $470;
          break;
         } else $x$01$i4$i = $470;
        }
       } else $x$1$i6$i = 0; while (0);
       HEAP8[$doc + 6532 + $x$1$i6$i >> 0] = 0;
       $cp$03$i$i396 = $455;
       $isWht$02$i$i = 1;
      } else label = 220;
      if ((label | 0) == 220) if (!$word$0$i) {
       $HasAlt$0$lcssa12$i = 0;
       $HasDescription$1$i = 0;
       break;
      } else {
       $cp$03$i$i396 = $word$0$i;
       $isWht$02$i$i = 1;
      }
      while (1) {
       $475 = HEAP8[$cp$03$i$i396 >> 0] | 0;
       if (!($475 << 24 >> 24)) {
        $isWht$0$lcssa$i$i = $isWht$02$i$i;
        break;
       }
       $isWht$02$i$i = _prvTidyIsWhite($475 << 24 >> 24) | 0;
       if (!$isWht$02$i$i) {
        $isWht$0$lcssa$i$i = 0;
        break;
       } else $cp$03$i$i396 = $cp$03$i$i396 + 1 | 0;
      }
      $HasAlt$0$lcssa12$i = 0;
      $HasDescription$1$i = ($isWht$0$lcssa$i$i | 0) == 0 & 1;
     }
    } while (0);
    if ($HasDescription$1$i | $HasAlt$0$lcssa12$i | 0) break L1;
    _prvTidyReportAccessError($doc, $node, 312);
    break L1;
    break;
   }
  case 76:
   {
    $doc$idx$i399 = $doc + 6396 | 0;
    $doc$idx$val$i400 = HEAP32[$doc$idx$i399 >> 2] | 0;
    if (($doc$idx$val$i400 + -1 | 0) >>> 0 < 3) {
     _prvTidyReportAccessWarning($doc, $node, 372);
     $doc$idx$val$i409 = HEAP32[$doc$idx$i399 >> 2] | 0;
    } else $doc$idx$val$i409 = $doc$idx$val$i400;
    do if (($doc$idx$val$i409 + -1 | 0) >>> 0 < 3) {
     $486 = HEAP32[$1 >> 2] | 0;
     if (!$486) $doc$idx$val$i417 = $doc$idx$val$i409; else {
      $488 = HEAP32[$486 >> 2] | 0;
      if (($488 | 0) == 6) $msgcode$08$i413 = 368; else if (($488 | 0) == 94) $msgcode$08$i413 = 369; else if (($488 | 0) == 76) $msgcode$08$i413 = 370; else {
       $doc$idx$val$i417 = $doc$idx$val$i409;
       break;
      }
      _prvTidyReportAccessWarning($doc, $node, $msgcode$08$i413);
      $doc$idx$val$i417 = HEAP32[$doc$idx$i399 >> 2] | 0;
     }
    } else $doc$idx$val$i417 = $doc$idx$val$i409; while (0);
    do if (($doc$idx$val$i417 + -1 | 0) >>> 0 < 3) {
     $493 = HEAP32[$1 >> 2] | 0;
     if ($493 | 0) {
      $495 = HEAP32[$493 >> 2] | 0;
      if (($495 | 0) == 94) $msgcode$015$i422 = 387; else if (($495 | 0) == 76) $msgcode$015$i422 = 388; else if (($495 | 0) == 34) $msgcode$015$i422 = 390; else if (($495 | 0) == 6) $msgcode$015$i422 = 389; else break;
      _prvTidyReportAccessWarning($doc, $node, $msgcode$015$i422);
     }
    } while (0);
    _CheckFlicker($doc, $node);
    _CheckColorAvailable($doc, $node);
    if (((HEAP32[$doc$idx$i399 >> 2] | 0) + -1 | 0) >>> 0 >= 3) break L1;
    $501 = $node + 12 | 0;
    $502 = HEAP32[$501 >> 2] | 0;
    L325 : do if (!$502) {
     $HasAlt$2$i = 0;
     $HasDescription$1$i446 = 0;
    } else {
     if ((HEAP32[$502 + 44 >> 2] | 0) != 4) {
      $av$016$i = HEAP32[$502 + 20 >> 2] | 0;
      if ($av$016$i | 0) {
       $av$017$i = $av$016$i;
       do {
        $510 = HEAP32[$av$017$i + 4 >> 2] | 0;
        if ($510 | 0) if ((HEAP32[$510 >> 2] | 0) == 10) {
         $HasAlt$2$i = 1;
         $HasDescription$1$i446 = 0;
         break L325;
        }
        $av$017$i = HEAP32[$av$017$i >> 2] | 0;
       } while (($av$017$i | 0) != 0);
      }
     }
     $516 = (_prvTidynodeIsText($502) | 0) == 0;
     $517 = HEAP32[$501 >> 2] | 0;
     L335 : do if ($516) {
      if (!(_prvTidynodeIsText(HEAP32[$517 + 12 >> 2] | 0) | 0)) {
       $HasAlt$2$i = 0;
       $HasDescription$1$i446 = 0;
       break L325;
      }
      $544 = HEAP32[(HEAP32[$501 >> 2] | 0) + 12 >> 2] | 0;
      $545 = $doc + 6532 | 0;
      L338 : do if (!$544) $x$1$i6$i439 = 0; else {
       $548 = HEAP32[$544 + 36 >> 2] | 0;
       $549 = $doc + 68 | 0;
       $550 = $544 + 40 | 0;
       if ($548 >>> 0 < (HEAP32[$550 >> 2] | 0) >>> 0) {
        $i$02$i3$i436 = $548;
        $x$01$i4$i437 = 0;
        while (1) {
         HEAP8[$doc + 6532 + $x$01$i4$i437 >> 0] = HEAP8[(HEAP32[(HEAP32[$549 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i3$i436 >> 0] | 0;
         if ($x$01$i4$i437 >>> 0 > 126) {
          $x$1$i6$i439 = $x$01$i4$i437;
          break L338;
         }
         $i$02$i3$i436 = $i$02$i3$i436 + 1 | 0;
         $561 = $x$01$i4$i437 + 1 | 0;
         if ($i$02$i3$i436 >>> 0 >= (HEAP32[$550 >> 2] | 0) >>> 0) {
          $x$1$i6$i439 = $561;
          break;
         } else $x$01$i4$i437 = $561;
        }
       } else $x$1$i6$i439 = 0;
      } while (0);
      HEAP8[$doc + 6532 + $x$1$i6$i439 >> 0] = 0;
      $cp$03$i$i440 = $545;
      $isWht$02$i$i441 = 1;
     } else {
      $518 = $doc + 6532 | 0;
      L345 : do if (!$517) $x$1$i$i433 = 0; else {
       $521 = HEAP32[$517 + 36 >> 2] | 0;
       $522 = $doc + 68 | 0;
       $523 = $517 + 40 | 0;
       if ($521 >>> 0 < (HEAP32[$523 >> 2] | 0) >>> 0) {
        $i$02$i$i430 = $521;
        $x$01$i$i431 = 0;
        while (1) {
         $531 = $doc + 6532 + $x$01$i$i431 | 0;
         HEAP8[$531 >> 0] = HEAP8[(HEAP32[(HEAP32[$522 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i$i430 >> 0] | 0;
         if ($x$01$i$i431 >>> 0 > 126) {
          $$lcssa923 = $531;
          break;
         }
         $i$02$i$i430 = $i$02$i$i430 + 1 | 0;
         $534 = $x$01$i$i431 + 1 | 0;
         if ($i$02$i$i430 >>> 0 >= (HEAP32[$523 >> 2] | 0) >>> 0) {
          $x$1$i$i433 = $534;
          break L345;
         } else $x$01$i$i431 = $534;
        }
        HEAP8[$$lcssa923 >> 0] = 0;
        $cp$03$i$i440 = $518;
        $isWht$02$i$i441 = 1;
        break L335;
       } else $x$1$i$i433 = 0;
      } while (0);
      HEAP8[$doc + 6532 + $x$1$i$i433 >> 0] = 0;
      $cp$03$i$i440 = $518;
      $isWht$02$i$i441 = 1;
     } while (0);
     while (1) {
      $565 = HEAP8[$cp$03$i$i440 >> 0] | 0;
      if (!($565 << 24 >> 24)) {
       $isWht$0$lcssa$i$i443 = $isWht$02$i$i441;
       break;
      }
      $isWht$02$i$i441 = _prvTidyIsWhite($565 << 24 >> 24) | 0;
      if (!$isWht$02$i$i441) {
       $isWht$0$lcssa$i$i443 = 0;
       break;
      } else $cp$03$i$i440 = $cp$03$i$i440 + 1 | 0;
     }
     $HasAlt$2$i = 0;
     $HasDescription$1$i446 = ($isWht$0$lcssa$i$i443 | 0) == 0 & 1;
    } while (0);
    if ($HasAlt$2$i | $HasDescription$1$i446 | 0) break L1;
    _prvTidyReportAccessError($doc, $node, 313);
    break L1;
    break;
   }
  case 38:
   {
    $574 = $doc + 6660 | 0;
    HEAP32[$574 >> 2] = (HEAP32[$574 >> 2] | 0) + 1;
    if (((HEAP32[$doc + 6396 >> 2] | 0) + -1 | 0) >>> 0 >= 3) break L1;
    $av$015$i = HEAP32[$node + 20 >> 2] | 0;
    if (!$av$015$i) label = 296; else {
     $580 = $doc + 6664 | 0;
     $HasTitle$016$i = 0;
     $av$017$i451 = $av$015$i;
     while (1) {
      $582 = HEAP32[$av$017$i451 + 4 >> 2] | 0;
      L364 : do if (!$582) $HasTitle$2$i = $HasTitle$016$i; else switch (HEAP32[$582 >> 2] | 0) {
      case 77:
       {
        $585 = $av$017$i451 + 24 | 0;
        $586 = HEAP32[$585 >> 2] | 0;
        if (!$586) {
         $HasTitle$2$i = $HasTitle$016$i;
         break L364;
        } else $cp$03$i$i$i452 = $586;
        while (1) {
         $588 = HEAP8[$cp$03$i$i$i452 >> 0] | 0;
         if (!($588 << 24 >> 24)) {
          $HasTitle$2$i = $HasTitle$016$i;
          break L364;
         }
         if (!(_prvTidyIsWhite($588 << 24 >> 24) | 0)) break; else $cp$03$i$i$i452 = $cp$03$i$i$i452 + 1 | 0;
        }
        if ((_prvTidytmbstrlen(HEAP32[$585 >> 2] | 0) | 0) >>> 0 <= 1) {
         $HasTitle$2$i = $HasTitle$016$i;
         break L364;
        }
        HEAP32[$580 >> 2] = (HEAP32[$580 >> 2] | 0) + 1;
        $HasTitle$2$i = $HasTitle$016$i;
        break L364;
        break;
       }
      case 139:
       {
        $599 = $av$017$i451 + 24 | 0;
        $600 = HEAP32[$599 >> 2] | 0;
        if (!$600) {
         $HasTitle$2$i = $HasTitle$016$i;
         break L364;
        } else $cp$03$i$i1$i = $600;
        while (1) {
         $602 = HEAP8[$cp$03$i$i1$i >> 0] | 0;
         if (!($602 << 24 >> 24)) {
          $HasTitle$2$i = $HasTitle$016$i;
          break L364;
         }
         if (!(_prvTidyIsWhite($602 << 24 >> 24) | 0)) break; else $cp$03$i$i1$i = $cp$03$i$i1$i + 1 | 0;
        }
        if (_IsValidSrcExtension(HEAP32[$599 >> 2] | 0) | 0) {
         $HasTitle$2$i = $HasTitle$016$i;
         break L364;
        }
        _prvTidyReportAccessError($doc, $node, 367);
        $HasTitle$2$i = $HasTitle$016$i;
        break L364;
        break;
       }
      case 148:
       {
        $611 = $av$017$i451 + 24 | 0;
        $612 = HEAP32[$611 >> 2] | 0;
        L380 : do if (!$612) $isWht$0$lcssa$i$i10$i = 1; else {
         $cp$03$i$i7$i = $612;
         $isWht$02$i$i8$i = 1;
         while (1) {
          $614 = HEAP8[$cp$03$i$i7$i >> 0] | 0;
          if (!($614 << 24 >> 24)) {
           $isWht$0$lcssa$i$i10$i = $isWht$02$i$i8$i;
           break L380;
          }
          $isWht$02$i$i8$i = _prvTidyIsWhite($614 << 24 >> 24) | 0;
          if (!$isWht$02$i$i8$i) {
           $HasTitle$2$i = 1;
           break L364;
          } else $cp$03$i$i7$i = $cp$03$i$i7$i + 1 | 0;
         }
        } while (0);
        $HasTitle$0$$i = ($isWht$0$lcssa$i$i10$i | 0) == 0 ? 1 : $HasTitle$016$i;
        if ($HasTitle$0$$i | 0) {
         $HasTitle$2$i = $HasTitle$0$$i;
         break L364;
        }
        $622 = HEAP32[$611 >> 2] | 0;
        if ($622 | 0) if (_prvTidytmbstrlen($622) | 0) {
         $626 = HEAP32[$611 >> 2] | 0;
         if (!$626) $634 = 0; else {
          $cp$03$i$i455 = $626;
          while (1) {
           $628 = HEAP8[$cp$03$i$i455 >> 0] | 0;
           if (!($628 << 24 >> 24)) break;
           if (!(_prvTidyIsWhite($628 << 24 >> 24) | 0)) {
            $HasTitle$2$i = 0;
            break L364;
           } else $cp$03$i$i455 = $cp$03$i$i455 + 1 | 0;
          }
          $634 = HEAP32[$611 >> 2] | 0;
         }
         if (!(_prvTidytmbstrlen($634) | 0)) {
          $HasTitle$2$i = 0;
          break L364;
         }
         _prvTidyReportAccessError($doc, $node, 417);
         $HasTitle$2$i = 1;
         break L364;
        }
        _prvTidyReportAccessError($doc, $node, 416);
        $HasTitle$2$i = 1;
        break L364;
        break;
       }
      default:
       {
        $HasTitle$2$i = $HasTitle$016$i;
        break L364;
       }
      } while (0);
      $av$017$i451 = HEAP32[$av$017$i451 >> 2] | 0;
      if (!$av$017$i451) {
       $HasTitle$2$i$lcssa = $HasTitle$2$i;
       break;
      } else $HasTitle$016$i = $HasTitle$2$i;
     }
     if (!$HasTitle$2$i$lcssa) label = 296;
    }
    if ((label | 0) == 296) _prvTidyReportAccessError($doc, $node, 415);
    if ((HEAP32[$574 >> 2] | 0) != 3) break L1;
    if ((HEAP32[$doc + 6664 >> 2] | 0) >= 3) break L1;
    HEAP32[$574 >> 2] = 0;
    _prvTidyReportAccessWarning($doc, $node, 320);
    break L1;
    break;
   }
  case 50:
   {
    if (((HEAP32[$doc + 6396 >> 2] | 0) + -1 | 0) >>> 0 >= 3) break L1;
    $645 = _prvTidyAttrGetById($node, 139) | 0;
    if (!$645) break L1;
    $647 = $645 + 24 | 0;
    $648 = HEAP32[$647 >> 2] | 0;
    if (!$648) break L1; else $cp$03$i$i$i466 = $648;
    while (1) {
     $650 = HEAP8[$cp$03$i$i$i466 >> 0] | 0;
     if (!($650 << 24 >> 24)) break L1;
     if (!(_prvTidyIsWhite($650 << 24 >> 24) | 0)) break; else $cp$03$i$i$i466 = $cp$03$i$i$i466 + 1 | 0;
    }
    if (_IsValidSrcExtension(HEAP32[$647 >> 2] | 0) | 0) break L1;
    _prvTidyReportAccessError($doc, $node, 367);
    break L1;
    break;
   }
  case 94:
   {
    $doc$idx$i470 = $doc + 6396 | 0;
    $doc$idx$val$i471 = HEAP32[$doc$idx$i470 >> 2] | 0;
    if (($doc$idx$val$i471 + -1 | 0) >>> 0 < 3) {
     _prvTidyReportAccessWarning($doc, $node, 369);
     $doc$idx$val$i479 = HEAP32[$doc$idx$i470 >> 2] | 0;
    } else $doc$idx$val$i479 = $doc$idx$val$i471;
    do if (($doc$idx$val$i479 + -1 | 0) >>> 0 < 3) {
     $661 = HEAP32[$1 >> 2] | 0;
     if (!$661) $doc$idx$val$i488 = $doc$idx$val$i479; else {
      $663 = HEAP32[$661 >> 2] | 0;
      if (($663 | 0) == 94) $msgcode$015$i484 = 371; else if (($663 | 0) == 76) $msgcode$015$i484 = 372; else if (($663 | 0) == 34) $msgcode$015$i484 = 373; else if (($663 | 0) == 6) $msgcode$015$i484 = 374; else {
       $doc$idx$val$i488 = $doc$idx$val$i479;
       break;
      }
      _prvTidyReportAccessWarning($doc, $node, $msgcode$015$i484);
      $doc$idx$val$i488 = HEAP32[$doc$idx$i470 >> 2] | 0;
     }
    } else $doc$idx$val$i488 = $doc$idx$val$i479; while (0);
    do if (($doc$idx$val$i488 + -1 | 0) >>> 0 < 3) {
     $669 = HEAP32[$1 >> 2] | 0;
     if ($669 | 0) {
      $671 = HEAP32[$669 >> 2] | 0;
      if (($671 | 0) == 94) $msgcode$015$i493 = 387; else if (($671 | 0) == 76) $msgcode$015$i493 = 388; else if (($671 | 0) == 34) $msgcode$015$i493 = 390; else if (($671 | 0) == 6) $msgcode$015$i493 = 389; else break;
      _prvTidyReportAccessWarning($doc, $node, $msgcode$015$i493);
     }
    } while (0);
    _CheckFlicker($doc, $node);
    _CheckColorAvailable($doc, $node);
    if (((HEAP32[$doc$idx$i470 >> 2] | 0) + -1 | 0) >>> 0 >= 3) break L1;
    $678 = HEAP32[$node + 8 >> 2] | 0;
    if ($678 | 0) {
     $681 = HEAP32[$678 + 28 >> 2] | 0;
     if ($681 | 0) if ((HEAP32[$681 >> 2] | 0) == 75) break L1;
    }
    _prvTidyReportAccessError($doc, $node, 322);
    break L1;
    break;
   }
  case 107:
   {
    _CheckColorContrast($doc, $node);
    $doc$idx11$i = $doc + 6396 | 0;
    $doc$idx11$val$i = HEAP32[$doc$idx11$i >> 2] | 0;
    do if (($doc$idx11$val$i | 0) == 3) {
     $av$025$i = HEAP32[$node + 20 >> 2] | 0;
     if (!$av$025$i) $HasSummary$0$lcssa$i = 0; else {
      $HasSummary$026$i = 0;
      $av$027$i = $av$025$i;
      while (1) {
       $689 = HEAP32[$av$027$i + 4 >> 2] | 0;
       L445 : do if (!$689) $HasSummary$2$i = $HasSummary$026$i; else if ((HEAP32[$689 >> 2] | 0) == 144) {
        $693 = $av$027$i + 24 | 0;
        $694 = HEAP32[$693 >> 2] | 0;
        do if ($694 | 0) {
         $cp$03$i$i$i499 = $694;
         while (1) {
          $696 = HEAP8[$cp$03$i$i$i499 >> 0] | 0;
          if (!($696 << 24 >> 24)) {
           $HasSummary$1$ph$ph$i = $HasSummary$026$i;
           break;
          }
          if (!(_prvTidyIsWhite($696 << 24 >> 24) | 0)) {
           label = 335;
           break;
          } else $cp$03$i$i$i499 = $cp$03$i$i$i499 + 1 | 0;
         }
         if ((label | 0) == 335) {
          label = 0;
          $702 = HEAP32[$693 >> 2] | 0;
          if (!$702) break;
          if (!(_prvTidytmbsubstr($702, 312125) | 0)) $HasSummary$1$ph$ph$i = 1; else {
           $706 = HEAP32[$693 >> 2] | 0;
           if (!$706) break;
           if (!(_prvTidytmbsubstr($706, 312133) | 0)) $HasSummary$1$ph$ph$i = 1; else {
            _prvTidyReportAccessError($doc, $node, 359);
            $HasSummary$1$ph$ph$i = 1;
           }
          }
         }
         $$pr39$pr$i = HEAP32[$693 >> 2] | 0;
         if ($$pr39$pr$i | 0) if (_prvTidytmbstrlen($$pr39$pr$i) | 0) {
          $713 = HEAP32[$693 >> 2] | 0;
          if (!$713) $721 = 0; else {
           $cp$03$i$i504 = $713;
           while (1) {
            $715 = HEAP8[$cp$03$i$i504 >> 0] | 0;
            if (!($715 << 24 >> 24)) break;
            if (!(_prvTidyIsWhite($715 << 24 >> 24) | 0)) {
             $HasSummary$2$i = $HasSummary$1$ph$ph$i;
             break L445;
            } else $cp$03$i$i504 = $cp$03$i$i504 + 1 | 0;
           }
           $721 = HEAP32[$693 >> 2] | 0;
          }
          if (!(_prvTidytmbstrlen($721) | 0)) {
           $HasSummary$2$i = $HasSummary$1$ph$ph$i;
           break L445;
          }
          _prvTidyReportAccessError($doc, $node, 358);
          $HasSummary$2$i = 1;
          break L445;
         }
        } while (0);
        _prvTidyReportAccessError($doc, $node, 357);
        $HasSummary$2$i = 1;
       } else $HasSummary$2$i = $HasSummary$026$i; while (0);
       $av$027$i = HEAP32[$av$027$i >> 2] | 0;
       if (!$av$027$i) {
        $HasSummary$0$lcssa$i = $HasSummary$2$i;
        break;
       } else $HasSummary$026$i = $HasSummary$2$i;
      }
     }
     if (!(HEAP32[$node + 12 >> 2] | 0)) {
      _prvTidyReportAccessError($doc, $node, 349);
      break L1;
     } else {
      $HasSummary$3$i = $HasSummary$0$lcssa$i;
      $doc$idx$val$i$i = HEAP32[$doc$idx11$i >> 2] | 0;
      break;
     }
    } else {
     $HasSummary$3$i = 0;
     $doc$idx$val$i$i = $doc$idx11$val$i;
    } while (0);
    $729 = $node + 12 | 0;
    if (($doc$idx$val$i$i + -1 | 0) >>> 0 < 3) {
     $730 = HEAP32[$729 >> 2] | 0;
     if ($730 | 0) {
      $TNode$016$i$i = $730;
      $validColSpanColumns$018$i$i = 1;
      $validColSpanRows$017$i$i = 1;
      while (1) {
       $733 = HEAP32[$TNode$016$i$i + 28 >> 2] | 0;
       if (!$733) {
        $validColSpanColumns$5$i$i = $validColSpanColumns$018$i$i;
        $validColSpanRows$5$i$i = $validColSpanRows$017$i$i;
       } else if ((HEAP32[$733 >> 2] | 0) == 115) {
        $738 = HEAP32[$TNode$016$i$i + 12 >> 2] | 0;
        if (!$738) {
         $validColSpanColumns$5$i$i = $validColSpanColumns$018$i$i;
         $validColSpanRows$5$i$i = $validColSpanRows$017$i$i;
        } else {
         $temp$010$i$i = $738;
         $validColSpanColumns$112$i$i = $validColSpanColumns$018$i$i;
         $validColSpanRows$111$i$i = $validColSpanRows$017$i$i;
         while (1) {
          $741 = HEAP32[$temp$010$i$i + 28 >> 2] | 0;
          if (!$741) {
           $validColSpanColumns$4$i$i = $validColSpanColumns$112$i$i;
           $validColSpanRows$4$i$i = $validColSpanRows$111$i$i;
          } else if ((HEAP32[$741 >> 2] | 0) == 112) {
           $av$04$i$i = HEAP32[$temp$010$i$i + 20 >> 2] | 0;
           if (!$av$04$i$i) {
            $validColSpanColumns$4$i$i = $validColSpanColumns$112$i$i;
            $validColSpanRows$4$i$i = $validColSpanRows$111$i$i;
           } else {
            $av$07$i$i = $av$04$i$i;
            $validColSpanColumns$26$i$i = $validColSpanColumns$112$i$i;
            $validColSpanRows$25$i$i = $validColSpanRows$111$i$i;
            while (1) {
             $748 = HEAP32[$av$07$i$i + 4 >> 2] | 0;
             L489 : do if (!$748) {
              $validColSpanColumns$31$i$i = $validColSpanColumns$26$i$i;
              $validColSpanRows$3$i$i = $validColSpanRows$25$i$i;
             } else switch (HEAP32[$748 >> 2] | 0) {
             case 34:
              {
               $754 = (_atoi(HEAP32[$av$07$i$i + 24 >> 2] | 0) | 0) > 1;
               $validColSpanColumns$31$i$i = $754 ? 0 : $validColSpanColumns$26$i$i;
               $validColSpanRows$3$i$i = $validColSpanRows$25$i$i;
               break L489;
               break;
              }
             case 127:
              {
               $758 = (_atoi(HEAP32[$av$07$i$i + 24 >> 2] | 0) | 0) > 1;
               $validColSpanColumns$31$i$i = $validColSpanColumns$26$i$i;
               $validColSpanRows$3$i$i = $758 ? 0 : $validColSpanRows$25$i$i;
               break L489;
               break;
              }
             default:
              {
               $validColSpanColumns$31$i$i = $validColSpanColumns$26$i$i;
               $validColSpanRows$3$i$i = $validColSpanRows$25$i$i;
               break L489;
              }
             } while (0);
             $av$07$i$i = HEAP32[$av$07$i$i >> 2] | 0;
             if (!$av$07$i$i) {
              $validColSpanColumns$4$i$i = $validColSpanColumns$31$i$i;
              $validColSpanRows$4$i$i = $validColSpanRows$3$i$i;
              break;
             } else {
              $validColSpanColumns$26$i$i = $validColSpanColumns$31$i$i;
              $validColSpanRows$25$i$i = $validColSpanRows$3$i$i;
             }
            }
           }
          } else {
           $validColSpanColumns$4$i$i = $validColSpanColumns$112$i$i;
           $validColSpanRows$4$i$i = $validColSpanRows$111$i$i;
          }
          $temp$010$i$i = HEAP32[$temp$010$i$i + 8 >> 2] | 0;
          if (!$temp$010$i$i) {
           $validColSpanColumns$5$i$i = $validColSpanColumns$4$i$i;
           $validColSpanRows$5$i$i = $validColSpanRows$4$i$i;
           break;
          } else {
           $validColSpanColumns$112$i$i = $validColSpanColumns$4$i$i;
           $validColSpanRows$111$i$i = $validColSpanRows$4$i$i;
          }
         }
        }
       } else {
        $validColSpanColumns$5$i$i = $validColSpanColumns$018$i$i;
        $validColSpanRows$5$i$i = $validColSpanRows$017$i$i;
       }
       $TNode$016$i$i = HEAP32[$TNode$016$i$i + 8 >> 2] | 0;
       if (!$TNode$016$i$i) {
        $validColSpanColumns$5$i$i$lcssa = $validColSpanColumns$5$i$i;
        $validColSpanRows$5$i$i$lcssa = $validColSpanRows$5$i$i;
        break;
       } else {
        $validColSpanColumns$018$i$i = $validColSpanColumns$5$i$i;
        $validColSpanRows$017$i$i = $validColSpanRows$5$i$i;
       }
      }
      if (!$validColSpanRows$5$i$i$lcssa) {
       _prvTidyReportAccessWarning($doc, $node, 353);
       _prvTidyDisplayHTMLTableAlgorithm($doc);
      }
      if (!$validColSpanColumns$5$i$i$lcssa) {
       _prvTidyReportAccessWarning($doc, $node, 352);
       _prvTidyDisplayHTMLTableAlgorithm($doc);
      }
     }
    }
    L503 : do if ((HEAP32[$doc$idx11$i >> 2] | 1 | 0) == 3) {
     $770 = HEAP32[$729 >> 2] | 0;
     L505 : do if ($770 | 0) {
      $773 = HEAP32[$770 + 28 >> 2] | 0;
      if ($773 | 0) if ((HEAP32[$773 >> 2] | 0) == 19) {
       $777 = $770 + 12 | 0;
       $778 = HEAP32[$777 >> 2] | 0;
       if ($778 | 0) if (!(HEAP32[$778 + 28 >> 2] | 0)) {
        _memset($doc + 6400 | 0, 0, 132) | 0;
        _getTextNode($doc, HEAP32[$777 >> 2] | 0);
        $cp$03$i14$i = $doc + 6404 | 0;
        while (1) {
         $786 = HEAP8[$cp$03$i14$i >> 0] | 0;
         if (!($786 << 24 >> 24)) break L505;
         if (!(_prvTidyIsWhite($786 << 24 >> 24) | 0)) break L503; else $cp$03$i14$i = $cp$03$i14$i + 1 | 0;
        }
       }
      }
     } while (0);
     _prvTidyReportAccessError($doc, $node, 360);
    } while (0);
    $792 = HEAP32[$729 >> 2] | 0;
    L516 : do if ($792 | 0) {
     $795 = HEAP32[$792 + 28 >> 2] | 0;
     if ($795 | 0) {
      switch (HEAP32[$795 >> 2] | 0) {
      case 19:
       break;
      case 115:
       {
        _CheckColumns($doc, $792);
        break L516;
        break;
       }
      default:
       break L516;
      }
      $799 = HEAP32[$792 + 8 >> 2] | 0;
      if ($799 | 0) {
       $802 = HEAP32[$799 + 28 >> 2] | 0;
       if ($802 | 0) if ((HEAP32[$802 >> 2] | 0) == 115) _CheckColumns($doc, $799);
      }
     }
    } while (0);
    $806 = $doc + 6708 | 0;
    L526 : do if (!(HEAP32[$806 >> 2] | 0)) {
     $809 = HEAP32[$729 >> 2] | 0;
     if ($809 | 0) {
      $812 = HEAP32[$809 + 28 >> 2] | 0;
      if ($812 | 0) {
       switch (HEAP32[$812 >> 2] | 0) {
       case 19:
        break;
       case 115:
        {
         _CheckRows($doc, $809);
         break L526;
         break;
        }
       default:
        break L526;
       }
       $816 = HEAP32[$809 + 8 >> 2] | 0;
       if ($816 | 0) {
        $819 = HEAP32[$816 + 28 >> 2] | 0;
        if ($819 | 0) if ((HEAP32[$819 >> 2] | 0) == 115) _CheckRows($doc, $816);
       }
      }
     }
    } while (0);
    $doc$idx10$val$i = HEAP32[$doc$idx11$i >> 2] | 0;
    if (($HasSummary$3$i | 0) == 0 & ($doc$idx10$val$i | 0) == 3) {
     _prvTidyReportAccessError($doc, $node, 356);
     $doc$idx$val$i512 = HEAP32[$doc$idx11$i >> 2] | 0;
    } else $doc$idx$val$i512 = $doc$idx10$val$i;
    if (($doc$idx$val$i512 | 1 | 0) == 3) {
     $827 = HEAP32[$729 >> 2] | 0;
     if ($827 | 0) {
      $numTR$024$i = 0;
      $temp$023$i = $827;
      while (1) {
       $830 = HEAP32[$temp$023$i + 28 >> 2] | 0;
       if (!$830) $numTR$1$i = $numTR$024$i; else $numTR$1$i = ((HEAP32[$830 >> 2] | 0) == 115 & 1) + $numTR$024$i | 0;
       $temp$023$i = HEAP32[$temp$023$i + 8 >> 2] | 0;
       if (!$temp$023$i) {
        $numTR$1$i$lcssa = $numTR$1$i;
        break;
       } else $numTR$024$i = $numTR$1$i;
      }
      if (($numTR$1$i$lcssa | 0) == 1) _prvTidyReportAccessWarning($doc, $node, 354);
     }
     if (HEAP32[$doc + 6692 >> 2] | 0) _prvTidyReportAccessWarning($doc, $node, 355);
    }
    if (((HEAP32[$doc$idx11$i >> 2] | 0) + -1 | 0) >>> 0 >= 3) break L1;
    if ((HEAP32[$doc + 6668 >> 2] | 0) != 2) break L1;
    $846 = $doc + 6704 | 0;
    do if (!(HEAP32[$846 >> 2] | 0)) {
     $851 = $doc + 6712 | 0;
     if (!(HEAP32[$806 >> 2] | 0)) if (!(HEAP32[$851 >> 2] | 0)) if (!(HEAP32[$doc + 6716 >> 2] | 0)) {
      _prvTidyReportAccessError($doc, $node, 349);
      if (HEAP32[$846 >> 2] | 0) break;
     }
     if (HEAP32[$851 >> 2] | 0) _prvTidyReportAccessError($doc, $node, 351);
    } while (0);
    if (HEAP32[$806 >> 2] | 0) break L1;
    if (!(HEAP32[$doc + 6716 >> 2] | 0)) break L1;
    _prvTidyReportAccessError($doc, $node, 350);
    break L1;
    break;
   }
  case 121:
  case 84:
   {
    $doc$idx4$i = $doc + 6396 | 0;
    $doc$idx4$val$i516 = HEAP32[$doc$idx4$i >> 2] | 0;
    do if (($doc$idx4$val$i516 + -1 | 0) >>> 0 < 3) {
     $866 = HEAP32[$node + 12 >> 2] | 0;
     if (!$866) {
      $HasSkipOverLink$2$i = 0;
      $IsAscii$1$i = 0;
      $doc$idx$val$i524 = $doc$idx4$val$i516;
      $skipOver$2$i = 0;
     } else {
      $869 = HEAP32[$866 + 36 >> 2] | 0;
      $871 = HEAP32[$866 + 40 >> 2] | 0;
      $i$0$i794 = $869 + 1 | 0;
      if ($i$0$i794 >>> 0 < $871 >>> 0) {
       $876 = HEAP32[(HEAP32[$doc + 68 >> 2] | 0) + 84 >> 2] | 0;
       $i$0$i797 = $i$0$i794;
       $i$0$in$i795 = $869;
       $newLines$0$i796 = -1;
       while (1) {
        $878 = HEAP8[$876 + $i$0$i797 >> 0] | 0;
        $$newLines$0$i = ($878 << 24 >> 24 == 10 & 1) + $newLines$0$i796 | 0;
        if ($i$0$i797 >>> 0 < ($i$0$in$i795 + 6 | 0) >>> 0) if ((HEAP8[$876 + ($i$0$in$i795 + 2) >> 0] | 0) == $878 << 24 >> 24) if ((HEAP8[$876 + ($i$0$in$i795 + 3) >> 0] | 0) == $878 << 24 >> 24) if ((HEAP8[$876 + ($i$0$in$i795 + 4) >> 0] | 0) == $878 << 24 >> 24) if ((HEAP8[$876 + ($i$0$in$i795 + 5) >> 0] | 0) == $878 << 24 >> 24) break;
        $i$0$i = $i$0$i797 + 1 | 0;
        if ($i$0$i >>> 0 < $871 >>> 0) {
         $i$0$in$i795$phi = $i$0$i797;
         $i$0$i797 = $i$0$i;
         $newLines$0$i796 = $$newLines$0$i;
         $i$0$in$i795 = $i$0$in$i795$phi;
        } else {
         $$newLines$0$i$lcssa927 = $$newLines$0$i;
         label = 429;
         break;
        }
       }
       if ((label | 0) == 429) if (($$newLines$0$i$lcssa927 | 0) <= 5) {
        $HasSkipOverLink$2$i = 0;
        $IsAscii$1$i = 0;
        $doc$idx$val$i524 = $doc$idx4$val$i516;
        $skipOver$2$i = 0;
        break;
       }
       $890 = HEAP32[$node + 4 >> 2] | 0;
       if (!$890) {
        $HasSkipOverLink$2$i = 0;
        $IsAscii$1$i = 1;
        $doc$idx$val$i524 = $doc$idx4$val$i516;
        $skipOver$2$i = 0;
       } else {
        $893 = HEAP32[$890 + 4 >> 2] | 0;
        if (!$893) {
         $HasSkipOverLink$2$i = 0;
         $IsAscii$1$i = 1;
         $doc$idx$val$i524 = $doc$idx4$val$i516;
         $skipOver$2$i = 0;
        } else {
         $av$021$i520 = HEAP32[$893 + 20 >> 2] | 0;
         if (!$av$021$i520) {
          $HasSkipOverLink$2$i = 0;
          $IsAscii$1$i = 1;
          $doc$idx$val$i524 = $doc$idx4$val$i516;
          $skipOver$2$i = 0;
         } else {
          $HasSkipOverLink$022$i = 0;
          $av$024$i521 = $av$021$i520;
          $skipOver$023$i = 0;
          while (1) {
           $898 = HEAP32[$av$024$i521 + 4 >> 2] | 0;
           L586 : do if (!$898) {
            $HasSkipOverLink$1$i = $HasSkipOverLink$022$i;
            $skipOver$1$i = $skipOver$023$i;
           } else if ((HEAP32[$898 >> 2] | 0) == 59) {
            $902 = $av$024$i521 + 24 | 0;
            $903 = HEAP32[$902 >> 2] | 0;
            if (!$903) {
             $HasSkipOverLink$1$i = $HasSkipOverLink$022$i;
             $skipOver$1$i = $skipOver$023$i;
            } else {
             $cp$03$i$i6$i = $903;
             while (1) {
              $905 = HEAP8[$cp$03$i$i6$i >> 0] | 0;
              if (!($905 << 24 >> 24)) {
               $HasSkipOverLink$1$i = $HasSkipOverLink$022$i;
               $skipOver$1$i = $skipOver$023$i;
               break L586;
              }
              if (!(_prvTidyIsWhite($905 << 24 >> 24) | 0)) break; else $cp$03$i$i6$i = $cp$03$i$i6$i + 1 | 0;
             }
             $HasSkipOverLink$1$i = $HasSkipOverLink$022$i + 1 | 0;
             $skipOver$1$i = HEAP32[$902 >> 2] | 0;
            }
           } else {
            $HasSkipOverLink$1$i = $HasSkipOverLink$022$i;
            $skipOver$1$i = $skipOver$023$i;
           } while (0);
           $av$024$i521 = HEAP32[$av$024$i521 >> 2] | 0;
           if (!$av$024$i521) {
            $HasSkipOverLink$1$i$lcssa = $HasSkipOverLink$1$i;
            $skipOver$1$i$lcssa = $skipOver$1$i;
            break;
           } else {
            $HasSkipOverLink$022$i = $HasSkipOverLink$1$i;
            $skipOver$023$i = $skipOver$1$i;
           }
          }
          $HasSkipOverLink$2$i = $HasSkipOverLink$1$i$lcssa;
          $IsAscii$1$i = 1;
          $doc$idx$val$i524 = HEAP32[$doc$idx4$i >> 2] | 0;
          $skipOver$2$i = $skipOver$1$i$lcssa;
         }
        }
       }
      } else {
       $HasSkipOverLink$2$i = 0;
       $IsAscii$1$i = 0;
       $doc$idx$val$i524 = $doc$idx4$val$i516;
       $skipOver$2$i = 0;
      }
     }
    } else {
     $HasSkipOverLink$2$i = 0;
     $IsAscii$1$i = 0;
     $doc$idx$val$i524 = $doc$idx4$val$i516;
     $skipOver$2$i = 0;
    } while (0);
    if (($doc$idx$val$i524 | 1 | 0) != 3) break L1;
    if (($HasSkipOverLink$2$i | 0) == 1) {
     $918 = HEAP32[$node + 8 >> 2] | 0;
     if (!$918) $HasSkipOverLink$5$i = 1; else {
      $921 = HEAP32[$918 + 28 >> 2] | 0;
      if (!$921) $HasSkipOverLink$5$i = 1; else if ((HEAP32[$921 >> 2] | 0) == 1) {
       $av$117$i = HEAP32[$918 + 20 >> 2] | 0;
       if (!$av$117$i) $HasSkipOverLink$5$i = 1; else {
        $HasSkipOverLink$318$i = 1;
        $av$119$i = $av$117$i;
        while (1) {
         $928 = HEAP32[$av$119$i + 4 >> 2] | 0;
         L604 : do if (!$928) $HasSkipOverLink$4$i = $HasSkipOverLink$318$i; else if ((HEAP32[$928 >> 2] | 0) == 85) {
          $932 = $av$119$i + 24 | 0;
          $933 = HEAP32[$932 >> 2] | 0;
          if (!$933) $HasSkipOverLink$4$i = $HasSkipOverLink$318$i; else {
           $cp$03$i$i$i526 = $933;
           while (1) {
            $935 = HEAP8[$cp$03$i$i$i526 >> 0] | 0;
            if (!($935 << 24 >> 24)) {
             $HasSkipOverLink$4$i = $HasSkipOverLink$318$i;
             break L604;
            }
            if (!(_prvTidyIsWhite($935 << 24 >> 24) | 0)) break; else $cp$03$i$i$i526 = $cp$03$i$i$i526 + 1 | 0;
           }
           $HasSkipOverLink$4$i = ((_strstr($skipOver$2$i, HEAP32[$932 >> 2] | 0) | 0) != 0 & 1) + $HasSkipOverLink$318$i | 0;
          }
         } else $HasSkipOverLink$4$i = $HasSkipOverLink$318$i; while (0);
         $av$119$i = HEAP32[$av$119$i >> 2] | 0;
         if (!$av$119$i) {
          $HasSkipOverLink$5$i = $HasSkipOverLink$4$i;
          break;
         } else $HasSkipOverLink$318$i = $HasSkipOverLink$4$i;
        }
       }
      } else $HasSkipOverLink$5$i = 1;
     }
    } else $HasSkipOverLink$5$i = $HasSkipOverLink$2$i;
    if (($IsAscii$1$i | 0) != 1) break L1;
    _prvTidyReportAccessError($doc, $node, 323);
    if (!(($HasSkipOverLink$5$i | 0) < 2 & (HEAP32[$doc$idx4$i >> 2] | 0) == 3)) break L1;
    _prvTidyReportAccessError($doc, $node, 430);
    break L1;
    break;
   }
  case 58:
   {
    if ((HEAP32[$doc + 6396 >> 2] | 1 | 0) != 3) break L1;
    $962 = _prvTidyAttrGetById($node, 51) | 0;
    L617 : do if ($962 | 0) {
     $965 = HEAP32[$962 + 24 >> 2] | 0;
     if ($965 | 0) {
      $cp$03$i$i$i534 = $965;
      while (1) {
       $967 = HEAP8[$cp$03$i$i$i534 >> 0] | 0;
       if (!($967 << 24 >> 24)) break L617;
       if (!(_prvTidyIsWhite($967 << 24 >> 24) | 0)) break; else $cp$03$i$i$i534 = $cp$03$i$i$i534 + 1 | 0;
      }
      HEAP32[$doc + 6696 >> 2] = 1;
     }
    } while (0);
    $974 = $doc + 6720 | 0;
    $976 = (HEAP32[$974 >> 2] | 0) + 1 | 0;
    HEAP32[$974 >> 2] = $976;
    if (($976 | 0) != 2) break L1;
    HEAP32[$974 >> 2] = 0;
    $978 = $doc + 6696 | 0;
    $981 = $doc + 6700 | 0;
    if (!(HEAP32[$978 >> 2] | 0)) {
     if (HEAP32[$981 >> 2] | 0) {
      _prvTidyReportAccessError($doc, $node, 419);
      label = 470;
     }
    } else label = 470;
    if ((label | 0) == 470) {
     if (HEAP32[$981 >> 2] | 0) break L1;
     if (HEAP32[$978 >> 2] | 0) {
      _prvTidyReportAccessError($doc, $node, 420);
      if (HEAP32[$981 >> 2] | 0) break L1;
      if (HEAP32[$978 >> 2] | 0) break L1;
     }
    }
    _prvTidyReportAccessError($doc, $node, 418);
    break L1;
    break;
   }
  case 53:
   {
    _CheckColorAvailable($doc, $node);
    $doc$idx$i542 = $doc + 6396 | 0;
    $988 = $node + 20 | 0;
    do if ((HEAP32[$doc$idx$i542 >> 2] | 1 | 0) == 3) {
     $av$01$i = HEAP32[$988 >> 2] | 0;
     if ($av$01$i | 0) {
      $990 = $doc + 6700 | 0;
      $av$02$i = $av$01$i;
      do {
       $992 = HEAP32[$av$02$i + 4 >> 2] | 0;
       L641 : do if ($992 | 0) if ((HEAP32[$992 >> 2] | 0) == 63) {
        $997 = HEAP32[$av$02$i + 24 >> 2] | 0;
        if ($997 | 0) {
         $cp$03$i$i$i545 = $997;
         while (1) {
          $999 = HEAP8[$cp$03$i$i$i545 >> 0] | 0;
          if (!($999 << 24 >> 24)) break L641;
          if (!(_prvTidyIsWhite($999 << 24 >> 24) | 0)) break; else $cp$03$i$i$i545 = $cp$03$i$i$i545 + 1 | 0;
         }
         HEAP32[$990 >> 2] = 1;
        }
       } while (0);
       $av$02$i = HEAP32[$av$02$i >> 2] | 0;
      } while (($av$02$i | 0) != 0);
     }
     $1006 = $doc + 6720 | 0;
     $1008 = (HEAP32[$1006 >> 2] | 0) + 1 | 0;
     HEAP32[$1006 >> 2] = $1008;
     if (($1008 | 0) == 2) {
      HEAP32[$1006 >> 2] = 0;
      $1010 = $doc + 6696 | 0;
      $1013 = $doc + 6700 | 0;
      if (!(HEAP32[$1010 >> 2] | 0)) {
       if (HEAP32[$1013 >> 2] | 0) {
        _prvTidyReportAccessError($doc, $node, 419);
        label = 489;
       }
      } else label = 489;
      if ((label | 0) == 489) {
       if (HEAP32[$1013 >> 2] | 0) break;
       if (HEAP32[$1010 >> 2] | 0) {
        _prvTidyReportAccessError($doc, $node, 420);
        if (HEAP32[$1013 >> 2] | 0) break;
        if (HEAP32[$1010 >> 2] | 0) break;
       }
      }
      _prvTidyReportAccessError($doc, $node, 418);
     }
    } while (0);
    $av$011$i561 = HEAP32[$988 >> 2] | 0;
    if (!$av$011$i561) break L1; else {
     $HasAlt$012$i = 0;
     $MustHaveAlt$013$i = 0;
     $av$014$i = $av$011$i561;
    }
    while (1) {
     $1019 = $av$014$i + 4 | 0;
     $1020 = HEAP32[$1019 >> 2] | 0;
     if (!$1020) {
      $HasAlt$1$i572 = $HasAlt$012$i;
      $MustHaveAlt$110$i = $MustHaveAlt$013$i;
     } else {
      L665 : do if ((HEAP32[$1020 >> 2] | 0) == 151) {
       $1024 = $av$014$i + 24 | 0;
       $1025 = HEAP32[$1024 >> 2] | 0;
       if (!$1025) $MustHaveAlt$1$ph$i = $MustHaveAlt$013$i; else {
        $cp$03$i$i$i564 = $1025;
        while (1) {
         $1027 = HEAP8[$cp$03$i$i$i564 >> 0] | 0;
         if (!($1027 << 24 >> 24)) {
          $MustHaveAlt$1$ph$i = $MustHaveAlt$013$i;
          break L665;
         }
         if (!(_prvTidyIsWhite($1027 << 24 >> 24) | 0)) break; else $cp$03$i$i$i564 = $cp$03$i$i$i564 + 1 | 0;
        }
        if (((HEAP32[$doc$idx$i542 >> 2] | 0) + -1 | 0) >>> 0 < 3) {
         $1034 = HEAP32[$1024 >> 2] | 0;
         if (!$1034) $MustHaveAlt$1$ph$i = $MustHaveAlt$013$i; else {
          $1037 = (_prvTidytmbstrcasecmp($1034, 313236) | 0) == 0;
          $MustHaveAlt$1$ph$i = $1037 ? 1 : $MustHaveAlt$013$i;
         }
        } else $MustHaveAlt$1$ph$i = $MustHaveAlt$013$i;
       }
      } else $MustHaveAlt$1$ph$i = $MustHaveAlt$013$i; while (0);
      $$pr$i569 = HEAP32[$1019 >> 2] | 0;
      if (!$$pr$i569) {
       $HasAlt$1$i572 = $HasAlt$012$i;
       $MustHaveAlt$110$i = $MustHaveAlt$1$ph$i;
      } else if ((HEAP32[$$pr$i569 >> 2] | 0) == 10) {
       $1042 = HEAP32[$av$014$i + 24 >> 2] | 0;
       L676 : do if (!$1042) $isWht$0$lcssa$i$i7$i = 1; else {
        $cp$03$i$i4$i = $1042;
        $isWht$02$i$i5$i = 1;
        while (1) {
         $1044 = HEAP8[$cp$03$i$i4$i >> 0] | 0;
         if (!($1044 << 24 >> 24)) {
          $isWht$0$lcssa$i$i7$i = $isWht$02$i$i5$i;
          break L676;
         }
         $isWht$02$i$i5$i = _prvTidyIsWhite($1044 << 24 >> 24) | 0;
         if (!$isWht$02$i$i5$i) {
          $isWht$0$lcssa$i$i7$i = 0;
          break;
         } else $cp$03$i$i4$i = $cp$03$i$i4$i + 1 | 0;
        }
       } while (0);
       $HasAlt$1$i572 = ($isWht$0$lcssa$i$i7$i | 0) == 0 ? 1 : $HasAlt$012$i;
       $MustHaveAlt$110$i = $MustHaveAlt$1$ph$i;
      } else {
       $HasAlt$1$i572 = $HasAlt$012$i;
       $MustHaveAlt$110$i = $MustHaveAlt$1$ph$i;
      }
     }
     $av$014$i = HEAP32[$av$014$i >> 2] | 0;
     if (!$av$014$i) {
      $HasAlt$1$i572$lcssa = $HasAlt$1$i572;
      $MustHaveAlt$110$i$lcssa = $MustHaveAlt$110$i;
      break;
     } else {
      $HasAlt$012$i = $HasAlt$1$i572;
      $MustHaveAlt$013$i = $MustHaveAlt$110$i;
     }
    }
    if (($MustHaveAlt$110$i$lcssa | 0) == 0 | ($HasAlt$1$i572$lcssa | 0) != 0) break L1;
    _prvTidyReportAccessError($doc, $node, 311);
    break L1;
    break;
   }
  case 39:
   {
    if (((HEAP32[$doc + 6396 >> 2] | 0) + -1 | 0) >>> 0 >= 3) break L1;
    $1055 = $doc + 6836 | 0;
    if (HEAP32[$1055 >> 2] & 64 | 0) {
     _prvTidyReportAccessError($doc, $node, 378);
     HEAP32[$1055 >> 2] = HEAP32[$1055 >> 2] & -65;
    }
    $temp$07$i = HEAP32[$node + 12 >> 2] | 0;
    if ($temp$07$i | 0) {
     $1063 = $doc + 6532 | 0;
     $1064 = $doc + 68 | 0;
     $HasNoFrames$08$i = 0;
     $temp$09$i = $temp$07$i;
     while (1) {
      $1066 = HEAP32[$temp$09$i + 28 >> 2] | 0;
      L693 : do if (!$1066) $HasNoFrames$1$i = $HasNoFrames$08$i; else if ((HEAP32[$1066 >> 2] | 0) == 72) {
       $1071 = HEAP32[$temp$09$i + 12 >> 2] | 0;
       if (!$1071) {
        _prvTidyReportAccessError($doc, $temp$09$i, 376);
        $HasNoFrames$1$i = 1;
        break;
       }
       $1074 = HEAP32[$1071 + 12 >> 2] | 0;
       if ($1074 | 0) {
        $1077 = HEAP32[$1074 + 28 >> 2] | 0;
        if ($1077 | 0) if ((HEAP32[$1077 >> 2] | 0) == 80) {
         $1081 = $1074 + 12 | 0;
         if (!(_prvTidynodeIsText(HEAP32[$1081 >> 2] | 0) | 0)) {
          $HasNoFrames$1$i = 1;
          break;
         }
         $1085 = HEAP32[$1081 >> 2] | 0;
         L704 : do if (!$1085) $x$1$i$i584 = 0; else {
          $1088 = HEAP32[$1085 + 36 >> 2] | 0;
          $1089 = $1085 + 40 | 0;
          if ($1088 >>> 0 < (HEAP32[$1089 >> 2] | 0) >>> 0) {
           $i$02$i$i582 = $1088;
           $x$01$i$i583 = 0;
          } else {
           $x$1$i$i584 = 0;
           break;
          }
          while (1) {
           HEAP8[$doc + 6532 + $x$01$i$i583 >> 0] = HEAP8[(HEAP32[(HEAP32[$1064 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i$i582 >> 0] | 0;
           if ($x$01$i$i583 >>> 0 > 126) {
            $x$1$i$i584 = $x$01$i$i583;
            break L704;
           }
           $i$02$i$i582 = $i$02$i$i582 + 1 | 0;
           $1100 = $x$01$i$i583 + 1 | 0;
           if ($i$02$i$i582 >>> 0 >= (HEAP32[$1089 >> 2] | 0) >>> 0) {
            $x$1$i$i584 = $1100;
            break;
           } else $x$01$i$i583 = $1100;
          }
         } while (0);
         HEAP8[$doc + 6532 + $x$1$i$i584 >> 0] = 0;
         if (!(_strstr($1063, 312139) | 0)) {
          $HasNoFrames$1$i = 1;
          break;
         }
         _prvTidyReportAccessError($doc, $1074, 377);
         $HasNoFrames$1$i = 1;
         break;
        }
       }
       $1107 = HEAP32[$1071 + 36 >> 2] | 0;
       $1108 = $1071 + 40 | 0;
       L712 : do if ($1107 >>> 0 < (HEAP32[$1108 >> 2] | 0) >>> 0) {
        $i$02$i2$i = $1107;
        $x$01$i3$i = 0;
        while (1) {
         HEAP8[$doc + 6532 + $x$01$i3$i >> 0] = HEAP8[(HEAP32[(HEAP32[$1064 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i2$i >> 0] | 0;
         if ($x$01$i3$i >>> 0 > 126) {
          $x$1$i5$i = $x$01$i3$i;
          break L712;
         }
         $i$02$i2$i = $i$02$i2$i + 1 | 0;
         $1119 = $x$01$i3$i + 1 | 0;
         if ($i$02$i2$i >>> 0 >= (HEAP32[$1108 >> 2] | 0) >>> 0) {
          $x$1$i5$i = $1119;
          break;
         } else $x$01$i3$i = $1119;
        }
       } else $x$1$i5$i = 0; while (0);
       HEAP8[$doc + 6532 + $x$1$i5$i >> 0] = 0;
       $cp$03$i$i587 = $1063;
       while (1) {
        $1123 = HEAP8[$cp$03$i$i587 >> 0] | 0;
        if (!($1123 << 24 >> 24)) break;
        if (!(_prvTidyIsWhite($1123 << 24 >> 24) | 0)) {
         $HasNoFrames$1$i = 1;
         break L693;
        } else $cp$03$i$i587 = $cp$03$i$i587 + 1 | 0;
       }
       _prvTidyReportAccessError($doc, $temp$09$i, 376);
       $HasNoFrames$1$i = 1;
      } else $HasNoFrames$1$i = $HasNoFrames$08$i; while (0);
      $temp$09$i = HEAP32[$temp$09$i + 8 >> 2] | 0;
      if (!$temp$09$i) {
       $HasNoFrames$1$i$lcssa = $HasNoFrames$1$i;
       break;
      } else $HasNoFrames$08$i = $HasNoFrames$1$i;
     }
     if ($HasNoFrames$1$i$lcssa | 0) break L1;
    }
    _prvTidyReportAccessError($doc, $node, 375);
    break L1;
    break;
   }
  default:
   {
    label = 541;
    break L1;
   }
  } while (0);
 } else label = 541; while (0);
 L724 : do if ((label | 0) == 541) {
  if (_prvTidynodeIsHeader($node) | 0) {
   if ((HEAP32[$doc + 6396 >> 2] | 1 | 0) != 3) break;
   $1137 = HEAP32[$node + 12 >> 2] | 0;
   if (!$1137) $NeedsDescription$1$i = 0; else if (!(HEAP32[$1137 + 28 >> 2] | 0)) {
    $1142 = $doc + 6532 | 0;
    $1144 = HEAP32[$1137 + 36 >> 2] | 0;
    $1145 = $doc + 68 | 0;
    $1146 = $1137 + 40 | 0;
    L732 : do if ($1144 >>> 0 < (HEAP32[$1146 >> 2] | 0) >>> 0) {
     $i$02$i$i595 = $1144;
     $x$01$i$i596 = 0;
     while (1) {
      HEAP8[$doc + 6532 + $x$01$i$i596 >> 0] = HEAP8[(HEAP32[(HEAP32[$1145 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i$i595 >> 0] | 0;
      if ($x$01$i$i596 >>> 0 > 126) {
       $x$1$i$i598 = $x$01$i$i596;
       break L732;
      }
      $i$02$i$i595 = $i$02$i$i595 + 1 | 0;
      $1157 = $x$01$i$i596 + 1 | 0;
      if ($i$02$i$i595 >>> 0 >= (HEAP32[$1146 >> 2] | 0) >>> 0) {
       $x$1$i$i598 = $1157;
       break;
      } else $x$01$i$i596 = $1157;
     }
    } else $x$1$i$i598 = 0; while (0);
    HEAP8[$doc + 6532 + $x$1$i$i598 >> 0] = 0;
    if (!(_prvTidytmbstrlen($1142) | 0)) $numWords$0$lcssa$i = 0; else {
     $i$02$i = 0;
     $numWords$01$i = 1;
     while (1) {
      $$numWords$0$i = ((HEAP8[$doc + 6532 + $i$02$i >> 0] | 0) == 32 & 1) + $numWords$01$i | 0;
      $i$02$i = $i$02$i + 1 | 0;
      if ($i$02$i >>> 0 >= (_prvTidytmbstrlen($1142) | 0) >>> 0) {
       $$numWords$0$i$lcssa = $$numWords$0$i;
       break;
      } else $numWords$01$i = $$numWords$0$i;
     }
     $numWords$0$lcssa$i = ($$numWords$0$i$lcssa | 0) > 20;
    }
    $NeedsDescription$1$i = $numWords$0$lcssa$i & 1;
   } else $NeedsDescription$1$i = 0;
   L743 : do if (!(_prvTidynodeIsHeader($node) | 0)) label = 557; else {
    $1172 = _prvTidynodeHeaderLevel($node) | 0;
    $1173 = $1172 + 1 | 0;
    $node$pn$i = $node;
    while (1) {
     $node$pn$i = HEAP32[$node$pn$i + 8 >> 2] | 0;
     if (!$node$pn$i) break L743;
     $1175 = _prvTidynodeHeaderLevel($node$pn$i) | 0;
     if ($1175 >>> 0 >= $1172 >>> 0) {
      $$lcssa = $1175;
      break;
     }
    }
    if ($$lcssa >>> 0 > $1173 >>> 0) label = 557;
   } while (0);
   if ((label | 0) == 557) _prvTidyReportAccessWarning($doc, $node, 338);
   if (!$NeedsDescription$1$i) break;
   _prvTidyReportAccessWarning($doc, $node, 342);
   break;
  }
  if ($0) {
   $1179 = $node + 28 | 0;
   $1180 = HEAP32[$1179 >> 2] | 0;
   if ($1180 | 0) {
    $1182 = HEAP32[$1180 >> 2] | 0;
    switch ($1182 | 0) {
    case 80:
     {
      if ((HEAP32[$doc + 6396 >> 2] | 1 | 0) != 3) break L724;
      $1185 = $node + 12 | 0;
      $1186 = HEAP32[$1185 >> 2] | 0;
      if (!$1186) break L724;
      $1189 = HEAP32[$1186 + 28 >> 2] | 0;
      if (!$1189) break L724; else $temp$04$i792 = $1186;
      while (1) {
       $temp$04$i792 = HEAP32[$temp$04$i792 + 8 >> 2] | 0;
       if (!$temp$04$i792) break;
       if (!(HEAP32[$temp$04$i792 + 28 >> 2] | 0)) break L724;
      }
      if ((HEAP32[$1189 >> 2] | 0) == 102) {
       _prvTidyReportAccessWarning($doc, $node, 339);
       $$pr$i612 = HEAP32[$1185 >> 2] | 0;
      } else $$pr$i612 = $1186;
      if (!$$pr$i612) break L724;
      $$pre = HEAP32[$$pr$i612 + 28 >> 2] | 0;
      if (!$$pre) break L724;
      if ((HEAP32[$$pre >> 2] | 0) == 117) {
       _prvTidyReportAccessWarning($doc, $node, 341);
       $$pr2$pr$pre$i = HEAP32[$1185 >> 2] | 0;
       if (!$$pr2$pr$pre$i) break L724;
       $$pre834 = HEAP32[$$pr2$pr$pre$i + 28 >> 2] | 0;
       if (!$$pre834) break L724; else $1204 = $$pre834;
      } else $1204 = $$pre;
      if ((HEAP32[$1204 >> 2] | 0) != 33) break L724;
      _prvTidyReportAccessWarning($doc, $node, 340);
      break L724;
      break;
     }
    case 48:
     {
      if ((HEAP32[$doc + 6396 >> 2] | 0) != 3) break L724;
      $1207 = _prvTidyAttrGetById($node, 71) | 0;
      if (!$1207) {
       _prvTidyReportAccessError($doc, $node, 347);
       break L724;
      }
      $1210 = HEAP32[$1207 + 24 >> 2] | 0;
      L852 : do if ($1210 | 0) {
       $cp$03$i$i$i616 = $1210;
       while (1) {
        $1212 = HEAP8[$cp$03$i$i$i616 >> 0] | 0;
        if (!($1212 << 24 >> 24)) break L852;
        if (!(_prvTidyIsWhite($1212 << 24 >> 24) | 0)) break L724; else $cp$03$i$i$i616 = $cp$03$i$i$i616 + 1 | 0;
       }
      } while (0);
      _prvTidyReportAccessError($doc, $node, 348);
      break L724;
      break;
     }
    case 14:
     {
      if ((HEAP32[$doc + 6396 >> 2] | 1 | 0) != 3) break L724;
      $1220 = $node + 12 | 0;
      if (!(_prvTidynodeIsText(HEAP32[$1220 >> 2] | 0) | 0)) break L724;
      $1224 = HEAP32[$1220 >> 2] | 0;
      $1225 = $doc + 6532 | 0;
      L860 : do if (!$1224) $x$1$i$i625 = 0; else {
       $1228 = HEAP32[$1224 + 36 >> 2] | 0;
       $1229 = $doc + 68 | 0;
       $1230 = $1224 + 40 | 0;
       if ($1228 >>> 0 < (HEAP32[$1230 >> 2] | 0) >>> 0) {
        $i$02$i$i622 = $1228;
        $x$01$i$i623 = 0;
        while (1) {
         HEAP8[$doc + 6532 + $x$01$i$i623 >> 0] = HEAP8[(HEAP32[(HEAP32[$1229 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i$i622 >> 0] | 0;
         if ($x$01$i$i623 >>> 0 > 126) {
          $x$1$i$i625 = $x$01$i$i623;
          break L860;
         }
         $i$02$i$i622 = $i$02$i$i622 + 1 | 0;
         $1241 = $x$01$i$i623 + 1 | 0;
         if ($i$02$i$i622 >>> 0 >= (HEAP32[$1230 >> 2] | 0) >>> 0) {
          $x$1$i$i625 = $1241;
          break;
         } else $x$01$i$i623 = $1241;
        }
       } else $x$1$i$i625 = 0;
      } while (0);
      HEAP8[$doc + 6532 + $x$1$i$i625 >> 0] = 0;
      $cp$03$i$i627 = $1225;
      while (1) {
       $1245 = HEAP8[$cp$03$i$i627 >> 0] | 0;
       if (!($1245 << 24 >> 24)) break L724;
       if (!(_prvTidyIsWhite($1245 << 24 >> 24) | 0)) break; else $cp$03$i$i627 = $cp$03$i$i627 + 1 | 0;
      }
      _prvTidyReportAccessError($doc, $node, 384);
      break L724;
      break;
     }
    case 66:
     {
      if ((HEAP32[$doc + 6396 >> 2] | 1 | 0) != 3) break L724;
      if (!(_prvTidynodeIsText($node) | 0)) break L724;
      $1256 = HEAP32[$node + 12 >> 2] | 0;
      $1257 = $doc + 6532 | 0;
      L873 : do if (!$1256) $x$1$i$i635 = 0; else {
       $1260 = HEAP32[$1256 + 36 >> 2] | 0;
       $1261 = $doc + 68 | 0;
       $1262 = $1256 + 40 | 0;
       if ($1260 >>> 0 < (HEAP32[$1262 >> 2] | 0) >>> 0) {
        $i$02$i$i632 = $1260;
        $x$01$i$i633 = 0;
        while (1) {
         HEAP8[$doc + 6532 + $x$01$i$i633 >> 0] = HEAP8[(HEAP32[(HEAP32[$1261 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i$i632 >> 0] | 0;
         if ($x$01$i$i633 >>> 0 > 126) {
          $x$1$i$i635 = $x$01$i$i633;
          break L873;
         }
         $i$02$i$i632 = $i$02$i$i632 + 1 | 0;
         $1273 = $x$01$i$i633 + 1 | 0;
         if ($i$02$i$i632 >>> 0 >= (HEAP32[$1262 >> 2] | 0) >>> 0) {
          $x$1$i$i635 = $1273;
          break;
         } else $x$01$i$i633 = $1273;
        }
       } else $x$1$i$i635 = 0;
      } while (0);
      HEAP8[$doc + 6532 + $x$1$i$i635 >> 0] = 0;
      $cp$03$i$i637 = $1257;
      while (1) {
       $1277 = HEAP8[$cp$03$i$i637 >> 0] | 0;
       if (!($1277 << 24 >> 24)) break L724;
       if (!(_prvTidyIsWhite($1277 << 24 >> 24) | 0)) break; else $cp$03$i$i637 = $cp$03$i$i637 + 1 | 0;
      }
      _prvTidyReportAccessError($doc, $node, 384);
      break L724;
      break;
     }
    case 62:
     {
      if (((HEAP32[$doc + 6396 >> 2] | 0) + -1 | 0) >>> 0 >= 3) break L724;
      $av$011$i643 = HEAP32[$node + 20 >> 2] | 0;
      if (!$av$011$i643) break L724; else {
       $HasRel$012$i = 0;
       $HasType$013$i = 0;
       $av$014$i644 = $av$011$i643;
      }
      while (1) {
       $1286 = $av$014$i644 + 4 | 0;
       $1287 = HEAP32[$1286 >> 2] | 0;
       if (!$1287) {
        $HasRel$110$i = $HasRel$012$i;
        $HasType$1$i = $HasType$013$i;
       } else {
        L889 : do if ((HEAP32[$1287 >> 2] | 0) == 122) {
         $1291 = $av$014$i644 + 24 | 0;
         $1292 = HEAP32[$1291 >> 2] | 0;
         if (!$1292) $HasRel$1$ph$i = $HasRel$012$i; else {
          $cp$03$i$i4$i646 = $1292;
          while (1) {
           $1294 = HEAP8[$cp$03$i$i4$i646 >> 0] | 0;
           if (!($1294 << 24 >> 24)) {
            $HasRel$1$ph$i = $HasRel$012$i;
            break L889;
           }
           if (!(_prvTidyIsWhite($1294 << 24 >> 24) | 0)) break; else $cp$03$i$i4$i646 = $cp$03$i$i4$i646 + 1 | 0;
          }
          $1300 = HEAP32[$1291 >> 2] | 0;
          if (!$1300) $HasRel$1$ph$i = $HasRel$012$i; else {
           $1303 = (_prvTidytmbsubstr($1300, 311719) | 0) == 0;
           $HasRel$1$ph$i = $1303 ? $HasRel$012$i : 1;
          }
         }
        } else $HasRel$1$ph$i = $HasRel$012$i; while (0);
        $$pr$i649 = HEAP32[$1286 >> 2] | 0;
        if (!$$pr$i649) {
         $HasRel$110$i = $HasRel$1$ph$i;
         $HasType$1$i = $HasType$013$i;
        } else if ((HEAP32[$$pr$i649 >> 2] | 0) == 151) {
         $1308 = HEAP32[$av$014$i644 + 24 >> 2] | 0;
         L899 : do if (!$1308) $isWht$0$lcssa$i$i$i = 1; else {
          $cp$03$i$i$i650 = $1308;
          $isWht$02$i$i$i = 1;
          while (1) {
           $1310 = HEAP8[$cp$03$i$i$i650 >> 0] | 0;
           if (!($1310 << 24 >> 24)) {
            $isWht$0$lcssa$i$i$i = $isWht$02$i$i$i;
            break L899;
           }
           $isWht$02$i$i$i = _prvTidyIsWhite($1310 << 24 >> 24) | 0;
           if (!$isWht$02$i$i$i) {
            $isWht$0$lcssa$i$i$i = 0;
            break;
           } else $cp$03$i$i$i650 = $cp$03$i$i$i650 + 1 | 0;
          }
         } while (0);
         $HasRel$110$i = $HasRel$1$ph$i;
         $HasType$1$i = ($isWht$0$lcssa$i$i$i | 0) == 0 ? 1 : $HasType$013$i;
        } else {
         $HasRel$110$i = $HasRel$1$ph$i;
         $HasType$1$i = $HasType$013$i;
        }
       }
       $av$014$i644 = HEAP32[$av$014$i644 >> 2] | 0;
       if (!$av$014$i644) {
        $HasRel$110$i$lcssa = $HasRel$110$i;
        $HasType$1$i$lcssa = $HasType$1$i;
        break;
       } else {
        $HasRel$012$i = $HasRel$110$i;
        $HasType$013$i = $HasType$1$i;
       }
      }
      if (!(($HasRel$110$i$lcssa | 0) != 0 & ($HasType$1$i$lcssa | 0) != 0)) break L724;
      _prvTidyReportAccessWarning($doc, $node, 364);
      break L724;
      break;
     }
    case 103:
     {
      _CheckColorContrast($doc, $node);
      if (((HEAP32[$doc + 6396 >> 2] | 0) + -1 | 0) >>> 0 >= 3) break L724;
      _prvTidyReportAccessWarning($doc, $node, 365);
      break L724;
      break;
     }
    case 34:
     {
      $doc$idx$i661 = $doc + 6396 | 0;
      L910 : do if (((HEAP32[$doc$idx$i661 >> 2] | 0) + -1 | 0) >>> 0 < 3) {
       $1322 = _prvTidyAttrGetById($node, 139) | 0;
       if ($1322 | 0) {
        $1324 = $1322 + 24 | 0;
        $1325 = HEAP32[$1324 >> 2] | 0;
        if ($1325 | 0) {
         $cp$03$i$i$i664 = $1325;
         while (1) {
          $1327 = HEAP8[$cp$03$i$i$i664 >> 0] | 0;
          if (!($1327 << 24 >> 24)) break L910;
          if (!(_prvTidyIsWhite($1327 << 24 >> 24) | 0)) break; else $cp$03$i$i$i664 = $cp$03$i$i$i664 + 1 | 0;
         }
         if (_IsValidMediaExtension(HEAP32[$1324 >> 2] | 0) | 0) _prvTidyReportAccessError($doc, $node, 325);
        }
       }
      } while (0);
      $doc$idx$val$i669 = HEAP32[$doc$idx$i661 >> 2] | 0;
      do if (($doc$idx$val$i669 + -1 | 0) >>> 0 < 3) {
       $1337 = HEAP32[$1179 >> 2] | 0;
       if (!$1337) $doc$idx$val$i678 = $doc$idx$val$i669; else {
        $1339 = HEAP32[$1337 >> 2] | 0;
        if (($1339 | 0) == 94) $msgcode$015$i674 = 371; else if (($1339 | 0) == 76) $msgcode$015$i674 = 372; else if (($1339 | 0) == 34) $msgcode$015$i674 = 373; else if (($1339 | 0) == 6) $msgcode$015$i674 = 374; else {
         $doc$idx$val$i678 = $doc$idx$val$i669;
         break;
        }
        _prvTidyReportAccessWarning($doc, $node, $msgcode$015$i674);
        $doc$idx$val$i678 = HEAP32[$doc$idx$i661 >> 2] | 0;
       }
      } else $doc$idx$val$i678 = $doc$idx$val$i669; while (0);
      do if (($doc$idx$val$i678 + -1 | 0) >>> 0 < 3) {
       $1345 = HEAP32[$1179 >> 2] | 0;
       if ($1345 | 0) {
        $1347 = HEAP32[$1345 >> 2] | 0;
        if (($1347 | 0) == 94) $msgcode$015$i683 = 387; else if (($1347 | 0) == 76) $msgcode$015$i683 = 388; else if (($1347 | 0) == 34) $msgcode$015$i683 = 390; else if (($1347 | 0) == 6) $msgcode$015$i683 = 389; else break;
        _prvTidyReportAccessWarning($doc, $node, $msgcode$015$i683);
       }
      } while (0);
      _CheckFlicker($doc, $node);
      break L724;
      break;
     }
    default:
     switch ($1182 | 0) {
     case 10:
     case 20:
     case 29:
     case 36:
     case 55:
     case 67:
     case 92:
     case 101:
     case 117:
      {
       if ((HEAP32[$doc + 6396 >> 2] | 1 | 0) != 3) break L724;
       if (($1182 | 0) == 10) $msgcode$078$i697 = 406; else if (($1182 | 0) == 20) $msgcode$078$i697 = 407; else if (($1182 | 0) == 29) $msgcode$078$i697 = 408; else if (($1182 | 0) == 36) $msgcode$078$i697 = 409; else if (($1182 | 0) == 55) $msgcode$078$i697 = 410; else if (($1182 | 0) == 67) $msgcode$078$i697 = 411; else if (($1182 | 0) == 92) $msgcode$078$i697 = 412; else if (($1182 | 0) == 101) $msgcode$078$i697 = 413; else if (($1182 | 0) == 117) $msgcode$078$i697 = 414; else break L724;
       _prvTidyReportAccessError($doc, $node, $msgcode$078$i697);
       break L724;
       break;
      }
     case 112:
      {
       if ((HEAP32[$doc + 6396 >> 2] | 0) != 3) break L724;
       $av$015$i702 = HEAP32[$node + 20 >> 2] | 0;
       if (!$av$015$i702) $HasAbbr$0$lcssa$i = 0; else {
        $HasAbbr$016$i = 0;
        $av$017$i703 = $av$015$i702;
        while (1) {
         $1367 = HEAP32[$av$017$i703 + 4 >> 2] | 0;
         L776 : do if (!$1367) $HasAbbr$3$i = $HasAbbr$016$i; else if ((HEAP32[$1367 >> 2] | 0) == 1) {
          $1371 = $av$017$i703 + 24 | 0;
          $1372 = HEAP32[$1371 >> 2] | 0;
          if (!$1372) label = 667; else {
           $cp$03$i2$i = $1372;
           $isWht$02$i3$i = 1;
           while (1) {
            $1374 = HEAP8[$cp$03$i2$i >> 0] | 0;
            if (!($1374 << 24 >> 24)) {
             $isWht$0$lcssa$i5$i = $isWht$02$i3$i;
             break;
            }
            $isWht$02$i3$i = _prvTidyIsWhite($1374 << 24 >> 24) | 0;
            if (!$isWht$02$i3$i) {
             $isWht$0$lcssa$i5$i = 0;
             break;
            } else $cp$03$i2$i = $cp$03$i2$i + 1 | 0;
           }
           $$pr$i706 = HEAP32[$1371 >> 2] | 0;
           if (!$$pr$i706) label = 667; else if (!(_prvTidytmbstrlen($$pr$i706) | 0)) label = 667; else $HasAbbr$2$i = ($isWht$0$lcssa$i5$i | 0) == 0 ? 1 : $HasAbbr$016$i;
          }
          if ((label | 0) == 667) {
           label = 0;
           _prvTidyReportAccessWarning($doc, $node, 362);
           $HasAbbr$2$i = 1;
          }
          $1384 = HEAP32[$1371 >> 2] | 0;
          if (!$1384) $1393 = 0; else {
           $cp$03$i7$i708 = $1384;
           $isWht$02$i8$i = 1;
           while (1) {
            $1386 = HEAP8[$cp$03$i7$i708 >> 0] | 0;
            if (!($1386 << 24 >> 24)) {
             $isWht$02$i8$i$lcssa = $isWht$02$i8$i;
             break;
            }
            $isWht$02$i8$i = _prvTidyIsWhite($1386 << 24 >> 24) | 0;
            if (!$isWht$02$i8$i) {
             $HasAbbr$3$i = $HasAbbr$2$i;
             break L776;
            } else $cp$03$i7$i708 = $cp$03$i7$i708 + 1 | 0;
           }
           if (($isWht$02$i8$i$lcssa | 0) != 1) {
            $HasAbbr$3$i = $HasAbbr$2$i;
            break;
           }
           $1393 = HEAP32[$1371 >> 2] | 0;
          }
          if (!(_prvTidytmbstrlen($1393) | 0)) $HasAbbr$3$i = $HasAbbr$2$i; else {
           _prvTidyReportAccessWarning($doc, $node, 363);
           $HasAbbr$3$i = 1;
          }
         } else $HasAbbr$3$i = $HasAbbr$016$i; while (0);
         $av$017$i703 = HEAP32[$av$017$i703 >> 2] | 0;
         if (!$av$017$i703) {
          $HasAbbr$0$lcssa$i = $HasAbbr$3$i;
          break;
         } else $HasAbbr$016$i = $HasAbbr$3$i;
        }
       }
       $1398 = HEAP32[$node + 12 >> 2] | 0;
       $1399 = $doc + 6532 | 0;
       L798 : do if (!$1398) $x$1$i$i716 = 0; else {
        $1402 = HEAP32[$1398 + 36 >> 2] | 0;
        $1403 = $doc + 68 | 0;
        $1404 = $1398 + 40 | 0;
        if ($1402 >>> 0 < (HEAP32[$1404 >> 2] | 0) >>> 0) {
         $i$02$i$i714 = $1402;
         $x$01$i$i715 = 0;
         while (1) {
          HEAP8[$doc + 6532 + $x$01$i$i715 >> 0] = HEAP8[(HEAP32[(HEAP32[$1403 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i$i714 >> 0] | 0;
          if ($x$01$i$i715 >>> 0 > 126) {
           $x$1$i$i716 = $x$01$i$i715;
           break L798;
          }
          $i$02$i$i714 = $i$02$i$i714 + 1 | 0;
          $1415 = $x$01$i$i715 + 1 | 0;
          if ($i$02$i$i714 >>> 0 >= (HEAP32[$1404 >> 2] | 0) >>> 0) {
           $x$1$i$i716 = $1415;
           break;
          } else $x$01$i$i715 = $1415;
         }
        } else $x$1$i$i716 = 0;
       } while (0);
       HEAP8[$doc + 6532 + $x$1$i$i716 >> 0] = 0;
       $cp$03$i$i718 = $1399;
       while (1) {
        $1419 = HEAP8[$cp$03$i$i718 >> 0] | 0;
        if (!($1419 << 24 >> 24)) break L724;
        if (!(_prvTidyIsWhite($1419 << 24 >> 24) | 0)) break; else $cp$03$i$i718 = $cp$03$i$i718 + 1 | 0;
       }
       if (!(($HasAbbr$0$lcssa$i | 0) == 0 & (_prvTidytmbstrlen($1399) | 0) >>> 0 > 15)) break L724;
       _prvTidyReportAccessWarning($doc, $node, 361);
       break L724;
       break;
      }
     case 118:
     case 77:
     case 61:
      {
       if ((HEAP32[$doc + 6396 >> 2] | 1 | 0) != 3) break L724;
       L811 : do if (($1182 | 0) == 77) $msgcode$02$i = 344; else {
        switch ($1182 | 0) {
        case 118:
         {
          $msgcode$02$i = 343;
          break L811;
          break;
         }
        case 61:
         break;
        default:
         break L724;
        }
        $1442 = HEAP32[$node >> 2] | 0;
        do if ($1442 | 0) {
         $1445 = HEAP32[$1442 + 28 >> 2] | 0;
         if ($1445 | 0) {
          $1447 = HEAP32[$1445 >> 2] | 0;
          if (($1447 | 0) == 77) $1453 = 77; else if (($1447 | 0) == 118) $1453 = 118; else break;
          if (!(HEAP32[$node + 60 >> 2] | 0)) break L724;
          switch ($1453 | 0) {
          case 118:
          case 77:
           break;
          default:
           break L724;
          }
          _prvTidyReportAccessWarning($doc, $node, ($1453 | 0) == 118 ? 343 : 344);
          break L724;
         }
        } while (0);
        _prvTidyReportAccessWarning($doc, $node, 345);
        break L724;
       } while (0);
       $1432 = HEAP32[$node + 12 >> 2] | 0;
       if ($1432 | 0) {
        $1435 = HEAP32[$1432 + 28 >> 2] | 0;
        if ($1435 | 0) if ((HEAP32[$1435 >> 2] | 0) == 61) {
         if (!(HEAP32[$node + 60 >> 2] | 0)) break L724;
         _prvTidyReportAccessWarning($doc, $node, 345);
         break L724;
        }
       }
       _prvTidyReportAccessWarning($doc, $node, $msgcode$02$i);
       break L724;
       break;
      }
     default:
      break L724;
     }
    }
   }
  }
 } while (0);
 $content$0790 = HEAP32[$node + 12 >> 2] | 0;
 if (!$content$0790) {
  STACKTOP = sp;
  return;
 } else $content$0791 = $content$0790;
 do {
  _AccessibilityCheckNode($doc, $content$0791);
  $content$0791 = HEAP32[$content$0791 + 8 >> 2] | 0;
 } while (($content$0791 | 0) != 0);
 STACKTOP = sp;
 return;
}

function _prvTidyGetToken($doc, $mode) {
 $doc = $doc | 0;
 $mode = $mode | 0;
 var $$$i = 0, $$$i$lcssa641 = 0, $$0 = 0, $$0$i1$i$i = 0, $$0$i2$i$i = 0, $$023$be$i = 0, $$023271$i = 0, $$023271$i$lcssa = 0, $$023271$i$lcssa596 = 0, $$1$i$i = 0, $$225101$i = 0, $$225102$i = 0, $$225103$i = 0, $$225103372$i237 = 0, $$4$i = 0, $$lcssa = 0, $$lcssa$i = 0, $$lcssa568 = 0, $$lcssa570 = 0, $$lcssa573 = 0, $$lcssa575 = 0, $$lcssa576 = 0, $$lcssa619 = 0, $$pn$i$i = 0, $$pr$i = 0, $$pre$phi$iZ2D = 0, $$pre231 = 0, $$pre360$i = 0, $$pre365$i$pre = 0, $0 = 0, $1 = 0, $1014 = 0, $1018 = 0, $1022 = 0, $1025 = 0, $1041 = 0, $1045 = 0, $1049 = 0, $105 = 0, $1052 = 0, $1068 = 0, $1072 = 0, $1076 = 0, $1079 = 0, $1096 = 0, $1098 = 0, $1102 = 0, $1106 = 0, $1109 = 0, $111 = 0, $1116 = 0, $1119 = 0, $1130 = 0, $1141 = 0, $1146 = 0, $1150 = 0, $1153 = 0, $1169 = 0, $117 = 0, $1179 = 0, $1181 = 0, $1183 = 0, $1184 = 0, $1192 = 0, $1196 = 0, $1199 = 0, $1215 = 0, $1217 = 0, $1218 = 0, $122 = 0, $1223 = 0, $1227 = 0, $1230 = 0, $1245 = 0, $1250 = 0, $1257 = 0, $1260 = 0, $1270 = 0, $1275 = 0, $1278 = 0, $1292 = 0, $1293 = 0, $1294 = 0, $157 = 0, $158 = 0, $161 = 0, $172 = 0, $174 = 0, $177 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $200 = 0, $201 = 0, $202 = 0, $205 = 0, $207 = 0, $212 = 0, $213 = 0, $230 = 0, $237 = 0, $240 = 0, $247 = 0, $253 = 0, $261 = 0, $267 = 0, $270 = 0, $282 = 0, $288 = 0, $29 = 0, $292 = 0, $295 = 0, $308 = 0, $310 = 0, $316 = 0, $327 = 0, $33 = 0, $330 = 0, $342 = 0, $346 = 0, $349 = 0, $36 = 0, $363 = 0, $367 = 0, $37 = 0, $371 = 0, $374 = 0, $38 = 0, $385 = 0, $389 = 0, $392 = 0, $403 = 0, $407 = 0, $410 = 0, $426 = 0, $430 = 0, $433 = 0, $44 = 0, $449 = 0, $453 = 0, $454 = 0, $456 = 0, $459 = 0, $46 = 0, $47 = 0, $470 = 0, $471 = 0, $478 = 0, $48 = 0, $481 = 0, $487 = 0, $488 = 0, $49 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $5 = 0, $50 = 0, $500 = 0, $503 = 0, $514 = 0, $515 = 0, $52 = 0, $522 = 0, $526 = 0, $528 = 0, $529 = 0, $53 = 0, $531 = 0, $537 = 0, $539 = 0, $54 = 0, $542 = 0, $545 = 0, $547 = 0, $549 = 0, $55 = 0, $552 = 0, $555 = 0, $557 = 0, $559 = 0, $560 = 0, $57 = 0, $571 = 0, $580 = 0, $583 = 0, $59 = 0, $590 = 0, $592 = 0, $595 = 0, $596 = 0, $597 = 0, $6 = 0, $60 = 0, $607 = 0, $612 = 0, $617 = 0, $622 = 0, $627 = 0, $630 = 0, $631 = 0, $633 = 0, $641 = 0, $649 = 0, $651 = 0, $653 = 0, $655 = 0, $665 = 0, $671 = 0, $674 = 0, $676 = 0, $678 = 0, $68 = 0, $682 = 0, $685 = 0, $7 = 0, $700 = 0, $702 = 0, $713 = 0, $718 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $733 = 0, $741 = 0, $744 = 0, $746 = 0, $747 = 0, $749 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $758 = 0, $774 = 0, $775 = 0, $777 = 0, $795 = 0, $796 = 0, $803 = 0, $806 = 0, $807 = 0, $821 = 0, $824 = 0, $825 = 0, $833 = 0, $836 = 0, $846 = 0, $849 = 0, $852 = 0, $857 = 0, $859 = 0, $860 = 0, $863 = 0, $875 = 0, $881 = 0, $886 = 0, $89 = 0, $9 = 0, $907 = 0, $908 = 0, $916 = 0, $917 = 0, $927 = 0, $938 = 0, $942 = 0, $943 = 0, $945 = 0, $947 = 0, $950 = 0, $955 = 0, $957 = 0, $960 = 0, $961 = 0, $963 = 0, $966 = 0, $969 = 0, $990 = 0, $991 = 0, $995 = 0, $998 = 0, $asp$i$i = 0, $attributes$sroa$0$0$be$i = 0, $attributes$sroa$0$0267$i = 0, $attributes$sroa$0$0267$i$lcssa601 = 0, $attributes$sroa$0$1370$i = 0, $attributes$sroa$0$3$ph$i = 0, $attributes$sroa$0$4$i = 0, $attributes$sroa$0$4$i$lcssa = 0, $badcomment$0$be$i = 0, $badcomment$0269$i = 0, $badcomment$1259$i = 0, $c$0$i$i = 0, $c$1$i = 0, $c$2$i = 0, $delim$0$be$i$i = 0, $delim$028$i$i = 0, $delim$i$i = 0, $doc$idx$val$i = 0, $doc$idx$val$i8 = 0, $doc$idx$val$idx$val$i = 0, $doc$idx$val$idx$val$i10 = 0, $doc$idx$val1315$i$i = 0, $doc$idx$val1317$i$i = 0, $doc$idx$val14$i$i = 0, $doc$idx30$val$i = 0, $doc$idx30$val$idx$val$i = 0, $doc$idx31$val$i = 0, $doc$idx31$val$idx$val$i = 0, $doc$idx32$i = 0, $doc$idx32$val$i = 0, $doc$idx32$val$idx$val$i = 0, $doc$idx37$val$i = 0, $doc$idx38$val$i = 0, $doc$idx39$val$i = 0, $doc$idx40$val$i = 0, $doc$idx41$val$i = 0, $doc$idx42$val$i = 0, $doc$idx43$val$i = 0, $doc$idx44$val$i = 0, $doc$idx45$val$i = 0, $doc$idx46$val$i = 0, $doc$idx47$val$i = 0, $doc$idx8$i = 0, $doc$idx8$val$i = 0, $doc$idx8$val$idx$val$i = 0, $hasfpi$0$be$i$i = 0, $hasfpi$027$i$i = 0, $here$0$i$i = 0, $here$0$i$i$i = 0, $here$0$i$i$i$lcssa = 0, $here$0$i$i$lcssa = 0, $here$0$i3$i$i = 0, $here$0$i3$i$i$lcssa = 0, $here$0$i7$i$i = 0, $here$0$i7$i$i$lcssa = 0, $i$0$lcssa$i = 0, $i$02$i$i$i = 0, $i$02$i$i$i$lcssa = 0, $i$02$lcssa$i$i$i = 0, $i$0257$i = 0, $i$04$i$i$i = 0, $i$052$i = 0, $i$053$i = 0, $i$150$i = 0, $i$151$i = 0, $i$257$i = 0, $isEmpty$0$be$i = 0, $isEmpty$035$i = 0, $isEmpty$063$i = 0, $isEmpty$063$i$lcssa = 0, $isEmpty$063$i$lcssa562 = 0, $isempty$i = 0, $list$0$ph$ph$i$i = 0, $list$0$ph16$i$i = 0, $list$0$ph16$i$i$lcssa = 0, $nested$0$be$i = 0, $nested$061$i = 0, $nested$2$i = 0, $phitmp1$i$i3 = 0, $phitmp1$i17$i = 0, $phitmp1$i23$i = 0, $phitmp1$i71$i = 0, $php$i$i = 0, $start$0$be$i = 0, $start$0$be$i$i = 0, $start$064$i = 0, $start$064$i$lcssa = 0, $start$064$i$lcssa559 = 0, $state$0$be$i = 0, $state$0$be$i$i = 0, $state$029$i$i = 0, $state$062$i = 0, $storemerge$i = 0, $storemerge$i$i = 0, dest = 0, label = 0, sp = 0, stop = 0, $i$257$i$looptemp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $delim$i$i = sp + 12 | 0;
 $asp$i$i = sp + 8 | 0;
 $php$i$i = sp + 4 | 0;
 $isempty$i = sp;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $1 + 12 | 0;
 $5 = $1 + 64 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = ($6 | 0) == 0;
 do if (!(HEAP32[$2 >> 2] | 0)) {
  if (!$7) {
   HEAP32[$5 >> 2] = 0;
   break;
  }
  if (!(HEAP32[$1 + 100 >> 2] | 0)) {
   if (HEAP32[$1 + 96 >> 2] | 0) label = 12;
  } else label = 12;
  if ((label | 0) == 12) if (HEAP32[$1 + 112 >> 2] | 0) {
   $29 = _prvTidyInsertedToken($doc) | 0;
   HEAP32[$1 + 60 >> 2] = $29;
   $$0 = $29;
   STACKTOP = sp;
   return $$0 | 0;
  }
  if (($mode | 0) == 5) {
   $33 = HEAP32[$1 + 72 >> 2] | 0;
   if (!$33) ___assert_fail(310397, 310231, 2428, 310419);
   $36 = (_prvTidyAttrGetById($33, 139) | 0) != 0;
   $37 = $33 + 28 | 0;
   $38 = HEAP32[$37 >> 2] | 0;
   L18 : do if (!$38) $111 = 0; else {
    switch (HEAP32[$38 >> 2] | 0) {
    case 103:
    case 94:
     break;
    default:
     {
      $111 = 0;
      break L18;
     }
    }
    $111 = (HEAP32[$doc + 452 >> 2] | 0) != 0;
   } while (0);
   $doc$idx8$i = $doc + 6776 | 0;
   $doc$idx8$val$i = HEAP32[$doc$idx8$i >> 2] | 0;
   $doc$idx8$val$idx$val$i = HEAP32[$doc$idx8$val$i + 288 >> 2] | 0;
   HEAP32[$1 >> 2] = HEAP32[$doc$idx8$val$i + 292 >> 2];
   $44 = $1 + 4 | 0;
   HEAP32[$44 >> 2] = $doc$idx8$val$idx$val$i;
   HEAP32[$1 + 8 >> 2] = 0;
   $46 = $1 + 92 | 0;
   $47 = HEAP32[$46 >> 2] | 0;
   $48 = $1 + 52 | 0;
   HEAP32[$48 >> 2] = $47;
   $49 = $1 + 48 | 0;
   HEAP32[$49 >> 2] = $47;
   $50 = _prvTidyReadChar($doc$idx8$val$i) | 0;
   do if (($50 | 0) == -1) {
    $52 = HEAP32[$48 >> 2] | 0;
    HEAP32[$49 >> 2] = $52;
    HEAP32[$46 >> 2] = $52;
    label = 71;
   } else {
    $53 = $33 + 32 | 0;
    $54 = $1 + 84 | 0;
    $55 = $doc + 460 | 0;
    $60 = $50;
    $isEmpty$063$i = 1;
    $nested$061$i = 0;
    $start$064$i = 0;
    $state$062$i = 0;
    L25 : while (1) {
     _prvTidyAddCharToLexer($1, $60);
     HEAP32[$48 >> 2] = HEAP32[$46 >> 2];
     L27 : do switch ($state$062$i | 0) {
     case 0:
      {
       if (($60 | 0) != 60) {
        if (!($60 >>> 0 < 128 & ($isEmpty$063$i | 0) != 0)) {
         $isEmpty$0$be$i = 0;
         $nested$0$be$i = $nested$061$i;
         $start$0$be$i = $start$064$i;
         $state$0$be$i = 0;
         break L27;
        }
        $isEmpty$0$be$i = HEAP32[316488 + ($60 << 2) >> 2] & 8 | 0 ? $isEmpty$063$i : 0;
        $nested$0$be$i = $nested$061$i;
        $start$0$be$i = $start$064$i;
        $state$0$be$i = 0;
        break L27;
       }
       $68 = _prvTidyReadChar(HEAP32[$doc$idx8$i >> 2] | 0) | 0;
       if ($68 >>> 0 < 128) if (HEAP32[316488 + ($68 << 2) >> 2] & 2 | 0) {
        if ($36 & ($isEmpty$063$i | 0) != 0) {
         $73 = HEAP32[$37 >> 2] | 0;
         if ($73 | 0) if ((HEAP32[$73 >> 2] | 0) == 94) {
          $$lcssa = $68;
          label = 34;
          break L25;
         }
        }
        _prvTidyAddCharToLexer($1, $68);
        $isEmpty$0$be$i = $isEmpty$063$i;
        $nested$0$be$i = $nested$061$i;
        $start$0$be$i = (HEAP32[$46 >> 2] | 0) + -1 | 0;
        $state$0$be$i = 1;
        break L27;
       }
       switch ($68 | 0) {
       case 47:
        {
         _prvTidyAddCharToLexer($1, 47);
         $57 = _prvTidyReadChar(HEAP32[$doc$idx8$i >> 2] | 0) | 0;
         if ($57 >>> 0 >= 128) {
          _prvTidyUngetChar($57, HEAP32[$doc$idx8$i >> 2] | 0);
          $isEmpty$0$be$i = $isEmpty$063$i;
          $nested$0$be$i = $nested$061$i;
          $start$0$be$i = $start$064$i;
          $state$0$be$i = 0;
          break L27;
         }
         $phitmp1$i23$i = (HEAP32[316488 + ($57 << 2) >> 2] & 2 | 0) == 0;
         _prvTidyUngetChar($57, HEAP32[$doc$idx8$i >> 2] | 0);
         if ($phitmp1$i23$i) {
          $isEmpty$0$be$i = $isEmpty$063$i;
          $nested$0$be$i = $nested$061$i;
          $start$0$be$i = $start$064$i;
          $state$0$be$i = 0;
          break L27;
         }
         $isEmpty$0$be$i = $isEmpty$063$i;
         $nested$0$be$i = $nested$061$i;
         $start$0$be$i = HEAP32[$46 >> 2] | 0;
         $state$0$be$i = 2;
         break L27;
         break;
        }
       case 92:
        {
         _prvTidyAddCharToLexer($1, 92);
         $89 = _prvTidyReadChar(HEAP32[$doc$idx8$i >> 2] | 0) | 0;
         if (($89 | 0) != 47) {
          _prvTidyUngetChar($89, HEAP32[$doc$idx8$i >> 2] | 0);
          $isEmpty$0$be$i = $isEmpty$063$i;
          $nested$0$be$i = $nested$061$i;
          $start$0$be$i = $start$064$i;
          $state$0$be$i = 0;
          break L27;
         }
         _prvTidyAddCharToLexer($1, 47);
         if ($111) {
          $isEmpty$0$be$i = $isEmpty$063$i;
          $nested$0$be$i = $nested$061$i;
          $start$0$be$i = $start$064$i;
          $state$0$be$i = 0;
          break L27;
         }
         $59 = _prvTidyReadChar(HEAP32[$doc$idx8$i >> 2] | 0) | 0;
         if ($59 >>> 0 >= 128) {
          _prvTidyUngetChar($59, HEAP32[$doc$idx8$i >> 2] | 0);
          $isEmpty$0$be$i = $isEmpty$063$i;
          $nested$0$be$i = $nested$061$i;
          $start$0$be$i = $start$064$i;
          $state$0$be$i = 0;
          break L27;
         }
         $phitmp1$i17$i = (HEAP32[316488 + ($59 << 2) >> 2] & 2 | 0) == 0;
         _prvTidyUngetChar($59, HEAP32[$doc$idx8$i >> 2] | 0);
         if ($phitmp1$i17$i) {
          $isEmpty$0$be$i = $isEmpty$063$i;
          $nested$0$be$i = $nested$061$i;
          $start$0$be$i = $start$064$i;
          $state$0$be$i = 0;
          break L27;
         }
         $isEmpty$0$be$i = $isEmpty$063$i;
         $nested$0$be$i = $nested$061$i;
         $start$0$be$i = HEAP32[$46 >> 2] | 0;
         $state$0$be$i = 2;
         break L27;
         break;
        }
       default:
        {
         _prvTidyUngetChar($68, HEAP32[$doc$idx8$i >> 2] | 0);
         $isEmpty$0$be$i = $isEmpty$063$i;
         $nested$0$be$i = $nested$061$i;
         $start$0$be$i = $start$064$i;
         $state$0$be$i = 0;
         break L27;
        }
       }
       break;
      }
     case 1:
      {
       if ($60 >>> 0 < 128) if (HEAP32[316488 + ($60 << 2) >> 2] & 2 | 0) {
        $isEmpty$0$be$i = $isEmpty$063$i;
        $nested$0$be$i = $nested$061$i;
        $start$0$be$i = $start$064$i;
        $state$0$be$i = 1;
        break L27;
       }
       $105 = HEAP32[$53 >> 2] | 0;
       $isEmpty$0$be$i = $isEmpty$063$i;
       $nested$0$be$i = (($111 | (_prvTidytmbstrncasecmp($105, (HEAP32[$54 >> 2] | 0) + $start$064$i | 0, _prvTidytmbstrlen($105) | 0) | 0) != 0) & 1 ^ 1) + $nested$061$i | 0;
       $start$0$be$i = $start$064$i;
       $state$0$be$i = 0;
       break;
      }
     case 2:
      {
       if ($60 >>> 0 < 128) if (HEAP32[316488 + ($60 << 2) >> 2] & 2 | 0) {
        $isEmpty$0$be$i = $isEmpty$063$i;
        $nested$0$be$i = $nested$061$i;
        $start$0$be$i = $start$064$i;
        $state$0$be$i = 2;
        break L27;
       }
       $117 = HEAP32[$53 >> 2] | 0;
       $122 = (_prvTidytmbstrncasecmp($117, (HEAP32[$54 >> 2] | 0) + $start$064$i | 0, _prvTidytmbstrlen($117) | 0) | 0) == 0;
       if (!(($isEmpty$063$i | 0) == 0 | $122)) {
        $isEmpty$063$i$lcssa = $isEmpty$063$i;
        $start$064$i$lcssa = $start$064$i;
        label = 54;
        break L25;
       }
       if ($122) if (($nested$061$i | 0) < 1) {
        $isEmpty$063$i$lcssa562 = $isEmpty$063$i;
        $start$064$i$lcssa559 = $start$064$i;
        label = 59;
        break L25;
       } else $nested$2$i = $nested$061$i + -1 | 0; else $nested$2$i = $nested$061$i;
       if ((HEAP8[(HEAP32[$54 >> 2] | 0) + ($start$064$i + -2) >> 0] | 0) == 92) {
        $isEmpty$0$be$i = $isEmpty$063$i;
        $nested$0$be$i = $nested$2$i;
        $start$0$be$i = $start$064$i;
        $state$0$be$i = 0;
       } else {
        $doc$idx$val$i = HEAP32[$doc$idx8$i >> 2] | 0;
        $doc$idx$val$idx$val$i = HEAP32[$doc$idx$val$i + 288 >> 2] | 0;
        HEAP32[$1 >> 2] = HEAP32[$doc$idx$val$i + 292 >> 2];
        HEAP32[$44 >> 2] = $doc$idx$val$idx$val$i + -3;
        if (!(_prvTidyIsJavaScript($33) | 0)) {
         $isEmpty$0$be$i = $isEmpty$063$i;
         $nested$0$be$i = $nested$2$i;
         $start$0$be$i = $start$064$i;
         $state$0$be$i = 0;
        } else if (!(HEAP32[$55 >> 2] | 0)) {
         $isEmpty$0$be$i = $isEmpty$063$i;
         $nested$0$be$i = $nested$2$i;
         $start$0$be$i = $start$064$i;
         $state$0$be$i = 0;
        } else {
         _prvTidyReportError($doc, 0, 0, 232);
         $157 = HEAP32[$46 >> 2] | 0;
         $158 = $start$064$i + -1 | 0;
         if ($157 >>> 0 > $158 >>> 0) {
          $i$257$i = $157;
          do {
           $i$257$i$looptemp = $i$257$i;
           $i$257$i = $i$257$i + -1 | 0;
           $161 = HEAP32[$54 >> 2] | 0;
           HEAP8[$161 + $i$257$i$looptemp >> 0] = HEAP8[$161 + $i$257$i >> 0] | 0;
          } while ($i$257$i >>> 0 > $158 >>> 0);
         }
         HEAP8[(HEAP32[$54 >> 2] | 0) + $158 >> 0] = 92;
         HEAP32[$46 >> 2] = (HEAP32[$46 >> 2] | 0) + 1;
         $isEmpty$0$be$i = $isEmpty$063$i;
         $nested$0$be$i = $nested$2$i;
         $start$0$be$i = $start$064$i;
         $state$0$be$i = 0;
        }
       }
       break;
      }
     default:
      {
       $isEmpty$0$be$i = $isEmpty$063$i;
       $nested$0$be$i = $nested$061$i;
       $start$0$be$i = $start$064$i;
       $state$0$be$i = $state$062$i;
      }
     } while (0);
     $60 = _prvTidyReadChar(HEAP32[$doc$idx8$i >> 2] | 0) | 0;
     if (($60 | 0) == -1) {
      $1292 = 1;
      $isEmpty$035$i = $isEmpty$0$be$i;
      break;
     } else {
      $isEmpty$063$i = $isEmpty$0$be$i;
      $nested$061$i = $nested$0$be$i;
      $start$064$i = $start$0$be$i;
      $state$062$i = $state$0$be$i;
     }
    }
    if ((label | 0) == 34) {
     HEAP32[$46 >> 2] = HEAP32[$49 >> 2];
     _prvTidyUngetChar($$lcssa, HEAP32[$doc$idx8$i >> 2] | 0);
     _prvTidyUngetChar(60, HEAP32[$doc$idx8$i >> 2] | 0);
     $$0 = 0;
     STACKTOP = sp;
     return $$0 | 0;
    } else if ((label | 0) == 54) {
     $i$052$i = (HEAP32[$46 >> 2] | 0) + -1 | 0;
     if ($i$052$i >>> 0 >= $start$064$i$lcssa >>> 0) {
      $i$053$i = $i$052$i;
      do {
       _prvTidyUngetChar(HEAP8[(HEAP32[$54 >> 2] | 0) + $i$053$i >> 0] | 0, HEAP32[$doc$idx8$i >> 2] | 0);
       $i$053$i = $i$053$i + -1 | 0;
      } while ($i$053$i >>> 0 >= $start$064$i$lcssa >>> 0);
     }
     _prvTidyUngetChar(47, HEAP32[$doc$idx8$i >> 2] | 0);
     _prvTidyUngetChar(60, HEAP32[$doc$idx8$i >> 2] | 0);
     $1292 = 0;
     $isEmpty$035$i = $isEmpty$063$i$lcssa;
    } else if ((label | 0) == 59) {
     $i$150$i = (HEAP32[$46 >> 2] | 0) + -1 | 0;
     if ($i$150$i >>> 0 >= $start$064$i$lcssa559 >>> 0) {
      $i$151$i = $i$150$i;
      do {
       _prvTidyUngetChar(HEAP8[(HEAP32[$54 >> 2] | 0) + $i$151$i >> 0] | 0, HEAP32[$doc$idx8$i >> 2] | 0);
       $i$151$i = $i$151$i + -1 | 0;
      } while ($i$151$i >>> 0 >= $start$064$i$lcssa559 >>> 0);
     }
     _prvTidyUngetChar(47, HEAP32[$doc$idx8$i >> 2] | 0);
     _prvTidyUngetChar(60, HEAP32[$doc$idx8$i >> 2] | 0);
     HEAP32[$46 >> 2] = $start$064$i$lcssa559 + -2;
     $1292 = 0;
     $isEmpty$035$i = $isEmpty$063$i$lcssa562;
    }
    if (!$isEmpty$035$i) {
     HEAP32[$48 >> 2] = HEAP32[$46 >> 2];
     if ($1292) {
      label = 71;
      break;
     } else break;
    } else {
     $172 = HEAP32[$48 >> 2] | 0;
     HEAP32[$49 >> 2] = $172;
     HEAP32[$46 >> 2] = $172;
     if ($1292) {
      label = 71;
      break;
     } else break;
    }
   } while (0);
   if ((label | 0) == 71) _prvTidyReportError($doc, $33, 0, 206);
   $174 = HEAP32[$1 + 124 >> 2] | 0;
   $177 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$174 >> 2] >> 2] & 31]($174, 68) | 0;
   dest = $177;
   stop = dest + 68 | 0;
   do {
    HEAP32[dest >> 2] = 0;
    dest = dest + 4 | 0;
   } while ((dest | 0) < (stop | 0));
   HEAP32[$177 + 48 >> 2] = HEAP32[$1 >> 2];
   HEAP32[$177 + 52 >> 2] = HEAP32[$44 >> 2];
   HEAP32[$177 + 44 >> 2] = 4;
   HEAP32[$177 + 36 >> 2] = HEAP32[$49 >> 2];
   HEAP32[$177 + 40 >> 2] = HEAP32[$48 >> 2];
   $$0 = $177;
   STACKTOP = sp;
   return $$0 | 0;
  }
  HEAP32[$isempty$i >> 2] = 0;
  $187 = $1 + 60 | 0;
  HEAP32[$187 >> 2] = 0;
  $doc$idx32$i = $doc + 6776 | 0;
  $doc$idx32$val$i = HEAP32[$doc$idx32$i >> 2] | 0;
  $doc$idx32$val$idx$val$i = HEAP32[$doc$idx32$val$i + 288 >> 2] | 0;
  HEAP32[$1 >> 2] = HEAP32[$doc$idx32$val$i + 292 >> 2];
  $188 = $1 + 4 | 0;
  HEAP32[$188 >> 2] = $doc$idx32$val$idx$val$i;
  $189 = $1 + 8 | 0;
  HEAP32[$189 >> 2] = 0;
  $190 = $1 + 92 | 0;
  $191 = HEAP32[$190 >> 2] | 0;
  $192 = $1 + 52 | 0;
  HEAP32[$192 >> 2] = $191;
  $193 = $1 + 48 | 0;
  HEAP32[$193 >> 2] = $191;
  $194 = _prvTidyReadChar($doc$idx32$val$i) | 0;
  L99 : do if (($194 | 0) == -1) {
   $$pre$phi$iZ2D = $1 + 56 | 0;
   label = 397;
  } else {
   $196 = $1 + 16 | 0;
   $197 = $1 + 56 | 0;
   $198 = $1 + 84 | 0;
   $199 = $doc + 6856 | 0;
   $200 = $doc + 228 | 0;
   $201 = $doc + 288 | 0;
   $202 = $1 + 28 | 0;
   $$023271$i = $mode;
   $205 = $194;
   $attributes$sroa$0$0267$i = 0;
   $badcomment$0269$i = 0;
   L102 : while (1) {
    if (HEAP32[$196 >> 2] | 0) {
     _prvTidyAddCharToLexer($1, 32);
     HEAP32[$189 >> 2] = 1;
     HEAP32[$196 >> 2] = 0;
    }
    $207 = ($$023271$i | 0) == 2;
    $$$i = ($205 | 0) == 160 & $207 ? 32 : $205;
    _prvTidyAddCharToLexer($1, $$$i);
    L107 : do switch (HEAP32[$197 >> 2] | 0) {
    case 3:
     {
      $$023271$i$lcssa = $$023271$i;
      $$lcssa619 = $207;
      label = 160;
      break L102;
      break;
     }
    case 5:
     {
      $$$i$lcssa641 = $$$i;
      label = 239;
      break L102;
      break;
     }
    case 0:
     {
      do if ($$$i >>> 0 < 128) {
       $phitmp1$i$i3 = (HEAP32[316488 + ($$$i << 2) >> 2] & 8 | 0) != 0;
       $212 = ($$023271$i | 0) == 0;
       if ($212 & $phitmp1$i$i3) {
        $213 = HEAP32[$190 >> 2] | 0;
        if (($213 | 0) == ((HEAP32[$193 >> 2] | 0) + 1 | 0)) {
         HEAP32[$190 >> 2] = $213 + -1;
         HEAP32[$189 >> 2] = 0;
         $doc$idx31$val$i = HEAP32[$doc$idx32$i >> 2] | 0;
         $doc$idx31$val$idx$val$i = HEAP32[$doc$idx31$val$i + 288 >> 2] | 0;
         HEAP32[$1 >> 2] = HEAP32[$doc$idx31$val$i + 292 >> 2];
         HEAP32[$188 >> 2] = $doc$idx31$val$idx$val$i;
         $$023$be$i = 0;
         $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
         $badcomment$0$be$i = $badcomment$0269$i;
         break L107;
        }
       }
       if (($$$i | 0) == 60) {
        HEAP32[$197 >> 2] = 1;
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       }
       if (!$phitmp1$i$i3) {
        if (!(($$023271$i | 0) != 3 & ($$$i | 0) == 38)) {
         $237 = $212;
         break;
        }
        _ParseEntity($doc, $$023271$i);
        $237 = $212;
        break;
       }
       if (HEAP32[$189 >> 2] | 0) {
        if (($$023271$i & -2 | 0) == 2) {
         $$023$be$i = $$023271$i;
         $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
         $badcomment$0$be$i = $badcomment$0269$i;
         break L107;
        }
        HEAP32[$190 >> 2] = (HEAP32[$190 >> 2] | 0) + -1;
        $doc$idx30$val$i = HEAP32[$doc$idx32$i >> 2] | 0;
        $doc$idx30$val$idx$val$i = HEAP32[$doc$idx30$val$i + 288 >> 2] | 0;
        HEAP32[$1 >> 2] = HEAP32[$doc$idx30$val$i + 292 >> 2];
        HEAP32[$188 >> 2] = $doc$idx30$val$idx$val$i;
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       }
       HEAP32[$189 >> 2] = 1;
       if (!(($$023271$i & -2 | 0) != 2 & ($$$i | 0) != 32)) {
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       }
       $230 = HEAP32[$190 >> 2] | 0;
       if (!$230) {
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       }
       HEAP8[(HEAP32[$198 >> 2] | 0) + ($230 + -1) >> 0] = 32;
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
       break L107;
      } else $237 = ($$023271$i | 0) == 0; while (0);
      HEAP32[$189 >> 2] = 0;
      $$023$be$i = $237 ? 1 : $$023271$i;
      $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
      $badcomment$0$be$i = $badcomment$0269$i;
      break;
     }
    case 1:
     {
      if (($$$i | 0) == 47) {
       $240 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
       if (($240 | 0) == -1) {
        _prvTidyUngetChar(-1, HEAP32[$doc$idx32$i >> 2] | 0);
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       }
       _prvTidyAddCharToLexer($1, $240);
       if ($240 >>> 0 < 128) if (HEAP32[316488 + ($240 << 2) >> 2] & 2 | 0) {
        $247 = (HEAP32[$190 >> 2] | 0) + -3 | 0;
        HEAP32[$190 >> 2] = $247;
        HEAP32[$192 >> 2] = $247;
        _prvTidyUngetChar($240, HEAP32[$doc$idx32$i >> 2] | 0);
        HEAP32[$197 >> 2] = 2;
        HEAP8[(HEAP32[$198 >> 2] | 0) + (HEAP32[$190 >> 2] | 0) >> 0] = 0;
        $253 = (HEAP32[$doc$idx32$i >> 2] | 0) + 288 | 0;
        HEAP32[$253 >> 2] = (HEAP32[$253 >> 2] | 0) + -2;
        if ((HEAP32[$192 >> 2] | 0) >>> 0 > (HEAP32[$193 >> 2] | 0) >>> 0) {
         $$023271$i$lcssa596 = $$023271$i;
         label = 103;
         break L102;
        } else {
         $$023$be$i = $$023271$i;
         $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
         $badcomment$0$be$i = $badcomment$0269$i;
         break L107;
        }
       }
       HEAP32[$189 >> 2] = 0;
       HEAP32[$197 >> 2] = 0;
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
       break L107;
      }
      if (($$023271$i | 0) == 3) {
       HEAP32[$189 >> 2] = 0;
       HEAP32[$197 >> 2] = 0;
       $$023$be$i = 3;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
       break L107;
      }
      switch ($$$i | 0) {
      case 33:
       {
        $282 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
        do if (($282 | 0) == 45) {
         if ((_prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0) != 45) {
          _prvTidyReportError($doc, 0, 0, 229);
          break;
         }
         HEAP32[$197 >> 2] = 4;
         $288 = (HEAP32[$190 >> 2] | 0) + -2 | 0;
         HEAP32[$190 >> 2] = $288;
         HEAP32[$192 >> 2] = $288;
         if ($288 >>> 0 > (HEAP32[$193 >> 2] | 0) >>> 0) {
          label = 114;
          break L102;
         }
         HEAP32[$193 >> 2] = $288;
         $$023$be$i = $$023271$i;
         $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
         $badcomment$0$be$i = $badcomment$0269$i;
         break L107;
        } else {
         if (($282 | 32 | 0) != 100) {
          if (($282 | 0) != 91) break;
          $342 = (HEAP32[$190 >> 2] | 0) + -2 | 0;
          HEAP32[$190 >> 2] = $342;
          HEAP32[$197 >> 2] = 8;
          HEAP32[$192 >> 2] = $342;
          if ($342 >>> 0 > (HEAP32[$193 >> 2] | 0) >>> 0) {
           label = 133;
           break L102;
          }
          HEAP32[$193 >> 2] = $342;
          $$023$be$i = $$023271$i;
          $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
          $badcomment$0$be$i = $badcomment$0269$i;
          break L107;
         }
         HEAP32[$197 >> 2] = 5;
         $308 = (HEAP32[$190 >> 2] | 0) + -2 | 0;
         HEAP32[$190 >> 2] = $308;
         HEAP32[$192 >> 2] = $308;
         L164 : while (1) {
          $310 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
          switch ($310 | 0) {
          case 62:
          case -1:
           {
            $$lcssa573 = $310;
            label = 120;
            break L164;
            break;
           }
          default:
           {}
          }
          if ($310 >>> 0 >= 128) continue;
          if (HEAP32[316488 + ($310 << 2) >> 2] & 8 | 0) {
           label = 123;
           break;
          }
         }
         do if ((label | 0) == 120) {
          label = 0;
          _prvTidyUngetChar($$lcssa573, HEAP32[$doc$idx32$i >> 2] | 0);
         } else if ((label | 0) == 123) {
          L170 : while (1) {
           label = 0;
           $316 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
           switch ($316 | 0) {
           case 62:
           case -1:
            {
             $$lcssa575 = $316;
             label = 124;
             break L170;
             break;
            }
           default:
            {}
           }
           if ($316 >>> 0 >= 128) {
            $$lcssa576 = $316;
            label = 127;
            break;
           }
           if (!(HEAP32[316488 + ($316 << 2) >> 2] & 8)) {
            $$lcssa576 = $316;
            label = 127;
            break;
           } else label = 123;
          }
          if ((label | 0) == 124) {
           label = 0;
           _prvTidyUngetChar($$lcssa575, HEAP32[$doc$idx32$i >> 2] | 0);
           break;
          } else if ((label | 0) == 127) {
           label = 0;
           _prvTidyUngetChar($$lcssa576, HEAP32[$doc$idx32$i >> 2] | 0);
           break;
          }
         } while (0);
         if ((HEAP32[$192 >> 2] | 0) >>> 0 > (HEAP32[$193 >> 2] | 0) >>> 0) {
          label = 130;
          break L102;
         }
         HEAP32[$193 >> 2] = HEAP32[$190 >> 2];
         $$023$be$i = 0;
         $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
         $badcomment$0$be$i = $badcomment$0269$i;
         break L107;
        } while (0);
        L179 : while (1) switch (_prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0) {
        case 62:
         {
          break L179;
          break;
         }
        case -1:
         {
          label = 136;
          break L179;
          break;
         }
        default:
         {}
        }
        if ((label | 0) == 136) {
         label = 0;
         _prvTidyUngetChar(-1, HEAP32[$doc$idx32$i >> 2] | 0);
        }
        $363 = (HEAP32[$190 >> 2] | 0) + -2 | 0;
        HEAP32[$190 >> 2] = $363;
        HEAP8[(HEAP32[$198 >> 2] | 0) + $363 >> 0] = 0;
        HEAP32[$197 >> 2] = 0;
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
        break;
       }
      case 63:
       {
        $367 = (HEAP32[$190 >> 2] | 0) + -2 | 0;
        HEAP32[$190 >> 2] = $367;
        HEAP32[$197 >> 2] = 6;
        HEAP32[$192 >> 2] = $367;
        if ($367 >>> 0 > (HEAP32[$193 >> 2] | 0) >>> 0) {
         label = 139;
         break L102;
        }
        HEAP32[$193 >> 2] = $367;
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
        break;
       }
      case 37:
       {
        $385 = (HEAP32[$190 >> 2] | 0) + -2 | 0;
        HEAP32[$190 >> 2] = $385;
        HEAP32[$197 >> 2] = 9;
        HEAP32[$192 >> 2] = $385;
        if ($385 >>> 0 > (HEAP32[$193 >> 2] | 0) >>> 0) {
         label = 142;
         break L102;
        }
        HEAP32[$193 >> 2] = $385;
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
        break;
       }
      case 35:
       {
        $403 = (HEAP32[$190 >> 2] | 0) + -2 | 0;
        HEAP32[$190 >> 2] = $403;
        HEAP32[$197 >> 2] = 10;
        HEAP32[$192 >> 2] = $403;
        if ($403 >>> 0 > (HEAP32[$193 >> 2] | 0) >>> 0) {
         label = 145;
         break L102;
        }
        HEAP32[$193 >> 2] = $403;
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
        break;
       }
      default:
       {
        if ($$$i >>> 0 < 128) {
         $phitmp1$i71$i = (HEAP32[316488 + ($$$i << 2) >> 2] & 2 | 0) == 0;
         _prvTidyUngetChar($$$i, HEAP32[$doc$idx32$i >> 2] | 0);
         if (!$phitmp1$i71$i) {
          _prvTidyUngetChar(60, HEAP32[$doc$idx32$i >> 2] | 0);
          $426 = (HEAP32[$190 >> 2] | 0) + -2 | 0;
          HEAP32[$190 >> 2] = $426;
          HEAP32[$192 >> 2] = $426;
          HEAP32[$197 >> 2] = 3;
          if ($426 >>> 0 > (HEAP32[$193 >> 2] | 0) >>> 0) {
           label = 150;
           break L102;
          } else {
           $$023$be$i = $$023271$i;
           $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
           $badcomment$0$be$i = $badcomment$0269$i;
           break L107;
          }
         }
        } else _prvTidyUngetChar($$$i, HEAP32[$doc$idx32$i >> 2] | 0);
        HEAP32[$190 >> 2] = (HEAP32[$190 >> 2] | 0) + -1;
        HEAP32[$197 >> 2] = 0;
        HEAP32[$189 >> 2] = 0;
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       }
      }
      break;
     }
    case 2:
     {
      HEAP32[$193 >> 2] = (HEAP32[$190 >> 2] | 0) + -1;
      $449 = (HEAP32[$doc$idx32$i >> 2] | 0) + 288 | 0;
      HEAP32[$449 >> 2] = (HEAP32[$449 >> 2] | 0) + 2;
      $453 = (_ParseTagName($doc) | 0) << 24 >> 24;
      $454 = HEAP32[$0 >> 2] | 0;
      $456 = HEAP32[$454 + 124 >> 2] | 0;
      $459 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$456 >> 2] >> 2] & 31]($456, 68) | 0;
      dest = $459;
      stop = dest + 68 | 0;
      do {
       HEAP32[dest >> 2] = 0;
       dest = dest + 4 | 0;
      } while ((dest | 0) < (stop | 0));
      if ($454 | 0) {
       HEAP32[$459 + 48 >> 2] = HEAP32[$454 >> 2];
       HEAP32[$459 + 52 >> 2] = HEAP32[$454 + 4 >> 2];
      }
      HEAP32[$459 + 44 >> 2] = 6;
      $470 = $454 + 48 | 0;
      $471 = HEAP32[$470 >> 2] | 0;
      HEAP32[$459 + 32 >> 2] = _prvTidytmbstrndup(HEAP32[$199 >> 2] | 0, (HEAP32[$454 + 84 >> 2] | 0) + $471 | 0, (HEAP32[$454 + 52 >> 2] | 0) - $471 | 0) | 0;
      $478 = HEAP32[$470 >> 2] | 0;
      HEAP32[$459 + 36 >> 2] = $478;
      HEAP32[$459 + 40 >> 2] = $478;
      _prvTidyFindTag($doc, $459) | 0;
      HEAP32[$187 >> 2] = $459;
      $481 = HEAP32[$193 >> 2] | 0;
      HEAP32[$192 >> 2] = $481;
      HEAP32[$190 >> 2] = $481;
      $c$1$i = $453;
      L194 : while (1) {
       switch ($c$1$i | 0) {
       case 62:
        {
         label = 159;
         break L102;
         break;
        }
       case -1:
        {
         break L194;
         break;
        }
       default:
        {}
       }
       $c$1$i = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
      }
      _prvTidyFreeNode($doc, HEAP32[$187 >> 2] | 0);
      $$023$be$i = $$023271$i;
      $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
      $badcomment$0$be$i = $badcomment$0269$i;
      break;
     }
    case 4:
     {
      if (($$$i | 0) == 45) {
       $671 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
       _prvTidyAddCharToLexer($1, $671);
       if (($671 | 0) == 45) {
        $674 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
        $676 = ($badcomment$0269$i | 0) != 0;
        if (($674 | 0) == 62) {
         $$lcssa$i = $676;
         label = 225;
         break L102;
        } else {
         $1293 = $676;
         $713 = $674;
         $badcomment$1259$i = $badcomment$0269$i;
        }
        while (1) {
         if (!$1293) {
          $doc$idx$val$i8 = HEAP32[$doc$idx32$i >> 2] | 0;
          $doc$idx$val$idx$val$i10 = HEAP32[$doc$idx$val$i8 + 288 >> 2] | 0;
          HEAP32[$1 >> 2] = HEAP32[$doc$idx$val$i8 + 292 >> 2];
          HEAP32[$188 >> 2] = $doc$idx$val$idx$val$i10 + -3;
         }
         $badcomment$1259$i = $badcomment$1259$i + 1 | 0;
         if (HEAP32[$200 >> 2] | 0) HEAP8[(HEAP32[$198 >> 2] | 0) + ((HEAP32[$190 >> 2] | 0) + -2) >> 0] = 61;
         if (($713 | 0) != 45) {
          $$lcssa568 = $713;
          $$lcssa570 = $badcomment$1259$i;
          break;
         }
         _prvTidyAddCharToLexer($1, 45);
         $713 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
         $718 = ($badcomment$1259$i | 0) != 0;
         if (($713 | 0) == 62) {
          $$lcssa$i = $718;
          label = 225;
          break L102;
         } else $1293 = $718;
        }
        HEAP8[(HEAP32[$198 >> 2] | 0) + ((HEAP32[$190 >> 2] | 0) + -1) >> 0] = 61;
        _prvTidyAddCharToLexer($1, $$lcssa568);
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $$lcssa570;
       } else {
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
       }
      } else {
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
      }
      break;
     }
    case 6:
     {
      $907 = HEAP32[$190 >> 2] | 0;
      $908 = HEAP32[$193 >> 2] | 0;
      do if (($907 - $908 | 0) == 3) if (!(_prvTidytmbstrncmp((HEAP32[$198 >> 2] | 0) + $908 | 0, 310512, 3) | 0)) {
       HEAP32[$197 >> 2] = 11;
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
       break L107;
      } else {
       $916 = HEAP32[$193 >> 2] | 0;
       $917 = HEAP32[$190 >> 2] | 0;
       break;
      } else {
       $916 = $908;
       $917 = $907;
      } while (0);
      if (($917 - $916 | 0) == 4) if (!(_prvTidytmbstrncmp((HEAP32[$198 >> 2] | 0) + $916 | 0, 310516, 3) | 0)) {
       $927 = HEAP8[(HEAP32[$198 >> 2] | 0) + ((HEAP32[$193 >> 2] | 0) + 3) >> 0] | 0;
       if ($927 << 24 >> 24 > -1) if (HEAP32[316488 + ($927 << 24 >> 24 << 2) >> 2] & 8 | 0) {
        HEAP32[$197 >> 2] = 12;
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = 0;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       }
      }
      if (!(HEAP32[$201 >> 2] | 0)) if (!(HEAP32[$202 >> 2] | 0)) $c$2$i = $$$i; else label = 320; else label = 320;
      do if ((label | 0) == 320) {
       label = 0;
       if (($$$i | 0) != 63) {
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       }
       $938 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
       if (($938 | 0) == -1) {
        _prvTidyReportError($doc, 0, 0, 236);
        _prvTidyUngetChar(-1, HEAP32[$doc$idx32$i >> 2] | 0);
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       } else {
        _prvTidyAddCharToLexer($1, $938);
        $c$2$i = $938;
        break;
       }
      } while (0);
      if (($c$2$i | 0) == 62) {
       label = 325;
       break L102;
      } else {
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
      }
      break;
     }
    case 9:
     {
      if (($$$i | 0) == 37) {
       $1014 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
       if (($1014 | 0) == 62) {
        label = 343;
        break L102;
       }
       _prvTidyUngetChar($1014, HEAP32[$doc$idx32$i >> 2] | 0);
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
      } else {
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
      }
      break;
     }
    case 10:
     {
      if (($$$i | 0) == 35) {
       $1041 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
       if (($1041 | 0) == 62) {
        label = 349;
        break L102;
       }
       _prvTidyUngetChar($1041, HEAP32[$doc$idx32$i >> 2] | 0);
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
      } else {
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
      }
      break;
     }
    case 11:
     {
      if (($$$i | 0) == 63) {
       $1068 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
       if (($1068 | 0) == 62) {
        label = 355;
        break L102;
       }
       _prvTidyUngetChar($1068, HEAP32[$doc$idx32$i >> 2] | 0);
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
      } else {
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
      }
      break;
     }
    case 12:
     {
      if ($$$i >>> 0 < 128) {
       $1096 = ($$$i | 0) != 63;
       if ($1096 & (HEAP32[316488 + ($$$i << 2) >> 2] & 8 | 0) != 0) {
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       }
       if ($1096) label = 361; else $attributes$sroa$0$4$i = $attributes$sroa$0$0267$i;
      } else label = 361;
      if ((label | 0) == 361) {
       label = 0;
       HEAP32[$php$i$i >> 2] = 0;
       HEAP32[$isempty$i >> 2] = 0;
       _prvTidyUngetChar($$$i, HEAP32[$doc$idx32$i >> 2] | 0);
       $1098 = _ParseAttribute($doc, $isempty$i, $delim$i$i, $asp$i$i) | 0;
       if (!$1098) {
        $attributes$sroa$0$0267$i$lcssa601 = $attributes$sroa$0$0267$i;
        label = 362;
        break L102;
       }
       $1116 = HEAP32[$199 >> 2] | 0;
       $1119 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1116 >> 2] >> 2] & 31]($1116, 28) | 0;
       HEAP32[$1119 >> 2] = 0;
       HEAP32[$1119 + 4 >> 2] = 0;
       HEAP32[$1119 + 8 >> 2] = 0;
       HEAP32[$1119 + 12 >> 2] = 0;
       HEAP32[$1119 + 16 >> 2] = 0;
       HEAP32[$1119 + 20 >> 2] = 0;
       HEAP32[$1119 + 24 >> 2] = 0;
       HEAP32[$1119 + 20 >> 2] = $1098;
       HEAP32[$1119 + 24 >> 2] = _ParseValue($doc, $1098, 1, $isempty$i, $php$i$i) | 0;
       HEAP32[$1119 + 16 >> 2] = HEAP32[$php$i$i >> 2];
       HEAP32[$1119 + 4 >> 2] = _prvTidyFindAttribute($doc, $1119) | 0;
       if (!$attributes$sroa$0$0267$i) $attributes$sroa$0$3$ph$i = $1119; else {
        $here$0$i$i = $attributes$sroa$0$0267$i;
        while (1) {
         $1130 = HEAP32[$here$0$i$i >> 2] | 0;
         if (!$1130) {
          $here$0$i$i$lcssa = $here$0$i$i;
          break;
         } else $here$0$i$i = $1130;
        }
        HEAP32[$here$0$i$i$lcssa >> 2] = $1119;
        $attributes$sroa$0$3$ph$i = $attributes$sroa$0$0267$i;
       }
       $attributes$sroa$0$4$i = $attributes$sroa$0$3$ph$i;
      }
      $1141 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
      if (($1141 | 0) == 62) {
       $attributes$sroa$0$4$i$lcssa = $attributes$sroa$0$4$i;
       label = 373;
       break L102;
      }
      _prvTidyUngetChar($1141, HEAP32[$doc$idx32$i >> 2] | 0);
      $$023$be$i = $$023271$i;
      $attributes$sroa$0$0$be$i = $attributes$sroa$0$4$i;
      $badcomment$0$be$i = $badcomment$0269$i;
      break;
     }
    case 8:
     {
      switch ($$$i | 0) {
      case 91:
       {
        $1169 = HEAP32[$193 >> 2] | 0;
        if ((HEAP32[$190 >> 2] | 0) != ($1169 + 6 | 0)) {
         $$023$be$i = $$023271$i;
         $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
         $badcomment$0$be$i = $badcomment$0269$i;
         break L107;
        }
        if (_prvTidytmbstrncmp((HEAP32[$198 >> 2] | 0) + $1169 | 0, 310520, 6) | 0) {
         $$023$be$i = $$023271$i;
         $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
         $badcomment$0$be$i = $badcomment$0269$i;
         break L107;
        }
        HEAP32[$197 >> 2] = 7;
        HEAP32[$190 >> 2] = (HEAP32[$190 >> 2] | 0) + -6;
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
        break;
       }
      case 93:
       break;
      default:
       {
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       }
      }
      $1179 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
      switch ($1179 | 0) {
      case 62:
       {
        label = 386;
        break L102;
        break;
       }
      case 45:
       break;
      default:
       {
        _prvTidyUngetChar($1179, HEAP32[$doc$idx32$i >> 2] | 0);
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       }
      }
      $1181 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
      $1183 = HEAP32[$doc$idx32$i >> 2] | 0;
      if (($1181 | 0) != 45) {
       _prvTidyUngetChar($1181, $1183);
       _prvTidyUngetChar(45, HEAP32[$doc$idx32$i >> 2] | 0);
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
       break L107;
      }
      $1184 = _prvTidyReadChar($1183) | 0;
      if (($1184 | 0) == 62) {
       label = 386;
       break L102;
      }
      _prvTidyUngetChar($1184, HEAP32[$doc$idx32$i >> 2] | 0);
      _prvTidyUngetChar(45, HEAP32[$doc$idx32$i >> 2] | 0);
      _prvTidyUngetChar(45, HEAP32[$doc$idx32$i >> 2] | 0);
      $$023$be$i = $$023271$i;
      $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
      $badcomment$0$be$i = $badcomment$0269$i;
      break;
     }
    case 7:
     {
      if (($$$i | 0) == 93) {
       $1215 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
       $1217 = HEAP32[$doc$idx32$i >> 2] | 0;
       if (($1215 | 0) != 93) {
        _prvTidyUngetChar($1215, $1217);
        $$023$be$i = $$023271$i;
        $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
        $badcomment$0$be$i = $badcomment$0269$i;
        break L107;
       }
       $1218 = _prvTidyReadChar($1217) | 0;
       if (($1218 | 0) == 62) {
        label = 394;
        break L102;
       }
       _prvTidyUngetChar($1218, HEAP32[$doc$idx32$i >> 2] | 0);
       _prvTidyUngetChar(93, HEAP32[$doc$idx32$i >> 2] | 0);
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
      } else {
       $$023$be$i = $$023271$i;
       $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
       $badcomment$0$be$i = $badcomment$0269$i;
      }
      break;
     }
    default:
     {
      $$023$be$i = $$023271$i;
      $attributes$sroa$0$0$be$i = $attributes$sroa$0$0267$i;
      $badcomment$0$be$i = $badcomment$0269$i;
     }
    } while (0);
    $205 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
    if (($205 | 0) == -1) {
     $$pre$phi$iZ2D = $197;
     label = 397;
     break L99;
    } else {
     $$023271$i = $$023$be$i;
     $attributes$sroa$0$0267$i = $attributes$sroa$0$0$be$i;
     $badcomment$0269$i = $badcomment$0$be$i;
    }
   }
   switch (label | 0) {
   case 103:
    {
     if (!$$023271$i$lcssa596) {
      $261 = (HEAP32[$190 >> 2] | 0) + -1 | 0;
      if ((HEAP8[(HEAP32[$198 >> 2] | 0) + $261 >> 0] | 0) == 32) {
       HEAP32[$190 >> 2] = $261;
       HEAP32[$192 >> 2] = $261;
      }
     }
     $267 = HEAP32[$1 + 124 >> 2] | 0;
     $270 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$267 >> 2] >> 2] & 31]($267, 68) | 0;
     dest = $270;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     HEAP32[$270 + 48 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$270 + 52 >> 2] = HEAP32[$188 >> 2];
     HEAP32[$270 + 44 >> 2] = 4;
     HEAP32[$270 + 36 >> 2] = HEAP32[$193 >> 2];
     HEAP32[$270 + 40 >> 2] = HEAP32[$192 >> 2];
     HEAP32[$187 >> 2] = $270;
     $$4$i = $270;
     break L99;
     break;
    }
   case 114:
    {
     $292 = HEAP32[$1 + 124 >> 2] | 0;
     $295 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$292 >> 2] >> 2] & 31]($292, 68) | 0;
     dest = $295;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     HEAP32[$295 + 48 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$295 + 52 >> 2] = HEAP32[$188 >> 2];
     HEAP32[$295 + 44 >> 2] = 4;
     HEAP32[$295 + 36 >> 2] = HEAP32[$193 >> 2];
     HEAP32[$295 + 40 >> 2] = HEAP32[$192 >> 2];
     HEAP32[$187 >> 2] = $295;
     $$4$i = $295;
     break L99;
     break;
    }
   case 130:
    {
     $327 = HEAP32[$1 + 124 >> 2] | 0;
     $330 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$327 >> 2] >> 2] & 31]($327, 68) | 0;
     dest = $330;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     HEAP32[$330 + 48 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$330 + 52 >> 2] = HEAP32[$188 >> 2];
     HEAP32[$330 + 44 >> 2] = 4;
     HEAP32[$330 + 36 >> 2] = HEAP32[$193 >> 2];
     HEAP32[$330 + 40 >> 2] = HEAP32[$192 >> 2];
     HEAP32[$187 >> 2] = $330;
     $$4$i = $330;
     break L99;
     break;
    }
   case 133:
    {
     $346 = HEAP32[$1 + 124 >> 2] | 0;
     $349 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$346 >> 2] >> 2] & 31]($346, 68) | 0;
     dest = $349;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     HEAP32[$349 + 48 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$349 + 52 >> 2] = HEAP32[$188 >> 2];
     HEAP32[$349 + 44 >> 2] = 4;
     HEAP32[$349 + 36 >> 2] = HEAP32[$193 >> 2];
     HEAP32[$349 + 40 >> 2] = HEAP32[$192 >> 2];
     HEAP32[$187 >> 2] = $349;
     $$4$i = $349;
     break L99;
     break;
    }
   case 139:
    {
     $371 = HEAP32[$1 + 124 >> 2] | 0;
     $374 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$371 >> 2] >> 2] & 31]($371, 68) | 0;
     dest = $374;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     HEAP32[$374 + 48 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$374 + 52 >> 2] = HEAP32[$188 >> 2];
     HEAP32[$374 + 44 >> 2] = 4;
     HEAP32[$374 + 36 >> 2] = HEAP32[$193 >> 2];
     HEAP32[$374 + 40 >> 2] = HEAP32[$192 >> 2];
     HEAP32[$187 >> 2] = $374;
     $$4$i = $374;
     break L99;
     break;
    }
   case 142:
    {
     $389 = HEAP32[$1 + 124 >> 2] | 0;
     $392 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$389 >> 2] >> 2] & 31]($389, 68) | 0;
     dest = $392;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     HEAP32[$392 + 48 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$392 + 52 >> 2] = HEAP32[$188 >> 2];
     HEAP32[$392 + 44 >> 2] = 4;
     HEAP32[$392 + 36 >> 2] = HEAP32[$193 >> 2];
     HEAP32[$392 + 40 >> 2] = HEAP32[$192 >> 2];
     HEAP32[$187 >> 2] = $392;
     $$4$i = $392;
     break L99;
     break;
    }
   case 145:
    {
     $407 = HEAP32[$1 + 124 >> 2] | 0;
     $410 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$407 >> 2] >> 2] & 31]($407, 68) | 0;
     dest = $410;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     HEAP32[$410 + 48 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$410 + 52 >> 2] = HEAP32[$188 >> 2];
     HEAP32[$410 + 44 >> 2] = 4;
     HEAP32[$410 + 36 >> 2] = HEAP32[$193 >> 2];
     HEAP32[$410 + 40 >> 2] = HEAP32[$192 >> 2];
     HEAP32[$187 >> 2] = $410;
     $$4$i = $410;
     break L99;
     break;
    }
   case 150:
    {
     $430 = HEAP32[$1 + 124 >> 2] | 0;
     $433 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$430 >> 2] >> 2] & 31]($430, 68) | 0;
     dest = $433;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     HEAP32[$433 + 48 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$433 + 52 >> 2] = HEAP32[$188 >> 2];
     HEAP32[$433 + 44 >> 2] = 4;
     HEAP32[$433 + 36 >> 2] = HEAP32[$193 >> 2];
     HEAP32[$433 + 40 >> 2] = HEAP32[$192 >> 2];
     HEAP32[$187 >> 2] = $433;
     $$4$i = $433;
     break L99;
     break;
    }
   case 159:
    {
     HEAP32[$197 >> 2] = 0;
     HEAP32[$189 >> 2] = 0;
     $$4$i = HEAP32[$187 >> 2] | 0;
     break L99;
     break;
    }
   case 160:
    {
     $487 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
     $488 = HEAP32[$190 >> 2] | 0;
     if (!$488) $495 = 0; else {
      HEAP8[(HEAP32[$198 >> 2] | 0) + ($488 + -1) >> 0] = $487;
      $495 = HEAP32[$190 >> 2] | 0;
     }
     HEAP32[$193 >> 2] = $495 + -1;
     $496 = _ParseTagName($doc) | 0;
     $497 = $496 << 24 >> 24;
     HEAP32[$isempty$i >> 2] = 0;
     $498 = HEAP32[$0 >> 2] | 0;
     $500 = HEAP32[$498 + 124 >> 2] | 0;
     $503 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$500 >> 2] >> 2] & 31]($500, 68) | 0;
     dest = $503;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($498 | 0) {
      HEAP32[$503 + 48 >> 2] = HEAP32[$498 >> 2];
      HEAP32[$503 + 52 >> 2] = HEAP32[$498 + 4 >> 2];
     }
     HEAP32[$503 + 44 >> 2] = 5;
     $514 = $498 + 48 | 0;
     $515 = HEAP32[$514 >> 2] | 0;
     HEAP32[$503 + 32 >> 2] = _prvTidytmbstrndup(HEAP32[$199 >> 2] | 0, (HEAP32[$498 + 84 >> 2] | 0) + $515 | 0, (HEAP32[$498 + 52 >> 2] | 0) - $515 | 0) | 0;
     $522 = HEAP32[$514 >> 2] | 0;
     HEAP32[$503 + 36 >> 2] = $522;
     HEAP32[$503 + 40 >> 2] = $522;
     _prvTidyFindTag($doc, $503) | 0;
     HEAP32[$187 >> 2] = $503;
     switch ($496 << 24 >> 24) {
     case 62:
      {
       $$pr$i = $503;
       $attributes$sroa$0$1370$i = 0;
       break;
      }
     case 47:
      {
       _prvTidyUngetChar($497, HEAP32[$doc$idx32$i >> 2] | 0);
       label = 166;
       break;
      }
     default:
      label = 166;
     }
     do if ((label | 0) == 166) {
      $526 = HEAP32[$0 >> 2] | 0;
      $doc$idx$val1315$i$i = HEAP32[$doc$idx32$i >> 2] | 0;
      if (!$doc$idx$val1315$i$i) ___assert_fail(310441, 310231, 926, 310460);
      $528 = $doc + 168 | 0;
      $529 = $526 + 60 | 0;
      $doc$idx$val1317$i$i = $doc$idx$val1315$i$i;
      $list$0$ph16$i$i = 0;
      L293 : while (1) {
       $531 = ($list$0$ph16$i$i | 0) == 0;
       $doc$idx$val14$i$i = $doc$idx$val1317$i$i;
       L295 : while (1) {
        if (!(HEAP32[$doc$idx$val14$i$i + 4 >> 2] | 0)) if (_prvTidyIsEOF($doc$idx$val14$i$i) | 0) {
         $list$0$ph16$i$i$lcssa = $list$0$ph16$i$i;
         label = 201;
         break L293;
        }
        $537 = _ParseAttribute($doc, $isempty$i, $asp$i$i, $php$i$i) | 0;
        L300 : do if (!$537) {
         $539 = HEAP32[$asp$i$i >> 2] | 0;
         if ($539 | 0) {
          $542 = HEAP32[$199 >> 2] | 0;
          $545 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$542 >> 2] >> 2] & 31]($542, 28) | 0;
          HEAP32[$545 >> 2] = 0;
          HEAP32[$545 + 4 >> 2] = 0;
          HEAP32[$545 + 8 >> 2] = 0;
          HEAP32[$545 + 12 >> 2] = 0;
          HEAP32[$545 + 16 >> 2] = 0;
          HEAP32[$545 + 20 >> 2] = 0;
          HEAP32[$545 + 24 >> 2] = 0;
          HEAP32[$545 + 8 >> 2] = $539;
          if ($531) {
           $list$0$ph$ph$i$i = $545;
           break L295;
          } else $here$0$i$i$i = $list$0$ph16$i$i;
          while (1) {
           $547 = HEAP32[$here$0$i$i$i >> 2] | 0;
           if (!$547) {
            $here$0$i$i$i$lcssa = $here$0$i$i$i;
            break;
           } else $here$0$i$i$i = $547;
          }
          HEAP32[$here$0$i$i$i$lcssa >> 2] = $545;
          break;
         }
         $549 = HEAP32[$php$i$i >> 2] | 0;
         if (!$549) {
          $list$0$ph16$i$i$lcssa = $list$0$ph16$i$i;
          label = 201;
          break L293;
         }
         $552 = HEAP32[$199 >> 2] | 0;
         $555 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$552 >> 2] >> 2] & 31]($552, 28) | 0;
         HEAP32[$555 >> 2] = 0;
         HEAP32[$555 + 4 >> 2] = 0;
         HEAP32[$555 + 8 >> 2] = 0;
         HEAP32[$555 + 12 >> 2] = 0;
         HEAP32[$555 + 16 >> 2] = 0;
         HEAP32[$555 + 20 >> 2] = 0;
         HEAP32[$555 + 24 >> 2] = 0;
         HEAP32[$555 + 12 >> 2] = $549;
         if ($531) {
          $list$0$ph$ph$i$i = $555;
          break L295;
         } else $here$0$i3$i$i = $list$0$ph16$i$i;
         while (1) {
          $557 = HEAP32[$here$0$i3$i$i >> 2] | 0;
          if (!$557) {
           $here$0$i3$i$i$lcssa = $here$0$i3$i$i;
           break;
          } else $here$0$i3$i$i = $557;
         }
         HEAP32[$here$0$i3$i$i$lcssa >> 2] = $555;
        } else {
         $559 = _ParseValue($doc, $537, 0, $isempty$i, $delim$i$i) | 0;
         $560 = HEAP8[$537 >> 0] | 0;
         L313 : do if ($560 << 24 >> 24 > -1) if (!(HEAP32[316488 + ($560 << 24 >> 24 << 2) >> 2] & 2)) label = 188; else {
          if ((_prvTidytmbstrlen($537) | 0) >>> 0 > 1) $i$04$i$i$i = 1; else break;
          do {
           $571 = HEAP8[$537 + $i$04$i$i$i >> 0] | 0;
           if ($571 << 24 >> 24 <= -1) {
            label = 188;
            break L313;
           }
           $i$04$i$i$i = $i$04$i$i$i + 1 | 0;
           if (!(HEAP32[316488 + ($571 << 24 >> 24 << 2) >> 2] & 4)) {
            label = 188;
            break L313;
           }
          } while ($i$04$i$i$i >>> 0 < (_prvTidytmbstrlen($537) | 0) >>> 0);
         } else label = 188; while (0);
         do if ((label | 0) == 188) {
          label = 0;
          if (HEAP32[$528 >> 2] | 0) if (_prvTidyIsValidXMLID($537) | 0) break;
          $592 = HEAP32[$199 >> 2] | 0;
          $595 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$592 >> 2] >> 2] & 31]($592, 28) | 0;
          HEAP32[$595 >> 2] = 0;
          HEAP32[$595 + 4 >> 2] = 0;
          HEAP32[$595 + 8 >> 2] = 0;
          HEAP32[$595 + 12 >> 2] = 0;
          HEAP32[$595 + 16 >> 2] = 0;
          $596 = $595 + 20 | 0;
          HEAP32[$596 >> 2] = $537;
          $597 = $595 + 24 | 0;
          HEAP32[$597 >> 2] = $559;
          do if (!(HEAP8[$537 >> 0] | 0)) label = 196; else {
           if ((HEAP8[$537 + ((_prvTidytmbstrlen($537) | 0) + -1) >> 0] | 0) != 34) {
            label = 196;
            break;
           }
           _prvTidyReportAttrError($doc, HEAP32[$529 >> 2] | 0, $595, 259);
          } while (0);
          do if ((label | 0) == 196) {
           label = 0;
           $607 = HEAP32[$529 >> 2] | 0;
           if (!$559) {
            _prvTidyReportAttrError($doc, $607, $595, 702);
            break;
           } else {
            _prvTidyReportAttrError($doc, $607, $595, 271);
            break;
           }
          } while (0);
          _prvTidyFreeNode($doc, HEAP32[$595 + 8 >> 2] | 0);
          _prvTidyFreeNode($doc, HEAP32[$595 + 12 >> 2] | 0);
          $612 = HEAP32[$199 >> 2] | 0;
          FUNCTION_TABLE_vii[HEAP32[(HEAP32[$612 >> 2] | 0) + 8 >> 2] & 15]($612, HEAP32[$596 >> 2] | 0);
          $617 = HEAP32[$199 >> 2] | 0;
          FUNCTION_TABLE_vii[HEAP32[(HEAP32[$617 >> 2] | 0) + 8 >> 2] & 15]($617, HEAP32[$597 >> 2] | 0);
          $622 = HEAP32[$199 >> 2] | 0;
          FUNCTION_TABLE_vii[HEAP32[(HEAP32[$622 >> 2] | 0) + 8 >> 2] & 15]($622, $595);
          break L300;
         } while (0);
         $580 = HEAP32[$199 >> 2] | 0;
         $583 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$580 >> 2] >> 2] & 31]($580, 28) | 0;
         HEAP32[$583 >> 2] = 0;
         HEAP32[$583 + 4 >> 2] = 0;
         HEAP32[$583 + 8 >> 2] = 0;
         HEAP32[$583 + 12 >> 2] = 0;
         HEAP32[$583 + 16 >> 2] = HEAP32[$delim$i$i >> 2];
         HEAP32[$583 + 20 >> 2] = $537;
         HEAP32[$583 + 24 >> 2] = $559;
         HEAP32[$583 + 4 >> 2] = _prvTidyFindAttribute($doc, $583) | 0;
         if ($531) {
          $list$0$ph$ph$i$i = $583;
          break L295;
         } else $here$0$i7$i$i = $list$0$ph16$i$i;
         while (1) {
          $590 = HEAP32[$here$0$i7$i$i >> 2] | 0;
          if (!$590) {
           $here$0$i7$i$i$lcssa = $here$0$i7$i$i;
           break;
          } else $here$0$i7$i$i = $590;
         }
         HEAP32[$here$0$i7$i$i$lcssa >> 2] = $583;
        } while (0);
        $doc$idx$val14$i$i = HEAP32[$doc$idx32$i >> 2] | 0;
        if (!$doc$idx$val14$i$i) {
         label = 170;
         break L293;
        }
       }
       $doc$idx$val1317$i$i = HEAP32[$doc$idx32$i >> 2] | 0;
       if (!$doc$idx$val1317$i$i) {
        label = 170;
        break;
       } else $list$0$ph16$i$i = $list$0$ph$ph$i$i;
      }
      if ((label | 0) == 170) ___assert_fail(310441, 310231, 926, 310460); else if ((label | 0) == 201) {
       $627 = $list$0$ph16$i$i$lcssa;
       $$pre365$i$pre = HEAP32[$187 >> 2] | 0;
       if (!(HEAP32[$isempty$i >> 2] | 0)) {
        $$pr$i = $$pre365$i$pre;
        $attributes$sroa$0$1370$i = $627;
        break;
       }
       HEAP32[$$pre365$i$pre + 44 >> 2] = 7;
       $$pr$i = $$pre365$i$pre;
       $attributes$sroa$0$1370$i = $627;
       break;
      }
     } while (0);
     HEAP32[$$pr$i + 20 >> 2] = $attributes$sroa$0$1370$i;
     $630 = HEAP32[$193 >> 2] | 0;
     HEAP32[$192 >> 2] = $630;
     HEAP32[$190 >> 2] = $630;
     $631 = ($$pr$i | 0) == 0;
     if ($631) label = 206; else {
      $633 = HEAP32[$$pr$i + 28 >> 2] | 0;
      if (!$633) label = 206; else if ($$lcssa619 | (HEAP32[$633 >> 2] | 0) == 84) {
       $$225103372$i237 = 2;
       $649 = $633;
       label = 212;
      } else label = 207;
     }
     if ((label | 0) == 206) if ($$lcssa619) {
      $$225103$i = 2;
      label = 210;
     } else label = 207;
     if ((label | 0) == 207) if ((HEAP32[$$pr$i + 44 >> 2] | 0) == 5) {
      $641 = HEAP32[$$pr$i + 28 >> 2] | 0;
      if (!$641) {
       $$225102$i = $$023271$i$lcssa;
       label = 213;
      } else if (!(HEAP32[$641 + 16 >> 2] & 1)) {
       $$225102$i = $$023271$i$lcssa;
       label = 213;
      } else {
       $$225103$i = $$023271$i$lcssa;
       label = 210;
      }
     } else {
      $$225103$i = $$023271$i$lcssa;
      label = 210;
     }
     if ((label | 0) == 210) if ($631) {
      $$225101$i = $$225103$i;
      $storemerge$i = 0;
     } else {
      $$pre231 = HEAP32[$$pr$i + 28 >> 2] | 0;
      if (!$$pre231) {
       $$225101$i = $$225103$i;
       $storemerge$i = 0;
      } else {
       $$225103372$i237 = $$225103$i;
       $649 = $$pre231;
       label = 212;
      }
     }
     if ((label | 0) == 212) switch (HEAP32[$649 >> 2] | 0) {
     case 47:
     case 17:
      {
       $$225102$i = $$225103372$i237;
       label = 213;
       break;
      }
     default:
      {
       $$225101$i = $$225103372$i237;
       $storemerge$i = 0;
      }
     }
     L360 : do if ((label | 0) == 213) {
      $651 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
      switch ($651 | 0) {
      case 10:
      case 12:
       {
        $$225101$i = $$225102$i;
        $storemerge$i = 1;
        break L360;
        break;
       }
      default:
       {}
      }
      _prvTidyUngetChar($651, HEAP32[$doc$idx32$i >> 2] | 0);
      $$225101$i = $$225102$i;
      $storemerge$i = 1;
     } while (0);
     HEAP32[$189 >> 2] = $storemerge$i;
     HEAP32[$197 >> 2] = 0;
     $653 = HEAP32[$187 >> 2] | 0;
     $655 = HEAP32[$653 + 28 >> 2] | 0;
     do if (!$655) {
      if (($$225101$i | 0) != 4) _prvTidyReportFatal($doc, 0, $653, 222);
     } else if (!(HEAP32[$doc + 168 >> 2] | 0)) {
      $665 = (HEAP32[$0 >> 2] | 0) + 32 | 0;
      HEAP32[$665 >> 2] = HEAP32[$665 >> 2] & (HEAP32[$655 + 8 >> 2] | 57344);
      _prvTidyRepairDuplicateAttributes($doc, $653, 0);
      break;
     } else {
      _prvTidyRepairDuplicateAttributes($doc, $653, 1);
      break;
     } while (0);
     $$4$i = HEAP32[$187 >> 2] | 0;
     break L99;
     break;
    }
   case 225:
    {
     if ($$lcssa$i) _prvTidyReportError($doc, 0, 0, 229);
     $678 = (HEAP32[$190 >> 2] | 0) + -2 | 0;
     HEAP32[$190 >> 2] = $678;
     HEAP32[$192 >> 2] = $678;
     HEAP8[(HEAP32[$198 >> 2] | 0) + $678 >> 0] = 0;
     HEAP32[$197 >> 2] = 0;
     HEAP32[$189 >> 2] = 0;
     $doc$idx47$val$i = HEAP32[$0 >> 2] | 0;
     $682 = HEAP32[$doc$idx47$val$i + 124 >> 2] | 0;
     $685 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$682 >> 2] >> 2] & 31]($682, 68) | 0;
     dest = $685;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($doc$idx47$val$i | 0) {
      HEAP32[$685 + 48 >> 2] = HEAP32[$doc$idx47$val$i >> 2];
      HEAP32[$685 + 52 >> 2] = HEAP32[$doc$idx47$val$i + 4 >> 2];
     }
     HEAP32[$685 + 44 >> 2] = 2;
     HEAP32[$685 + 36 >> 2] = HEAP32[$doc$idx47$val$i + 48 >> 2];
     HEAP32[$685 + 40 >> 2] = HEAP32[$doc$idx47$val$i + 52 >> 2];
     HEAP32[$187 >> 2] = $685;
     $700 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
     if (($700 | 0) == 10) {
      $702 = HEAP32[$187 >> 2] | 0;
      HEAP32[$702 + 64 >> 2] = 1;
      $$4$i = $702;
      break L99;
     } else {
      _prvTidyUngetChar($700, HEAP32[$doc$idx32$i >> 2] | 0);
      $$4$i = HEAP32[$187 >> 2] | 0;
      break L99;
     }
     break;
    }
   case 239:
    {
     _prvTidyUngetChar($$$i$lcssa641, HEAP32[$doc$idx32$i >> 2] | 0);
     HEAP32[$190 >> 2] = (HEAP32[$190 >> 2] | 0) + -1;
     $726 = HEAP32[$0 >> 2] | 0;
     $727 = $726 + 92 | 0;
     $728 = HEAP32[$727 >> 2] | 0;
     $729 = $726 + 124 | 0;
     $730 = HEAP32[$729 >> 2] | 0;
     $733 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$730 >> 2] >> 2] & 31]($730, 68) | 0;
     dest = $733;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($726 | 0) {
      HEAP32[$733 + 48 >> 2] = HEAP32[$726 >> 2];
      HEAP32[$733 + 52 >> 2] = HEAP32[$726 + 4 >> 2];
     }
     HEAP32[$733 + 44 >> 2] = 1;
     $741 = $726 + 48 | 0;
     HEAP32[$733 + 36 >> 2] = HEAP32[$741 >> 2];
     $744 = $726 + 52 | 0;
     $746 = $733 + 40 | 0;
     HEAP32[$746 >> 2] = HEAP32[$744 >> 2];
     $747 = $726 + 8 | 0;
     HEAP32[$747 >> 2] = 0;
     $749 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
     L376 : do if (($749 | 0) == -1) label = 275; else {
      $751 = $726 + 84 | 0;
      $752 = $733 + 32 | 0;
      $753 = $726 + 4 | 0;
      $$pn$i$i = $728;
      $755 = $749;
      $delim$028$i$i = 0;
      $hasfpi$027$i$i = 1;
      $state$029$i$i = 1;
      L378 : while (1) {
       $754 = ($state$029$i$i | 0) != 4;
       $c$0$i$i = ($755 | 0) == 10 & $754 ? 32 : $755;
       $758 = $c$0$i$i >>> 0 < 128;
       if ($758) if ($754 & (HEAP32[316488 + ($c$0$i$i << 2) >> 2] & 8 | 0) != 0) if (!(HEAP32[$747 >> 2] | 0)) {
        _prvTidyAddCharToLexer($726, $c$0$i$i);
        $storemerge$i$i = 1;
        label = 248;
       } else {
        $delim$0$be$i$i = $delim$028$i$i;
        $hasfpi$0$be$i$i = $hasfpi$027$i$i;
        $start$0$be$i$i = $$pn$i$i;
        $state$0$be$i$i = $state$029$i$i;
       } else label = 247; else label = 247;
       if ((label | 0) == 247) {
        label = 0;
        _prvTidyAddCharToLexer($726, $c$0$i$i);
        $storemerge$i$i = 0;
        label = 248;
       }
       L386 : do if ((label | 0) == 248) {
        label = 0;
        HEAP32[$747 >> 2] = $storemerge$i$i;
        switch ($state$029$i$i | 0) {
        case 0:
         {
          L390 : do if ($758) {
           switch ((HEAP32[316488 + ($c$0$i$i << 2) >> 2] & 32 | 0 ? $c$0$i$i + -32 | 0 : $c$0$i$i) | 0) {
           case 83:
           case 80:
            break;
           default:
            break L390;
           }
           $delim$0$be$i$i = $delim$028$i$i;
           $hasfpi$0$be$i$i = $hasfpi$027$i$i;
           $start$0$be$i$i = (HEAP32[$727 >> 2] | 0) + -1 | 0;
           $state$0$be$i$i = 2;
           break L386;
          } while (0);
          switch ($c$0$i$i | 0) {
          case 62:
           {
            break L378;
            break;
           }
          case 91:
           {
            $delim$0$be$i$i = $delim$028$i$i;
            $hasfpi$0$be$i$i = $hasfpi$027$i$i;
            $start$0$be$i$i = HEAP32[$727 >> 2] | 0;
            $state$0$be$i$i = 4;
            break L386;
            break;
           }
          case 34:
          case 39:
           {
            $delim$0$be$i$i = $c$0$i$i;
            $hasfpi$0$be$i$i = $hasfpi$027$i$i;
            $start$0$be$i$i = HEAP32[$727 >> 2] | 0;
            $state$0$be$i$i = 3;
            break L386;
            break;
           }
          default:
           {
            $delim$0$be$i$i = $delim$028$i$i;
            $hasfpi$0$be$i$i = $hasfpi$027$i$i;
            $start$0$be$i$i = $$pn$i$i;
            $state$0$be$i$i = 0;
            break L386;
           }
          }
          break;
         }
        case 1:
         {
          if ($758) {
           if (!(HEAP32[316488 + ($c$0$i$i << 2) >> 2] & 8)) label = 263;
          } else label = 263;
          if ((label | 0) == 263) {
           label = 0;
           switch ($c$0$i$i | 0) {
           case 62:
           case 91:
            break;
           default:
            {
             $delim$0$be$i$i = $delim$028$i$i;
             $hasfpi$0$be$i$i = $hasfpi$027$i$i;
             $start$0$be$i$i = $$pn$i$i;
             $state$0$be$i$i = 1;
             break L386;
            }
           }
          }
          HEAP32[$752 >> 2] = _prvTidytmbstrndup(HEAP32[$199 >> 2] | 0, (HEAP32[$751 >> 2] | 0) + $$pn$i$i | 0, (HEAP32[$727 >> 2] | 0) + ~$$pn$i$i | 0) | 0;
          switch ($c$0$i$i | 0) {
          case 62:
          case 91:
           break;
          default:
           {
            $delim$0$be$i$i = $delim$028$i$i;
            $hasfpi$0$be$i$i = $hasfpi$027$i$i;
            $start$0$be$i$i = $$pn$i$i;
            $state$0$be$i$i = 0;
            break L386;
           }
          }
          HEAP32[$727 >> 2] = (HEAP32[$727 >> 2] | 0) + -1;
          _prvTidyUngetChar($c$0$i$i, HEAP32[$doc$idx32$i >> 2] | 0);
          $delim$0$be$i$i = $delim$028$i$i;
          $hasfpi$0$be$i$i = $hasfpi$027$i$i;
          $start$0$be$i$i = $$pn$i$i;
          $state$0$be$i$i = 0;
          break L386;
          break;
         }
        case 2:
         {
          if ($758) $796 = (HEAP32[316488 + ($c$0$i$i << 2) >> 2] & 8 | 0) != 0; else $796 = 0;
          $795 = ($c$0$i$i | 0) == 62;
          if (!($795 | $796)) {
           $delim$0$be$i$i = $delim$028$i$i;
           $hasfpi$0$be$i$i = $hasfpi$027$i$i;
           $start$0$be$i$i = $$pn$i$i;
           $state$0$be$i$i = 2;
           break L386;
          }
          $803 = _prvTidytmbstrndup(HEAP32[$199 >> 2] | 0, (HEAP32[$751 >> 2] | 0) + $$pn$i$i | 0, (HEAP32[$727 >> 2] | 0) + ~$$pn$i$i | 0) | 0;
          $806 = (_prvTidytmbstrcasecmp($803, 310777) | 0) != 0 & 1;
          $807 = HEAP32[$199 >> 2] | 0;
          FUNCTION_TABLE_vii[HEAP32[(HEAP32[$807 >> 2] | 0) + 8 >> 2] & 15]($807, $803);
          if (!$795) {
           $delim$0$be$i$i = $delim$028$i$i;
           $hasfpi$0$be$i$i = $806;
           $start$0$be$i$i = $$pn$i$i;
           $state$0$be$i$i = 0;
           break L386;
          }
          HEAP32[$727 >> 2] = (HEAP32[$727 >> 2] | 0) + -1;
          _prvTidyUngetChar(62, HEAP32[$doc$idx32$i >> 2] | 0);
          $delim$0$be$i$i = $delim$028$i$i;
          $hasfpi$0$be$i$i = $806;
          $start$0$be$i$i = $$pn$i$i;
          $state$0$be$i$i = 0;
          break L386;
          break;
         }
        case 3:
         {
          if (($c$0$i$i | 0) != ($delim$028$i$i | 0)) {
           $delim$0$be$i$i = $delim$028$i$i;
           $hasfpi$0$be$i$i = $hasfpi$027$i$i;
           $start$0$be$i$i = $$pn$i$i;
           $state$0$be$i$i = 3;
           break L386;
          }
          $821 = _prvTidytmbstrndup(HEAP32[$199 >> 2] | 0, (HEAP32[$751 >> 2] | 0) + $$pn$i$i | 0, (HEAP32[$727 >> 2] | 0) + ~$$pn$i$i | 0) | 0;
          $824 = _prvTidyAddAttribute($doc, $733, $hasfpi$027$i$i | 0 ? 310770 : 310777, $821) | 0;
          $825 = HEAP32[$199 >> 2] | 0;
          FUNCTION_TABLE_vii[HEAP32[(HEAP32[$825 >> 2] | 0) + 8 >> 2] & 15]($825, $821);
          HEAP32[$824 + 16 >> 2] = $delim$028$i$i;
          $delim$0$be$i$i = 0;
          $hasfpi$0$be$i$i = 0;
          $start$0$be$i$i = $$pn$i$i;
          $state$0$be$i$i = 0;
          break L386;
          break;
         }
        case 4:
         {
          if (($c$0$i$i | 0) != 93) {
           $delim$0$be$i$i = $delim$028$i$i;
           $hasfpi$0$be$i$i = $hasfpi$027$i$i;
           $start$0$be$i$i = $$pn$i$i;
           $state$0$be$i$i = 4;
           break L386;
          }
          HEAP32[$741 >> 2] = $$pn$i$i;
          HEAP32[$744 >> 2] = (HEAP32[$727 >> 2] | 0) + -1;
          $833 = HEAP32[$729 >> 2] | 0;
          $836 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$833 >> 2] >> 2] & 31]($833, 68) | 0;
          dest = $836;
          stop = dest + 68 | 0;
          do {
           HEAP32[dest >> 2] = 0;
           dest = dest + 4 | 0;
          } while ((dest | 0) < (stop | 0));
          HEAP32[$836 + 48 >> 2] = HEAP32[$726 >> 2];
          HEAP32[$836 + 52 >> 2] = HEAP32[$753 >> 2];
          HEAP32[$836 + 44 >> 2] = 4;
          HEAP32[$836 + 36 >> 2] = HEAP32[$741 >> 2];
          HEAP32[$836 + 40 >> 2] = HEAP32[$744 >> 2];
          _prvTidyInsertNodeAtEnd($733, $836);
          $delim$0$be$i$i = $delim$028$i$i;
          $hasfpi$0$be$i$i = $hasfpi$027$i$i;
          $start$0$be$i$i = $$pn$i$i;
          $state$0$be$i$i = 0;
          break L386;
          break;
         }
        default:
         {
          $delim$0$be$i$i = $delim$028$i$i;
          $hasfpi$0$be$i$i = $hasfpi$027$i$i;
          $start$0$be$i$i = $$pn$i$i;
          $state$0$be$i$i = $state$029$i$i;
          break L386;
         }
        }
       } while (0);
       $755 = _prvTidyReadChar(HEAP32[$doc$idx32$i >> 2] | 0) | 0;
       if (($755 | 0) == -1) {
        label = 275;
        break L376;
       } else {
        $$pn$i$i = $start$0$be$i$i;
        $delim$028$i$i = $delim$0$be$i$i;
        $hasfpi$027$i$i = $hasfpi$0$be$i$i;
        $state$029$i$i = $state$0$be$i$i;
       }
      }
      $774 = (HEAP32[$727 >> 2] | 0) + -1 | 0;
      HEAP32[$727 >> 2] = $774;
      HEAP32[$746 >> 2] = $774;
      $775 = _prvTidyGetAttrByName($733, 310777) | 0;
      if ($775 | 0) _prvTidyCheckUrl($doc, $733, $775);
      $777 = HEAP32[$752 >> 2] | 0;
      if ($777 | 0) if (_prvTidyIsValidXMLID($777) | 0) {
       $$1$i$i = $733;
       break;
      }
      _prvTidyReportError($doc, 0, 0, 235);
      _prvTidyFreeNode($doc, $733);
      $$1$i$i = 0;
     } while (0);
     if ((label | 0) == 275) {
      _prvTidyReportError($doc, 0, 0, 235);
      _prvTidyFreeNode($doc, $733);
      $$1$i$i = 0;
     }
     HEAP32[$187 >> 2] = $$1$i$i;
     $846 = HEAP32[$190 >> 2] | 0;
     HEAP32[$192 >> 2] = $846;
     HEAP8[(HEAP32[$198 >> 2] | 0) + $846 >> 0] = 0;
     HEAP32[$197 >> 2] = 0;
     HEAP32[$189 >> 2] = 0;
     $849 = $1 + 36 | 0;
     do if (!(HEAP32[$849 >> 2] | 0)) {
      $852 = HEAP32[$187 >> 2] | 0;
      if ($852 | 0) if (!(HEAP32[$doc + 168 >> 2] | 0)) {
       $857 = _prvTidyGetAttrByName($852, 310770) | 0;
       if (!$857) label = 281; else {
        $859 = $857 + 24 | 0;
        $860 = HEAP32[$859 >> 2] | 0;
        if (!$860) label = 281; else {
         $i$02$i$i$i = 0;
         while (1) {
          if ($i$02$i$i$i >>> 0 < 17) if (!(_prvTidytmbstrcasecmp(HEAP32[63656 + ($i$02$i$i$i * 20 | 0) + 12 >> 2] | 0, $860) | 0)) {
           $i$02$i$i$i$lcssa = $i$02$i$i$i;
           label = 288;
           break;
          }
          $i$02$i$i$i = $i$02$i$i$i + 1 | 0;
          if (($i$02$i$i$i | 0) == 19) {
           $$0$i2$i$i = 0;
           break;
          }
         }
         if ((label | 0) == 288) {
          $875 = HEAP32[63656 + ($i$02$i$i$i$lcssa * 20 | 0) + 4 >> 2] | 0;
          if (!(659455 >>> $i$02$i$i$i$lcssa & 1)) {
           _prvTidySetOptionBool($doc, 25, 1) | 0;
           _prvTidySetOptionBool($doc, 26, 1) | 0;
           HEAP32[(HEAP32[$0 >> 2] | 0) + 28 >> 2] = 1;
           $$0$i2$i$i = $875;
          } else $$0$i2$i$i = $875;
         }
         $881 = HEAP32[$199 >> 2] | 0;
         FUNCTION_TABLE_vii[HEAP32[(HEAP32[$881 >> 2] | 0) + 8 >> 2] & 15]($881, HEAP32[$859 >> 2] | 0);
         $886 = HEAP32[$199 >> 2] | 0;
         do if (($$0$i2$i$i | 0) == 1) {
          $i$02$lcssa$i$i$i = 0;
          label = 291;
         } else if (($$0$i2$i$i | 0) == 2) {
          $i$02$lcssa$i$i$i = 3;
          label = 291;
         } else {
          if (($$0$i2$i$i | 0) == 4) {
           $i$02$lcssa$i$i$i = 6;
           label = 291;
           break;
          }
          if (($$0$i2$i$i | 0) == 8) {
           $i$02$lcssa$i$i$i = 7;
           label = 291;
           break;
          }
          if (($$0$i2$i$i | 0) == 16) {
           $i$02$lcssa$i$i$i = 8;
           label = 291;
           break;
          }
          if (($$0$i2$i$i | 0) == 32) {
           $i$02$lcssa$i$i$i = 9;
           label = 291;
           break;
          }
          if (($$0$i2$i$i | 0) == 64) {
           $i$02$lcssa$i$i$i = 10;
           label = 291;
           break;
          }
          if (($$0$i2$i$i | 0) == 128) {
           $i$02$lcssa$i$i$i = 11;
           label = 291;
           break;
          }
          if (($$0$i2$i$i | 0) == 256) {
           $i$02$lcssa$i$i$i = 12;
           label = 291;
           break;
          }
          if (($$0$i2$i$i | 0) == 512) {
           $i$02$lcssa$i$i$i = 13;
           label = 291;
           break;
          }
          if (($$0$i2$i$i | 0) == 1024) {
           $i$02$lcssa$i$i$i = 14;
           label = 291;
           break;
          }
          if (($$0$i2$i$i | 0) == 2048) {
           $i$02$lcssa$i$i$i = 15;
           label = 291;
           break;
          }
          if (($$0$i2$i$i | 0) == 4096) {
           $i$02$lcssa$i$i$i = 16;
           label = 291;
           break;
          }
          if (($$0$i2$i$i | 0) == 131072) {
           $i$02$lcssa$i$i$i = 17;
           label = 291;
           break;
          }
          if (($$0$i2$i$i | 0) == 262144) {
           $i$02$lcssa$i$i$i = 18;
           label = 291;
          } else $$0$i1$i$i = 0;
         } while (0);
         if ((label | 0) == 291) $$0$i1$i$i = HEAP32[63656 + ($i$02$lcssa$i$i$i * 20 | 0) + 12 >> 2] | 0;
         HEAP32[$859 >> 2] = _prvTidytmbstrdup($886, $$0$i1$i$i) | 0;
         HEAP32[$849 >> 2] = $$0$i2$i$i;
         if (($$0$i2$i$i | 0) == 393216) break;
        }
       }
       if ((label | 0) == 281) {
        $863 = HEAP32[$852 + 32 >> 2] | 0;
        if ($863 | 0) if (!(_prvTidytmbstrcmp($863, 310346) | 0)) {
         HEAP32[$849 >> 2] = 393216;
         break;
        }
        HEAP32[$849 >> 2] = 0;
       }
       _prvTidyAdjustTags($doc);
      }
     } while (0);
     $$4$i = HEAP32[$187 >> 2] | 0;
     break L99;
     break;
    }
   case 325:
    {
     $942 = HEAP32[$190 >> 2] | 0;
     $943 = $942 + -1 | 0;
     HEAP32[$190 >> 2] = $943;
     if (!$943) {
      HEAP32[$192 >> 2] = 0;
      HEAP8[HEAP32[$198 >> 2] >> 0] = 0;
      $doc$idx45$val$i = HEAP32[$0 >> 2] | 0;
      $995 = HEAP32[$doc$idx45$val$i + 124 >> 2] | 0;
      $998 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$995 >> 2] >> 2] & 31]($995, 68) | 0;
      dest = $998;
      stop = dest + 68 | 0;
      do {
       HEAP32[dest >> 2] = 0;
       dest = dest + 4 | 0;
      } while ((dest | 0) < (stop | 0));
      if ($doc$idx45$val$i | 0) {
       HEAP32[$998 + 48 >> 2] = HEAP32[$doc$idx45$val$i >> 2];
       HEAP32[$998 + 52 >> 2] = HEAP32[$doc$idx45$val$i + 4 >> 2];
      }
      HEAP32[$998 + 44 >> 2] = 3;
      HEAP32[$998 + 36 >> 2] = HEAP32[$doc$idx45$val$i + 48 >> 2];
      HEAP32[$998 + 40 >> 2] = HEAP32[$doc$idx45$val$i + 52 >> 2];
      HEAP32[$187 >> 2] = $998;
      $1294 = $998;
     } else {
      $945 = HEAP32[$193 >> 2] | 0;
      $$pre360$i = HEAP32[$198 >> 2] | 0;
      L479 : do if (($943 | 0) == ($945 | 0)) $i$0$lcssa$i = 0; else {
       $947 = $943 - $945 | 0;
       $i$0257$i = 0;
       while (1) {
        $950 = HEAP8[$$pre360$i + ($i$0257$i + $945) >> 0] | 0;
        if ($950 << 24 >> 24 > -1) if (HEAP32[316488 + ($950 << 24 >> 24 << 2) >> 2] & 8 | 0) {
         $i$0$lcssa$i = $i$0257$i;
         break L479;
        }
        $955 = $i$0257$i + 1 | 0;
        if ($955 >>> 0 < $947 >>> 0) $i$0257$i = $955; else {
         $i$0$lcssa$i = $955;
         break;
        }
       }
      } while (0);
      $957 = $942 + -2 | 0;
      $960 = (HEAP8[$$pre360$i + $957 >> 0] | 0) == 63;
      $961 = $960 & 1;
      if ($960) {
       HEAP32[$190 >> 2] = $957;
       $963 = $957;
      } else $963 = $943;
      HEAP32[$193 >> 2] = $i$0$lcssa$i + $945;
      HEAP32[$192 >> 2] = $963;
      HEAP8[$$pre360$i + $963 >> 0] = 0;
      $doc$idx46$val$i = HEAP32[$0 >> 2] | 0;
      $966 = HEAP32[$doc$idx46$val$i + 124 >> 2] | 0;
      $969 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$966 >> 2] >> 2] & 31]($966, 68) | 0;
      dest = $969;
      stop = dest + 68 | 0;
      do {
       HEAP32[dest >> 2] = 0;
       dest = dest + 4 | 0;
      } while ((dest | 0) < (stop | 0));
      if ($doc$idx46$val$i | 0) {
       HEAP32[$969 + 48 >> 2] = HEAP32[$doc$idx46$val$i >> 2];
       HEAP32[$969 + 52 >> 2] = HEAP32[$doc$idx46$val$i + 4 >> 2];
      }
      HEAP32[$969 + 44 >> 2] = 3;
      HEAP32[$969 + 36 >> 2] = HEAP32[$doc$idx46$val$i + 48 >> 2];
      HEAP32[$969 + 40 >> 2] = HEAP32[$doc$idx46$val$i + 52 >> 2];
      HEAP32[$187 >> 2] = $969;
      HEAP32[$969 + 56 >> 2] = $961;
      $990 = _prvTidytmbstrndup(HEAP32[$199 >> 2] | 0, (HEAP32[$198 >> 2] | 0) + (HEAP32[$193 >> 2] | 0) + (0 - $i$0$lcssa$i) | 0, $i$0$lcssa$i) | 0;
      $991 = HEAP32[$187 >> 2] | 0;
      HEAP32[$991 + 32 >> 2] = $990;
      $1294 = $991;
     }
     HEAP32[$197 >> 2] = 0;
     HEAP32[$189 >> 2] = 0;
     $$4$i = $1294;
     break L99;
     break;
    }
   case 343:
    {
     $1018 = (HEAP32[$190 >> 2] | 0) + -1 | 0;
     HEAP32[$190 >> 2] = $1018;
     HEAP32[$192 >> 2] = $1018;
     HEAP8[(HEAP32[$198 >> 2] | 0) + $1018 >> 0] = 0;
     HEAP32[$197 >> 2] = 0;
     HEAP32[$189 >> 2] = 0;
     $doc$idx44$val$i = HEAP32[$0 >> 2] | 0;
     $1022 = HEAP32[$doc$idx44$val$i + 124 >> 2] | 0;
     $1025 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1022 >> 2] >> 2] & 31]($1022, 68) | 0;
     dest = $1025;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($doc$idx44$val$i | 0) {
      HEAP32[$1025 + 48 >> 2] = HEAP32[$doc$idx44$val$i >> 2];
      HEAP32[$1025 + 52 >> 2] = HEAP32[$doc$idx44$val$i + 4 >> 2];
     }
     HEAP32[$1025 + 44 >> 2] = 10;
     HEAP32[$1025 + 36 >> 2] = HEAP32[$doc$idx44$val$i + 48 >> 2];
     HEAP32[$1025 + 40 >> 2] = HEAP32[$doc$idx44$val$i + 52 >> 2];
     HEAP32[$187 >> 2] = $1025;
     $$4$i = $1025;
     break L99;
     break;
    }
   case 349:
    {
     $1045 = (HEAP32[$190 >> 2] | 0) + -1 | 0;
     HEAP32[$190 >> 2] = $1045;
     HEAP32[$192 >> 2] = $1045;
     HEAP8[(HEAP32[$198 >> 2] | 0) + $1045 >> 0] = 0;
     HEAP32[$197 >> 2] = 0;
     HEAP32[$189 >> 2] = 0;
     $doc$idx43$val$i = HEAP32[$0 >> 2] | 0;
     $1049 = HEAP32[$doc$idx43$val$i + 124 >> 2] | 0;
     $1052 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1049 >> 2] >> 2] & 31]($1049, 68) | 0;
     dest = $1052;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($doc$idx43$val$i | 0) {
      HEAP32[$1052 + 48 >> 2] = HEAP32[$doc$idx43$val$i >> 2];
      HEAP32[$1052 + 52 >> 2] = HEAP32[$doc$idx43$val$i + 4 >> 2];
     }
     HEAP32[$1052 + 44 >> 2] = 11;
     HEAP32[$1052 + 36 >> 2] = HEAP32[$doc$idx43$val$i + 48 >> 2];
     HEAP32[$1052 + 40 >> 2] = HEAP32[$doc$idx43$val$i + 52 >> 2];
     HEAP32[$187 >> 2] = $1052;
     $$4$i = $1052;
     break L99;
     break;
    }
   case 355:
    {
     $1072 = (HEAP32[$190 >> 2] | 0) + -1 | 0;
     HEAP32[$190 >> 2] = $1072;
     HEAP32[$192 >> 2] = $1072;
     HEAP8[(HEAP32[$198 >> 2] | 0) + $1072 >> 0] = 0;
     HEAP32[$197 >> 2] = 0;
     HEAP32[$189 >> 2] = 0;
     $doc$idx42$val$i = HEAP32[$0 >> 2] | 0;
     $1076 = HEAP32[$doc$idx42$val$i + 124 >> 2] | 0;
     $1079 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1076 >> 2] >> 2] & 31]($1076, 68) | 0;
     dest = $1079;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($doc$idx42$val$i | 0) {
      HEAP32[$1079 + 48 >> 2] = HEAP32[$doc$idx42$val$i >> 2];
      HEAP32[$1079 + 52 >> 2] = HEAP32[$doc$idx42$val$i + 4 >> 2];
     }
     HEAP32[$1079 + 44 >> 2] = 12;
     HEAP32[$1079 + 36 >> 2] = HEAP32[$doc$idx42$val$i + 48 >> 2];
     HEAP32[$1079 + 40 >> 2] = HEAP32[$doc$idx42$val$i + 52 >> 2];
     HEAP32[$187 >> 2] = $1079;
     $$4$i = $1079;
     break L99;
     break;
    }
   case 362:
    {
     HEAP32[$190 >> 2] = (HEAP32[$190 >> 2] | 0) + -1;
     $1102 = HEAP32[$193 >> 2] | 0;
     HEAP32[$192 >> 2] = $1102;
     HEAP8[(HEAP32[$198 >> 2] | 0) + $1102 >> 0] = 0;
     HEAP32[$197 >> 2] = 0;
     HEAP32[$189 >> 2] = 0;
     $doc$idx41$val$i = HEAP32[$0 >> 2] | 0;
     $1106 = HEAP32[$doc$idx41$val$i + 124 >> 2] | 0;
     $1109 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1106 >> 2] >> 2] & 31]($1106, 68) | 0;
     dest = $1109;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($doc$idx41$val$i | 0) {
      HEAP32[$1109 + 48 >> 2] = HEAP32[$doc$idx41$val$i >> 2];
      HEAP32[$1109 + 52 >> 2] = HEAP32[$doc$idx41$val$i + 4 >> 2];
     }
     HEAP32[$1109 + 44 >> 2] = 13;
     HEAP32[$1109 + 36 >> 2] = HEAP32[$doc$idx41$val$i + 48 >> 2];
     HEAP32[$1109 + 40 >> 2] = HEAP32[$doc$idx41$val$i + 52 >> 2];
     HEAP32[$187 >> 2] = $1109;
     HEAP32[$1109 + 20 >> 2] = $attributes$sroa$0$0267$i$lcssa601;
     $$4$i = $1109;
     break L99;
     break;
    }
   case 373:
    {
     HEAP32[$190 >> 2] = (HEAP32[$190 >> 2] | 0) + -1;
     $1146 = HEAP32[$193 >> 2] | 0;
     HEAP32[$192 >> 2] = $1146;
     HEAP8[(HEAP32[$198 >> 2] | 0) + $1146 >> 0] = 0;
     HEAP32[$197 >> 2] = 0;
     HEAP32[$189 >> 2] = 0;
     $doc$idx40$val$i = HEAP32[$0 >> 2] | 0;
     $1150 = HEAP32[$doc$idx40$val$i + 124 >> 2] | 0;
     $1153 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1150 >> 2] >> 2] & 31]($1150, 68) | 0;
     dest = $1153;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($doc$idx40$val$i | 0) {
      HEAP32[$1153 + 48 >> 2] = HEAP32[$doc$idx40$val$i >> 2];
      HEAP32[$1153 + 52 >> 2] = HEAP32[$doc$idx40$val$i + 4 >> 2];
     }
     HEAP32[$1153 + 44 >> 2] = 13;
     HEAP32[$1153 + 36 >> 2] = HEAP32[$doc$idx40$val$i + 48 >> 2];
     HEAP32[$1153 + 40 >> 2] = HEAP32[$doc$idx40$val$i + 52 >> 2];
     HEAP32[$187 >> 2] = $1153;
     HEAP32[$1153 + 20 >> 2] = $attributes$sroa$0$4$i$lcssa;
     $$4$i = $1153;
     break L99;
     break;
    }
   case 386:
    {
     $1192 = (HEAP32[$190 >> 2] | 0) + -1 | 0;
     HEAP32[$190 >> 2] = $1192;
     HEAP32[$192 >> 2] = $1192;
     HEAP8[(HEAP32[$198 >> 2] | 0) + $1192 >> 0] = 0;
     HEAP32[$197 >> 2] = 0;
     HEAP32[$189 >> 2] = 0;
     $doc$idx39$val$i = HEAP32[$0 >> 2] | 0;
     $1196 = HEAP32[$doc$idx39$val$i + 124 >> 2] | 0;
     $1199 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1196 >> 2] >> 2] & 31]($1196, 68) | 0;
     dest = $1199;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($doc$idx39$val$i | 0) {
      HEAP32[$1199 + 48 >> 2] = HEAP32[$doc$idx39$val$i >> 2];
      HEAP32[$1199 + 52 >> 2] = HEAP32[$doc$idx39$val$i + 4 >> 2];
     }
     HEAP32[$1199 + 44 >> 2] = 9;
     HEAP32[$1199 + 36 >> 2] = HEAP32[$doc$idx39$val$i + 48 >> 2];
     HEAP32[$1199 + 40 >> 2] = HEAP32[$doc$idx39$val$i + 52 >> 2];
     HEAP32[$187 >> 2] = $1199;
     $$4$i = $1199;
     break L99;
     break;
    }
   case 394:
    {
     $1223 = (HEAP32[$190 >> 2] | 0) + -1 | 0;
     HEAP32[$190 >> 2] = $1223;
     HEAP32[$192 >> 2] = $1223;
     HEAP8[(HEAP32[$198 >> 2] | 0) + $1223 >> 0] = 0;
     HEAP32[$197 >> 2] = 0;
     HEAP32[$189 >> 2] = 0;
     $doc$idx38$val$i = HEAP32[$0 >> 2] | 0;
     $1227 = HEAP32[$doc$idx38$val$i + 124 >> 2] | 0;
     $1230 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1227 >> 2] >> 2] & 31]($1227, 68) | 0;
     dest = $1230;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($doc$idx38$val$i | 0) {
      HEAP32[$1230 + 48 >> 2] = HEAP32[$doc$idx38$val$i >> 2];
      HEAP32[$1230 + 52 >> 2] = HEAP32[$doc$idx38$val$i + 4 >> 2];
     }
     HEAP32[$1230 + 44 >> 2] = 8;
     HEAP32[$1230 + 36 >> 2] = HEAP32[$doc$idx38$val$i + 48 >> 2];
     HEAP32[$1230 + 40 >> 2] = HEAP32[$doc$idx38$val$i + 52 >> 2];
     HEAP32[$187 >> 2] = $1230;
     $$4$i = $1230;
     break L99;
     break;
    }
   }
  } while (0);
  L539 : do if ((label | 0) == 397) {
   switch (HEAP32[$$pre$phi$iZ2D >> 2] | 0) {
   case 0:
    break;
   case 4:
    {
     _prvTidyReportError($doc, 0, 0, 229);
     $1270 = HEAP32[$190 >> 2] | 0;
     HEAP32[$192 >> 2] = $1270;
     HEAP8[(HEAP32[$1 + 84 >> 2] | 0) + $1270 >> 0] = 0;
     HEAP32[$$pre$phi$iZ2D >> 2] = 0;
     HEAP32[$189 >> 2] = 0;
     $doc$idx37$val$i = HEAP32[$0 >> 2] | 0;
     $1275 = HEAP32[$doc$idx37$val$i + 124 >> 2] | 0;
     $1278 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1275 >> 2] >> 2] & 31]($1275, 68) | 0;
     dest = $1278;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($doc$idx37$val$i | 0) {
      HEAP32[$1278 + 48 >> 2] = HEAP32[$doc$idx37$val$i >> 2];
      HEAP32[$1278 + 52 >> 2] = HEAP32[$doc$idx37$val$i + 4 >> 2];
     }
     HEAP32[$1278 + 44 >> 2] = 2;
     HEAP32[$1278 + 36 >> 2] = HEAP32[$doc$idx37$val$i + 48 >> 2];
     HEAP32[$1278 + 40 >> 2] = HEAP32[$doc$idx37$val$i + 52 >> 2];
     HEAP32[$187 >> 2] = $1278;
     $$4$i = $1278;
     break L539;
     break;
    }
   default:
    {
     $$4$i = 0;
     break L539;
    }
   }
   $1245 = HEAP32[$190 >> 2] | 0;
   HEAP32[$192 >> 2] = $1245;
   if ($1245 >>> 0 > (HEAP32[$193 >> 2] | 0) >>> 0) {
    _prvTidyUngetChar(-1, HEAP32[$doc$idx32$i >> 2] | 0);
    $1250 = (HEAP32[$190 >> 2] | 0) + -1 | 0;
    if ((HEAP8[(HEAP32[$1 + 84 >> 2] | 0) + $1250 >> 0] | 0) == 32) {
     HEAP32[$190 >> 2] = $1250;
     HEAP32[$192 >> 2] = $1250;
    }
    $1257 = HEAP32[$1 + 124 >> 2] | 0;
    $1260 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1257 >> 2] >> 2] & 31]($1257, 68) | 0;
    dest = $1260;
    stop = dest + 68 | 0;
    do {
     HEAP32[dest >> 2] = 0;
     dest = dest + 4 | 0;
    } while ((dest | 0) < (stop | 0));
    HEAP32[$1260 + 48 >> 2] = HEAP32[$1 >> 2];
    HEAP32[$1260 + 52 >> 2] = HEAP32[$188 >> 2];
    HEAP32[$1260 + 44 >> 2] = 4;
    HEAP32[$1260 + 36 >> 2] = HEAP32[$193 >> 2];
    HEAP32[$1260 + 40 >> 2] = HEAP32[$192 >> 2];
    HEAP32[$187 >> 2] = $1260;
    $$4$i = $1260;
   } else $$4$i = 0;
  } while (0);
  $$0 = $$4$i;
  STACKTOP = sp;
  return $$0 | 0;
 } else if (!$7) {
  HEAP32[$2 >> 2] = 0;
  $$0 = $6;
  STACKTOP = sp;
  return $$0 | 0;
 } while (0);
 HEAP32[$2 >> 2] = 0;
 $9 = HEAP32[$1 + 60 >> 2] | 0;
 if ((HEAP32[$9 + 44 >> 2] | 0) != 4) {
  $$0 = $9;
  STACKTOP = sp;
  return $$0 | 0;
 }
 if (!(HEAP32[$1 + 100 >> 2] | 0)) if (!(HEAP32[$1 + 96 >> 2] | 0)) {
  $$0 = $9;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $19 = _prvTidyInsertedToken($doc) | 0;
 HEAP32[$5 >> 2] = $19;
 $$0 = $19;
 STACKTOP = sp;
 return $$0 | 0;
}

function _main($argc, $argv) {
 $argc = $argc | 0;
 $argv = $argv | 0;
 var $$0$i$i = 0, $$0$i$i$i = 0, $$0$i$i$i$i = 0, $$0$i16$i$i$i = 0, $$06126 = 0, $$06126$be$in = 0, $$09125 = 0, $$110 = 0, $$110$lcssa = 0, $$110$lcssa$lcssa403 = 0, $$17 = 0, $$17$lcssa = 0, $$17$lcssa$lcssa415 = 0, $$2 = 0, $$4 = 0, $$413 = 0, $$413$pn = 0, $$lcssa = 0, $$lcssa$i$i$i = 0, $$lcssa$i$i$i$i = 0, $$lcssa$i9$i$i$i = 0, $$lcssa370 = 0, $$lcssa421 = 0, $$lcssa422 = 0, $$pre$phi$i$iZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $103 = 0, $104 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $118 = 0, $120 = 0, $121 = 0, $125 = 0, $126 = 0, $129 = 0, $13 = 0, $131 = 0, $132 = 0, $135 = 0, $136 = 0, $14 = 0, $142 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $15 = 0, $152 = 0, $153 = 0, $157 = 0, $162 = 0, $166 = 0, $167 = 0, $168 = 0, $171 = 0, $172 = 0, $179 = 0, $18 = 0, $184 = 0, $196 = 0, $2 = 0, $213 = 0, $218 = 0, $221 = 0, $224 = 0, $227 = 0, $230 = 0, $233 = 0, $236 = 0, $239 = 0, $242 = 0, $245 = 0, $248 = 0, $251 = 0, $254 = 0, $257 = 0, $260 = 0, $263 = 0, $266 = 0, $269 = 0, $272 = 0, $275 = 0, $278 = 0, $281 = 0, $3 = 0, $307 = 0, $322 = 0, $331 = 0, $339 = 0, $342 = 0, $345 = 0, $348 = 0, $354 = 0, $356 = 0, $360 = 0, $361 = 0, $366 = 0, $368 = 0, $371 = 0, $374 = 0, $376 = 0, $379 = 0, $380 = 0, $387 = 0, $388 = 0, $389 = 0, $394 = 0, $395 = 0, $396 = 0, $398 = 0, $401 = 0, $407 = 0, $411 = 0, $418 = 0, $420 = 0, $422 = 0, $423 = 0, $426 = 0, $428 = 0, $431 = 0, $433 = 0, $454 = 0, $456 = 0, $463 = 0, $484 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $490 = 0, $491 = 0, $497 = 0, $5 = 0, $501 = 0, $503 = 0, $509 = 0, $511 = 0, $513 = 0, $522 = 0, $523 = 0, $524 = 0, $531 = 0, $556 = 0, $567 = 0, $568 = 0, $570 = 0, $578 = 0, $587 = 0, $6 = 0, $600 = 0, $601 = 0, $603 = 0, $605 = 0, $609 = 0, $610 = 0, $613 = 0, $614 = 0, $623 = 0, $636 = 0, $639 = 0, $641 = 0, $8 = 0, $86 = 0, $87 = 0, $91 = 0, $93 = 0, $96 = 0, $99 = 0, $cat$04$i$i = 0, $charstate$0$i$i = 0, $contentErrors$0121 = 0, $contentErrors$1 = 0, $contentErrors$1$lcssa = 0, $contentErrors$2 = 0, $contentWarnings$0122 = 0, $contentWarnings$1 = 0, $contentWarnings$1$lcssa = 0, $contentWarnings$2 = 0, $d$i$i41 = 0, $endptr$i$i$i = 0, $endptr2$i$i$i = 0, $errfil$0124 = 0, $errfil$0124$be = 0, $errfil$1 = 0, $errfil$2 = 0, $errfil$3 = 0, $htmlfil$0 = 0, $i$0$i$i = 0, $i$02$i$i = 0, $i$2$i$i = 0, $i_name$0$i$i = 0, $i_name$2$i$i = 0, $i_result$0$i$i = 0, $i_result$2$i$i = 0, $j$0$lcssa$i1$i$i = 0, $j$0$lcssa$i419$i$i$i = 0, $j$06$lcssa$i$i = 0, $j$08$i$i$i = 0, $j$08$i$lcssa$i$i$i = 0, $j$08$i2$i$i$i = 0, $j$1$lcssa$i$i$i = 0, $j$1$lcssa$i$i$i$i = 0, $j$1$lcssa$i10$i$i$i = 0, $j$13$i$i$i = 0, $j$13$i7$i$i$i = 0, $l$0$i$i$i = 0, $l$0$i$i$i$i = 0, $l$0$i14$i$i$i = 0, $l_name$0$i$i = 0, $l_name$1$i$i = 0, $l_name$2$i$i = 0, $l_name$4$i$i = 0, $l_result$0$i$i = 0, $l_result$1$i$i = 0, $l_result$2$i$i = 0, $l_result$4$i$i = 0, $len$0$i$i$i = 0, $len$1$i$i$i = 0, $localPos$sroa$15$0$i$i$i = 0, $localPos$sroa$94$0$i$i$i = 0, $n$0$i$i$i = 0, $n$0$i$i$i$i = 0, $n$0$i15$i$i$i = 0, $name$0$i$i = 0, $name$0$i$i$lcssa = 0, $name$0$lcssa$i$i = 0, $name$03$i$i = 0, $name$1$i$i = 0, $name$1$i$i37 = 0, $name$2$i$i = 0, $name$4$i$i = 0, $name$5$i$i = 0, $pc1$0$i$i = 0, $pc1$0$i$i$i = 0, $pc2$0$i$i$i = 0, $pos$02$i$i = 0, $pos$02$i$i22 = 0, $pos$i$i40 = 0, $result$0$i = 0, $result$0$i$i = 0, $result$0$i$i$lcssa = 0, $result$1$i$i = 0, $result$2$i$i = 0, $result$4$i$i = 0, $result$5$i$i = 0, $state$0$i$i = 0, $state$1$i$i = 0, $status$0 = 0, $strlenfirst$i$i = 0, $vararg_buffer = 0, $vararg_buffer101 = 0, $vararg_buffer104 = 0, $vararg_buffer108 = 0, $vararg_buffer111 = 0, $vararg_buffer114 = 0, $vararg_buffer119 = 0, $vararg_buffer12 = 0, $vararg_buffer124 = 0, $vararg_buffer127 = 0, $vararg_buffer130 = 0, $vararg_buffer133 = 0, $vararg_buffer136 = 0, $vararg_buffer139 = 0, $vararg_buffer142 = 0, $vararg_buffer145 = 0, $vararg_buffer147 = 0, $vararg_buffer15 = 0, $vararg_buffer150 = 0, $vararg_buffer153 = 0, $vararg_buffer155 = 0, $vararg_buffer158 = 0, $vararg_buffer161 = 0, $vararg_buffer164 = 0, $vararg_buffer167 = 0, $vararg_buffer170 = 0, $vararg_buffer175 = 0, $vararg_buffer18 = 0, $vararg_buffer180 = 0, $vararg_buffer183 = 0, $vararg_buffer186 = 0, $vararg_buffer189 = 0, $vararg_buffer192 = 0, $vararg_buffer2 = 0, $vararg_buffer22 = 0, $vararg_buffer26 = 0, $vararg_buffer28 = 0, $vararg_buffer33 = 0, $vararg_buffer38 = 0, $vararg_buffer41 = 0, $vararg_buffer44 = 0, $vararg_buffer47 = 0, $vararg_buffer5 = 0, $vararg_buffer51 = 0, $vararg_buffer54 = 0, $vararg_buffer57 = 0, $vararg_buffer60 = 0, $vararg_buffer63 = 0, $vararg_buffer66 = 0, $vararg_buffer70 = 0, $vararg_buffer73 = 0, $vararg_buffer76 = 0, $vararg_buffer79 = 0, $vararg_buffer83 = 0, $vararg_buffer86 = 0, $vararg_buffer89 = 0, $vararg_buffer9 = 0, $vararg_buffer92 = 0, $vararg_buffer95 = 0, $vararg_buffer98 = 0, $writer$0$i$i = 0, $writer$4$i$i = 0, $writer_len$0$i$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 736 | 0;
 $vararg_buffer192 = sp + 520 | 0;
 $vararg_buffer189 = sp + 512 | 0;
 $vararg_buffer186 = sp + 504 | 0;
 $vararg_buffer183 = sp + 496 | 0;
 $vararg_buffer180 = sp + 488 | 0;
 $vararg_buffer175 = sp + 472 | 0;
 $vararg_buffer170 = sp + 456 | 0;
 $vararg_buffer167 = sp + 448 | 0;
 $vararg_buffer164 = sp + 440 | 0;
 $vararg_buffer161 = sp + 432 | 0;
 $vararg_buffer158 = sp + 424 | 0;
 $vararg_buffer155 = sp + 416 | 0;
 $vararg_buffer153 = sp + 408 | 0;
 $vararg_buffer150 = sp + 400 | 0;
 $vararg_buffer147 = sp + 392 | 0;
 $vararg_buffer145 = sp + 384 | 0;
 $vararg_buffer142 = sp + 376 | 0;
 $vararg_buffer139 = sp + 368 | 0;
 $vararg_buffer136 = sp + 360 | 0;
 $vararg_buffer133 = sp + 352 | 0;
 $vararg_buffer130 = sp + 344 | 0;
 $vararg_buffer127 = sp + 336 | 0;
 $vararg_buffer124 = sp + 328 | 0;
 $vararg_buffer119 = sp + 312 | 0;
 $vararg_buffer114 = sp + 296 | 0;
 $vararg_buffer111 = sp + 288 | 0;
 $vararg_buffer108 = sp + 280 | 0;
 $vararg_buffer104 = sp + 272 | 0;
 $vararg_buffer101 = sp + 264 | 0;
 $vararg_buffer98 = sp + 256 | 0;
 $vararg_buffer95 = sp + 248 | 0;
 $vararg_buffer92 = sp + 240 | 0;
 $vararg_buffer89 = sp + 232 | 0;
 $vararg_buffer86 = sp + 224 | 0;
 $vararg_buffer83 = sp + 216 | 0;
 $vararg_buffer79 = sp + 208 | 0;
 $vararg_buffer76 = sp + 200 | 0;
 $vararg_buffer73 = sp + 192 | 0;
 $vararg_buffer70 = sp + 184 | 0;
 $vararg_buffer66 = sp + 176 | 0;
 $vararg_buffer63 = sp + 168 | 0;
 $vararg_buffer60 = sp + 160 | 0;
 $vararg_buffer57 = sp + 152 | 0;
 $vararg_buffer54 = sp + 144 | 0;
 $vararg_buffer51 = sp + 136 | 0;
 $vararg_buffer47 = sp + 128 | 0;
 $vararg_buffer44 = sp + 120 | 0;
 $vararg_buffer41 = sp + 112 | 0;
 $vararg_buffer38 = sp + 104 | 0;
 $vararg_buffer33 = sp + 88 | 0;
 $vararg_buffer28 = sp + 72 | 0;
 $vararg_buffer26 = sp + 64 | 0;
 $vararg_buffer22 = sp + 56 | 0;
 $vararg_buffer18 = sp + 48 | 0;
 $vararg_buffer15 = sp + 40 | 0;
 $vararg_buffer12 = sp + 32 | 0;
 $vararg_buffer9 = sp + 24 | 0;
 $vararg_buffer5 = sp + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $pos$i$i40 = sp + 632 | 0;
 $d$i$i41 = sp + 528 | 0;
 $0 = HEAP32[$argv >> 2] | 0;
 $1 = _tidyCreate() | 0;
 $2 = HEAP32[55027] | 0;
 HEAP32[79116] = $2;
 _atexit(1) | 0;
 $3 = _tidySystemLocale(0) | 0;
 _tidySetLanguage($3) | 0;
 $5 = $2;
 if ($3 | 0) _free($3);
 $6 = _getenv(220808) | 0;
 if ($6 | 0) {
  $8 = _tidyLoadConfig($1, $6) | 0;
  if ($8 | 0) {
   $10 = HEAP32[79116] | 0;
   $11 = _tidyLocalizedString(4110) | 0;
   HEAP32[$vararg_buffer >> 2] = $6;
   HEAP32[$vararg_buffer + 4 >> 2] = $8;
   _fprintf($10, $11, $vararg_buffer) | 0;
   _fputc(10, HEAP32[79116] | 0) | 0;
  }
 }
 L8 : do if (($argc | 0) > 0) {
  $$06126 = $argc;
  $$09125 = $argv;
  $contentErrors$0121 = 0;
  $contentWarnings$0122 = 0;
  $errfil$0124 = 0;
  L10 : while (1) {
   $$110 = $$09125;
   $$17 = $$06126;
   $contentErrors$1 = $contentErrors$0121;
   $contentWarnings$1 = $contentWarnings$0122;
   while (1) {
    $13 = ($$17 | 0) > 1;
    if ($13) {
     $14 = $$110 + 4 | 0;
     $15 = HEAP32[$14 >> 2] | 0;
     if ((HEAP8[$15 >> 0] | 0) == 45) {
      $$110$lcssa = $$110;
      $$17$lcssa = $$17;
      $$lcssa421 = $14;
      $$lcssa422 = $15;
      $contentErrors$1$lcssa = $contentErrors$1;
      $contentWarnings$1$lcssa = $contentWarnings$1;
      break;
     }
     if (_tidyOptGetBool($1, 61) | 0) _tidyOptSetValue($1, 62, $15) | 0;
     $htmlfil$0 = $15;
     $status$0 = _tidyParseFile($1, $15) | 0;
    } else {
     $htmlfil$0 = 221049;
     $status$0 = _tidyParseStdin($1) | 0;
    }
    do if (($status$0 | 0) > -1) if ((_tidyCleanAndRepair($1) | 0) > -1) {
     $623 = _tidyRunDiagnostics($1) | 0;
     if (!(_tidyOptGetBool($1, 19) | 0)) if (!(_tidyOptGetBool($1, 17) | 0)) {
      _tidyOptSetBool($1, 17, 1) | 0;
      _tidyReportDoctype($1) | 0;
      _tidyOptSetBool($1, 17, 0) | 0;
     }
     if (($623 | 0) > 1) {
      if (!(_tidyOptGetBool($1, 69) | 0)) break;
     } else if (($623 | 0) <= -1) break;
     if (_tidyOptGetBool($1, 16) | 0) {
      if ($13 & (_tidyOptGetBool($1, 15) | 0) != 0) {
       _tidySaveFile($1, $htmlfil$0) | 0;
       break;
      }
      $636 = _tidyOptGetValue($1, 14) | 0;
      if (!$636) {
       _tidySaveStdout($1) | 0;
       break;
      } else {
       _tidySaveFile($1, $636) | 0;
       break;
      }
     }
    } while (0);
    $639 = (_tidyErrorCount($1) | 0) + $contentErrors$1 | 0;
    $641 = (_tidyWarningCount($1) | 0) + $contentWarnings$1 | 0;
    $$17 = $$17 + -1 | 0;
    if (!($13 & ($$17 | 0) > 1)) {
     $contentErrors$2 = $639;
     $contentWarnings$2 = $641;
     break L8;
    } else {
     $$110 = $$110 + 4 | 0;
     $contentErrors$1 = $639;
     $contentWarnings$1 = $641;
    }
   }
   $18 = $$lcssa422 + 1 | 0;
   L42 : do if (!(_strcasecmp($18, 310516) | 0)) {
    _tidyOptSetBool($1, 24, 1) | 0;
    $$06126$be$in = $$17$lcssa;
    $$413$pn = $$110$lcssa;
    $errfil$0124$be = $errfil$0124;
   } else {
    if (_strcasecmp($18, 220818) | 0) if (_strcasecmp($18, 220824) | 0) {
     if (!(_strcasecmp($18, 220832) | 0)) {
      _tidyOptSetBool($1, 27, 1) | 0;
      $$06126$be$in = $$17$lcssa;
      $$413$pn = $$110$lcssa;
      $errfil$0124$be = $errfil$0124;
      break;
     }
     if (!(_strcasecmp($18, 224295) | 0)) {
      _tidyOptSetInt($1, 20, 2) | 0;
      if (_tidyOptGetInt($1, 1) | 0) {
       $$06126$be$in = $$17$lcssa;
       $$413$pn = $$110$lcssa;
       $errfil$0124$be = $errfil$0124;
       break;
      }
      _tidyOptResetToDefault($1, 1) | 0;
      $$06126$be$in = $$17$lcssa;
      $$413$pn = $$110$lcssa;
      $errfil$0124$be = $errfil$0124;
      break;
     }
     if (!(_strcasecmp($18, 223998) | 0)) {
      _tidyOptSetBool($1, 22, 1) | 0;
      $$06126$be$in = $$17$lcssa;
      $$413$pn = $$110$lcssa;
      $errfil$0124$be = $errfil$0124;
      break;
     }
     if (!(_strcasecmp($18, 220839) | 0)) {
      _tidyOptSetBool($1, 29, 1) | 0;
      $$06126$be$in = $$17$lcssa;
      $$413$pn = $$110$lcssa;
      $errfil$0124$be = $errfil$0124;
      break;
     }
     if (!(_strcasecmp($18, 224449) | 0)) {
      _tidyOptSetBool($1, 32, 1) | 0;
      $$06126$be$in = $$17$lcssa;
      $$413$pn = $$110$lcssa;
      $errfil$0124$be = $errfil$0124;
      break;
     }
     if (!(_strcasecmp($18, 224455) | 0)) {
      _tidyOptSetBool($1, 33, 1) | 0;
      $$06126$be$in = $$17$lcssa;
      $$413$pn = $$110$lcssa;
      $errfil$0124$be = $errfil$0124;
      break;
     }
     if (!(_strcasecmp($18, 224444) | 0)) {
      _tidyOptSetBool($1, 31, 1) | 0;
      $$06126$be$in = $$17$lcssa;
      $$413$pn = $$110$lcssa;
      $errfil$0124$be = $errfil$0124;
      break;
     }
     do if (_strcasecmp($18, 226242) | 0) if (_strcasecmp($18, 226159) | 0) {
      if (!(_strcasecmp($18, 226165) | 0)) break;
      if (!(_strcasecmp($18, 226172) | 0)) break;
      if (!(_strcasecmp($18, 226179) | 0)) break;
      if (!(_strcasecmp($18, 226234) | 0)) break;
      if (!(_strcasecmp($18, 226203) | 0)) break;
      if (!(_strcasecmp($18, 226211) | 0)) break;
      if (!(_strcasecmp($18, 226219) | 0)) break;
      if (!(_strcasecmp($18, 226225) | 0)) break;
      if (!(_strcasecmp($18, 226137) | 0)) break;
      if (!(_strcasecmp($18, 226184) | 0)) break;
      if (!(_strcasecmp($18, 226188) | 0)) break;
      if (!(_strcasecmp($18, 226196) | 0)) break;
      if (!(_strcasecmp($18, 220845) | 0)) {
       _tidyOptSetBool($1, 42, 1) | 0;
       $$06126$be$in = $$17$lcssa;
       $$413$pn = $$110$lcssa;
       $errfil$0124$be = $errfil$0124;
       break L42;
      }
      do if (_strcasecmp($18, 220853) | 0) {
       if (!(_strcasecmp($18, 220860) | 0)) break;
       if (!(_strcasecmp($18, 220867) | 0)) break;
       if (!(_strcasecmp($18, 226956) | 0)) {
        _tidyOptSetBool($1, 16, 0) | 0;
        $$06126$be$in = $$17$lcssa;
        $$413$pn = $$110$lcssa;
        $errfil$0124$be = $errfil$0124;
        break L42;
       }
       if (!(_strcasecmp($18, 224289) | 0)) {
        _tidyOptSetBool($1, 19, 1) | 0;
        $$06126$be$in = $$17$lcssa;
        $$413$pn = $$110$lcssa;
        $errfil$0124$be = $errfil$0124;
        break L42;
       }
       L98 : do if (!(_strcasecmp($18, 305184) | 0)) label = 58; else {
        if (!(_strcasecmp($18, 313532) | 0)) {
         label = 58;
         break;
        }
        if (!(_strcasecmp($18, 220874) | 0)) {
         label = 73;
         break L10;
        }
        if (!(_strcasecmp($18, 220879) | 0)) {
         label = 73;
         break L10;
        }
        if (!(_strcasecmp($18, 220885) | 0)) {
         label = 73;
         break L10;
        }
        $118 = HEAP8[$18 >> 0] | 0;
        if ($118 << 24 >> 24 == 63) {
         label = 73;
         break L10;
        }
        if (!(_strcasecmp($18, 220887) | 0)) {
         label = 175;
         break L10;
        }
        if (!(_strcasecmp($18, 220896) | 0)) {
         label = 182;
         break L10;
        }
        if (!(_strcasecmp($18, 220914) | 0)) {
         label = 189;
         break L10;
        }
        if (!(_strcasecmp($18, 220934) | 0)) {
         label = 196;
         break L10;
        }
        if (!(_strcasecmp($18, 220946) | 0)) {
         label = 202;
         break L10;
        }
        if (!(_strcasecmp($18, 220958) | 0)) {
         $$110$lcssa$lcssa403 = $$110$lcssa;
         $$17$lcssa$lcssa415 = $$17$lcssa;
         label = 204;
         break L10;
        }
        if (!(_strcasecmp($18, 220970) | 0)) {
         label = 271;
         break L10;
        }
        if (!(_strcasecmp($18, 220981) | 0)) {
         label = 295;
         break L10;
        }
        if (!(_strcasecmp($18, 220993) | 0)) {
         if (($$17$lcssa | 0) <= 2) {
          $$06126$be$in = 2;
          $$413$pn = $$110$lcssa;
          $errfil$0124$be = $errfil$0124;
          break L42;
         }
         _tidyLoadConfig($1, HEAP32[$$110$lcssa + 8 >> 2] | 0) | 0;
         $531 = _tidyOptGetValue($1, 13) | 0;
         do if (!$531) $errfil$1 = $errfil$0124; else {
          if ($errfil$0124 | 0) if (!(_strcmp($errfil$0124, $531) | 0)) {
           $errfil$1 = $errfil$0124;
           break;
          }
          HEAP32[79116] = _tidySetErrorFile($1, $531) | 0;
          $errfil$1 = $531;
         } while (0);
         $$4 = $$17$lcssa + -1 | 0;
         $$413 = $$lcssa421;
         $errfil$3 = $errfil$1;
         break;
        }
        do if (_strcasecmp($18, 308864) | 0) {
         if (!(_strcasecmp($18, 221e3) | 0)) break;
         if (!(_strcasecmp($18, 221013) | 0)) break;
         do if (_strcasecmp($18, 305938) | 0) {
          if (!(_strcasecmp($18, 221015) | 0)) break;
          if (!(_strcasecmp($18, 221021) | 0)) break;
          do if (_strcasecmp($18, 306074) | 0) {
           if (!(_strcasecmp($18, 221023) | 0)) break;
           if (!(_strcasecmp($18, 221029) | 0)) break;
           if (!(_strcasecmp($18, 310376) | 0)) {
            label = 321;
            break L10;
           }
           if (!(_strcasecmp($18, 221031) | 0)) {
            label = 321;
            break L10;
           }
           if (!(_strcasecmp($18, 221040) | 0)) {
            label = 321;
            break L10;
           }
           if (!(_strncmp($$lcssa422, 310767, 2) | 0)) {
            if (!(_tidyOptParseValue($1, $$lcssa422 + 2 | 0, HEAP32[$$110$lcssa + 8 >> 2] | 0) | 0)) {
             $$06126$be$in = $$17$lcssa;
             $$413$pn = $$110$lcssa;
             $errfil$0124$be = $errfil$0124;
             break L42;
            }
            $587 = _tidyOptGetValue($1, 13) | 0;
            do if (!$587) $errfil$2 = $errfil$0124; else {
             if ($errfil$0124 | 0) if (!(_strcmp($errfil$0124, $587) | 0)) {
              $errfil$2 = $errfil$0124;
              break;
             }
             HEAP32[79116] = _tidySetErrorFile($1, $587) | 0;
             $errfil$2 = $587;
            } while (0);
            $$4 = $$17$lcssa + -1 | 0;
            $$413 = $$lcssa421;
            $errfil$3 = $errfil$2;
            break L98;
           }
           if (!(_strcasecmp($18, 221042) | 0)) {
            if (($$17$lcssa | 0) <= 2) {
             $$06126$be$in = 2;
             $$413$pn = $$110$lcssa;
             $errfil$0124$be = $errfil$0124;
             break L42;
            }
            HEAP32[$pos$i$i40 >> 2] = 0;
            $600 = HEAP32[$$110$lcssa + 8 >> 2] | 0;
            HEAP32[$vararg_buffer189 >> 2] = $pos$i$i40;
            $601 = _sscanf($600, 312312, $vararg_buffer189) | 0;
            _tidyOptSetInt($1, 84, HEAP32[$pos$i$i40 >> 2] | 0) | 0;
            $603 = ($601 | 0) > 0;
            $$4 = ($603 << 31 >> 31) + $$17$lcssa | 0;
            $$413 = $603 ? $$lcssa421 : $$110$lcssa;
            $errfil$3 = $errfil$0124;
            break L98;
           }
           if (!($118 << 24 >> 24)) {
            $$06126$be$in = $$17$lcssa;
            $$413$pn = $$110$lcssa;
            $errfil$0124$be = $errfil$0124;
            break L42;
           }
           $605 = $118 << 24 >> 24;
           $609 = $18;
           while (1) {
            L155 : do switch ($605 | 0) {
            case 105:
             {
              _tidyOptSetInt($1, 20, 2) | 0;
              if (_tidyOptGetInt($1, 1) | 0) break L155;
              _tidyOptResetToDefault($1, 1) | 0;
              break;
             }
            case 117:
             {
              _tidyOptSetBool($1, 29, 1) | 0;
              break;
             }
            case 99:
             {
              _tidyOptSetBool($1, 32, 1) | 0;
              break;
             }
            case 103:
             {
              _tidyOptSetBool($1, 33, 1) | 0;
              break;
             }
            case 98:
             {
              _tidyOptSetBool($1, 31, 1) | 0;
              break;
             }
            case 110:
             {
              _tidyOptSetBool($1, 42, 1) | 0;
              break;
             }
            case 109:
             {
              _tidyOptSetBool($1, 15, 1) | 0;
              break;
             }
            case 101:
             {
              _tidyOptSetBool($1, 16, 0) | 0;
              break;
             }
            case 113:
             {
              _tidyOptSetBool($1, 19, 1) | 0;
              break;
             }
            default:
             {
              $613 = HEAP32[79116] | 0;
              $614 = _tidyLocalizedString(4170) | 0;
              HEAP32[$vararg_buffer192 >> 2] = $605;
              _fprintf($613, $614, $vararg_buffer192) | 0;
              _fputc(10, HEAP32[79116] | 0) | 0;
             }
            } while (0);
            $609 = $609 + 1 | 0;
            $610 = HEAP8[$609 >> 0] | 0;
            if (!($610 << 24 >> 24)) {
             $$4 = $$17$lcssa;
             $$413 = $$110$lcssa;
             $errfil$3 = $errfil$0124;
             break L98;
            } else $605 = $610 << 24 >> 24;
           }
          } while (0);
          if (($$17$lcssa | 0) <= 2) {
           $$06126$be$in = 2;
           $$413$pn = $$110$lcssa;
           $errfil$0124$be = $errfil$0124;
           break L42;
          }
          HEAP32[$pos$i$i40 >> 2] = 0;
          $567 = HEAP32[$$110$lcssa + 8 >> 2] | 0;
          HEAP32[$vararg_buffer183 >> 2] = $pos$i$i40;
          $568 = _sscanf($567, 312312, $vararg_buffer183) | 0;
          _tidyOptSetInt($1, 2, HEAP32[$pos$i$i40 >> 2] | 0) | 0;
          $570 = ($568 | 0) > 0;
          $$4 = ($570 << 31 >> 31) + $$17$lcssa | 0;
          $$413 = $570 ? $$lcssa421 : $$110$lcssa;
          $errfil$3 = $errfil$0124;
          break L98;
         } while (0);
         if (($$17$lcssa | 0) <= 2) {
          $$06126$be$in = 2;
          $$413$pn = $$110$lcssa;
          $errfil$0124$be = $errfil$0124;
          break L42;
         }
         $556 = HEAP32[$$110$lcssa + 8 >> 2] | 0;
         HEAP32[79116] = _tidySetErrorFile($1, $556) | 0;
         $$06126$be$in = $$17$lcssa + -1 | 0;
         $$413$pn = $$lcssa421;
         $errfil$0124$be = $556;
         break L42;
        } while (0);
        if (($$17$lcssa | 0) <= 2) {
         $$06126$be$in = 2;
         $$413$pn = $$110$lcssa;
         $errfil$0124$be = $errfil$0124;
         break L42;
        }
        _tidyOptSetValue($1, 14, HEAP32[$$110$lcssa + 8 >> 2] | 0) | 0;
        $$06126$be$in = $$17$lcssa + -1 | 0;
        $$413$pn = $$lcssa421;
        $errfil$0124$be = $errfil$0124;
        break L42;
       } while (0);
       if ((label | 0) == 58) {
        label = 0;
        if (($$17$lcssa | 0) <= 2) {
         _puts(_tidyLocalizedString(4163) | 0) | 0;
         $$06126$be$in = 2;
         $$413$pn = $$110$lcssa;
         $errfil$0124$be = $errfil$0124;
         break L42;
        }
        $86 = $$110$lcssa + 8 | 0;
        $87 = HEAP32[$86 >> 2] | 0;
        if (!(_strcasecmp($87, 220874) | 0)) {
         label = 60;
         break L10;
        }
        if (!(_tidySetLanguage($87) | 0)) {
         $107 = _tidyLocalizedString(4164) | 0;
         $108 = HEAP32[$86 >> 2] | 0;
         $109 = _tidyGetLanguage() | 0;
         HEAP32[$vararg_buffer18 >> 2] = $108;
         HEAP32[$vararg_buffer18 + 4 >> 2] = $109;
         _printf($107, $vararg_buffer18) | 0;
         _putchar(10) | 0;
        }
        $$4 = $$17$lcssa + -1 | 0;
        $$413 = $$lcssa421;
        $errfil$3 = $errfil$0124;
       }
       if (($$4 | 0) > 1) {
        $$06126$be$in = $$4;
        $$413$pn = $$413;
        $errfil$0124$be = $errfil$3;
        break L42;
       } else {
        $contentErrors$2 = $contentErrors$1$lcssa;
        $contentWarnings$2 = $contentWarnings$1$lcssa;
        break L8;
       }
      } while (0);
      _tidyOptSetBool($1, 15, 1) | 0;
      $$06126$be$in = $$17$lcssa;
      $$413$pn = $$110$lcssa;
      $errfil$0124$be = $errfil$0124;
      break L42;
     } while (0);
     _tidySetCharEncoding($1, $18) | 0;
     $$06126$be$in = $$17$lcssa;
     $$413$pn = $$110$lcssa;
     $errfil$0124$be = $errfil$0124;
     break;
    }
    _tidyOptSetBool($1, 26, 1) | 0;
    $$06126$be$in = $$17$lcssa;
    $$413$pn = $$110$lcssa;
    $errfil$0124$be = $errfil$0124;
   } while (0);
   $$06126 = $$06126$be$in + -1 | 0;
   $$09125 = $$413$pn + 4 | 0;
   $contentErrors$0121 = $contentErrors$1$lcssa;
   $contentWarnings$0122 = $contentWarnings$1$lcssa;
   $errfil$0124 = $errfil$0124$be;
  }
  switch (label | 0) {
  case 60:
   {
    HEAP32[$vararg_buffer2 >> 2] = _tidyLocalizedString(4182) | 0;
    _printf(223602, $vararg_buffer2) | 0;
    $91 = _getWindowsLanguageList() | 0;
    HEAP32[$vararg_buffer2 >> 2] = $91;
    if ($91 | 0) do {
     $93 = _getNextWindowsLanguage($vararg_buffer2) | 0;
     $96 = HEAP32[$93 + 4 >> 2] | 0;
     HEAP32[$vararg_buffer5 >> 2] = HEAP32[$93 >> 2];
     HEAP32[$vararg_buffer5 + 4 >> 2] = $96;
     _printf(221055, $vararg_buffer5) | 0;
    } while ((HEAP32[$vararg_buffer2 >> 2] | 0) != 0);
    HEAP32[$vararg_buffer9 >> 2] = _tidyLocalizedString(4183) | 0;
    _printf(223602, $vararg_buffer9) | 0;
    $99 = _getInstalledLanguageList() | 0;
    HEAP32[$vararg_buffer9 >> 2] = $99;
    if (!$99) {
     $103 = _tidyLocalizedString(4184) | 0;
     $104 = _tidyGetLanguage() | 0;
     HEAP32[$vararg_buffer15 >> 2] = $104;
     _printf($103, $vararg_buffer15) | 0;
     _exit(0);
    }
    do {
     HEAP32[$vararg_buffer12 >> 2] = _getNextInstalledLanguage($vararg_buffer9) | 0;
     _printf(221070, $vararg_buffer12) | 0;
    } while ((HEAP32[$vararg_buffer9 >> 2] | 0) != 0);
    $103 = _tidyLocalizedString(4184) | 0;
    $104 = _tidyGetLanguage() | 0;
    HEAP32[$vararg_buffer15 >> 2] = $104;
    _printf($103, $vararg_buffer15) | 0;
    _exit(0);
    break;
   }
  case 73:
   {
    $120 = _tidyLocalizedString(4174) | 0;
    $121 = _strlen($0) | 0;
    L370 : do if (!$121) $name$0$lcssa$i$i = $0; else {
     $i$02$i$i = 0;
     $name$03$i$i = $0;
     while (1) {
      switch (HEAP8[$0 + $i$02$i$i >> 0] | 0) {
      case 47:
      case 92:
       {
        $125 = $i$02$i$i + 1 | 0;
        $126 = $0 + $125 | 0;
        $$pre$phi$i$iZ2D = $125;
        $name$1$i$i = (HEAP8[$126 >> 0] | 0) == 0 ? $name$03$i$i : $126;
        break;
       }
      default:
       {
        $$pre$phi$i$iZ2D = $i$02$i$i + 1 | 0;
        $name$1$i$i = $name$03$i$i;
       }
      }
      if (($$pre$phi$i$iZ2D | 0) == ($121 | 0)) {
       $name$0$lcssa$i$i = $name$1$i$i;
       break L370;
      } else {
       $i$02$i$i = $$pre$phi$i$iZ2D;
       $name$03$i$i = $name$1$i$i;
      }
     }
    } while (0);
    $129 = _tidyLibraryVersion() | 0;
    HEAP32[$vararg_buffer22 >> 2] = $name$0$lcssa$i$i;
    HEAP32[$vararg_buffer22 + 4 >> 2] = $129;
    _printf($120, $vararg_buffer22) | 0;
    $131 = _stringWithFormat(_tidyLocalizedString(4176) | 0, $vararg_buffer26) | 0;
    _puts($131) | 0;
    $132 = _strlen($131) | 0;
    HEAP32[$vararg_buffer28 >> 2] = $132;
    HEAP32[$vararg_buffer28 + 4 >> 2] = $132;
    HEAP32[$vararg_buffer28 + 8 >> 2] = 221083;
    _printf(221076, $vararg_buffer28) | 0;
    _free($131);
    _putchar(10) | 0;
    $cat$04$i$i = 0;
    L378 : while (1) {
     $135 = _tidyLocalizedString(HEAP32[1240 + ($cat$04$i$i << 3) + 4 >> 2] | 0) | 0;
     $136 = _strlen($135) | 0;
     _puts($135) | 0;
     HEAP32[$vararg_buffer33 >> 2] = $136;
     HEAP32[$vararg_buffer33 + 4 >> 2] = $136;
     HEAP32[$vararg_buffer33 + 8 >> 2] = 221149;
     _printf(221076, $vararg_buffer33) | 0;
     $146 = 221235;
     $pos$02$i$i = 8;
     while (1) {
      if ((HEAP32[$pos$02$i$i >> 2] | 0) == ($cat$04$i$i | 0)) {
       $142 = HEAP32[$pos$02$i$i + 20 >> 2] | 0;
       $144 = HEAP32[$pos$02$i$i + 24 >> 2] | 0;
       $145 = _tidyLocalizedString(HEAP32[$pos$02$i$i + 12 >> 2] | 0) | 0;
       HEAP32[$vararg_buffer38 >> 2] = $145;
       $147 = _stringWithFormat($146, $vararg_buffer38) | 0;
       if (!$142) $localPos$sroa$94$0$i$i$i = 0; else {
        HEAP32[$vararg_buffer41 >> 2] = $145;
        $localPos$sroa$94$0$i$i$i = _stringWithFormat($142, $vararg_buffer41) | 0;
       }
       if (!$144) $localPos$sroa$15$0$i$i$i = 0; else {
        HEAP32[$vararg_buffer44 >> 2] = $145;
        $localPos$sroa$15$0$i$i$i = _stringWithFormat($144, $vararg_buffer44) | 0;
       }
       $152 = _strlen($147) | 0;
       $153 = ($localPos$sroa$94$0$i$i$i | 0) == 0;
       if ($153) $len$0$i$i$i = $152; else $len$0$i$i$i = $152 + 2 + (_strlen($localPos$sroa$94$0$i$i$i) | 0) | 0;
       $157 = ($localPos$sroa$15$0$i$i$i | 0) == 0;
       if ($157) $len$1$i$i$i = $len$0$i$i$i; else $len$1$i$i$i = $len$0$i$i$i + 2 + (_strlen($localPos$sroa$15$0$i$i$i) | 0) | 0;
       $162 = _malloc($len$1$i$i$i + 1 | 0) | 0;
       if (!$162) {
        label = 90;
        break L378;
       }
       _strcpy($162, $147) | 0;
       _free($147);
       if (!$153) {
        $endptr2$i$i$i = $162 + (_strlen($162) | 0) | 0;
        HEAP8[$endptr2$i$i$i >> 0] = HEAP8[225098] | 0;
        HEAP8[$endptr2$i$i$i + 1 >> 0] = HEAP8[225099] | 0;
        HEAP8[$endptr2$i$i$i + 2 >> 0] = HEAP8[225100] | 0;
        _strcat($162, $localPos$sroa$94$0$i$i$i) | 0;
        _free($localPos$sroa$94$0$i$i$i);
       }
       if (!$157) {
        $endptr$i$i$i = $162 + (_strlen($162) | 0) | 0;
        HEAP8[$endptr$i$i$i >> 0] = HEAP8[225098] | 0;
        HEAP8[$endptr$i$i$i + 1 >> 0] = HEAP8[225099] | 0;
        HEAP8[$endptr$i$i$i + 2 >> 0] = HEAP8[225100] | 0;
        _strcat($162, $localPos$sroa$15$0$i$i$i) | 0;
        _free($localPos$sroa$15$0$i$i$i);
       }
       $166 = _tidyLocalizedString(HEAP32[$pos$02$i$i + 8 >> 2] | 0) | 0;
       $167 = _malloc(26) | 0;
       $168 = _malloc(53) | 0;
       if (!$167) {
        label = 96;
        break L378;
       }
       if (!$168) {
        label = 99;
        break L378;
       }
       $171 = $168 + 52 | 0;
       $172 = $167 + 25 | 0;
       $pc1$0$i$i$i = $162;
       $pc2$0$i$i$i = $166;
       while (1) {
        do if (!$pc1$0$i$i$i) {
         HEAP8[$167 >> 0] = 0;
         $$0$i$i$i$i = 0;
        } else {
         if ((_strlen($pc1$0$i$i$i) | 0) >>> 0 <= 25) {
          _strcpy($167, $pc1$0$i$i$i) | 0;
          HEAP8[$172 >> 0] = 0;
          $$0$i$i$i$i = 0;
          break;
         }
         do if ((HEAP8[$pc1$0$i$i$i >> 0] | 0) == 10) {
          $j$08$i$lcssa$i$i$i = 0;
          label = 109;
         } else {
          $179 = HEAP8[$pc1$0$i$i$i + 1 >> 0] | 0;
          if ($179 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 1;
           label = 109;
           break;
          }
          $218 = HEAP8[$pc1$0$i$i$i + 2 >> 0] | 0;
          if ($218 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 2;
           label = 109;
           break;
          }
          $221 = HEAP8[$pc1$0$i$i$i + 3 >> 0] | 0;
          if ($221 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 3;
           label = 109;
           break;
          }
          $224 = HEAP8[$pc1$0$i$i$i + 4 >> 0] | 0;
          if ($224 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 4;
           label = 109;
           break;
          }
          $227 = HEAP8[$pc1$0$i$i$i + 5 >> 0] | 0;
          if ($227 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 5;
           label = 109;
           break;
          }
          $230 = HEAP8[$pc1$0$i$i$i + 6 >> 0] | 0;
          if ($230 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 6;
           label = 109;
           break;
          }
          $233 = HEAP8[$pc1$0$i$i$i + 7 >> 0] | 0;
          if ($233 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 7;
           label = 109;
           break;
          }
          $236 = HEAP8[$pc1$0$i$i$i + 8 >> 0] | 0;
          if ($236 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 8;
           label = 109;
           break;
          }
          $239 = HEAP8[$pc1$0$i$i$i + 9 >> 0] | 0;
          if ($239 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 9;
           label = 109;
           break;
          }
          $242 = HEAP8[$pc1$0$i$i$i + 10 >> 0] | 0;
          if ($242 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 10;
           label = 109;
           break;
          }
          $245 = HEAP8[$pc1$0$i$i$i + 11 >> 0] | 0;
          if ($245 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 11;
           label = 109;
           break;
          }
          $248 = HEAP8[$pc1$0$i$i$i + 12 >> 0] | 0;
          if ($248 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 12;
           label = 109;
           break;
          }
          $251 = HEAP8[$pc1$0$i$i$i + 13 >> 0] | 0;
          if ($251 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 13;
           label = 109;
           break;
          }
          $254 = HEAP8[$pc1$0$i$i$i + 14 >> 0] | 0;
          if ($254 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 14;
           label = 109;
           break;
          }
          $257 = HEAP8[$pc1$0$i$i$i + 15 >> 0] | 0;
          if ($257 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 15;
           label = 109;
           break;
          }
          $260 = HEAP8[$pc1$0$i$i$i + 16 >> 0] | 0;
          if ($260 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 16;
           label = 109;
           break;
          }
          $263 = HEAP8[$pc1$0$i$i$i + 17 >> 0] | 0;
          if ($263 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 17;
           label = 109;
           break;
          }
          $266 = HEAP8[$pc1$0$i$i$i + 18 >> 0] | 0;
          if ($266 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 18;
           label = 109;
           break;
          }
          $269 = HEAP8[$pc1$0$i$i$i + 19 >> 0] | 0;
          if ($269 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 19;
           label = 109;
           break;
          }
          $272 = HEAP8[$pc1$0$i$i$i + 20 >> 0] | 0;
          if ($272 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 20;
           label = 109;
           break;
          }
          $275 = HEAP8[$pc1$0$i$i$i + 21 >> 0] | 0;
          if ($275 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 21;
           label = 109;
           break;
          }
          $278 = HEAP8[$pc1$0$i$i$i + 22 >> 0] | 0;
          if ($278 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 22;
           label = 109;
           break;
          }
          $281 = HEAP8[$pc1$0$i$i$i + 23 >> 0] | 0;
          if ($281 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 23;
           label = 109;
           break;
          }
          $184 = HEAP8[$pc1$0$i$i$i + 24 >> 0] | 0;
          if ($184 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i$i$i = 24;
           label = 109;
           break;
          }
          do if ((HEAP8[$pc1$0$i$i$i + 25 >> 0] | 0) == 32) {
           $$lcssa$i$i$i$i = 0;
           $j$1$lcssa$i$i$i$i = 25;
          } else {
           if ($184 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 24;
            break;
           }
           if ($281 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 23;
            break;
           }
           if ($278 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 22;
            break;
           }
           if ($275 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 21;
            break;
           }
           if ($272 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 20;
            break;
           }
           if ($269 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 19;
            break;
           }
           if ($266 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 18;
            break;
           }
           if ($263 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 17;
            break;
           }
           if ($260 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 16;
            break;
           }
           if ($257 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 15;
            break;
           }
           if ($254 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 14;
            break;
           }
           if ($251 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 13;
            break;
           }
           if ($248 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 12;
            break;
           }
           if ($245 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 11;
            break;
           }
           if ($242 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 10;
            break;
           }
           if ($239 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 9;
            break;
           }
           if ($236 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 8;
            break;
           }
           if ($233 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 7;
            break;
           }
           if ($230 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 6;
            break;
           }
           if ($227 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 5;
            break;
           }
           if ($224 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 4;
            break;
           }
           if ($221 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 3;
            break;
           }
           if ($218 << 24 >> 24 == 32) {
            $$lcssa$i$i$i$i = 0;
            $j$1$lcssa$i$i$i$i = 2;
            break;
           }
           $307 = $179 << 24 >> 24 == 32;
           $$lcssa$i$i$i$i = $307 ^ 1;
           $j$1$lcssa$i$i$i$i = $307 & 1;
          } while (0);
          $l$0$i$i$i$i = $$lcssa$i$i$i$i ? 25 : $j$1$lcssa$i$i$i$i;
          $n$0$i$i$i$i = $$lcssa$i$i$i$i ? 25 : $j$1$lcssa$i$i$i$i + 1 | 0;
         } while (0);
         if ((label | 0) == 109) {
          label = 0;
          $l$0$i$i$i$i = $j$08$i$lcssa$i$i$i;
          $n$0$i$i$i$i = $j$08$i$lcssa$i$i$i + 1 | 0;
         }
         _strncpy($167, $pc1$0$i$i$i, $l$0$i$i$i$i) | 0;
         HEAP8[$167 + $l$0$i$i$i$i >> 0] = 0;
         $$0$i$i$i$i = $pc1$0$i$i$i + $n$0$i$i$i$i | 0;
        } while (0);
        do if (!$pc2$0$i$i$i) {
         HEAP8[$168 >> 0] = 0;
         $$0$i16$i$i$i = 0;
        } else {
         if ((_strlen($pc2$0$i$i$i) | 0) >>> 0 > 52) $j$08$i2$i$i$i = 0; else {
          _strcpy($168, $pc2$0$i$i$i) | 0;
          HEAP8[$171 >> 0] = 0;
          $$0$i16$i$i$i = 0;
          break;
         }
         while (1) {
          if ((HEAP8[$pc2$0$i$i$i + $j$08$i2$i$i$i >> 0] | 0) == 10) {
           $j$0$lcssa$i419$i$i$i = $j$08$i2$i$i$i;
           label = 121;
           break;
          }
          $196 = $j$08$i2$i$i$i + 1 | 0;
          if ($196 >>> 0 < 52) $j$08$i2$i$i$i = $196; else {
           $$lcssa = $196;
           label = 117;
           break;
          }
         }
         do if ((label | 0) == 117) {
          label = 0;
          if (($$lcssa | 0) == 52) $j$13$i7$i$i$i = 52; else {
           $j$0$lcssa$i419$i$i$i = $$lcssa;
           label = 121;
           break;
          }
          while (1) {
           if ((HEAP8[$pc2$0$i$i$i + $j$13$i7$i$i$i >> 0] | 0) == 32) {
            $$lcssa$i9$i$i$i = 0;
            $j$1$lcssa$i10$i$i$i = $j$13$i7$i$i$i;
            break;
           }
           $j$13$i7$i$i$i = $j$13$i7$i$i$i + -1 | 0;
           if (!$j$13$i7$i$i$i) {
            $$lcssa$i9$i$i$i = 1;
            $j$1$lcssa$i10$i$i$i = 0;
            break;
           }
          }
          $l$0$i14$i$i$i = $$lcssa$i9$i$i$i ? 52 : $j$1$lcssa$i10$i$i$i;
          $n$0$i15$i$i$i = $$lcssa$i9$i$i$i ? 52 : $j$1$lcssa$i10$i$i$i + 1 | 0;
         } while (0);
         if ((label | 0) == 121) {
          label = 0;
          $l$0$i14$i$i$i = $j$0$lcssa$i419$i$i$i;
          $n$0$i15$i$i$i = $j$0$lcssa$i419$i$i$i + 1 | 0;
         }
         _strncpy($168, $pc2$0$i$i$i, $l$0$i14$i$i$i) | 0;
         HEAP8[$168 + $l$0$i14$i$i$i >> 0] = 0;
         $$0$i16$i$i$i = $pc2$0$i$i$i + $n$0$i15$i$i$i | 0;
        } while (0);
        $213 = HEAP8[$168 >> 0] | 0 ? $168 : 317568;
        HEAP32[$vararg_buffer47 >> 2] = HEAP8[$167 >> 0] | 0 ? $167 : 317568;
        HEAP32[$vararg_buffer47 + 4 >> 2] = $213;
        _printf(221215, $vararg_buffer47) | 0;
        if (($$0$i$i$i$i | 0) != 0 | ($$0$i16$i$i$i | 0) != 0) {
         $pc1$0$i$i$i = $$0$i$i$i$i;
         $pc2$0$i$i$i = $$0$i16$i$i$i;
        } else break;
       }
       _free($167);
       _free($168);
       _free($162);
      }
      $146 = HEAP32[$pos$02$i$i + 32 >> 2] | 0;
      if (!$146) break; else $pos$02$i$i = $pos$02$i$i + 28 | 0;
     }
     _putchar(10) | 0;
     $cat$04$i$i = $cat$04$i$i + 1 | 0;
     if (($cat$04$i$i | 0) == 5) {
      label = 173;
      break;
     }
    }
    if ((label | 0) == 90) _outOfMemory(); else if ((label | 0) == 96) _outOfMemory(); else if ((label | 0) == 99) _outOfMemory(); else if ((label | 0) == 173) {
     HEAP32[$vararg_buffer51 >> 2] = _tidyLocalizedString(4177) | 0;
     _printf(223602, $vararg_buffer51) | 0;
     _tidyRelease($1);
     $$2 = 0;
     STACKTOP = sp;
     return $$2 | 0;
    }
    break;
   }
  case 175:
   {
    HEAP32[$vararg_buffer54 >> 2] = _tidyLibraryVersion() | 0;
    _printf(222012, $vararg_buffer54) | 0;
    $322 = 12;
    $pos$02$i$i22 = 8;
    while (1) {
     HEAP32[$vararg_buffer57 >> 2] = HEAP32[1240 + (HEAP32[$pos$02$i$i22 >> 2] << 3) >> 2];
     _printf(222058, $vararg_buffer57) | 0;
     _print_xml_help_option_element(311658, HEAP32[$322 >> 2] | 0);
     _print_xml_help_option_element(311658, HEAP32[$pos$02$i$i22 + 20 >> 2] | 0);
     _print_xml_help_option_element(311658, HEAP32[$pos$02$i$i22 + 24 >> 2] | 0);
     _print_xml_help_option_element(222080, _tidyLocalizedString(HEAP32[$pos$02$i$i22 + 8 >> 2] | 0) | 0);
     $331 = HEAP32[$pos$02$i$i22 + 16 >> 2] | 0;
     if (!$331) _puts(223201) | 0; else _print_xml_help_option_element(222092, $331);
     _puts(223306) | 0;
     $322 = $pos$02$i$i22 + 32 | 0;
     if (!(HEAP32[$322 >> 2] | 0)) break; else $pos$02$i$i22 = $pos$02$i$i22 + 28 | 0;
    }
    _puts(223038) | 0;
    _tidyRelease($1);
    $$2 = 0;
    STACKTOP = sp;
    return $$2 | 0;
   }
  case 182:
   {
    $339 = _getErrorCodeList() | 0;
    HEAP32[$pos$i$i40 >> 2] = $339;
    _puts(223049) | 0;
    HEAP32[$vararg_buffer60 >> 2] = _tidyLibraryVersion() | 0;
    _printf(222116, $vararg_buffer60) | 0;
    if ($339 | 0) do {
     $342 = _getNextErrorCode($pos$i$i40) | 0;
     $345 = _tidyLocalizedString(HEAP32[$342 + 4 >> 2] | 0) | 0;
     _puts(223088) | 0;
     HEAP32[$vararg_buffer63 >> 2] = HEAP32[$342 >> 2];
     _printf(222146, $vararg_buffer63) | 0;
     $348 = _tidyGetLanguage() | 0;
     if (!$345) {
      HEAP32[$vararg_buffer70 >> 2] = $348;
      _printf(222211, $vararg_buffer70) | 0;
     } else {
      HEAP32[$vararg_buffer66 >> 2] = $348;
      HEAP32[$vararg_buffer66 + 4 >> 2] = $345;
      _printf(222165, $vararg_buffer66) | 0;
     }
     _puts(223104) | 0;
    } while ((HEAP32[$pos$i$i40 >> 2] | 0) != 0);
    _puts(223071) | 0;
    _tidyRelease($1);
    $$2 = 0;
    STACKTOP = sp;
    return $$2 | 0;
   }
  case 189:
   {
    HEAP32[$vararg_buffer73 >> 2] = _tidyLibraryVersion() | 0;
    _printf(222247, $vararg_buffer73) | 0;
    $354 = _tidyGetOptionList($1) | 0;
    HEAP32[$vararg_buffer73 >> 2] = $354;
    if ($354 | 0) do {
     $356 = _tidyGetNextOption($1, $vararg_buffer73) | 0;
     _GetOption($1, $356, $pos$i$i40);
     if (!(_tidyOptIsReadOnly($356) | 0)) {
      _puts(223216) | 0;
      HEAP32[$vararg_buffer76 >> 2] = HEAP32[$pos$i$i40 >> 2];
      _printf(222146, $vararg_buffer76) | 0;
      $360 = _tidyGetLanguage() | 0;
      $361 = _tidyOptGetDoc($1, $356) | 0;
      HEAP32[$vararg_buffer79 >> 2] = $360;
      HEAP32[$vararg_buffer79 + 4 >> 2] = $361;
      _printf(222165, $vararg_buffer79) | 0;
      _puts(223306) | 0;
     }
    } while ((HEAP32[$vararg_buffer73 >> 2] | 0) != 0);
    _puts(223121) | 0;
    _tidyRelease($1);
    $$2 = 0;
    STACKTOP = sp;
    return $$2 | 0;
   }
  case 196:
   {
    $366 = _strcmp(_tidyGetLanguage() | 0, 226752) | 0;
    HEAP32[$vararg_buffer83 >> 2] = _tidyLibraryVersion() | 0;
    _printf(222635, $vararg_buffer83) | 0;
    $368 = _getStringKeyList() | 0;
    HEAP32[$pos$i$i40 >> 2] = $368;
    if ($368 | 0) if (!$366) do {
     $371 = _getNextStringKey($pos$i$i40) | 0;
     HEAP32[$vararg_buffer86 >> 2] = $371;
     _printf(222691, $vararg_buffer86) | 0;
     HEAP32[$vararg_buffer89 >> 2] = 226752;
     _printf(222719, $vararg_buffer89) | 0;
     HEAP32[$vararg_buffer92 >> 2] = _tidyDefaultString($371) | 0;
     _printf(223602, $vararg_buffer92) | 0;
     _puts(223161) | 0;
     _puts(223171) | 0;
    } while ((HEAP32[$pos$i$i40 >> 2] | 0) != 0); else do {
     $374 = _getNextStringKey($pos$i$i40) | 0;
     HEAP32[$vararg_buffer95 >> 2] = $374;
     _printf(222691, $vararg_buffer95) | 0;
     HEAP32[$vararg_buffer98 >> 2] = 226752;
     _printf(222719, $vararg_buffer98) | 0;
     HEAP32[$vararg_buffer101 >> 2] = _tidyDefaultString($374) | 0;
     _printf(223602, $vararg_buffer101) | 0;
     _puts(223161) | 0;
     $376 = _tidyLocalizedString($374) | 0;
     $379 = (_strcmp($376, _tidyDefaultString($374) | 0) | 0) == 0;
     $380 = _tidyGetLanguage() | 0;
     HEAP32[$vararg_buffer104 >> 2] = $380;
     HEAP32[$vararg_buffer104 + 4 >> 2] = $379 ? 305751 : 305743;
     _printf(222740, $vararg_buffer104) | 0;
     HEAP32[$vararg_buffer108 >> 2] = _tidyLocalizedString($374) | 0;
     _printf(223602, $vararg_buffer108) | 0;
     _puts(223161) | 0;
     _puts(223171) | 0;
    } while ((HEAP32[$pos$i$i40 >> 2] | 0) != 0);
    _puts(223140) | 0;
    _tidyRelease($1);
    $$2 = 0;
    STACKTOP = sp;
    return $$2 | 0;
   }
  case 202:
   {
    HEAP32[$vararg_buffer111 >> 2] = _tidyLocalizedString(4178) | 0;
    _printf(223602, $vararg_buffer111) | 0;
    $387 = _tidyLocalizedString(4179) | 0;
    $388 = _tidyLocalizedString(4180) | 0;
    $389 = _tidyLocalizedString(4181) | 0;
    HEAP32[$vararg_buffer114 >> 2] = $387;
    HEAP32[$vararg_buffer114 + 4 >> 2] = $388;
    HEAP32[$vararg_buffer114 + 8 >> 2] = $389;
    _printf(222779, $vararg_buffer114) | 0;
    HEAP32[$vararg_buffer119 >> 2] = 221083;
    HEAP32[$vararg_buffer119 + 4 >> 2] = 221083;
    HEAP32[$vararg_buffer119 + 8 >> 2] = 221083;
    _printf(222779, $vararg_buffer119) | 0;
    _ForEachSortedOption($1, 47);
    _tidyRelease($1);
    $$2 = 0;
    STACKTOP = sp;
    return $$2 | 0;
   }
  case 204:
   {
    if (($$17$lcssa$lcssa415 | 0) > 2) {
     $394 = HEAP32[$$110$lcssa$lcssa403 + 8 >> 2] | 0;
     $395 = _tidyOptGetIdForName($394) | 0;
     $396 = $395 >>> 0 < 98;
     if ($396) {
      $398 = _tidyOptGetDoc($1, _tidyGetOption($1, $395) | 0) | 0;
      if (!$398) $$0$i$i = 0; else {
       $strlenfirst$i$i = HEAP8[$398 >> 0] | 0;
       if (!($strlenfirst$i$i << 24 >> 24)) $$0$i$i = 0; else {
        $401 = $strlenfirst$i$i;
        $i$0$i$i = 0;
        $i_name$0$i$i = 0;
        $i_result$0$i$i = 0;
        $l_name$0$i$i = 0;
        $l_result$0$i$i = 0;
        $name$0$i$i = 0;
        $result$0$i$i = 0;
        $state$0$i$i = 1;
        $writer$0$i$i = 0;
        L245 : while (1) {
         HEAP8[$pos$i$i40 >> 0] = $401;
         switch ($401 << 24 >> 24 | 0) {
         case 0:
          {
           $charstate$0$i$i = 1;
           break;
          }
         case 38:
         case 60:
          {
           $charstate$0$i$i = 3;
           break;
          }
         case 59:
         case 62:
          {
           $charstate$0$i$i = 2;
           break;
          }
         default:
          $charstate$0$i$i = 4;
         }
         switch ($state$0$i$i | 0) {
         case 1:
          {
           if (($charstate$0$i$i | 0) == 1) {
            $j$06$lcssa$i$i = 0;
            label = 214;
           } else if (($charstate$0$i$i | 0) == 3) {
            $j$06$lcssa$i$i = 1;
            label = 214;
           } else if (($charstate$0$i$i | 0) == 2) {
            $j$06$lcssa$i$i = 2;
            label = 214;
           } else if (($charstate$0$i$i | 0) == 4) {
            $j$06$lcssa$i$i = 3;
            label = 214;
           } else {
            $i$2$i$i = $i$0$i$i;
            $i_name$2$i$i = $i_name$0$i$i;
            $i_result$2$i$i = $i_result$0$i$i;
            $l_name$4$i$i = $l_name$0$i$i;
            $l_result$4$i$i = $l_result$0$i$i;
            $name$4$i$i = $name$0$i$i;
            $result$4$i$i = $result$0$i$i;
            $state$1$i$i = 1;
            $writer$4$i$i = $writer$0$i$i;
           }
           break;
          }
         case 2:
          {
           if (($charstate$0$i$i | 0) == 4) {
            $j$06$lcssa$i$i = 4;
            label = 214;
           } else if (($charstate$0$i$i | 0) == 2) {
            $j$06$lcssa$i$i = 5;
            label = 214;
           } else {
            $i$2$i$i = $i$0$i$i;
            $i_name$2$i$i = $i_name$0$i$i;
            $i_result$2$i$i = $i_result$0$i$i;
            $l_name$4$i$i = $l_name$0$i$i;
            $l_result$4$i$i = $l_result$0$i$i;
            $name$4$i$i = $name$0$i$i;
            $result$4$i$i = $result$0$i$i;
            $state$1$i$i = 2;
            $writer$4$i$i = $writer$0$i$i;
           }
           break;
          }
         case 3:
          {
           if (($charstate$0$i$i | 0) == 1) {
            $j$06$lcssa$i$i = 6;
            label = 214;
           } else if (($charstate$0$i$i | 0) == 4) {
            $j$06$lcssa$i$i = 7;
            label = 214;
           } else {
            $i$2$i$i = $i$0$i$i;
            $i_name$2$i$i = $i_name$0$i$i;
            $i_result$2$i$i = $i_result$0$i$i;
            $l_name$4$i$i = $l_name$0$i$i;
            $l_result$4$i$i = $l_result$0$i$i;
            $name$4$i$i = $name$0$i$i;
            $result$4$i$i = $result$0$i$i;
            $state$1$i$i = 3;
            $writer$4$i$i = $writer$0$i$i;
           }
           break;
          }
         case 4:
          {
           if (($charstate$0$i$i | 0) == 3) {
            $j$06$lcssa$i$i = 8;
            label = 214;
           } else if (($charstate$0$i$i | 0) == 1) {
            $j$06$lcssa$i$i = 9;
            label = 214;
           } else if (($charstate$0$i$i | 0) == 2) {
            $j$06$lcssa$i$i = 10;
            label = 214;
           } else if (($charstate$0$i$i | 0) == 4) {
            $j$06$lcssa$i$i = 11;
            label = 214;
           } else {
            $i$2$i$i = $i$0$i$i;
            $i_name$2$i$i = $i_name$0$i$i;
            $i_result$2$i$i = $i_result$0$i$i;
            $l_name$4$i$i = $l_name$0$i$i;
            $l_result$4$i$i = $l_result$0$i$i;
            $name$4$i$i = $name$0$i$i;
            $result$4$i$i = $result$0$i$i;
            $state$1$i$i = 4;
            $writer$4$i$i = $writer$0$i$i;
           }
           break;
          }
         default:
          {
           $i$2$i$i = $i$0$i$i;
           $i_name$2$i$i = $i_name$0$i$i;
           $i_result$2$i$i = $i_result$0$i$i;
           $l_name$4$i$i = $l_name$0$i$i;
           $l_result$4$i$i = $l_result$0$i$i;
           $name$4$i$i = $name$0$i$i;
           $result$4$i$i = $result$0$i$i;
           $state$1$i$i = $state$0$i$i;
           $writer$4$i$i = $writer$0$i$i;
          }
         }
         L265 : do if ((label | 0) == 214) {
          label = 0;
          $407 = HEAP32[1280 + ($j$06$lcssa$i$i << 4) + 12 >> 2] | 0;
          switch (HEAP32[1280 + ($j$06$lcssa$i$i << 4) + 8 >> 2] | 0) {
          case 6:
           {
            $name$0$i$i$lcssa = $name$0$i$i;
            $result$0$i$i$lcssa = $result$0$i$i;
            label = 232;
            break L245;
            break;
           }
          case 0:
           {
            $i$2$i$i = $i$0$i$i;
            $i_name$2$i$i = $i_name$0$i$i;
            $i_result$2$i$i = $i_result$0$i$i;
            $l_name$4$i$i = $l_name$0$i$i;
            $l_result$4$i$i = $l_result$0$i$i;
            $name$4$i$i = $name$0$i$i;
            $result$4$i$i = $result$0$i$i;
            $state$1$i$i = $407;
            $writer$4$i$i = $writer$0$i$i;
            break L265;
            break;
           }
          case 1:
           {
            if (!$name$0$i$i) {
             $l_name$1$i$i = 10;
             $name$1$i$i37 = _calloc(10, 1) | 0;
            } else {
             $l_name$1$i$i = $l_name$0$i$i;
             $name$1$i$i37 = $name$0$i$i;
            }
            if (($i_name$0$i$i | 0) < ($l_name$1$i$i | 0)) {
             $l_name$2$i$i = $l_name$1$i$i;
             $name$2$i$i = $name$1$i$i37;
            } else {
             $411 = $l_name$1$i$i + 10 | 0;
             $l_name$2$i$i = $411;
             $name$2$i$i = _realloc($name$1$i$i37, $411) | 0;
            }
            _strncpy($name$2$i$i + $i_name$0$i$i | 0, $pos$i$i40, 1) | 0;
            $i$2$i$i = $i$0$i$i + 1 | 0;
            $i_name$2$i$i = $i_name$0$i$i + 1 | 0;
            $i_result$2$i$i = $i_result$0$i$i;
            $l_name$4$i$i = $l_name$2$i$i;
            $l_result$4$i$i = $l_result$0$i$i;
            $name$4$i$i = $name$2$i$i;
            $result$4$i$i = $result$0$i$i;
            $state$1$i$i = $407;
            $writer$4$i$i = $writer$0$i$i;
            break L265;
            break;
           }
          case 3:
           {
            $i$2$i$i = $i$0$i$i;
            $i_name$2$i$i = $i_name$0$i$i;
            $i_result$2$i$i = $i_result$0$i$i;
            $l_name$4$i$i = $l_name$0$i$i;
            $l_result$4$i$i = $l_result$0$i$i;
            $name$4$i$i = $name$0$i$i;
            $result$4$i$i = $result$0$i$i;
            $state$1$i$i = $407;
            $writer$4$i$i = 0;
            break L265;
            break;
           }
          case 4:
           {
            HEAP8[$name$0$i$i + $i_name$0$i$i >> 0] = 0;
            $418 = (_strcmp(312329, $name$0$i$i) | 0) == 0;
            $420 = (_strcmp(312332, $name$0$i$i) | 0) == 0;
            $422 = (_strcmp(222831, $name$0$i$i) | 0) == 0;
            $i$2$i$i = $i$0$i$i;
            $i_name$2$i$i = 0;
            $i_result$2$i$i = $i_result$0$i$i;
            $l_name$4$i$i = $l_name$0$i$i;
            $l_result$4$i$i = $l_result$0$i$i;
            $name$4$i$i = $name$0$i$i;
            $result$4$i$i = $result$0$i$i;
            $state$1$i$i = $407;
            $writer$4$i$i = $422 ? 222835 : $420 ? 222829 : $418 ? 222827 : 317568;
            break L265;
            break;
           }
          case 5:
           {
            $423 = ($writer$0$i$i | 0) != 0;
            if ($423) $writer_len$0$i$i = _strlen($writer$0$i$i) | 0; else $writer_len$0$i$i = 1;
            if (!$result$0$i$i) {
             $426 = $writer_len$0$i$i + 100 | 0;
             $l_result$1$i$i = $426;
             $result$1$i$i = _calloc($426, 1) | 0;
            } else {
             $l_result$1$i$i = $l_result$0$i$i;
             $result$1$i$i = $result$0$i$i;
            }
            $428 = $writer_len$0$i$i + $i_result$0$i$i | 0;
            if (($428 | 0) < ($l_result$1$i$i | 0)) {
             $l_result$2$i$i = $l_result$1$i$i;
             $result$2$i$i = $result$1$i$i;
            } else {
             $431 = $writer_len$0$i$i + 100 + $l_result$1$i$i | 0;
             $l_result$2$i$i = $431;
             $result$2$i$i = _realloc($result$1$i$i, $431) | 0;
            }
            $433 = $result$2$i$i + $i_result$0$i$i | 0;
            if ($423) _strncpy($433, $writer$0$i$i, $writer_len$0$i$i) | 0; else {
             HEAP8[$433 >> 0] = $401;
             HEAP8[$result$2$i$i + ($i_result$0$i$i + 1) >> 0] = 0;
            }
            $i$2$i$i = $i$0$i$i + 1 | 0;
            $i_name$2$i$i = $i_name$0$i$i;
            $i_result$2$i$i = $428;
            $l_name$4$i$i = $l_name$0$i$i;
            $l_result$4$i$i = $l_result$2$i$i;
            $name$4$i$i = $name$0$i$i;
            $result$4$i$i = $result$2$i$i;
            $state$1$i$i = $407;
            $writer$4$i$i = $writer$0$i$i;
            break L265;
            break;
           }
          default:
           {
            $i$2$i$i = $i$0$i$i + 1 | 0;
            $i_name$2$i$i = $i_name$0$i$i;
            $i_result$2$i$i = $i_result$0$i$i;
            $l_name$4$i$i = $l_name$0$i$i;
            $l_result$4$i$i = $l_result$0$i$i;
            $name$4$i$i = $name$0$i$i;
            $result$4$i$i = $result$0$i$i;
            $state$1$i$i = $407;
            $writer$4$i$i = $writer$0$i$i;
            break L265;
           }
          }
         } while (0);
         $401 = HEAP8[$398 + $i$2$i$i >> 0] | 0;
         if (!($401 << 24 >> 24)) {
          $name$5$i$i = $name$4$i$i;
          $result$5$i$i = $result$4$i$i;
          break;
         } else {
          $i$0$i$i = $i$2$i$i;
          $i_name$0$i$i = $i_name$2$i$i;
          $i_result$0$i$i = $i_result$2$i$i;
          $l_name$0$i$i = $l_name$4$i$i;
          $l_result$0$i$i = $l_result$4$i$i;
          $name$0$i$i = $name$4$i$i;
          $result$0$i$i = $result$4$i$i;
          $state$0$i$i = $state$1$i$i;
          $writer$0$i$i = $writer$4$i$i;
         }
        }
        if ((label | 0) == 232) {
         _puts(223226) | 0;
         $name$5$i$i = $name$0$i$i$lcssa;
         $result$5$i$i = $result$0$i$i$lcssa;
        }
        if (!$name$5$i$i) $$0$i$i = $result$5$i$i; else {
         _free($name$5$i$i);
         $$0$i$i = $result$5$i$i;
        }
       }
      }
      $result$0$i = $$0$i$i;
     } else $result$0$i = _tidyLocalizedString(4171) | 0;
     _putchar(10) | 0;
     HEAP32[$vararg_buffer124 >> 2] = $394;
     _printf(222808, $vararg_buffer124) | 0;
     $454 = _malloc(69) | 0;
     if (!$454) _outOfMemory();
     $456 = $454 + 68 | 0;
     $pc1$0$i$i = $result$0$i;
     while (1) {
      do if (!$pc1$0$i$i) {
       HEAP8[$454 >> 0] = 0;
       $$0$i$i$i = 0;
      } else {
       if ((_strlen($pc1$0$i$i) | 0) >>> 0 > 68) $j$08$i$i$i = 0; else {
        _strcpy($454, $pc1$0$i$i) | 0;
        HEAP8[$456 >> 0] = 0;
        $$0$i$i$i = 0;
        break;
       }
       while (1) {
        if ((HEAP8[$pc1$0$i$i + $j$08$i$i$i >> 0] | 0) == 10) {
         $j$0$lcssa$i1$i$i = $j$08$i$i$i;
         label = 263;
         break;
        }
        $463 = $j$08$i$i$i + 1 | 0;
        if ($463 >>> 0 < 68) $j$08$i$i$i = $463; else {
         $$lcssa370 = $463;
         label = 259;
         break;
        }
       }
       if ((label | 0) == 259) {
        label = 0;
        if (($$lcssa370 | 0) == 68) {
         $j$13$i$i$i = 68;
         while (1) {
          if ((HEAP8[$pc1$0$i$i + $j$13$i$i$i >> 0] | 0) == 32) {
           $$lcssa$i$i$i = 0;
           $j$1$lcssa$i$i$i = $j$13$i$i$i;
           break;
          }
          $j$13$i$i$i = $j$13$i$i$i + -1 | 0;
          if (!$j$13$i$i$i) {
           $$lcssa$i$i$i = 1;
           $j$1$lcssa$i$i$i = 0;
           break;
          }
         }
         $l$0$i$i$i = $$lcssa$i$i$i ? 68 : $j$1$lcssa$i$i$i;
         $n$0$i$i$i = $$lcssa$i$i$i ? 68 : $j$1$lcssa$i$i$i + 1 | 0;
        } else {
         $j$0$lcssa$i1$i$i = $$lcssa370;
         label = 263;
        }
       }
       if ((label | 0) == 263) {
        label = 0;
        $l$0$i$i$i = $j$0$lcssa$i1$i$i;
        $n$0$i$i$i = $j$0$lcssa$i1$i$i + 1 | 0;
       }
       _strncpy($454, $pc1$0$i$i, $l$0$i$i$i) | 0;
       HEAP8[$454 + $l$0$i$i$i >> 0] = 0;
       $$0$i$i$i = $pc1$0$i$i + $n$0$i$i$i | 0;
      } while (0);
      HEAP32[$vararg_buffer127 >> 2] = HEAP8[$454 >> 0] | 0 ? $454 : 317568;
      _printf(222817, $vararg_buffer127) | 0;
      if (!$$0$i$i$i) break; else $pc1$0$i$i = $$0$i$i$i;
     }
     _free($454);
     _putchar(10) | 0;
     if ($396 & ($result$0$i | 0) != 0) _free($result$0$i);
    } else _puts(_tidyLocalizedString(4165) | 0) | 0;
    _tidyRelease($1);
    $$2 = 0;
    STACKTOP = sp;
    return $$2 | 0;
   }
  case 271:
   {
    HEAP32[$vararg_buffer130 >> 2] = _tidyLibraryVersion() | 0;
    _printf(222838, $vararg_buffer130) | 0;
    $484 = _tidyGetOptionList($1) | 0;
    HEAP32[$pos$i$i40 >> 2] = $484;
    if ($484 | 0) {
     $486 = $d$i$i41 + 4 | 0;
     $487 = $d$i$i41 + 8 | 0;
     $488 = $d$i$i41 + 16 | 0;
     $489 = $d$i$i41 + 100 | 0;
     $490 = $d$i$i41 + 12 | 0;
     do {
      $491 = _tidyGetNextOption($1, $pos$i$i40) | 0;
      _GetOption($1, $491, $d$i$i41);
      if (!(_tidyOptIsReadOnly($491) | 0)) {
       HEAP32[$vararg_buffer133 >> 2] = HEAP32[$486 >> 2];
       _printf(222058, $vararg_buffer133) | 0;
       HEAP32[$vararg_buffer136 >> 2] = HEAP32[$d$i$i41 >> 2];
       _printf(222146, $vararg_buffer136) | 0;
       HEAP32[$vararg_buffer139 >> 2] = HEAP32[$487 >> 2];
       _printf(222883, $vararg_buffer139) | 0;
       $497 = HEAP32[$488 >> 2] | 0;
       if (!$497) _puts(223278) | 0; else {
        HEAP32[$vararg_buffer142 >> 2] = $497;
        _printf(222902, $vararg_buffer142) | 0;
       }
       if (!(HEAP32[$489 >> 2] | 0)) _puts(223292) | 0; else {
        _printf(222927, $vararg_buffer145) | 0;
        $501 = HEAP32[$490 >> 2] | 0;
        if (!$501) {
         $503 = _tidyOptGetPickList($491) | 0;
         HEAP32[$vararg_buffer130 >> 2] = $503;
         if ($503 | 0) {
          HEAP32[$vararg_buffer150 >> 2] = _tidyOptGetNextPick($491, $vararg_buffer130) | 0;
          _printf(223602, $vararg_buffer150) | 0;
          if (HEAP32[$vararg_buffer130 >> 2] | 0) do {
           _printf(225098, $vararg_buffer153) | 0;
           HEAP32[$vararg_buffer155 >> 2] = _tidyOptGetNextPick($491, $vararg_buffer130) | 0;
           _printf(223602, $vararg_buffer155) | 0;
          } while ((HEAP32[$vararg_buffer130 >> 2] | 0) != 0);
         }
        } else {
         HEAP32[$vararg_buffer147 >> 2] = $501;
         _printf(223602, $vararg_buffer147) | 0;
        }
        _puts(223317) | 0;
       }
       $509 = _tidyOptGetDoc($1, $491) | 0;
       if (!$509) {
        _puts(223328) | 0;
        $511 = _tidyLocalizedString(4159) | 0;
        HEAP32[$vararg_buffer161 >> 2] = _tidyOptGetName($491) | 0;
        _fprintf($5, $511, $vararg_buffer161) | 0;
        _fputc(10, $5) | 0;
       } else {
        HEAP32[$vararg_buffer158 >> 2] = $509;
        _printf(222939, $vararg_buffer158) | 0;
       }
       $513 = _tidyOptGetDocLinksList($1, $491) | 0;
       HEAP32[$vararg_buffer130 >> 2] = $513;
       if ($513 | 0) do {
        HEAP32[$vararg_buffer164 >> 2] = _tidyOptGetName(_tidyOptGetNextDocLinks($1, $vararg_buffer130) | 0) | 0;
        _printf(222972, $vararg_buffer164) | 0;
       } while ((HEAP32[$vararg_buffer130 >> 2] | 0) != 0);
       _puts(223306) | 0;
      }
     } while ((HEAP32[$pos$i$i40 >> 2] | 0) != 0);
    }
    _puts(223191) | 0;
    _tidyRelease($1);
    $$2 = 0;
    STACKTOP = sp;
    return $$2 | 0;
   }
  case 295:
   {
    HEAP32[$vararg_buffer167 >> 2] = _tidyLocalizedString(4154) | 0;
    _printf(223715, $vararg_buffer167) | 0;
    $522 = _tidyLocalizedString(4155) | 0;
    $523 = _tidyLocalizedString(4156) | 0;
    $524 = _tidyLocalizedString(4157) | 0;
    HEAP32[$vararg_buffer170 >> 2] = $522;
    HEAP32[$vararg_buffer170 + 4 >> 2] = $523;
    HEAP32[$vararg_buffer170 + 8 >> 2] = $524;
    _printf(222779, $vararg_buffer170) | 0;
    HEAP32[$vararg_buffer175 >> 2] = 221083;
    HEAP32[$vararg_buffer175 + 4 >> 2] = 221083;
    HEAP32[$vararg_buffer175 + 8 >> 2] = 221083;
    _printf(222779, $vararg_buffer175) | 0;
    _ForEachSortedOption($1, 48);
    HEAP32[$vararg_buffer180 >> 2] = _tidyLocalizedString(4158) | 0;
    _printf(222997, $vararg_buffer180) | 0;
    _tidyRelease($1);
    $$2 = 0;
    STACKTOP = sp;
    return $$2 | 0;
   }
  case 321:
   {
    $578 = _tidyLocalizedString(4173) | 0;
    HEAP32[$vararg_buffer186 >> 2] = _tidyLibraryVersion() | 0;
    _printf($578, $vararg_buffer186) | 0;
    _putchar(10) | 0;
    _tidyRelease($1);
    $$2 = 0;
    STACKTOP = sp;
    return $$2 | 0;
   }
  }
 } else {
  $contentErrors$2 = 0;
  $contentWarnings$2 = 0;
 } while (0);
 if (!(_tidyOptGetBool($1, 19) | 0)) if (!(($contentErrors$2 | 0) != 0 | (HEAP32[79116] | 0) != ($5 | 0))) _fputc(10, $5) | 0;
 if (($contentErrors$2 | 0) != (0 - $contentWarnings$2 | 0)) if (!(_tidyOptGetBool($1, 19) | 0)) _tidyErrorSummary($1);
 if (!(_tidyOptGetBool($1, 19) | 0)) _tidyGeneralInfo($1);
 _tidyRelease($1);
 if ($contentErrors$2 | 0) {
  $$2 = 2;
  STACKTOP = sp;
  return $$2 | 0;
 }
 $$2 = ($contentWarnings$2 | 0) != 0 & 1;
 STACKTOP = sp;
 return $$2 | 0;
}

function _prvTidyPPrintTree($doc, $mode, $indent, $node) {
 $doc = $doc | 0;
 $mode = $mode | 0;
 $indent = $indent | 0;
 $node = $node | 0;
 var $$pr = 0, $$pr150 = 0, $$pr152$pr = 0, $$pre$i$i = 0, $$pre$i$i$i = 0, $$pre$i$i102 = 0, $$pre$i$i111 = 0, $$pre$i$i120 = 0, $$pre$i$i129 = 0, $$pre$i$i13$i = 0, $$pre$i$i138 = 0, $$pre$i$i22$i = 0, $$pre$i$i33$i = 0, $$pre$i$i42$i = 0, $$pre$i$i51$i = 0, $$pre$i$i63 = 0, $$pre$i$i75 = 0, $$pre$i$i84 = 0, $$pre$i$i93 = 0, $$pre$phi$i$iZ2D = 0, $$pre$phiZ2D = 0, $1 = 0, $100 = 0, $1001 = 0, $1003 = 0, $1004 = 0, $1009 = 0, $1019 = 0, $1022 = 0, $1026 = 0, $1028 = 0, $103 = 0, $1035 = 0, $1038 = 0, $105 = 0, $1050 = 0, $1062 = 0, $1076 = 0, $1083 = 0, $1089 = 0, $1099 = 0, $1105 = 0, $1107 = 0, $1109 = 0, $1110 = 0, $112 = 0, $1136 = 0, $1142 = 0, $1152 = 0, $1172 = 0, $1179 = 0, $1180 = 0, $1190 = 0, $1206 = 0, $1211 = 0, $125 = 0, $128 = 0, $135 = 0, $138 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $15 = 0, $151 = 0, $155 = 0, $158 = 0, $160 = 0, $17 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $18 = 0, $181 = 0, $185 = 0, $188 = 0, $19 = 0, $190 = 0, $2 = 0, $202 = 0, $205 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $223 = 0, $227 = 0, $230 = 0, $232 = 0, $24 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $253 = 0, $257 = 0, $260 = 0, $262 = 0, $274 = 0, $275 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $291 = 0, $295 = 0, $298 = 0, $3 = 0, $300 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $324 = 0, $328 = 0, $33 = 0, $331 = 0, $333 = 0, $34 = 0, $345 = 0, $348 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $361 = 0, $365 = 0, $368 = 0, $370 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $391 = 0, $395 = 0, $398 = 0, $40 = 0, $400 = 0, $412 = 0, $413 = 0, $423 = 0, $436 = 0, $439 = 0, $44 = 0, $442 = 0, $447 = 0, $450 = 0, $467 = 0, $47 = 0, $470 = 0, $476 = 0, $479 = 0, $489 = 0, $49 = 0, $492 = 0, $498 = 0, $500 = 0, $509 = 0, $512 = 0, $527 = 0, $530 = 0, $534 = 0, $540 = 0, $542 = 0, $543 = 0, $550 = 0, $553 = 0, $556 = 0, $567 = 0, $574 = 0, $589 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0, $6 = 0, $601 = 0, $603 = 0, $61 = 0, $611 = 0, $614 = 0, $62 = 0, $624 = 0, $627 = 0, $63 = 0, $632 = 0, $637 = 0, $64 = 0, $642 = 0, $643 = 0, $646 = 0, $648 = 0, $649 = 0, $658 = 0, $659 = 0, $661 = 0, $675 = 0, $678 = 0, $679 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $688 = 0, $69 = 0, $692 = 0, $695 = 0, $697 = 0, $709 = 0, $710 = 0, $711 = 0, $716 = 0, $720 = 0, $723 = 0, $725 = 0, $73 = 0, $737 = 0, $738 = 0, $739 = 0, $744 = 0, $748 = 0, $751 = 0, $753 = 0, $76 = 0, $770 = 0, $776 = 0, $777 = 0, $78 = 0, $780 = 0, $784 = 0, $786 = 0, $790 = 0, $808 = 0, $813 = 0, $817 = 0, $818 = 0, $819 = 0, $820 = 0, $821 = 0, $822 = 0, $827 = 0, $831 = 0, $834 = 0, $836 = 0, $848 = 0, $849 = 0, $850 = 0, $855 = 0, $859 = 0, $862 = 0, $864 = 0, $876 = 0, $877 = 0, $878 = 0, $883 = 0, $887 = 0, $890 = 0, $892 = 0, $90 = 0, $91 = 0, $910 = 0, $915 = 0, $935 = 0, $945 = 0, $951 = 0, $956 = 0, $957 = 0, $96 = 0, $965 = 0, $968 = 0, $982 = 0, $991 = 0, $992 = 0, $993 = 0, $994 = 0, $buflen$0$i$i$i = 0, $buflen$0$i$i$i$i = 0, $buflen$0$i$i$i$i$lcssa = 0, $buflen$0$i$i$i$lcssa = 0, $buflen$0$i$i$i100 = 0, $buflen$0$i$i$i100$lcssa = 0, $buflen$0$i$i$i109 = 0, $buflen$0$i$i$i109$lcssa = 0, $buflen$0$i$i$i11$i = 0, $buflen$0$i$i$i11$i$lcssa = 0, $buflen$0$i$i$i118 = 0, $buflen$0$i$i$i118$lcssa = 0, $buflen$0$i$i$i127 = 0, $buflen$0$i$i$i127$lcssa = 0, $buflen$0$i$i$i136 = 0, $buflen$0$i$i$i136$lcssa = 0, $buflen$0$i$i$i20$i = 0, $buflen$0$i$i$i20$i$lcssa = 0, $buflen$0$i$i$i31$i = 0, $buflen$0$i$i$i31$i$lcssa = 0, $buflen$0$i$i$i40$i = 0, $buflen$0$i$i$i40$i$lcssa = 0, $buflen$0$i$i$i49$i = 0, $buflen$0$i$i$i49$i$lcssa = 0, $buflen$0$i$i$i61 = 0, $buflen$0$i$i$i61$lcssa = 0, $buflen$0$i$i$i71 = 0, $buflen$0$i$i$i71$lcssa = 0, $buflen$0$i$i$i73 = 0, $buflen$0$i$i$i73$lcssa = 0, $buflen$0$i$i$i82 = 0, $buflen$0$i$i$i82$lcssa = 0, $buflen$0$i$i$i91 = 0, $buflen$0$i$i$i91$lcssa = 0, $commentEnd$0$i = 0, $commentEnd$1$i = 0, $commentStart$0$i = 0, $commentStart$1$i = 0, $content$0$i178 = 0, $content$0$i180 = 0, $content$0$i55184 = 0, $content$0$i55185 = 0, $content$0188 = 0, $content$0189 = 0, $content$1174 = 0, $content$1175 = 0, $content$2170 = 0, $content$2171 = 0, $content$3166 = 0, $content$3167 = 0, $content$4162 = 0, $content$4163 = 0, $content$5 = 0, $content$5159 = 0, $content$5161 = 0, $content$5161$us = 0, $contentIndent$0$i179 = 0, $contentIndent$1 = 0, $contentIndent$1$i = 0, $contentIndent$1$i$lcssa = 0, $hasCData$0$i = 0, $indent$ = 0, $ix$0$i$i = 0, $ix$0$lcssa$i$i = 0, $ix$01$i$i = 0, $ix$01$i$i$i = 0, $ix$01$i$i104 = 0, $ix$01$i$i113 = 0, $ix$01$i$i122 = 0, $ix$01$i$i131 = 0, $ix$01$i$i140 = 0, $ix$01$i$i15$i = 0, $ix$01$i$i24$i = 0, $ix$01$i$i35$i = 0, $ix$01$i$i44$i = 0, $ix$01$i$i53$i = 0, $ix$01$i$i65 = 0, $ix$01$i$i77 = 0, $ix$01$i$i86 = 0, $ix$01$i$i95 = 0, $ix$06$i$i = 0, $ix$07$i$i = 0, $last$0160 = 0, $last$0160$phi = 0, $node$01$i = 0, $node$02$i = 0, $node$tr$i$i = 0, label = 0;
 $1 = HEAP32[$doc + 76 >> 2] | 0;
 $2 = $doc + 176 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 if (!$node) return;
 $6 = HEAP32[$doc + 6804 >> 2] | 0;
 if ($6 | 0) FUNCTION_TABLE_viiii[$6 & 0]($doc, HEAP32[$node + 48 >> 2] | 0, HEAP32[$node + 52 >> 2] | 0, (HEAP32[$doc + 6744 >> 2] | 0) + 1 | 0);
 $15 = $node + 44 | 0;
 do switch (HEAP32[$15 >> 2] | 0) {
 case 4:
  {
   _PPrintText($doc, $mode, $indent, $node);
   return;
  }
 case 2:
  {
   $17 = $doc + 6724 | 0;
   $18 = $doc + 6736 | 0;
   $19 = HEAP32[$18 >> 2] | 0;
   if (($19 + $indent | 0) >>> 0 < (HEAP32[$doc + 80 >> 2] | 0) >>> 0) {
    $24 = $doc + 6752 | 0;
    if ((HEAP32[$24 >> 2] | 0) < 0) HEAP32[$24 >> 2] = $indent;
    HEAP32[$doc + 6740 >> 2] = $19;
   } else {
    $28 = $doc + 6748 | 0;
    if (!(HEAP32[$28 >> 2] | 0)) {
     HEAP32[$doc + 6764 >> 2] = $indent;
     HEAP32[$28 >> 2] = 1;
    }
   }
   $32 = _prvTidytmbstrlen(310762) | 0;
   $33 = $32 + $19 | 0;
   $34 = $doc + 6732 | 0;
   $35 = HEAP32[$34 >> 2] | 0;
   if ($33 >>> 0 >= $35 >>> 0) {
    $buflen$0$i$i$i = ($35 | 0) == 0 ? 256 : $35;
    while (1) if ($buflen$0$i$i$i >>> 0 > $33 >>> 0) {
     $buflen$0$i$i$i$lcssa = $buflen$0$i$i$i;
     break;
    } else $buflen$0$i$i$i = $buflen$0$i$i$i << 1;
    $40 = HEAP32[$17 >> 2] | 0;
    $44 = $doc + 6728 | 0;
    $47 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$40 >> 2] | 0) + 4 >> 2] & 15]($40, HEAP32[$44 >> 2] | 0, $buflen$0$i$i$i$lcssa << 2) | 0;
    if ($47 | 0) {
     $49 = HEAP32[$34 >> 2] | 0;
     _memset($47 + ($49 << 2) | 0, 0, $buflen$0$i$i$i$lcssa - $49 << 2 | 0) | 0;
     HEAP32[$34 >> 2] = $buflen$0$i$i$i$lcssa;
     HEAP32[$44 >> 2] = $47;
    }
   }
   if ($32 | 0) {
    $$pre$i$i = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i = 0;
    do {
     HEAP32[$$pre$i$i + ($ix$01$i$i + $19 << 2) >> 2] = HEAP8[310762 + $ix$01$i$i >> 0];
     $ix$01$i$i = $ix$01$i$i + 1 | 0;
    } while (($ix$01$i$i | 0) != ($32 | 0));
   }
   HEAP32[$18 >> 2] = $33;
   _PPrintText($doc, 2, 0, $node);
   $61 = HEAP32[$18 >> 2] | 0;
   $62 = _prvTidytmbstrlen(310767) | 0;
   $63 = $62 + $61 | 0;
   $64 = HEAP32[$34 >> 2] | 0;
   if ($63 >>> 0 >= $64 >>> 0) {
    $buflen$0$i$i$i61 = ($64 | 0) == 0 ? 256 : $64;
    while (1) if ($buflen$0$i$i$i61 >>> 0 > $63 >>> 0) {
     $buflen$0$i$i$i61$lcssa = $buflen$0$i$i$i61;
     break;
    } else $buflen$0$i$i$i61 = $buflen$0$i$i$i61 << 1;
    $69 = HEAP32[$17 >> 2] | 0;
    $73 = $doc + 6728 | 0;
    $76 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$69 >> 2] | 0) + 4 >> 2] & 15]($69, HEAP32[$73 >> 2] | 0, $buflen$0$i$i$i61$lcssa << 2) | 0;
    if ($76 | 0) {
     $78 = HEAP32[$34 >> 2] | 0;
     _memset($76 + ($78 << 2) | 0, 0, $buflen$0$i$i$i61$lcssa - $78 << 2 | 0) | 0;
     HEAP32[$34 >> 2] = $buflen$0$i$i$i61$lcssa;
     HEAP32[$73 >> 2] = $76;
    }
   }
   if ($62 | 0) {
    $$pre$i$i63 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i65 = 0;
    do {
     HEAP32[$$pre$i$i63 + ($ix$01$i$i65 + $61 << 2) >> 2] = HEAP8[310767 + $ix$01$i$i65 >> 0];
     $ix$01$i$i65 = $ix$01$i$i65 + 1 | 0;
    } while (($ix$01$i$i65 | 0) != ($62 | 0));
   }
   HEAP32[$18 >> 2] = $63;
   $90 = $63 + 1 | 0;
   $91 = HEAP32[$34 >> 2] | 0;
   if ($90 >>> 0 < $91 >>> 0) $$pre$phi$i$iZ2D = $doc + 6728 | 0; else {
    $buflen$0$i$i$i71 = ($91 | 0) == 0 ? 256 : $91;
    while (1) if ($buflen$0$i$i$i71 >>> 0 > $90 >>> 0) {
     $buflen$0$i$i$i71$lcssa = $buflen$0$i$i$i71;
     break;
    } else $buflen$0$i$i$i71 = $buflen$0$i$i$i71 << 1;
    $96 = HEAP32[$17 >> 2] | 0;
    $100 = $doc + 6728 | 0;
    $103 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$96 >> 2] | 0) + 4 >> 2] & 15]($96, HEAP32[$100 >> 2] | 0, $buflen$0$i$i$i71$lcssa << 2) | 0;
    if (!$103) $$pre$phi$i$iZ2D = $100; else {
     $105 = HEAP32[$34 >> 2] | 0;
     _memset($103 + ($105 << 2) | 0, 0, $buflen$0$i$i$i71$lcssa - $105 << 2 | 0) | 0;
     HEAP32[$34 >> 2] = $buflen$0$i$i$i71$lcssa;
     HEAP32[$100 >> 2] = $103;
     $$pre$phi$i$iZ2D = $100;
    }
   }
   HEAP32[(HEAP32[$$pre$phi$i$iZ2D >> 2] | 0) + ($63 << 2) >> 2] = 62;
   $112 = (HEAP32[$18 >> 2] | 0) + 1 | 0;
   HEAP32[$18 >> 2] = $112;
   if (!(HEAP32[$node + 64 >> 2] | 0)) return;
   if (!(HEAP32[$node + 8 >> 2] | 0)) return;
   if ($112 | 0) _PFlushLineImpl($doc);
   if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
    _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
    $125 = $doc + 6744 | 0;
    HEAP32[$125 >> 2] = (HEAP32[$125 >> 2] | 0) + 1;
   }
   $128 = $doc + 6752 | 0;
   if ((HEAP32[$128 >> 2] | 0) == ($indent | 0)) return;
   HEAP32[$128 >> 2] = $indent;
   return;
  }
 case 0:
  {
   $content$0188 = HEAP32[$node + 12 >> 2] | 0;
   if (!$content$0188) return; else $content$0189 = $content$0188;
   do {
    _prvTidyPPrintTree($doc, $mode, $indent, $content$0189);
    $content$0189 = HEAP32[$content$0189 + 8 >> 2] | 0;
   } while (($content$0189 | 0) != 0);
   return;
  }
 case 1:
  {
   _PPrintDocType($doc, $indent, $node);
   return;
  }
 case 3:
  {
   _PPrintPI($doc, $indent, $node);
   return;
  }
 case 13:
  {
   _PPrintXmlDecl($doc, $indent, $node);
   return;
  }
 case 8:
  {
   _PPrintCDATA($doc, $indent, $node);
   return;
  }
 case 9:
  {
   $135 = $doc + 6724 | 0;
   $138 = (HEAP32[$doc + 264 >> 2] | 0) != 0;
   $140 = HEAP32[$doc + 80 >> 2] | 0;
   if (!$138) _prvTidySetOptionInt($doc, 2, -1) | 0;
   $141 = $doc + 6736 | 0;
   $142 = HEAP32[$141 >> 2] | 0;
   $143 = _prvTidytmbstrlen(310853) | 0;
   $144 = $143 + $142 | 0;
   $145 = $doc + 6732 | 0;
   $146 = HEAP32[$145 >> 2] | 0;
   if ($144 >>> 0 >= $146 >>> 0) {
    $buflen$0$i$i$i82 = ($146 | 0) == 0 ? 256 : $146;
    while (1) if ($buflen$0$i$i$i82 >>> 0 > $144 >>> 0) {
     $buflen$0$i$i$i82$lcssa = $buflen$0$i$i$i82;
     break;
    } else $buflen$0$i$i$i82 = $buflen$0$i$i$i82 << 1;
    $151 = HEAP32[$135 >> 2] | 0;
    $155 = $doc + 6728 | 0;
    $158 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$151 >> 2] | 0) + 4 >> 2] & 15]($151, HEAP32[$155 >> 2] | 0, $buflen$0$i$i$i82$lcssa << 2) | 0;
    if ($158 | 0) {
     $160 = HEAP32[$145 >> 2] | 0;
     _memset($158 + ($160 << 2) | 0, 0, $buflen$0$i$i$i82$lcssa - $160 << 2 | 0) | 0;
     HEAP32[$145 >> 2] = $buflen$0$i$i$i82$lcssa;
     HEAP32[$155 >> 2] = $158;
    }
   }
   if ($143 | 0) {
    $$pre$i$i84 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i86 = 0;
    do {
     HEAP32[$$pre$i$i84 + ($ix$01$i$i86 + $142 << 2) >> 2] = HEAP8[310853 + $ix$01$i$i86 >> 0];
     $ix$01$i$i86 = $ix$01$i$i86 + 1 | 0;
    } while (($ix$01$i$i86 | 0) != ($143 | 0));
   }
   HEAP32[$141 >> 2] = $144;
   _PPrintText($doc, $138 ? 16 : 2, $indent, $node);
   $173 = HEAP32[$141 >> 2] | 0;
   $174 = _prvTidytmbstrlen(310857) | 0;
   $175 = $174 + $173 | 0;
   $176 = HEAP32[$145 >> 2] | 0;
   if ($175 >>> 0 >= $176 >>> 0) {
    $buflen$0$i$i$i73 = ($176 | 0) == 0 ? 256 : $176;
    while (1) if ($buflen$0$i$i$i73 >>> 0 > $175 >>> 0) {
     $buflen$0$i$i$i73$lcssa = $buflen$0$i$i$i73;
     break;
    } else $buflen$0$i$i$i73 = $buflen$0$i$i$i73 << 1;
    $181 = HEAP32[$135 >> 2] | 0;
    $185 = $doc + 6728 | 0;
    $188 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$181 >> 2] | 0) + 4 >> 2] & 15]($181, HEAP32[$185 >> 2] | 0, $buflen$0$i$i$i73$lcssa << 2) | 0;
    if ($188 | 0) {
     $190 = HEAP32[$145 >> 2] | 0;
     _memset($188 + ($190 << 2) | 0, 0, $buflen$0$i$i$i73$lcssa - $190 << 2 | 0) | 0;
     HEAP32[$145 >> 2] = $buflen$0$i$i$i73$lcssa;
     HEAP32[$185 >> 2] = $188;
    }
   }
   if ($174 | 0) {
    $$pre$i$i75 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i77 = 0;
    do {
     HEAP32[$$pre$i$i75 + ($ix$01$i$i77 + $173 << 2) >> 2] = HEAP8[310857 + $ix$01$i$i77 >> 0];
     $ix$01$i$i77 = $ix$01$i$i77 + 1 | 0;
    } while (($ix$01$i$i77 | 0) != ($174 | 0));
   }
   HEAP32[$141 >> 2] = $175;
   _prvTidySetOptionInt($doc, 2, $140) | 0;
   return;
  }
 case 10:
  {
   $202 = $doc + 6724 | 0;
   $205 = (HEAP32[$doc + 268 >> 2] | 0) != 0;
   if ($205) {
    $212 = HEAP32[$doc + 80 >> 2] | 0;
    if (!(HEAP32[$doc + 272 >> 2] | 0)) {
     $1211 = $212;
     label = 70;
    } else $274 = $212;
   } else {
    $1211 = HEAP32[$doc + 80 >> 2] | 0;
    label = 70;
   }
   if ((label | 0) == 70) {
    _prvTidySetOptionInt($doc, 2, -1) | 0;
    $274 = $1211;
   }
   $213 = $doc + 6736 | 0;
   $214 = HEAP32[$213 >> 2] | 0;
   $215 = _prvTidytmbstrlen(310860) | 0;
   $216 = $215 + $214 | 0;
   $217 = $doc + 6732 | 0;
   $218 = HEAP32[$217 >> 2] | 0;
   if ($216 >>> 0 >= $218 >>> 0) {
    $buflen$0$i$i$i100 = ($218 | 0) == 0 ? 256 : $218;
    while (1) if ($buflen$0$i$i$i100 >>> 0 > $216 >>> 0) {
     $buflen$0$i$i$i100$lcssa = $buflen$0$i$i$i100;
     break;
    } else $buflen$0$i$i$i100 = $buflen$0$i$i$i100 << 1;
    $223 = HEAP32[$202 >> 2] | 0;
    $227 = $doc + 6728 | 0;
    $230 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$223 >> 2] | 0) + 4 >> 2] & 15]($223, HEAP32[$227 >> 2] | 0, $buflen$0$i$i$i100$lcssa << 2) | 0;
    if ($230 | 0) {
     $232 = HEAP32[$217 >> 2] | 0;
     _memset($230 + ($232 << 2) | 0, 0, $buflen$0$i$i$i100$lcssa - $232 << 2 | 0) | 0;
     HEAP32[$217 >> 2] = $buflen$0$i$i$i100$lcssa;
     HEAP32[$227 >> 2] = $230;
    }
   }
   if ($215 | 0) {
    $$pre$i$i102 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i104 = 0;
    do {
     HEAP32[$$pre$i$i102 + ($ix$01$i$i104 + $214 << 2) >> 2] = HEAP8[310860 + $ix$01$i$i104 >> 0];
     $ix$01$i$i104 = $ix$01$i$i104 + 1 | 0;
    } while (($ix$01$i$i104 | 0) != ($215 | 0));
   }
   HEAP32[$213 >> 2] = $216;
   _PPrintText($doc, $205 ? 16 : 2, $indent, $node);
   $245 = HEAP32[$213 >> 2] | 0;
   $246 = _prvTidytmbstrlen(310863) | 0;
   $247 = $246 + $245 | 0;
   $248 = HEAP32[$217 >> 2] | 0;
   if ($247 >>> 0 >= $248 >>> 0) {
    $buflen$0$i$i$i91 = ($248 | 0) == 0 ? 256 : $248;
    while (1) if ($buflen$0$i$i$i91 >>> 0 > $247 >>> 0) {
     $buflen$0$i$i$i91$lcssa = $buflen$0$i$i$i91;
     break;
    } else $buflen$0$i$i$i91 = $buflen$0$i$i$i91 << 1;
    $253 = HEAP32[$202 >> 2] | 0;
    $257 = $doc + 6728 | 0;
    $260 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$253 >> 2] | 0) + 4 >> 2] & 15]($253, HEAP32[$257 >> 2] | 0, $buflen$0$i$i$i91$lcssa << 2) | 0;
    if ($260 | 0) {
     $262 = HEAP32[$217 >> 2] | 0;
     _memset($260 + ($262 << 2) | 0, 0, $buflen$0$i$i$i91$lcssa - $262 << 2 | 0) | 0;
     HEAP32[$217 >> 2] = $buflen$0$i$i$i91$lcssa;
     HEAP32[$257 >> 2] = $260;
    }
   }
   if ($246 | 0) {
    $$pre$i$i93 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i95 = 0;
    do {
     HEAP32[$$pre$i$i93 + ($ix$01$i$i95 + $245 << 2) >> 2] = HEAP8[310863 + $ix$01$i$i95 >> 0];
     $ix$01$i$i95 = $ix$01$i$i95 + 1 | 0;
    } while (($ix$01$i$i95 | 0) != ($246 | 0));
   }
   HEAP32[$213 >> 2] = $247;
   _prvTidySetOptionInt($doc, 2, $274) | 0;
   return;
  }
 case 11:
  {
   $275 = $doc + 6724 | 0;
   $280 = HEAP32[$doc + 80 >> 2] | 0;
   if (!(HEAP32[$doc + 268 >> 2] | 0)) _prvTidySetOptionInt($doc, 2, -1) | 0;
   $281 = $doc + 6736 | 0;
   $282 = HEAP32[$281 >> 2] | 0;
   $283 = _prvTidytmbstrlen(310866) | 0;
   $284 = $283 + $282 | 0;
   $285 = $doc + 6732 | 0;
   $286 = HEAP32[$285 >> 2] | 0;
   if ($284 >>> 0 >= $286 >>> 0) {
    $buflen$0$i$i$i118 = ($286 | 0) == 0 ? 256 : $286;
    while (1) if ($buflen$0$i$i$i118 >>> 0 > $284 >>> 0) {
     $buflen$0$i$i$i118$lcssa = $buflen$0$i$i$i118;
     break;
    } else $buflen$0$i$i$i118 = $buflen$0$i$i$i118 << 1;
    $291 = HEAP32[$275 >> 2] | 0;
    $295 = $doc + 6728 | 0;
    $298 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$291 >> 2] | 0) + 4 >> 2] & 15]($291, HEAP32[$295 >> 2] | 0, $buflen$0$i$i$i118$lcssa << 2) | 0;
    if ($298 | 0) {
     $300 = HEAP32[$285 >> 2] | 0;
     _memset($298 + ($300 << 2) | 0, 0, $buflen$0$i$i$i118$lcssa - $300 << 2 | 0) | 0;
     HEAP32[$285 >> 2] = $buflen$0$i$i$i118$lcssa;
     HEAP32[$295 >> 2] = $298;
    }
   }
   if ($283 | 0) {
    $$pre$i$i120 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i122 = 0;
    do {
     HEAP32[$$pre$i$i120 + ($ix$01$i$i122 + $282 << 2) >> 2] = HEAP8[310866 + $ix$01$i$i122 >> 0];
     $ix$01$i$i122 = $ix$01$i$i122 + 1 | 0;
    } while (($ix$01$i$i122 | 0) != ($283 | 0));
   }
   HEAP32[$281 >> 2] = $284;
   _PPrintText($doc, HEAP32[$doc + 272 >> 2] | 0 ? 16 : 2, $indent, $node);
   $316 = HEAP32[$281 >> 2] | 0;
   $317 = _prvTidytmbstrlen(310869) | 0;
   $318 = $317 + $316 | 0;
   $319 = HEAP32[$285 >> 2] | 0;
   if ($318 >>> 0 >= $319 >>> 0) {
    $buflen$0$i$i$i109 = ($319 | 0) == 0 ? 256 : $319;
    while (1) if ($buflen$0$i$i$i109 >>> 0 > $318 >>> 0) {
     $buflen$0$i$i$i109$lcssa = $buflen$0$i$i$i109;
     break;
    } else $buflen$0$i$i$i109 = $buflen$0$i$i$i109 << 1;
    $324 = HEAP32[$275 >> 2] | 0;
    $328 = $doc + 6728 | 0;
    $331 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$324 >> 2] | 0) + 4 >> 2] & 15]($324, HEAP32[$328 >> 2] | 0, $buflen$0$i$i$i109$lcssa << 2) | 0;
    if ($331 | 0) {
     $333 = HEAP32[$285 >> 2] | 0;
     _memset($331 + ($333 << 2) | 0, 0, $buflen$0$i$i$i109$lcssa - $333 << 2 | 0) | 0;
     HEAP32[$285 >> 2] = $buflen$0$i$i$i109$lcssa;
     HEAP32[$328 >> 2] = $331;
    }
   }
   if ($317 | 0) {
    $$pre$i$i111 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i113 = 0;
    do {
     HEAP32[$$pre$i$i111 + ($ix$01$i$i113 + $316 << 2) >> 2] = HEAP8[310869 + $ix$01$i$i113 >> 0];
     $ix$01$i$i113 = $ix$01$i$i113 + 1 | 0;
    } while (($ix$01$i$i113 | 0) != ($317 | 0));
   }
   HEAP32[$281 >> 2] = $318;
   _prvTidySetOptionInt($doc, 2, $280) | 0;
   return;
  }
 case 12:
  {
   $345 = $doc + 6724 | 0;
   $348 = (HEAP32[$doc + 276 >> 2] | 0) != 0;
   $350 = HEAP32[$doc + 80 >> 2] | 0;
   if (!$348) _prvTidySetOptionInt($doc, 2, -1) | 0;
   $351 = $doc + 6736 | 0;
   $352 = HEAP32[$351 >> 2] | 0;
   $353 = _prvTidytmbstrlen(310813) | 0;
   $354 = $353 + $352 | 0;
   $355 = $doc + 6732 | 0;
   $356 = HEAP32[$355 >> 2] | 0;
   if ($354 >>> 0 >= $356 >>> 0) {
    $buflen$0$i$i$i136 = ($356 | 0) == 0 ? 256 : $356;
    while (1) if ($buflen$0$i$i$i136 >>> 0 > $354 >>> 0) {
     $buflen$0$i$i$i136$lcssa = $buflen$0$i$i$i136;
     break;
    } else $buflen$0$i$i$i136 = $buflen$0$i$i$i136 << 1;
    $361 = HEAP32[$345 >> 2] | 0;
    $365 = $doc + 6728 | 0;
    $368 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$361 >> 2] | 0) + 4 >> 2] & 15]($361, HEAP32[$365 >> 2] | 0, $buflen$0$i$i$i136$lcssa << 2) | 0;
    if ($368 | 0) {
     $370 = HEAP32[$355 >> 2] | 0;
     _memset($368 + ($370 << 2) | 0, 0, $buflen$0$i$i$i136$lcssa - $370 << 2 | 0) | 0;
     HEAP32[$355 >> 2] = $buflen$0$i$i$i136$lcssa;
     HEAP32[$365 >> 2] = $368;
    }
   }
   if ($353 | 0) {
    $$pre$i$i138 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i140 = 0;
    do {
     HEAP32[$$pre$i$i138 + ($ix$01$i$i140 + $352 << 2) >> 2] = HEAP8[310813 + $ix$01$i$i140 >> 0];
     $ix$01$i$i140 = $ix$01$i$i140 + 1 | 0;
    } while (($ix$01$i$i140 | 0) != ($353 | 0));
   }
   HEAP32[$351 >> 2] = $354;
   _PPrintText($doc, $348 ? 16 : 2, $indent, $node);
   $383 = HEAP32[$351 >> 2] | 0;
   $384 = _prvTidytmbstrlen(310872) | 0;
   $385 = $384 + $383 | 0;
   $386 = HEAP32[$355 >> 2] | 0;
   if ($385 >>> 0 >= $386 >>> 0) {
    $buflen$0$i$i$i127 = ($386 | 0) == 0 ? 256 : $386;
    while (1) if ($buflen$0$i$i$i127 >>> 0 > $385 >>> 0) {
     $buflen$0$i$i$i127$lcssa = $buflen$0$i$i$i127;
     break;
    } else $buflen$0$i$i$i127 = $buflen$0$i$i$i127 << 1;
    $391 = HEAP32[$345 >> 2] | 0;
    $395 = $doc + 6728 | 0;
    $398 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$391 >> 2] | 0) + 4 >> 2] & 15]($391, HEAP32[$395 >> 2] | 0, $buflen$0$i$i$i127$lcssa << 2) | 0;
    if ($398 | 0) {
     $400 = HEAP32[$355 >> 2] | 0;
     _memset($398 + ($400 << 2) | 0, 0, $buflen$0$i$i$i127$lcssa - $400 << 2 | 0) | 0;
     HEAP32[$355 >> 2] = $buflen$0$i$i$i127$lcssa;
     HEAP32[$395 >> 2] = $398;
    }
   }
   if ($384 | 0) {
    $$pre$i$i129 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i131 = 0;
    do {
     HEAP32[$$pre$i$i129 + ($ix$01$i$i131 + $383 << 2) >> 2] = HEAP8[310872 + $ix$01$i$i131 >> 0];
     $ix$01$i$i131 = $ix$01$i$i131 + 1 | 0;
    } while (($ix$01$i$i131 | 0) != ($384 | 0));
   }
   HEAP32[$351 >> 2] = $385;
   _prvTidySetOptionInt($doc, 2, $350) | 0;
   return;
  }
 default:
  {
   $412 = $node + 28 | 0;
   $413 = HEAP32[$412 >> 2] | 0;
   if ($413 | 0) if ((HEAP32[$413 >> 2] | 0) == 65) {
    _PPrintTag($doc, 4, $indent, $node);
    $content$0$i55184 = HEAP32[$node + 12 >> 2] | 0;
    if ($content$0$i55184 | 0) {
     $content$0$i55185 = $content$0$i55184;
     do {
      _prvTidyPPrintTree($doc, 4, $indent, $content$0$i55185);
      $content$0$i55185 = HEAP32[$content$0$i55185 + 8 >> 2] | 0;
     } while (($content$0$i55185 | 0) != 0);
    }
    _PPrintEndTag($doc, HEAP32[$node + 32 >> 2] | 0);
    return;
   }
   if (!(_prvTidynodeCMIsEmpty($node) | 0)) {
    $423 = HEAP32[$15 >> 2] | 0;
    if (($3 | 0) != 0 | ($423 | 0) != 7) {
     if (($423 | 0) == 7) HEAP32[$15 >> 2] = 5;
     $534 = HEAP32[$412 >> 2] | 0;
     L24 : do if ($534 | 0) {
      L26 : do if ((HEAP32[$534 + 20 >> 2] | 0) != 35) {
       switch (HEAP32[$534 >> 2] | 0) {
       case 110:
        {
         break L26;
         break;
        }
       case 94:
       case 103:
        break;
       default:
        break L24;
       }
       $594 = $mode | 25;
       $595 = $doc + 6724 | 0;
       $596 = HEAP32[$2 >> 2] | 0;
       $597 = $534;
       $node$tr$i$i = $node;
       while (1) {
        if ($597 | 0) if ((HEAP32[$597 >> 2] | 0) == 46) {
         label = 212;
         break;
        }
        $601 = HEAP32[$node$tr$i$i >> 2] | 0;
        if (!$601) {
         label = 218;
         break;
        }
        $597 = HEAP32[$601 + 28 >> 2] | 0;
        $node$tr$i$i = $601;
       }
       if ((label | 0) == 212) {
        $603 = $doc + 6736 | 0;
        if (HEAP32[$603 >> 2] | 0) _PFlushLineImpl($doc);
        if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
         _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
         $611 = $doc + 6744 | 0;
         HEAP32[$611 >> 2] = (HEAP32[$611 >> 2] | 0) + 1;
        }
        $614 = $doc + 6752 | 0;
        if ((HEAP32[$614 >> 2] | 0) == ($indent | 0)) $$pre$phiZ2D = $603; else {
         HEAP32[$614 >> 2] = $indent;
         $$pre$phiZ2D = $603;
        }
       } else if ((label | 0) == 218) $$pre$phiZ2D = $doc + 6736 | 0;
       if (HEAP32[$$pre$phiZ2D >> 2] | 0) {
        _PFlushLineImpl($doc);
        if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
         _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
         $624 = $doc + 6744 | 0;
         HEAP32[$624 >> 2] = (HEAP32[$624 >> 2] | 0) + 1;
        }
       }
       $627 = $doc + 6752 | 0;
       if ((HEAP32[$627 >> 2] | 0) != ($indent | 0)) HEAP32[$627 >> 2] = $indent;
       _PPrintTag($doc, $594, $indent, $node);
       if (HEAP32[$$pre$phiZ2D >> 2] | 0) _PFlushLineImpl($doc);
       $632 = $doc + 412 | 0;
       if ((HEAP32[$632 >> 2] | 0) != 2) {
        _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
        $637 = $doc + 6744 | 0;
        HEAP32[$637 >> 2] = (HEAP32[$637 >> 2] | 0) + 1;
       }
       if ((HEAP32[$627 >> 2] | 0) != ($indent | 0)) HEAP32[$627 >> 2] = $indent;
       $642 = ($596 | 0) != 0;
       $643 = $node + 12 | 0;
       do if ($642) if (!(HEAP32[$643 >> 2] | 0)) {
        $commentEnd$1$i = 317568;
        $commentStart$1$i = 317568;
        $hasCData$0$i = 0;
       } else {
        $646 = _prvTidyAttrGetById($node, 151) | 0;
        do if (!$646) {
         $commentEnd$0$i = 317568;
         $commentStart$0$i = 317568;
        } else {
         $648 = $646 + 24 | 0;
         $649 = HEAP32[$648 >> 2] | 0;
         if (!$649) {
          $commentEnd$0$i = 317568;
          $commentStart$0$i = 317568;
          break;
         }
         if (!(_prvTidytmbstrcasecmp($649, 310897) | 0)) {
          $commentEnd$0$i = 317568;
          $commentStart$0$i = 310932;
          break;
         }
         $$pr150 = HEAP32[$648 >> 2] | 0;
         if (!$$pr150) {
          $commentEnd$0$i = 317568;
          $commentStart$0$i = 317568;
          break;
         }
         if (!(_prvTidytmbstrcasecmp($$pr150, 311277) | 0)) {
          $commentEnd$0$i = 310929;
          $commentStart$0$i = 310935;
          break;
         }
         $$pr152$pr = HEAP32[$648 >> 2] | 0;
         if (!$$pr152$pr) {
          $commentEnd$0$i = 317568;
          $commentStart$0$i = 317568;
          break;
         }
         $658 = (_prvTidytmbstrcasecmp($$pr152$pr, 310913) | 0) == 0;
         $commentEnd$0$i = 317568;
         $commentStart$0$i = $658 ? 310927 : 317568;
        } while (0);
        $659 = HEAP32[$643 >> 2] | 0;
        $661 = HEAP32[$659 + 36 >> 2] | 0;
        if ((HEAP32[$659 + 44 >> 2] | 0) == 4) {
         $675 = (_prvTidytmbsubstrn((HEAP32[(HEAP32[$doc + 68 >> 2] | 0) + 84 >> 2] | 0) + $661 | 0, 1 - $661 + (HEAP32[$659 + 40 >> 2] | 0) | 0, 310839) | 0) != 0;
         if ($675) {
          $commentEnd$1$i = $commentEnd$0$i;
          $commentStart$1$i = $commentStart$0$i;
          $hasCData$0$i = $675 & 1;
          break;
         }
        }
        $678 = HEAP32[$doc + 80 >> 2] | 0;
        _prvTidySetOptionInt($doc, 2, -1) | 0;
        $679 = HEAP32[$$pre$phiZ2D >> 2] | 0;
        $680 = _prvTidytmbstrlen($commentStart$0$i) | 0;
        $681 = $680 + $679 | 0;
        $682 = $doc + 6732 | 0;
        $683 = HEAP32[$682 >> 2] | 0;
        do if ($681 >>> 0 >= $683 >>> 0) {
         $buflen$0$i$i$i$i = ($683 | 0) == 0 ? 256 : $683;
         while (1) if ($buflen$0$i$i$i$i >>> 0 > $681 >>> 0) {
          $buflen$0$i$i$i$i$lcssa = $buflen$0$i$i$i$i;
          break;
         } else $buflen$0$i$i$i$i = $buflen$0$i$i$i$i << 1;
         $688 = HEAP32[$595 >> 2] | 0;
         $692 = $doc + 6728 | 0;
         $695 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$688 >> 2] | 0) + 4 >> 2] & 15]($688, HEAP32[$692 >> 2] | 0, $buflen$0$i$i$i$i$lcssa << 2) | 0;
         if (!$695) break;
         $697 = HEAP32[$682 >> 2] | 0;
         _memset($695 + ($697 << 2) | 0, 0, $buflen$0$i$i$i$i$lcssa - $697 << 2 | 0) | 0;
         HEAP32[$682 >> 2] = $buflen$0$i$i$i$i$lcssa;
         HEAP32[$692 >> 2] = $695;
        } while (0);
        if ($680 | 0) {
         $$pre$i$i$i = HEAP32[$doc + 6728 >> 2] | 0;
         $ix$01$i$i$i = 0;
         do {
          HEAP32[$$pre$i$i$i + ($ix$01$i$i$i + $679 << 2) >> 2] = HEAP8[$commentStart$0$i + $ix$01$i$i$i >> 0];
          $ix$01$i$i$i = $ix$01$i$i$i + 1 | 0;
         } while (($ix$01$i$i$i | 0) != ($680 | 0));
        }
        HEAP32[$$pre$phiZ2D >> 2] = $681;
        $709 = _prvTidytmbstrlen(310839) | 0;
        $710 = $709 + $681 | 0;
        $711 = HEAP32[$682 >> 2] | 0;
        do if ($710 >>> 0 >= $711 >>> 0) {
         $buflen$0$i$i$i11$i = ($711 | 0) == 0 ? 256 : $711;
         while (1) if ($buflen$0$i$i$i11$i >>> 0 > $710 >>> 0) {
          $buflen$0$i$i$i11$i$lcssa = $buflen$0$i$i$i11$i;
          break;
         } else $buflen$0$i$i$i11$i = $buflen$0$i$i$i11$i << 1;
         $716 = HEAP32[$595 >> 2] | 0;
         $720 = $doc + 6728 | 0;
         $723 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$716 >> 2] | 0) + 4 >> 2] & 15]($716, HEAP32[$720 >> 2] | 0, $buflen$0$i$i$i11$i$lcssa << 2) | 0;
         if (!$723) break;
         $725 = HEAP32[$682 >> 2] | 0;
         _memset($723 + ($725 << 2) | 0, 0, $buflen$0$i$i$i11$i$lcssa - $725 << 2 | 0) | 0;
         HEAP32[$682 >> 2] = $buflen$0$i$i$i11$i$lcssa;
         HEAP32[$720 >> 2] = $723;
        } while (0);
        if ($709 | 0) {
         $$pre$i$i13$i = HEAP32[$doc + 6728 >> 2] | 0;
         $ix$01$i$i15$i = 0;
         do {
          HEAP32[$$pre$i$i13$i + ($ix$01$i$i15$i + $681 << 2) >> 2] = HEAP8[310839 + $ix$01$i$i15$i >> 0];
          $ix$01$i$i15$i = $ix$01$i$i15$i + 1 | 0;
         } while (($ix$01$i$i15$i | 0) != ($709 | 0));
        }
        HEAP32[$$pre$phiZ2D >> 2] = $710;
        $737 = _prvTidytmbstrlen($commentEnd$0$i) | 0;
        $738 = $737 + $710 | 0;
        $739 = HEAP32[$682 >> 2] | 0;
        do if ($738 >>> 0 >= $739 >>> 0) {
         $buflen$0$i$i$i20$i = ($739 | 0) == 0 ? 256 : $739;
         while (1) if ($buflen$0$i$i$i20$i >>> 0 > $738 >>> 0) {
          $buflen$0$i$i$i20$i$lcssa = $buflen$0$i$i$i20$i;
          break;
         } else $buflen$0$i$i$i20$i = $buflen$0$i$i$i20$i << 1;
         $744 = HEAP32[$595 >> 2] | 0;
         $748 = $doc + 6728 | 0;
         $751 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$744 >> 2] | 0) + 4 >> 2] & 15]($744, HEAP32[$748 >> 2] | 0, $buflen$0$i$i$i20$i$lcssa << 2) | 0;
         if (!$751) break;
         $753 = HEAP32[$682 >> 2] | 0;
         _memset($751 + ($753 << 2) | 0, 0, $buflen$0$i$i$i20$i$lcssa - $753 << 2 | 0) | 0;
         HEAP32[$682 >> 2] = $buflen$0$i$i$i20$i$lcssa;
         HEAP32[$748 >> 2] = $751;
        } while (0);
        if ($737 | 0) {
         $$pre$i$i22$i = HEAP32[$doc + 6728 >> 2] | 0;
         $ix$01$i$i24$i = 0;
         do {
          HEAP32[$$pre$i$i22$i + ($ix$01$i$i24$i + $710 << 2) >> 2] = HEAP8[$commentEnd$0$i + $ix$01$i$i24$i >> 0];
          $ix$01$i$i24$i = $ix$01$i$i24$i + 1 | 0;
         } while (($ix$01$i$i24$i | 0) != ($737 | 0));
        }
        HEAP32[$$pre$phiZ2D >> 2] = $738;
        do if ($738 | 0) {
         _PFlushLineImpl($doc);
         if ((HEAP32[$632 >> 2] | 0) == 2) break;
         _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
         $770 = $doc + 6744 | 0;
         HEAP32[$770 >> 2] = (HEAP32[$770 >> 2] | 0) + 1;
        } while (0);
        if ((HEAP32[$627 >> 2] | 0) != ($indent | 0)) HEAP32[$627 >> 2] = $indent;
        _prvTidySetOptionInt($doc, 2, $678) | 0;
        $commentEnd$1$i = $commentEnd$0$i;
        $commentStart$1$i = $commentStart$0$i;
        $hasCData$0$i = 0;
       } else {
        $commentEnd$1$i = 317568;
        $commentStart$1$i = 317568;
        $hasCData$0$i = 0;
       } while (0);
       $content$0$i178 = HEAP32[$643 >> 2] | 0;
       if (!$content$0$i178) label = 283; else {
        $776 = $node + 16 | 0;
        $777 = $doc + 68 | 0;
        $content$0$i180 = $content$0$i178;
        $contentIndent$0$i179 = -1;
        while (1) {
         _prvTidyPPrintTree($doc, $594, $indent, $content$0$i180);
         do if (($content$0$i180 | 0) == (HEAP32[$776 >> 2] | 0)) {
          $780 = HEAP32[$777 >> 2] | 0;
          if (!(_prvTidynodeIsText($content$0$i180) | 0)) {
           $contentIndent$1$i = -1;
           break;
          }
          $784 = HEAP32[$content$0$i180 + 40 >> 2] | 0;
          $786 = HEAP32[$content$0$i180 + 36 >> 2] | 0;
          if ($784 >>> 0 <= $786 >>> 0) {
           $contentIndent$1$i = -1;
           break;
          }
          $ix$06$i$i = $784 + -1 | 0;
          $790 = HEAP32[$780 + 84 >> 2] | 0;
          L128 : do if ($ix$06$i$i >>> 0 > $786 >>> 0) {
           $ix$07$i$i = $ix$06$i$i;
           while (1) {
            switch (HEAP8[$790 + $ix$07$i$i >> 0] | 0) {
            case 9:
            case 32:
            case 13:
             break;
            default:
             {
              $ix$0$lcssa$i$i = $ix$07$i$i;
              break L128;
             }
            }
            $ix$0$i$i = $ix$07$i$i + -1 | 0;
            if ($ix$0$i$i >>> 0 > $786 >>> 0) $ix$07$i$i = $ix$0$i$i; else {
             $ix$0$lcssa$i$i = $ix$0$i$i;
             break L128;
            }
           }
          } else $ix$0$lcssa$i$i = $ix$06$i$i; while (0);
          if ((HEAP8[$790 + $ix$0$lcssa$i$i >> 0] | 0) != 10) {
           $contentIndent$1$i = -1;
           break;
          }
          $contentIndent$1$i = $784 + ~$ix$0$lcssa$i$i | 0;
         } else $contentIndent$1$i = $contentIndent$0$i179; while (0);
         $content$0$i180 = HEAP32[$content$0$i180 + 8 >> 2] | 0;
         if (!$content$0$i180) {
          $contentIndent$1$i$lcssa = $contentIndent$1$i;
          break;
         } else $contentIndent$0$i179 = $contentIndent$1$i;
        }
        if (($contentIndent$1$i$lcssa | 0) < 0) label = 283;
       }
       do if ((label | 0) == 283) {
        do if (HEAP32[$$pre$phiZ2D >> 2] | 0) {
         _PFlushLineImpl($doc);
         if ((HEAP32[$632 >> 2] | 0) == 2) break;
         _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
         $808 = $doc + 6744 | 0;
         HEAP32[$808 >> 2] = (HEAP32[$808 >> 2] | 0) + 1;
        } while (0);
        if ((HEAP32[$627 >> 2] | 0) == ($indent | 0)) break;
        HEAP32[$627 >> 2] = $indent;
       } while (0);
       do if ($642) {
        $813 = HEAP32[$643 >> 2] | 0;
        if (($hasCData$0$i | 0) != 0 | ($813 | 0) == 0) {
         $915 = $813;
         break;
        }
        $817 = HEAP32[$doc + 80 >> 2] | 0;
        _prvTidySetOptionInt($doc, 2, -1) | 0;
        $818 = HEAP32[$$pre$phiZ2D >> 2] | 0;
        $819 = _prvTidytmbstrlen($commentStart$1$i) | 0;
        $820 = $819 + $818 | 0;
        $821 = $doc + 6732 | 0;
        $822 = HEAP32[$821 >> 2] | 0;
        do if ($820 >>> 0 >= $822 >>> 0) {
         $buflen$0$i$i$i31$i = ($822 | 0) == 0 ? 256 : $822;
         while (1) if ($buflen$0$i$i$i31$i >>> 0 > $820 >>> 0) {
          $buflen$0$i$i$i31$i$lcssa = $buflen$0$i$i$i31$i;
          break;
         } else $buflen$0$i$i$i31$i = $buflen$0$i$i$i31$i << 1;
         $827 = HEAP32[$595 >> 2] | 0;
         $831 = $doc + 6728 | 0;
         $834 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$827 >> 2] | 0) + 4 >> 2] & 15]($827, HEAP32[$831 >> 2] | 0, $buflen$0$i$i$i31$i$lcssa << 2) | 0;
         if (!$834) break;
         $836 = HEAP32[$821 >> 2] | 0;
         _memset($834 + ($836 << 2) | 0, 0, $buflen$0$i$i$i31$i$lcssa - $836 << 2 | 0) | 0;
         HEAP32[$821 >> 2] = $buflen$0$i$i$i31$i$lcssa;
         HEAP32[$831 >> 2] = $834;
        } while (0);
        if ($819 | 0) {
         $$pre$i$i33$i = HEAP32[$doc + 6728 >> 2] | 0;
         $ix$01$i$i35$i = 0;
         do {
          HEAP32[$$pre$i$i33$i + ($ix$01$i$i35$i + $818 << 2) >> 2] = HEAP8[$commentStart$1$i + $ix$01$i$i35$i >> 0];
          $ix$01$i$i35$i = $ix$01$i$i35$i + 1 | 0;
         } while (($ix$01$i$i35$i | 0) != ($819 | 0));
        }
        HEAP32[$$pre$phiZ2D >> 2] = $820;
        $848 = _prvTidytmbstrlen(310849) | 0;
        $849 = $848 + $820 | 0;
        $850 = HEAP32[$821 >> 2] | 0;
        do if ($849 >>> 0 >= $850 >>> 0) {
         $buflen$0$i$i$i40$i = ($850 | 0) == 0 ? 256 : $850;
         while (1) if ($buflen$0$i$i$i40$i >>> 0 > $849 >>> 0) {
          $buflen$0$i$i$i40$i$lcssa = $buflen$0$i$i$i40$i;
          break;
         } else $buflen$0$i$i$i40$i = $buflen$0$i$i$i40$i << 1;
         $855 = HEAP32[$595 >> 2] | 0;
         $859 = $doc + 6728 | 0;
         $862 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$855 >> 2] | 0) + 4 >> 2] & 15]($855, HEAP32[$859 >> 2] | 0, $buflen$0$i$i$i40$i$lcssa << 2) | 0;
         if (!$862) break;
         $864 = HEAP32[$821 >> 2] | 0;
         _memset($862 + ($864 << 2) | 0, 0, $buflen$0$i$i$i40$i$lcssa - $864 << 2 | 0) | 0;
         HEAP32[$821 >> 2] = $buflen$0$i$i$i40$i$lcssa;
         HEAP32[$859 >> 2] = $862;
        } while (0);
        if ($848 | 0) {
         $$pre$i$i42$i = HEAP32[$doc + 6728 >> 2] | 0;
         $ix$01$i$i44$i = 0;
         do {
          HEAP32[$$pre$i$i42$i + ($ix$01$i$i44$i + $820 << 2) >> 2] = HEAP8[310849 + $ix$01$i$i44$i >> 0];
          $ix$01$i$i44$i = $ix$01$i$i44$i + 1 | 0;
         } while (($ix$01$i$i44$i | 0) != ($848 | 0));
        }
        HEAP32[$$pre$phiZ2D >> 2] = $849;
        $876 = _prvTidytmbstrlen($commentEnd$1$i) | 0;
        $877 = $876 + $849 | 0;
        $878 = HEAP32[$821 >> 2] | 0;
        do if ($877 >>> 0 >= $878 >>> 0) {
         $buflen$0$i$i$i49$i = ($878 | 0) == 0 ? 256 : $878;
         while (1) if ($buflen$0$i$i$i49$i >>> 0 > $877 >>> 0) {
          $buflen$0$i$i$i49$i$lcssa = $buflen$0$i$i$i49$i;
          break;
         } else $buflen$0$i$i$i49$i = $buflen$0$i$i$i49$i << 1;
         $883 = HEAP32[$595 >> 2] | 0;
         $887 = $doc + 6728 | 0;
         $890 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$883 >> 2] | 0) + 4 >> 2] & 15]($883, HEAP32[$887 >> 2] | 0, $buflen$0$i$i$i49$i$lcssa << 2) | 0;
         if (!$890) break;
         $892 = HEAP32[$821 >> 2] | 0;
         _memset($890 + ($892 << 2) | 0, 0, $buflen$0$i$i$i49$i$lcssa - $892 << 2 | 0) | 0;
         HEAP32[$821 >> 2] = $buflen$0$i$i$i49$i$lcssa;
         HEAP32[$887 >> 2] = $890;
        } while (0);
        if ($876 | 0) {
         $$pre$i$i51$i = HEAP32[$doc + 6728 >> 2] | 0;
         $ix$01$i$i53$i = 0;
         do {
          HEAP32[$$pre$i$i51$i + ($ix$01$i$i53$i + $849 << 2) >> 2] = HEAP8[$commentEnd$1$i + $ix$01$i$i53$i >> 0];
          $ix$01$i$i53$i = $ix$01$i$i53$i + 1 | 0;
         } while (($ix$01$i$i53$i | 0) != ($876 | 0));
        }
        HEAP32[$$pre$phiZ2D >> 2] = $877;
        _prvTidySetOptionInt($doc, 2, $817) | 0;
        do if (HEAP32[$$pre$phiZ2D >> 2] | 0) {
         _PFlushLineImpl($doc);
         if ((HEAP32[$632 >> 2] | 0) == 2) break;
         _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
         $910 = $doc + 6744 | 0;
         HEAP32[$910 >> 2] = (HEAP32[$910 >> 2] | 0) + 1;
        } while (0);
        if ((HEAP32[$627 >> 2] | 0) == ($indent | 0)) {
         label = 319;
         break;
        }
        HEAP32[$627 >> 2] = $indent;
        label = 319;
       } else label = 319; while (0);
       if ((label | 0) == 319) $915 = HEAP32[$643 >> 2] | 0;
       do if ($915 | 0) {
        if ((HEAP32[$627 >> 2] | 0) == ($indent | 0)) break;
        HEAP32[$627 >> 2] = $indent;
       } while (0);
       _PPrintEndTag($doc, HEAP32[$node + 32 >> 2] | 0);
       if (HEAP32[$doc + 152 >> 2] | 0) return;
       if (!(HEAP32[$node + 8 >> 2] | 0)) return;
       if (_prvTidynodeHasCM($node, 16) | 0) return;
       if (_prvTidynodeIsText($node) | 0) return;
       if (HEAP32[$$pre$phiZ2D >> 2] | 0) _PFlushLineImpl($doc);
       if ((HEAP32[$632 >> 2] | 0) != 2) {
        _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
        $935 = $doc + 6744 | 0;
        HEAP32[$935 >> 2] = (HEAP32[$935 >> 2] | 0) + 1;
       }
       if ((HEAP32[$627 >> 2] | 0) == ($indent | 0)) return;
       HEAP32[$627 >> 2] = $indent;
       return;
      } while (0);
      $540 = $doc + 412 | 0;
      $542 = (HEAP32[$540 >> 2] | 0) == 1;
      $543 = $doc + 6736 | 0;
      if (HEAP32[$543 >> 2] | 0) {
       _PFlushLineImpl($doc);
       if ((HEAP32[$540 >> 2] | 0) != 2) {
        _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
        $550 = $doc + 6744 | 0;
        HEAP32[$550 >> 2] = (HEAP32[$550 >> 2] | 0) + 1;
       }
      }
      $553 = $doc + 6752 | 0;
      if ((HEAP32[$553 >> 2] | 0) != ($indent | 0)) HEAP32[$553 >> 2] = $indent;
      if ($542) {
       $556 = HEAP32[$node >> 2] | 0;
       if ($556 | 0) if ((HEAP32[$556 + 12 >> 2] | 0) != ($node | 0)) {
        if (HEAP32[$543 >> 2] | 0) _PFlushLineImpl($doc);
        if ((HEAP32[$540 >> 2] | 0) != 2) {
         _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
         $567 = $doc + 6744 | 0;
         HEAP32[$567 >> 2] = (HEAP32[$567 >> 2] | 0) + 1;
        }
        if ((HEAP32[$553 >> 2] | 0) != ($indent | 0)) HEAP32[$553 >> 2] = $indent;
       }
      }
      _PPrintTag($doc, $mode, $indent, $node);
      $content$1174 = HEAP32[$node + 12 >> 2] | 0;
      if ($content$1174 | 0) {
       $574 = $mode | 9;
       $content$1175 = $content$1174;
       do {
        _prvTidyPPrintTree($doc, $574, 0, $content$1175);
        $content$1175 = HEAP32[$content$1175 + 8 >> 2] | 0;
       } while (($content$1175 | 0) != 0);
      }
      _PPrintEndTag($doc, HEAP32[$node + 32 >> 2] | 0);
      if (HEAP32[$doc + 152 >> 2] | 0) return;
      if (!(HEAP32[$node + 8 >> 2] | 0)) return;
      if (HEAP32[$543 >> 2] | 0) _PFlushLineImpl($doc);
      if ((HEAP32[$540 >> 2] | 0) != 2) {
       _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
       $589 = $doc + 6744 | 0;
       HEAP32[$589 >> 2] = (HEAP32[$589 >> 2] | 0) + 1;
      }
      if ((HEAP32[$553 >> 2] | 0) == ($indent | 0)) return;
      HEAP32[$553 >> 2] = $indent;
      return;
     } while (0);
     if (_prvTidynodeCMIsInline($node) | 0) {
      if (HEAP32[$doc + 200 >> 2] | 0) {
       $945 = HEAP32[$412 >> 2] | 0;
       if ($945 | 0) if ((HEAP32[$945 >> 2] | 0) == 70) {
        $content$2170 = HEAP32[$node + 12 >> 2] | 0;
        if (!$content$2170) return;
        $951 = $mode | 8;
        $content$2171 = $content$2170;
        do {
         _prvTidyPPrintTree($doc, $951, $indent, $content$2171);
         $content$2171 = HEAP32[$content$2171 + 8 >> 2] | 0;
        } while (($content$2171 | 0) != 0);
        return;
       }
      }
      _PPrintTag($doc, $mode, $indent, $node);
      if (!(_ShouldIndent(HEAP32[$doc + 152 >> 2] | 0, $node) | 0)) {
       $content$4162 = HEAP32[$node + 12 >> 2] | 0;
       if ($content$4162 | 0) {
        $content$4163 = $content$4162;
        do {
         _prvTidyPPrintTree($doc, $mode, $indent, $content$4163);
         $content$4163 = HEAP32[$content$4163 + 8 >> 2] | 0;
        } while (($content$4163 | 0) != 0);
       }
      } else {
       $956 = $1 + $indent | 0;
       $957 = $doc + 6736 | 0;
       if (HEAP32[$957 >> 2] | 0) {
        _PFlushLineImpl($doc);
        if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
         _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
         $965 = $doc + 6744 | 0;
         HEAP32[$965 >> 2] = (HEAP32[$965 >> 2] | 0) + 1;
        }
       }
       $968 = $doc + 6752 | 0;
       if ((HEAP32[$968 >> 2] | 0) != ($956 | 0)) HEAP32[$968 >> 2] = $956;
       $content$3166 = HEAP32[$node + 12 >> 2] | 0;
       if ($content$3166 | 0) {
        $content$3167 = $content$3166;
        do {
         _prvTidyPPrintTree($doc, $mode, $956, $content$3167);
         $content$3167 = HEAP32[$content$3167 + 8 >> 2] | 0;
        } while (($content$3167 | 0) != 0);
       }
       if (HEAP32[$957 >> 2] | 0) {
        _PFlushLineImpl($doc);
        if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
         _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
         $982 = $doc + 6744 | 0;
         HEAP32[$982 >> 2] = (HEAP32[$982 >> 2] | 0) + 1;
        }
       }
       if ((HEAP32[$968 >> 2] | 0) != ($indent | 0)) HEAP32[$968 >> 2] = $indent;
      }
      _PPrintEndTag($doc, HEAP32[$node + 32 >> 2] | 0);
      return;
     }
     $991 = $doc + 152 | 0;
     $992 = HEAP32[$991 >> 2] | 0;
     $993 = ($992 | 0) != 0;
     $994 = ($992 | 0) == 2;
     if (!(HEAP32[$doc + 164 >> 2] | 0)) $1179 = (HEAP32[$doc + 160 >> 2] | 0) != 0; else $1179 = 1;
     $1001 = $doc + 412 | 0;
     $1003 = (HEAP32[$1001 >> 2] | 0) == 1;
     do if ($1003) {
      $1004 = HEAP32[$node >> 2] | 0;
      if ($1004 | 0) if ((HEAP32[$1004 + 12 >> 2] | 0) != ($node | 0)) {
       $1009 = HEAP32[$412 >> 2] | 0;
       if ($1009 | 0) if ((HEAP32[$1009 >> 2] | 0) == 48) break;
       if (!(HEAP32[$doc + 6736 >> 2] | 0)) label = 365; else {
        _PFlushLineImpl($doc);
        if ((HEAP32[$1001 >> 2] | 0) != 2) label = 365;
       }
       if ((label | 0) == 365) {
        _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
        $1019 = $doc + 6744 | 0;
        HEAP32[$1019 >> 2] = (HEAP32[$1019 >> 2] | 0) + 1;
       }
       $1022 = $doc + 6752 | 0;
       if ((HEAP32[$1022 >> 2] | 0) != ($indent | 0)) HEAP32[$1022 >> 2] = $indent;
      }
     } while (0);
     $1026 = (_ShouldIndent(HEAP32[$991 >> 2] | 0, $node) | 0) == 0;
     $indent$ = ($1026 ? 0 : $1) + $indent | 0;
     $1028 = $doc + 6736 | 0;
     if (HEAP32[$1028 >> 2] | 0) {
      _PFlushLineImpl($doc);
      if ((HEAP32[$1001 >> 2] | 0) != 2) {
       _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
       $1035 = $doc + 6744 | 0;
       HEAP32[$1035 >> 2] = (HEAP32[$1035 >> 2] | 0) + 1;
      }
     }
     $1038 = $doc + 6752 | 0;
     if ((HEAP32[$1038 >> 2] | 0) != ($indent | 0)) HEAP32[$1038 >> 2] = $indent;
     if ($994) if ($1003 & (HEAP32[$node + 4 >> 2] | 0) != 0) {
      if (HEAP32[$1028 >> 2] | 0) _PFlushLineImpl($doc);
      if ((HEAP32[$1001 >> 2] | 0) != 2) {
       _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
       $1050 = $doc + 6744 | 0;
       HEAP32[$1050 >> 2] = (HEAP32[$1050 >> 2] | 0) + 1;
      }
      if ((HEAP32[$1038 >> 2] | 0) != ($indent | 0)) HEAP32[$1038 >> 2] = $indent;
     }
     if ($1179) if (!(_prvTidynodeHasCM($node, 2097152) | 0)) label = 384; else if (!(HEAP32[$node + 20 >> 2] | 0)) {
      $1105 = (_ShouldIndent(HEAP32[$991 >> 2] | 0, $node) | 0) == 0;
      $contentIndent$1 = $indent$ - ($1105 ? 0 : $1) | 0;
     } else label = 384; else label = 384;
     L335 : do if ((label | 0) == 384) {
      _PPrintTag($doc, $mode, $indent, $node);
      if (_ShouldIndent(HEAP32[$991 >> 2] | 0, $node) | 0) {
       $1062 = HEAP32[$412 >> 2] | 0;
       do if ($1062 | 0) {
        if ((HEAP32[$1062 >> 2] | 0) != 61) break;
        if (_prvTidynodeIsText(HEAP32[$node + 12 >> 2] | 0) | 0) {
         $contentIndent$1 = $indent$;
         break L335;
        }
       } while (0);
       do if (HEAP32[$1028 >> 2] | 0) {
        _PFlushLineImpl($doc);
        if ((HEAP32[$1001 >> 2] | 0) == 2) break;
        _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
        $1076 = $doc + 6744 | 0;
        HEAP32[$1076 >> 2] = (HEAP32[$1076 >> 2] | 0) + 1;
       } while (0);
       if ((HEAP32[$1038 >> 2] | 0) == ($indent$ | 0)) {
        $contentIndent$1 = $indent$;
        break;
       }
       HEAP32[$1038 >> 2] = $indent$;
       $contentIndent$1 = $indent$;
       break;
      }
      do if (!(_prvTidynodeHasCM($node, 2) | 0)) {
       $1083 = HEAP32[$412 >> 2] | 0;
       if ($1083 | 0) if ((HEAP32[$1083 >> 2] | 0) == 72) break;
       if (!(_prvTidynodeHasCM($node, 4) | 0)) {
        $contentIndent$1 = $indent$;
        break L335;
       }
       $1089 = HEAP32[$412 >> 2] | 0;
       if (!$1089) break;
       if ((HEAP32[$1089 >> 2] | 0) == 114) {
        $contentIndent$1 = $indent$;
        break L335;
       }
      } while (0);
      if (HEAP32[$1028 >> 2] | 0) _PFlushLineImpl($doc);
      if ((HEAP32[$1001 >> 2] | 0) != 2) {
       _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
       $1099 = $doc + 6744 | 0;
       HEAP32[$1099 >> 2] = (HEAP32[$1099 >> 2] | 0) + 1;
      }
      if ((HEAP32[$1038 >> 2] | 0) == ($indent$ | 0)) {
       $contentIndent$1 = $indent$;
       break;
      }
      HEAP32[$1038 >> 2] = $indent$;
      $contentIndent$1 = $indent$;
     } while (0);
     $1107 = $node + 12 | 0;
     $content$5159 = HEAP32[$1107 >> 2] | 0;
     L365 : do if ($content$5159 | 0) {
      $1109 = $doc + 6780 | 0;
      $1110 = $doc + 6744 | 0;
      if ($993) {
       $content$5161$us = $content$5159;
       while (1) {
        _prvTidyPPrintTree($doc, $mode, $contentIndent$1, $content$5161$us);
        $content$5161$us = HEAP32[$content$5161$us + 8 >> 2] | 0;
        if (!$content$5161$us) break L365;
       }
      } else {
       $content$5161 = $content$5159;
       $last$0160 = 0;
      }
      while (1) {
       do if ($last$0160 | 0) {
        if (!(_prvTidynodeIsText($last$0160) | 0)) break;
        if (!(HEAP32[$content$5161 + 28 >> 2] | 0)) break;
        if (_prvTidynodeHasCM($content$5161, 16) | 0) break;
        if (HEAP32[$1028 >> 2] | 0) _PFlushLineImpl($doc);
        if ((HEAP32[$1001 >> 2] | 0) != 2) {
         _prvTidyWriteChar(10, HEAP32[$1109 >> 2] | 0);
         HEAP32[$1110 >> 2] = (HEAP32[$1110 >> 2] | 0) + 1;
        }
        if ((HEAP32[$1038 >> 2] | 0) == ($contentIndent$1 | 0)) break;
        HEAP32[$1038 >> 2] = $contentIndent$1;
       } while (0);
       _prvTidyPPrintTree($doc, $mode, $contentIndent$1, $content$5161);
       $content$5 = HEAP32[$content$5161 + 8 >> 2] | 0;
       if (!$content$5) break; else {
        $last$0160$phi = $content$5161;
        $content$5161 = $content$5;
        $last$0160 = $last$0160$phi;
       }
      }
     } while (0);
     L386 : do if (!(_ShouldIndent(HEAP32[$991 >> 2] | 0, $node) | 0)) {
      do if ($1179) {
       if (!(_prvTidynodeHasCM($node, 32768) | 0)) break;
       if ((HEAP32[$1038 >> 2] | 0) == ($indent | 0)) {
        label = 460;
        break L386;
       }
       HEAP32[$1038 >> 2] = $indent;
       label = 460;
       break L386;
      } else {
       if (_prvTidynodeHasCM($node, 2) | 0) {
        label = 428;
        break L386;
       }
       $1136 = HEAP32[$412 >> 2] | 0;
       if ($1136 | 0) if ((HEAP32[$1136 >> 2] | 0) == 72) {
        label = 428;
        break L386;
       }
       if (!(_prvTidynodeHasCM($node, 4) | 0)) break;
       $1142 = HEAP32[$412 >> 2] | 0;
       if (!$1142) {
        label = 428;
        break L386;
       }
       if ((HEAP32[$1142 >> 2] | 0) != 114) {
        label = 428;
        break L386;
       }
      } while (0);
      L400 : do if ($1003) {
       $node$01$i = HEAP32[$1107 >> 2] | 0;
       if ($node$01$i | 0) {
        $node$02$i = $node$01$i;
        do {
         if (_prvTidynodeIsText($node$02$i) | 0) break L400;
         $node$02$i = HEAP32[$node$02$i + 8 >> 2] | 0;
        } while (($node$02$i | 0) != 0);
       }
       if (HEAP32[$1028 >> 2] | 0) _PFlushLineImpl($doc);
       if ((HEAP32[$1001 >> 2] | 0) != 2) {
        _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
        $1172 = $doc + 6744 | 0;
        HEAP32[$1172 >> 2] = (HEAP32[$1172 >> 2] | 0) + 1;
       }
       if ((HEAP32[$1038 >> 2] | 0) == ($indent | 0)) break;
       HEAP32[$1038 >> 2] = $indent;
      } while (0);
      _PPrintEndTag($doc, HEAP32[$node + 32 >> 2] | 0);
      label = 450;
     } else label = 428; while (0);
     do if ((label | 0) == 428) {
      do if (HEAP32[$1028 >> 2] | 0) {
       _PFlushLineImpl($doc);
       if ((HEAP32[$1001 >> 2] | 0) == 2) break;
       _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
       $1152 = $doc + 6744 | 0;
       HEAP32[$1152 >> 2] = (HEAP32[$1152 >> 2] | 0) + 1;
      } while (0);
      if ((HEAP32[$1038 >> 2] | 0) != ($indent | 0)) HEAP32[$1038 >> 2] = $indent;
      if ($1179) if (_prvTidynodeHasCM($node, 32768) | 0) {
       label = 460;
       break;
      }
      _PPrintEndTag($doc, HEAP32[$node + 32 >> 2] | 0);
      label = 450;
     } while (0);
     do if ((label | 0) == 450) if ($993 | $1179) label = 460; else {
      $1180 = HEAP32[$412 >> 2] | 0;
      if (!$1180) {
       if ($1003) break;
      } else if ($1003 | (HEAP32[$1180 >> 2] | 0) == 48) {
       label = 460;
       break;
      }
      if (HEAP32[$1028 >> 2] | 0) _PFlushLineImpl($doc);
      if ((HEAP32[$1001 >> 2] | 0) != 2) {
       _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
       $1190 = $doc + 6744 | 0;
       HEAP32[$1190 >> 2] = (HEAP32[$1190 >> 2] | 0) + 1;
      }
      if ((HEAP32[$1038 >> 2] | 0) == ($indent | 0)) return;
      HEAP32[$1038 >> 2] = $indent;
      return;
     } while (0);
     if ((label | 0) == 460) if (!$1003) return;
     if (!(HEAP32[$node + 8 >> 2] | 0)) return;
     if (!(_prvTidynodeHasCM($node, 232) | 0)) return;
     if (HEAP32[$1028 >> 2] | 0) _PFlushLineImpl($doc);
     if ((HEAP32[$1001 >> 2] | 0) != 2) {
      _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
      $1206 = $doc + 6744 | 0;
      HEAP32[$1206 >> 2] = (HEAP32[$1206 >> 2] | 0) + 1;
     }
     if ((HEAP32[$1038 >> 2] | 0) == ($indent | 0)) return;
     HEAP32[$1038 >> 2] = $indent;
     return;
    }
   }
   if (!(_prvTidynodeHasCM($node, 16) | 0)) {
    if (HEAP32[$doc + 6736 >> 2] | 0) {
     _PFlushLineImpl($doc);
     if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
      _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
      $436 = $doc + 6744 | 0;
      HEAP32[$436 >> 2] = (HEAP32[$436 >> 2] | 0) + 1;
     }
    }
    $439 = $doc + 6752 | 0;
    if ((HEAP32[$439 >> 2] | 0) != ($indent | 0)) HEAP32[$439 >> 2] = $indent;
   }
   $442 = HEAP32[$412 >> 2] | 0;
   if ($442 | 0) {
    do if ((HEAP32[$442 >> 2] | 0) == 17) {
     $447 = HEAP32[$node + 4 >> 2] | 0;
     if ($447 | 0) {
      $450 = HEAP32[$447 + 28 >> 2] | 0;
      if (!$450) {
       if ($mode & 1 | 0) break;
      } else if (!(($mode & 1 | 0) == 0 & (HEAP32[$450 >> 2] | 0) != 17)) break;
      if (HEAP32[$doc + 232 >> 2] | 0) {
       if (HEAP32[$doc + 6736 >> 2] | 0) _PFlushLineImpl($doc);
       if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
        _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
        $467 = $doc + 6744 | 0;
        HEAP32[$467 >> 2] = (HEAP32[$467 >> 2] | 0) + 1;
       }
       $470 = $doc + 6752 | 0;
       if ((HEAP32[$470 >> 2] | 0) != ($indent | 0)) HEAP32[$470 >> 2] = $indent;
      }
     }
    } while (0);
    $$pr = HEAP32[$412 >> 2] | 0;
    if ($$pr | 0) if ((HEAP32[$$pr >> 2] | 0) == 47) {
     $476 = $doc + 412 | 0;
     if ((HEAP32[$476 >> 2] | 0) == 1) {
      $479 = HEAP32[$node >> 2] | 0;
      if ($479 | 0) if ((HEAP32[$479 + 12 >> 2] | 0) != ($node | 0)) {
       if (!(HEAP32[$doc + 6736 >> 2] | 0)) label = 159; else {
        _PFlushLineImpl($doc);
        if ((HEAP32[$476 >> 2] | 0) != 2) label = 159;
       }
       if ((label | 0) == 159) {
        _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
        $489 = $doc + 6744 | 0;
        HEAP32[$489 >> 2] = (HEAP32[$489 >> 2] | 0) + 1;
       }
       $492 = $doc + 6752 | 0;
       if ((HEAP32[$492 >> 2] | 0) != ($indent | 0)) HEAP32[$492 >> 2] = $indent;
      }
     }
    }
   }
   _PPrintTag($doc, $mode, $indent, $node);
   if (!(HEAP32[$node + 8 >> 2] | 0)) return;
   $498 = HEAP32[$412 >> 2] | 0;
   if (!$498) return;
   $500 = HEAP32[$498 >> 2] | 0;
   switch ($500 | 0) {
   case 7:
   case 81:
    {
     if (HEAP32[$doc + 6736 >> 2] | 0) {
      _PFlushLineImpl($doc);
      if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
       _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
       $509 = $doc + 6744 | 0;
       HEAP32[$509 >> 2] = (HEAP32[$509 >> 2] | 0) + 1;
      }
     }
     $512 = $doc + 6752 | 0;
     if ((HEAP32[$512 >> 2] | 0) == ($indent | 0)) return;
     HEAP32[$512 >> 2] = $indent;
     return;
    }
   default:
    {}
   }
   if (!(($mode & 1 | 0) == 0 & ($500 | 0) == 17 | ($500 | 0) == 47)) return;
   if (HEAP32[$doc + 6736 >> 2] | 0) _PFlushLineImpl($doc);
   if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
    _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
    $527 = $doc + 6744 | 0;
    HEAP32[$527 >> 2] = (HEAP32[$527 >> 2] | 0) + 1;
   }
   $530 = $doc + 6752 | 0;
   if ((HEAP32[$530 >> 2] | 0) == ($indent | 0)) return;
   HEAP32[$530 >> 2] = $indent;
   return;
  }
 } while (0);
}

function ___floatscan($f, $prec, $pok) {
 $f = $f | 0;
 $prec = $prec | 0;
 $pok = $pok | 0;
 var $$0 = 0.0, $$010$i = 0, $$012$i = 0, $$07$i = 0, $$0710$i = 0, $$0711$i = 0, $$1$i = 0.0, $$111$be$i = 0, $$111$ph$i = 0, $$2$i = 0, $$24$i = 0, $$3$be$i = 0, $$3$lcssa$i = 0, $$3112$i = 0, $$in = 0, $$lcssa = 0, $$lcssa258 = 0, $$lcssa258$lcssa = 0, $$lcssa259 = 0, $$lcssa259$lcssa = 0, $$lcssa265 = 0, $$lcssa266 = 0, $$lcssa267 = 0, $$lcssa277 = 0, $$not$i = 0, $$pre$i = 0, $$pre$i17 = 0, $$pre$phi43$iZ2D = 0.0, $$sink$off0$i = 0, $0 = 0, $1 = 0, $115 = 0, $123 = 0, $125 = 0, $132 = 0, $139 = 0, $147 = 0, $15 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $16 = 0, $160 = 0, $164 = 0, $168 = 0, $170 = 0, $183 = 0.0, $190 = 0, $192 = 0, $2 = 0, $201 = 0, $205 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $223 = 0, $224 = 0, $225 = 0, $235 = 0, $236 = 0, $249 = 0, $251 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $270 = 0, $272 = 0, $283 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $295 = 0, $297 = 0, $298 = 0, $299 = 0, $300 = 0, $310 = 0.0, $322 = 0.0, $330 = 0, $331 = 0, $338 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $350 = 0, $358 = 0, $36 = 0, $360 = 0, $362 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $371 = 0, $376 = 0, $377 = 0, $381 = 0, $39 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $402 = 0, $403 = 0, $412 = 0, $413 = 0, $414 = 0, $42 = 0, $422 = 0, $426 = 0, $428 = 0, $429 = 0, $431 = 0, $444 = 0, $446 = 0, $456 = 0, $458 = 0, $470 = 0, $471 = 0, $472 = 0, $493 = 0, $505 = 0, $509 = 0, $512 = 0, $514 = 0, $515 = 0, $516 = 0, $519 = 0, $520 = 0, $532 = 0, $533 = 0, $534 = 0, $538 = 0, $540 = 0, $542 = 0, $543 = 0, $549 = 0, $551 = 0, $556 = 0, $559 = 0, $563 = 0, $566 = 0, $571 = 0, $575 = 0, $576 = 0, $578 = 0, $582 = 0, $584 = 0, $587 = 0, $588 = 0, $589 = 0, $590 = 0, $593 = 0, $594 = 0, $60 = 0, $602 = 0, $608 = 0, $609 = 0, $616 = 0, $618 = 0.0, $620 = 0, $624 = 0.0, $625 = 0.0, $628 = 0.0, $632 = 0, $635 = 0, $642 = 0.0, $660 = 0.0, $662 = 0, $668 = 0, $669 = 0, $67 = 0, $679 = 0, $69 = 0, $690 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $700 = 0, $701 = 0, $702 = 0, $703 = 0, $704 = 0, $705 = 0, $706 = 0, $707 = 0, $708 = 0, $709 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $720 = 0, $721 = 0, $722 = 0, $76 = 0, $82 = 0, $9 = 0, $90 = 0, $99 = 0, $a$0$lcssa161$i = 0, $a$093$i = 0, $a$1$i = 0, $a$1$i$lcssa = 0, $a$2$ph46$i = 0, $a$4$i = 0, $a$4$i$lcssa250 = 0, $a$4$i251 = 0, $a$4$ph$i = 0, $a$4$ph167$i = 0, $a$586$i = 0, $a$6$i = 0, $a$6$i$lcssa = 0, $a$6$i$lcssa$lcssa = 0, $bias$0$i = 0.0, $bias$0$i25 = 0.0, $bits$0$ph = 0, $c$0 = 0, $c$0$i = 0, $c$1$lcssa = 0, $c$1$ph$i = 0, $c$179 = 0, $c$2 = 0, $c$2$i = 0, $c$2$lcssa$i = 0, $c$377 = 0, $c$4 = 0, $c$5 = 0, $c$6 = 0, $carry$095$i = 0, $carry1$0$i = 0, $carry1$1$i = 0, $carry1$1$i$lcssa = 0, $carry1$1$i$lcssa$lcssa = 0, $carry4$089$i = 0, $d$0$i = 0, $denormal$0$i = 0, $denormal$2$i = 0, $e2$0$i19 = 0, $e2$0$ph$i = 0, $e2$1$i = 0, $e2$1$i248 = 0, $e2$1$ph$i = 0, $e2$1$ph166$i = 0, $e2$3$i = 0, $e2$4$i = 0, $emin$0$ph = 0, $frac$0$i = 0.0, $frac$1$i = 0.0, $frac$3$i = 0.0, $gotdig$0$i = 0, $gotdig$0$i$lcssa244 = 0, $gotdig$0$i12 = 0, $gotdig$0$i12$lcssa275 = 0, $gotdig$2$i = 0, $gotdig$2$i$lcssa = 0, $gotdig$2$i13 = 0, $gotdig$3$i = 0, $gotdig$3$lcssa$i = 0, $gotdig$3108$i = 0, $gotdig$3108$i$lcssa = 0, $gotdig$4$i = 0, $gotrad$0$i = 0, $gotrad$0$i$lcssa = 0, $gotrad$0$i14 = 0, $gotrad$1$i = 0, $gotrad$1$lcssa$i = 0, $gotrad$1109$i = 0, $gotrad$2$i = 0, $gottail$0$i = 0, $gottail$1$i = 0, $gottail$2$i = 0, $i$0$lcssa = 0, $i$078 = 0, $i$1 = 0, $i$276 = 0, $i$3 = 0, $i$4 = 0, $i$4$lcssa = 0, $j$0$lcssa$i = 0, $j$0111$i = 0, $j$0111$i$lcssa = 0, $j$075$i = 0, $j$076$i = 0, $j$077$i = 0, $j$2$i = 0, $j$3102$i = 0, $k$0$lcssa$i = 0, $k$0110$i = 0, $k$0110$i$lcssa = 0, $k$071$i = 0, $k$072$i = 0, $k$073$i = 0, $k$2$i = 0, $k$3$i = 0, $k$494$i = 0, $k$5$i = 0, $k$5$in$i = 0, $k$687$i = 0, $lnz$0$lcssa$i = 0, $lnz$0107$i = 0, $lnz$0107$i$lcssa = 0, $lnz$065$i = 0, $lnz$066$i = 0, $lnz$067$i = 0, $lnz$2$i = 0, $or$cond21$i = 0, $or$cond25$i = 0, $or$cond9$i = 0, $rp$0$lcssa162$i = 0, $rp$092$i = 0, $rp$1$i18 = 0, $rp$1$i18$lcssa = 0, $rp$2$ph44$i = 0, $rp$4$ph$i = 0, $rp$4$ph42$i = 0, $rp$585$i = 0, $rp$6$i = 0, $rp$6$i$lcssa = 0, $rp$6$i$lcssa$lcssa = 0, $scale$0$i = 0.0, $scale$1$i = 0.0, $scale$2$i = 0.0, $sign$0 = 0, $storemerge$i = 0, $sum$i = 0, $x$0$i = 0, $x$0$i$lcssa = 0, $x$1$i = 0, $x$2$i = 0, $x$3$lcssa$i = 0, $x$324$i = 0, $x$4$lcssa$i = 0, $x$419$i = 0, $x$5$i = 0, $x$i = 0, $y$0$i = 0.0, $y$0$i$lcssa = 0.0, $y$1$i = 0.0, $y$1$i24 = 0.0, $y$2$i = 0.0, $y$2$i26 = 0.0, $y$3$i = 0.0, $y$3$lcssa$i = 0.0, $y$320$i = 0.0, $y$4$i = 0.0, $z$0$i = 0, $z$1$i = 0, $z$1$ph45$i = 0, $z$10$1$i = 0, $z$10$i = 0, $z$2$i = 0, $z$3$i = 0, $z$3$i$lcssa = 0, $z$3$i$lcssa$lcssa = 0, $z$4$i = 0, $z$6$ph$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 512 | 0;
 $x$i = sp;
 switch ($prec | 0) {
 case 0:
  {
   $bits$0$ph = 24;
   $emin$0$ph = -149;
   label = 4;
   break;
  }
 case 1:
  {
   $bits$0$ph = 53;
   $emin$0$ph = -1074;
   label = 4;
   break;
  }
 case 2:
  {
   $bits$0$ph = 53;
   $emin$0$ph = -1074;
   label = 4;
   break;
  }
 default:
  $$0 = 0.0;
 }
 L4 : do if ((label | 0) == 4) {
  $0 = $f + 4 | 0;
  $1 = $f + 100 | 0;
  do {
   $2 = HEAP32[$0 >> 2] | 0;
   if ($2 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
    HEAP32[$0 >> 2] = $2 + 1;
    $9 = HEAPU8[$2 >> 0] | 0;
   } else $9 = ___shgetc($f) | 0;
  } while ((_isspace($9) | 0) != 0);
  $$lcssa277 = $9;
  L13 : do switch ($$lcssa277 | 0) {
  case 43:
  case 45:
   {
    $15 = 1 - ((($$lcssa277 | 0) == 45 & 1) << 1) | 0;
    $16 = HEAP32[$0 >> 2] | 0;
    if ($16 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
     HEAP32[$0 >> 2] = $16 + 1;
     $c$0 = HEAPU8[$16 >> 0] | 0;
     $sign$0 = $15;
     break L13;
    } else {
     $c$0 = ___shgetc($f) | 0;
     $sign$0 = $15;
     break L13;
    }
    break;
   }
  default:
   {
    $c$0 = $$lcssa277;
    $sign$0 = 1;
   }
  } while (0);
  $c$179 = $c$0;
  $i$078 = 0;
  while (1) {
   if (($c$179 | 32 | 0) != (HEAP8[316443 + $i$078 >> 0] | 0)) {
    $c$1$lcssa = $c$179;
    $i$0$lcssa = $i$078;
    break;
   }
   do if ($i$078 >>> 0 < 7) {
    $29 = HEAP32[$0 >> 2] | 0;
    if ($29 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
     HEAP32[$0 >> 2] = $29 + 1;
     $c$2 = HEAPU8[$29 >> 0] | 0;
     break;
    } else {
     $c$2 = ___shgetc($f) | 0;
     break;
    }
   } else $c$2 = $c$179; while (0);
   $36 = $i$078 + 1 | 0;
   if ($36 >>> 0 < 8) {
    $c$179 = $c$2;
    $i$078 = $36;
   } else {
    $c$1$lcssa = $c$2;
    $i$0$lcssa = $36;
    break;
   }
  }
  L29 : do switch ($i$0$lcssa | 0) {
  case 8:
   break;
  case 3:
   {
    label = 23;
    break;
   }
  default:
   {
    $39 = ($pok | 0) != 0;
    if ($39 & $i$0$lcssa >>> 0 > 3) if (($i$0$lcssa | 0) == 8) break L29; else {
     label = 23;
     break L29;
    }
    L34 : do if (!$i$0$lcssa) {
     $c$377 = $c$1$lcssa;
     $i$276 = 0;
     while (1) {
      if (($c$377 | 32 | 0) != (HEAP8[316452 + $i$276 >> 0] | 0)) {
       $c$5 = $c$377;
       $i$3 = $i$276;
       break L34;
      }
      do if ($i$276 >>> 0 < 2) {
       $60 = HEAP32[$0 >> 2] | 0;
       if ($60 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
        HEAP32[$0 >> 2] = $60 + 1;
        $c$4 = HEAPU8[$60 >> 0] | 0;
        break;
       } else {
        $c$4 = ___shgetc($f) | 0;
        break;
       }
      } else $c$4 = $c$377; while (0);
      $67 = $i$276 + 1 | 0;
      if ($67 >>> 0 < 3) {
       $c$377 = $c$4;
       $i$276 = $67;
      } else {
       $c$5 = $c$4;
       $i$3 = $67;
       break;
      }
     }
    } else {
     $c$5 = $c$1$lcssa;
     $i$3 = $i$0$lcssa;
    } while (0);
    switch ($i$3 | 0) {
    case 3:
     {
      $69 = HEAP32[$0 >> 2] | 0;
      if ($69 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
       HEAP32[$0 >> 2] = $69 + 1;
       $76 = HEAPU8[$69 >> 0] | 0;
      } else $76 = ___shgetc($f) | 0;
      if (($76 | 0) == 40) $i$4 = 1; else {
       if (!(HEAP32[$1 >> 2] | 0)) {
        $$0 = nan;
        break L4;
       }
       HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
       $$0 = nan;
       break L4;
      }
      while (1) {
       $82 = HEAP32[$0 >> 2] | 0;
       if ($82 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
        HEAP32[$0 >> 2] = $82 + 1;
        $90 = HEAPU8[$82 >> 0] | 0;
       } else $90 = ___shgetc($f) | 0;
       if (!(($90 + -48 | 0) >>> 0 < 10 | ($90 + -65 | 0) >>> 0 < 26)) if (!(($90 | 0) == 95 | ($90 + -97 | 0) >>> 0 < 26)) {
        $$lcssa = $90;
        $i$4$lcssa = $i$4;
        break;
       }
       $i$4 = $i$4 + 1 | 0;
      }
      if (($$lcssa | 0) == 41) {
       $$0 = nan;
       break L4;
      }
      $99 = (HEAP32[$1 >> 2] | 0) == 0;
      if (!$99) HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
      if (!$39) {
       HEAP32[(___errno_location() | 0) >> 2] = 22;
       ___shlim($f, 0);
       $$0 = 0.0;
       break L4;
      }
      if (!$i$4$lcssa) {
       $$0 = nan;
       break L4;
      } else $$in = $i$4$lcssa;
      while (1) {
       $$in = $$in + -1 | 0;
       if (!$99) HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
       if (!$$in) {
        $$0 = nan;
        break L4;
       }
      }
      break;
     }
    case 0:
     {
      do if (($c$5 | 0) == 48) {
       $115 = HEAP32[$0 >> 2] | 0;
       if ($115 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
        HEAP32[$0 >> 2] = $115 + 1;
        $123 = HEAPU8[$115 >> 0] | 0;
       } else $123 = ___shgetc($f) | 0;
       if (($123 | 32 | 0) != 120) {
        if (!(HEAP32[$1 >> 2] | 0)) {
         $c$6 = 48;
         break;
        }
        HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
        $c$6 = 48;
        break;
       }
       $125 = HEAP32[$0 >> 2] | 0;
       if ($125 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
        HEAP32[$0 >> 2] = $125 + 1;
        $c$0$i = HEAPU8[$125 >> 0] | 0;
        $gotdig$0$i = 0;
       } else {
        $c$0$i = ___shgetc($f) | 0;
        $gotdig$0$i = 0;
       }
       L94 : while (1) {
        switch ($c$0$i | 0) {
        case 46:
         {
          $gotdig$0$i$lcssa244 = $gotdig$0$i;
          label = 74;
          break L94;
          break;
         }
        case 48:
         break;
        default:
         {
          $168 = 0;
          $170 = 0;
          $693 = 0;
          $694 = 0;
          $c$2$i = $c$0$i;
          $gotdig$2$i = $gotdig$0$i;
          $gotrad$0$i = 0;
          $gottail$0$i = 0;
          $scale$0$i = 1.0;
          $x$0$i = 0;
          $y$0$i = 0.0;
          break L94;
         }
        }
        $132 = HEAP32[$0 >> 2] | 0;
        if ($132 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
         HEAP32[$0 >> 2] = $132 + 1;
         $c$0$i = HEAPU8[$132 >> 0] | 0;
         $gotdig$0$i = 1;
         continue;
        } else {
         $c$0$i = ___shgetc($f) | 0;
         $gotdig$0$i = 1;
         continue;
        }
       }
       if ((label | 0) == 74) {
        $139 = HEAP32[$0 >> 2] | 0;
        if ($139 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
         HEAP32[$0 >> 2] = $139 + 1;
         $c$1$ph$i = HEAPU8[$139 >> 0] | 0;
        } else $c$1$ph$i = ___shgetc($f) | 0;
        if (($c$1$ph$i | 0) == 48) {
         $154 = 0;
         $155 = 0;
         while (1) {
          $147 = HEAP32[$0 >> 2] | 0;
          if ($147 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
           HEAP32[$0 >> 2] = $147 + 1;
           $158 = HEAPU8[$147 >> 0] | 0;
          } else $158 = ___shgetc($f) | 0;
          $156 = _i64Add($154 | 0, $155 | 0, -1, -1) | 0;
          $157 = tempRet0;
          if (($158 | 0) == 48) {
           $154 = $156;
           $155 = $157;
          } else {
           $168 = 0;
           $170 = 0;
           $693 = $156;
           $694 = $157;
           $c$2$i = $158;
           $gotdig$2$i = 1;
           $gotrad$0$i = 1;
           $gottail$0$i = 0;
           $scale$0$i = 1.0;
           $x$0$i = 0;
           $y$0$i = 0.0;
           break;
          }
         }
        } else {
         $168 = 0;
         $170 = 0;
         $693 = 0;
         $694 = 0;
         $c$2$i = $c$1$ph$i;
         $gotdig$2$i = $gotdig$0$i$lcssa244;
         $gotrad$0$i = 1;
         $gottail$0$i = 0;
         $scale$0$i = 1.0;
         $x$0$i = 0;
         $y$0$i = 0.0;
        }
       }
       while (1) {
        $160 = $c$2$i + -48 | 0;
        $$pre$i = $c$2$i | 32;
        if ($160 >>> 0 < 10) label = 86; else {
         $164 = ($c$2$i | 0) == 46;
         if (!($164 | ($$pre$i + -97 | 0) >>> 0 < 6)) {
          $212 = $693;
          $213 = $170;
          $215 = $694;
          $216 = $168;
          $c$2$lcssa$i = $c$2$i;
          $gotdig$2$i$lcssa = $gotdig$2$i;
          $gotrad$0$i$lcssa = $gotrad$0$i;
          $x$0$i$lcssa = $x$0$i;
          $y$0$i$lcssa = $y$0$i;
          break;
         }
         if ($164) if (!$gotrad$0$i) {
          $695 = $170;
          $696 = $168;
          $697 = $170;
          $698 = $168;
          $gotdig$3$i = $gotdig$2$i;
          $gotrad$1$i = 1;
          $gottail$2$i = $gottail$0$i;
          $scale$2$i = $scale$0$i;
          $x$2$i = $x$0$i;
          $y$2$i = $y$0$i;
         } else {
          $212 = $693;
          $213 = $170;
          $215 = $694;
          $216 = $168;
          $c$2$lcssa$i = 46;
          $gotdig$2$i$lcssa = $gotdig$2$i;
          $gotrad$0$i$lcssa = $gotrad$0$i;
          $x$0$i$lcssa = $x$0$i;
          $y$0$i$lcssa = $y$0$i;
          break;
         } else label = 86;
        }
        if ((label | 0) == 86) {
         label = 0;
         $d$0$i = ($c$2$i | 0) > 57 ? $$pre$i + -87 | 0 : $160;
         do if (($168 | 0) < 0 | ($168 | 0) == 0 & $170 >>> 0 < 8) {
          $gottail$1$i = $gottail$0$i;
          $scale$1$i = $scale$0$i;
          $x$1$i = $d$0$i + ($x$0$i << 4) | 0;
          $y$1$i = $y$0$i;
         } else {
          if (($168 | 0) < 0 | ($168 | 0) == 0 & $170 >>> 0 < 14) {
           $183 = $scale$0$i * .0625;
           $gottail$1$i = $gottail$0$i;
           $scale$1$i = $183;
           $x$1$i = $x$0$i;
           $y$1$i = $y$0$i + $183 * +($d$0$i | 0);
           break;
          }
          if (($gottail$0$i | 0) != 0 | ($d$0$i | 0) == 0) {
           $gottail$1$i = $gottail$0$i;
           $scale$1$i = $scale$0$i;
           $x$1$i = $x$0$i;
           $y$1$i = $y$0$i;
          } else {
           $gottail$1$i = 1;
           $scale$1$i = $scale$0$i;
           $x$1$i = $x$0$i;
           $y$1$i = $y$0$i + $scale$0$i * .5;
          }
         } while (0);
         $190 = _i64Add($170 | 0, $168 | 0, 1, 0) | 0;
         $695 = $693;
         $696 = $694;
         $697 = $190;
         $698 = tempRet0;
         $gotdig$3$i = 1;
         $gotrad$1$i = $gotrad$0$i;
         $gottail$2$i = $gottail$1$i;
         $scale$2$i = $scale$1$i;
         $x$2$i = $x$1$i;
         $y$2$i = $y$1$i;
        }
        $192 = HEAP32[$0 >> 2] | 0;
        if ($192 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
         HEAP32[$0 >> 2] = $192 + 1;
         $168 = $698;
         $170 = $697;
         $693 = $695;
         $694 = $696;
         $c$2$i = HEAPU8[$192 >> 0] | 0;
         $gotdig$2$i = $gotdig$3$i;
         $gotrad$0$i = $gotrad$1$i;
         $gottail$0$i = $gottail$2$i;
         $scale$0$i = $scale$2$i;
         $x$0$i = $x$2$i;
         $y$0$i = $y$2$i;
         continue;
        } else {
         $168 = $698;
         $170 = $697;
         $693 = $695;
         $694 = $696;
         $c$2$i = ___shgetc($f) | 0;
         $gotdig$2$i = $gotdig$3$i;
         $gotrad$0$i = $gotrad$1$i;
         $gottail$0$i = $gottail$2$i;
         $scale$0$i = $scale$2$i;
         $x$0$i = $x$2$i;
         $y$0$i = $y$2$i;
         continue;
        }
       }
       if (!$gotdig$2$i$lcssa) {
        $201 = (HEAP32[$1 >> 2] | 0) == 0;
        if (!$201) HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
        if (!$pok) ___shlim($f, 0); else if (!$201) {
         $205 = HEAP32[$0 >> 2] | 0;
         HEAP32[$0 >> 2] = $205 + -1;
         if ($gotrad$0$i$lcssa | 0) HEAP32[$0 >> 2] = $205 + -2;
        }
        $$0 = +($sign$0 | 0) * 0.0;
        break L4;
       }
       $211 = ($gotrad$0$i$lcssa | 0) == 0;
       $214 = $211 ? $213 : $212;
       $217 = $211 ? $216 : $215;
       if (($216 | 0) < 0 | ($216 | 0) == 0 & $213 >>> 0 < 8) {
        $224 = $213;
        $225 = $216;
        $x$324$i = $x$0$i$lcssa;
        while (1) {
         $223 = $x$324$i << 4;
         $224 = _i64Add($224 | 0, $225 | 0, 1, 0) | 0;
         $225 = tempRet0;
         if (!(($225 | 0) < 0 | ($225 | 0) == 0 & $224 >>> 0 < 8)) {
          $x$3$lcssa$i = $223;
          break;
         } else $x$324$i = $223;
        }
       } else $x$3$lcssa$i = $x$0$i$lcssa;
       if (($c$2$lcssa$i | 32 | 0) == 112) {
        $235 = _scanexp($f, $pok) | 0;
        $236 = tempRet0;
        if (($235 | 0) == 0 & ($236 | 0) == -2147483648) {
         if (!$pok) {
          ___shlim($f, 0);
          $$0 = 0.0;
          break L4;
         }
         if (!(HEAP32[$1 >> 2] | 0)) {
          $253 = 0;
          $254 = 0;
         } else {
          HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
          $253 = 0;
          $254 = 0;
         }
        } else {
         $253 = $235;
         $254 = $236;
        }
       } else if (!(HEAP32[$1 >> 2] | 0)) {
        $253 = 0;
        $254 = 0;
       } else {
        HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
        $253 = 0;
        $254 = 0;
       }
       $249 = _bitshift64Shl($214 | 0, $217 | 0, 2) | 0;
       $251 = _i64Add($249 | 0, tempRet0 | 0, -32, -1) | 0;
       $255 = _i64Add($251 | 0, tempRet0 | 0, $253 | 0, $254 | 0) | 0;
       $256 = tempRet0;
       if (!$x$3$lcssa$i) {
        $$0 = +($sign$0 | 0) * 0.0;
        break L4;
       }
       if (($256 | 0) > 0 | ($256 | 0) == 0 & $255 >>> 0 > (0 - $emin$0$ph | 0) >>> 0) {
        HEAP32[(___errno_location() | 0) >> 2] = 34;
        $$0 = +($sign$0 | 0) * 1797693134862315708145274.0e284 * 1797693134862315708145274.0e284;
        break L4;
       }
       $270 = $emin$0$ph + -106 | 0;
       $272 = (($270 | 0) < 0) << 31 >> 31;
       if (($256 | 0) < ($272 | 0) | ($256 | 0) == ($272 | 0) & $255 >>> 0 < $270 >>> 0) {
        HEAP32[(___errno_location() | 0) >> 2] = 34;
        $$0 = +($sign$0 | 0) * 2.2250738585072014e-308 * 2.2250738585072014e-308;
        break L4;
       }
       if (($x$3$lcssa$i | 0) > -1) {
        $288 = $255;
        $289 = $256;
        $x$419$i = $x$3$lcssa$i;
        $y$320$i = $y$0$i$lcssa;
        while (1) {
         $283 = !($y$320$i >= .5);
         $287 = $283 & 1 | $x$419$i << 1;
         $x$5$i = $287 ^ 1;
         $y$4$i = $y$320$i + ($283 ? $y$320$i : $y$320$i + -1.0);
         $290 = _i64Add($288 | 0, $289 | 0, -1, -1) | 0;
         $291 = tempRet0;
         if (($287 | 0) > -1) {
          $288 = $290;
          $289 = $291;
          $x$419$i = $x$5$i;
          $y$320$i = $y$4$i;
         } else {
          $297 = $290;
          $298 = $291;
          $x$4$lcssa$i = $x$5$i;
          $y$3$lcssa$i = $y$4$i;
          break;
         }
        }
       } else {
        $297 = $255;
        $298 = $256;
        $x$4$lcssa$i = $x$3$lcssa$i;
        $y$3$lcssa$i = $y$0$i$lcssa;
       }
       $295 = _i64Subtract(32, 0, $emin$0$ph | 0, (($emin$0$ph | 0) < 0) << 31 >> 31 | 0) | 0;
       $299 = _i64Add($297 | 0, $298 | 0, $295 | 0, tempRet0 | 0) | 0;
       $300 = tempRet0;
       if (0 > ($300 | 0) | 0 == ($300 | 0) & $bits$0$ph >>> 0 > $299 >>> 0) if (($299 | 0) < 0) {
        $$0710$i = 0;
        label = 127;
       } else {
        $$07$i = $299;
        label = 125;
       } else {
        $$07$i = $bits$0$ph;
        label = 125;
       }
       if ((label | 0) == 125) if (($$07$i | 0) < 53) {
        $$0710$i = $$07$i;
        label = 127;
       } else {
        $$0711$i = $$07$i;
        $$pre$phi43$iZ2D = +($sign$0 | 0);
        $bias$0$i = 0.0;
       }
       if ((label | 0) == 127) {
        $310 = +($sign$0 | 0);
        $$0711$i = $$0710$i;
        $$pre$phi43$iZ2D = $310;
        $bias$0$i = +_copysignl(+_scalbn(1.0, 84 - $$0710$i | 0), $310);
       }
       $or$cond9$i = ($x$4$lcssa$i & 1 | 0) == 0 & ($y$3$lcssa$i != 0.0 & ($$0711$i | 0) < 32);
       $322 = $$pre$phi43$iZ2D * ($or$cond9$i ? 0.0 : $y$3$lcssa$i) + ($bias$0$i + $$pre$phi43$iZ2D * +((($or$cond9$i & 1) + $x$4$lcssa$i | 0) >>> 0)) - $bias$0$i;
       if (!($322 != 0.0)) HEAP32[(___errno_location() | 0) >> 2] = 34;
       $$0 = +_scalbnl($322, $297);
       break L4;
      } else $c$6 = $c$5; while (0);
      $sum$i = $emin$0$ph + $bits$0$ph | 0;
      $330 = 0 - $sum$i | 0;
      $$010$i = $c$6;
      $gotdig$0$i12 = 0;
      L184 : while (1) {
       switch ($$010$i | 0) {
       case 46:
        {
         $gotdig$0$i12$lcssa275 = $gotdig$0$i12;
         label = 138;
         break L184;
         break;
        }
       case 48:
        break;
       default:
        {
         $$2$i = $$010$i;
         $699 = 0;
         $700 = 0;
         $gotdig$2$i13 = $gotdig$0$i12;
         $gotrad$0$i14 = 0;
         break L184;
        }
       }
       $331 = HEAP32[$0 >> 2] | 0;
       if ($331 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
        HEAP32[$0 >> 2] = $331 + 1;
        $$010$i = HEAPU8[$331 >> 0] | 0;
        $gotdig$0$i12 = 1;
        continue;
       } else {
        $$010$i = ___shgetc($f) | 0;
        $gotdig$0$i12 = 1;
        continue;
       }
      }
      if ((label | 0) == 138) {
       $338 = HEAP32[$0 >> 2] | 0;
       if ($338 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
        HEAP32[$0 >> 2] = $338 + 1;
        $$111$ph$i = HEAPU8[$338 >> 0] | 0;
       } else $$111$ph$i = ___shgetc($f) | 0;
       if (($$111$ph$i | 0) == 48) {
        $346 = 0;
        $347 = 0;
        while (1) {
         $348 = _i64Add($346 | 0, $347 | 0, -1, -1) | 0;
         $349 = tempRet0;
         $350 = HEAP32[$0 >> 2] | 0;
         if ($350 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
          HEAP32[$0 >> 2] = $350 + 1;
          $$111$be$i = HEAPU8[$350 >> 0] | 0;
         } else $$111$be$i = ___shgetc($f) | 0;
         if (($$111$be$i | 0) == 48) {
          $346 = $348;
          $347 = $349;
         } else {
          $$2$i = $$111$be$i;
          $699 = $348;
          $700 = $349;
          $gotdig$2$i13 = 1;
          $gotrad$0$i14 = 1;
          break;
         }
        }
       } else {
        $$2$i = $$111$ph$i;
        $699 = 0;
        $700 = 0;
        $gotdig$2$i13 = $gotdig$0$i12$lcssa275;
        $gotrad$0$i14 = 1;
       }
      }
      HEAP32[$x$i >> 2] = 0;
      $358 = $$2$i + -48 | 0;
      $360 = ($$2$i | 0) == 46;
      L203 : do if ($360 | $358 >>> 0 < 10) {
       $362 = $x$i + 496 | 0;
       $$3112$i = $$2$i;
       $365 = 0;
       $366 = 0;
       $701 = $360;
       $702 = $358;
       $703 = $699;
       $704 = $700;
       $gotdig$3108$i = $gotdig$2$i13;
       $gotrad$1109$i = $gotrad$0$i14;
       $j$0111$i = 0;
       $k$0110$i = 0;
       $lnz$0107$i = 0;
       L205 : while (1) {
        do if ($701) if (!$gotrad$1109$i) {
         $705 = $365;
         $706 = $366;
         $707 = $365;
         $708 = $366;
         $gotdig$4$i = $gotdig$3108$i;
         $gotrad$2$i = 1;
         $j$2$i = $j$0111$i;
         $k$2$i = $k$0110$i;
         $lnz$2$i = $lnz$0107$i;
        } else {
         $709 = $703;
         $710 = $704;
         $711 = $365;
         $712 = $366;
         $gotdig$3108$i$lcssa = $gotdig$3108$i;
         $j$0111$i$lcssa = $j$0111$i;
         $k$0110$i$lcssa = $k$0110$i;
         $lnz$0107$i$lcssa = $lnz$0107$i;
         break L205;
        } else {
         $367 = _i64Add($365 | 0, $366 | 0, 1, 0) | 0;
         $368 = tempRet0;
         $369 = ($$3112$i | 0) != 48;
         if (($k$0110$i | 0) >= 125) {
          if (!$369) {
           $705 = $703;
           $706 = $704;
           $707 = $367;
           $708 = $368;
           $gotdig$4$i = $gotdig$3108$i;
           $gotrad$2$i = $gotrad$1109$i;
           $j$2$i = $j$0111$i;
           $k$2$i = $k$0110$i;
           $lnz$2$i = $lnz$0107$i;
           break;
          }
          HEAP32[$362 >> 2] = HEAP32[$362 >> 2] | 1;
          $705 = $703;
          $706 = $704;
          $707 = $367;
          $708 = $368;
          $gotdig$4$i = $gotdig$3108$i;
          $gotrad$2$i = $gotrad$1109$i;
          $j$2$i = $j$0111$i;
          $k$2$i = $k$0110$i;
          $lnz$2$i = $lnz$0107$i;
          break;
         }
         $371 = $x$i + ($k$0110$i << 2) | 0;
         if (!$j$0111$i) $storemerge$i = $702; else $storemerge$i = $$3112$i + -48 + ((HEAP32[$371 >> 2] | 0) * 10 | 0) | 0;
         HEAP32[$371 >> 2] = $storemerge$i;
         $376 = $j$0111$i + 1 | 0;
         $377 = ($376 | 0) == 9;
         $705 = $703;
         $706 = $704;
         $707 = $367;
         $708 = $368;
         $gotdig$4$i = 1;
         $gotrad$2$i = $gotrad$1109$i;
         $j$2$i = $377 ? 0 : $376;
         $k$2$i = ($377 & 1) + $k$0110$i | 0;
         $lnz$2$i = $369 ? $367 : $lnz$0107$i;
        } while (0);
        $381 = HEAP32[$0 >> 2] | 0;
        if ($381 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
         HEAP32[$0 >> 2] = $381 + 1;
         $$3$be$i = HEAPU8[$381 >> 0] | 0;
        } else $$3$be$i = ___shgetc($f) | 0;
        $702 = $$3$be$i + -48 | 0;
        $701 = ($$3$be$i | 0) == 46;
        if (!($701 | $702 >>> 0 < 10)) {
         $$3$lcssa$i = $$3$be$i;
         $393 = $705;
         $394 = $707;
         $396 = $706;
         $397 = $708;
         $gotdig$3$lcssa$i = $gotdig$4$i;
         $gotrad$1$lcssa$i = $gotrad$2$i;
         $j$0$lcssa$i = $j$2$i;
         $k$0$lcssa$i = $k$2$i;
         $lnz$0$lcssa$i = $lnz$2$i;
         label = 161;
         break L203;
        } else {
         $$3112$i = $$3$be$i;
         $365 = $707;
         $366 = $708;
         $703 = $705;
         $704 = $706;
         $gotdig$3108$i = $gotdig$4$i;
         $gotrad$1109$i = $gotrad$2$i;
         $j$0111$i = $j$2$i;
         $k$0110$i = $k$2$i;
         $lnz$0107$i = $lnz$2$i;
        }
       }
       $713 = $711;
       $714 = $712;
       $715 = $709;
       $716 = $710;
       $717 = ($gotdig$3108$i$lcssa | 0) != 0;
       $j$077$i = $j$0111$i$lcssa;
       $k$073$i = $k$0110$i$lcssa;
       $lnz$067$i = $lnz$0107$i$lcssa;
       label = 169;
      } else {
       $$3$lcssa$i = $$2$i;
       $393 = $699;
       $394 = 0;
       $396 = $700;
       $397 = 0;
       $gotdig$3$lcssa$i = $gotdig$2$i13;
       $gotrad$1$lcssa$i = $gotrad$0$i14;
       $j$0$lcssa$i = 0;
       $k$0$lcssa$i = 0;
       $lnz$0$lcssa$i = 0;
       label = 161;
      } while (0);
      do if ((label | 0) == 161) {
       $392 = ($gotrad$1$lcssa$i | 0) == 0;
       $395 = $392 ? $394 : $393;
       $398 = $392 ? $397 : $396;
       $399 = ($gotdig$3$lcssa$i | 0) != 0;
       if (!(($$3$lcssa$i | 32 | 0) == 101 & $399)) if (($$3$lcssa$i | 0) > -1) {
        $713 = $394;
        $714 = $397;
        $715 = $395;
        $716 = $398;
        $717 = $399;
        $j$077$i = $j$0$lcssa$i;
        $k$073$i = $k$0$lcssa$i;
        $lnz$067$i = $lnz$0$lcssa$i;
        label = 169;
        break;
       } else {
        $718 = $394;
        $719 = $397;
        $720 = $399;
        $721 = $395;
        $722 = $398;
        $j$076$i = $j$0$lcssa$i;
        $k$072$i = $k$0$lcssa$i;
        $lnz$066$i = $lnz$0$lcssa$i;
        label = 171;
        break;
       }
       $402 = _scanexp($f, $pok) | 0;
       $403 = tempRet0;
       if (($402 | 0) == 0 & ($403 | 0) == -2147483648) {
        if (!$pok) {
         ___shlim($f, 0);
         $$1$i = 0.0;
         break;
        }
        if (!(HEAP32[$1 >> 2] | 0)) {
         $412 = 0;
         $413 = 0;
        } else {
         HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
         $412 = 0;
         $413 = 0;
        }
       } else {
        $412 = $402;
        $413 = $403;
       }
       $414 = _i64Add($412 | 0, $413 | 0, $395 | 0, $398 | 0) | 0;
       $426 = $414;
       $428 = $394;
       $429 = tempRet0;
       $431 = $397;
       $j$075$i = $j$0$lcssa$i;
       $k$071$i = $k$0$lcssa$i;
       $lnz$065$i = $lnz$0$lcssa$i;
       label = 173;
      } while (0);
      if ((label | 0) == 169) if (!(HEAP32[$1 >> 2] | 0)) {
       $718 = $713;
       $719 = $714;
       $720 = $717;
       $721 = $715;
       $722 = $716;
       $j$076$i = $j$077$i;
       $k$072$i = $k$073$i;
       $lnz$066$i = $lnz$067$i;
       label = 171;
      } else {
       HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
       if ($717) {
        $426 = $715;
        $428 = $713;
        $429 = $716;
        $431 = $714;
        $j$075$i = $j$077$i;
        $k$071$i = $k$073$i;
        $lnz$065$i = $lnz$067$i;
        label = 173;
       } else label = 172;
      }
      if ((label | 0) == 171) if ($720) {
       $426 = $721;
       $428 = $718;
       $429 = $722;
       $431 = $719;
       $j$075$i = $j$076$i;
       $k$071$i = $k$072$i;
       $lnz$065$i = $lnz$066$i;
       label = 173;
      } else label = 172;
      do if ((label | 0) == 172) {
       HEAP32[(___errno_location() | 0) >> 2] = 22;
       ___shlim($f, 0);
       $$1$i = 0.0;
      } else if ((label | 0) == 173) {
       $422 = HEAP32[$x$i >> 2] | 0;
       if (!$422) {
        $$1$i = +($sign$0 | 0) * 0.0;
        break;
       }
       if ((($431 | 0) < 0 | ($431 | 0) == 0 & $428 >>> 0 < 10) & (($426 | 0) == ($428 | 0) & ($429 | 0) == ($431 | 0))) if ($bits$0$ph >>> 0 > 30 | ($422 >>> $bits$0$ph | 0) == 0) {
        $$1$i = +($sign$0 | 0) * +($422 >>> 0);
        break;
       }
       $444 = ($emin$0$ph | 0) / -2 | 0;
       $446 = (($444 | 0) < 0) << 31 >> 31;
       if (($429 | 0) > ($446 | 0) | ($429 | 0) == ($446 | 0) & $426 >>> 0 > $444 >>> 0) {
        HEAP32[(___errno_location() | 0) >> 2] = 34;
        $$1$i = +($sign$0 | 0) * 1797693134862315708145274.0e284 * 1797693134862315708145274.0e284;
        break;
       }
       $456 = $emin$0$ph + -106 | 0;
       $458 = (($456 | 0) < 0) << 31 >> 31;
       if (($429 | 0) < ($458 | 0) | ($429 | 0) == ($458 | 0) & $426 >>> 0 < $456 >>> 0) {
        HEAP32[(___errno_location() | 0) >> 2] = 34;
        $$1$i = +($sign$0 | 0) * 2.2250738585072014e-308 * 2.2250738585072014e-308;
        break;
       }
       if (!$j$075$i) $k$3$i = $k$071$i; else {
        if (($j$075$i | 0) < 9) {
         $470 = $x$i + ($k$071$i << 2) | 0;
         $472 = HEAP32[$470 >> 2] | 0;
         $j$3102$i = $j$075$i;
         while (1) {
          $471 = $472 * 10 | 0;
          $j$3102$i = $j$3102$i + 1 | 0;
          if (($j$3102$i | 0) == 9) {
           $$lcssa267 = $471;
           break;
          } else $472 = $471;
         }
         HEAP32[$470 >> 2] = $$lcssa267;
        }
        $k$3$i = $k$071$i + 1 | 0;
       }
       if (($lnz$065$i | 0) < 9) if (($lnz$065$i | 0) <= ($426 | 0) & ($426 | 0) < 18) {
        if (($426 | 0) == 9) {
         $$1$i = +($sign$0 | 0) * +((HEAP32[$x$i >> 2] | 0) >>> 0);
         break;
        }
        if (($426 | 0) < 9) {
         $$1$i = +($sign$0 | 0) * +((HEAP32[$x$i >> 2] | 0) >>> 0) / +(HEAP32[220776 + (8 - $426 << 2) >> 2] | 0);
         break;
        }
        $493 = $bits$0$ph + 27 + (Math_imul($426, -3) | 0) | 0;
        $$pre$i17 = HEAP32[$x$i >> 2] | 0;
        if (($493 | 0) > 30 | ($$pre$i17 >>> $493 | 0) == 0) {
         $$1$i = +($sign$0 | 0) * +($$pre$i17 >>> 0) * +(HEAP32[220776 + ($426 + -10 << 2) >> 2] | 0);
         break;
        }
       }
       $505 = ($426 | 0) % 9 | 0;
       if (!$505) {
        $a$2$ph46$i = 0;
        $e2$0$ph$i = 0;
        $rp$2$ph44$i = $426;
        $z$1$ph45$i = $k$3$i;
       } else {
        $509 = ($426 | 0) > -1 ? $505 : $505 + 9 | 0;
        $512 = HEAP32[220776 + (8 - $509 << 2) >> 2] | 0;
        if (!$k$3$i) {
         $a$0$lcssa161$i = 0;
         $rp$0$lcssa162$i = $426;
         $z$0$i = 0;
        } else {
         $514 = 1e9 / ($512 | 0) | 0;
         $a$093$i = 0;
         $carry$095$i = 0;
         $k$494$i = 0;
         $rp$092$i = $426;
         while (1) {
          $515 = $x$i + ($k$494$i << 2) | 0;
          $516 = HEAP32[$515 >> 2] | 0;
          $519 = (($516 >>> 0) / ($512 >>> 0) | 0) + $carry$095$i | 0;
          HEAP32[$515 >> 2] = $519;
          $520 = Math_imul(($516 >>> 0) % ($512 >>> 0) | 0, $514) | 0;
          $or$cond21$i = ($k$494$i | 0) == ($a$093$i | 0) & ($519 | 0) == 0;
          $k$494$i = $k$494$i + 1 | 0;
          $rp$1$i18 = $or$cond21$i ? $rp$092$i + -9 | 0 : $rp$092$i;
          $a$1$i = $or$cond21$i ? $k$494$i & 127 : $a$093$i;
          if (($k$494$i | 0) == ($k$3$i | 0)) {
           $$lcssa266 = $520;
           $a$1$i$lcssa = $a$1$i;
           $rp$1$i18$lcssa = $rp$1$i18;
           break;
          } else {
           $a$093$i = $a$1$i;
           $carry$095$i = $520;
           $rp$092$i = $rp$1$i18;
          }
         }
         if (!$$lcssa266) {
          $a$0$lcssa161$i = $a$1$i$lcssa;
          $rp$0$lcssa162$i = $rp$1$i18$lcssa;
          $z$0$i = $k$3$i;
         } else {
          HEAP32[$x$i + ($k$3$i << 2) >> 2] = $$lcssa266;
          $a$0$lcssa161$i = $a$1$i$lcssa;
          $rp$0$lcssa162$i = $rp$1$i18$lcssa;
          $z$0$i = $k$3$i + 1 | 0;
         }
        }
        $a$2$ph46$i = $a$0$lcssa161$i;
        $e2$0$ph$i = 0;
        $rp$2$ph44$i = 9 - $509 + $rp$0$lcssa162$i | 0;
        $z$1$ph45$i = $z$0$i;
       }
       L284 : while (1) {
        $532 = ($rp$2$ph44$i | 0) < 18;
        $533 = ($rp$2$ph44$i | 0) == 18;
        $534 = $x$i + ($a$2$ph46$i << 2) | 0;
        $e2$0$i19 = $e2$0$ph$i;
        $z$1$i = $z$1$ph45$i;
        while (1) {
         if (!$532) {
          if (!$533) {
           $a$4$ph$i = $a$2$ph46$i;
           $e2$1$ph$i = $e2$0$i19;
           $rp$4$ph42$i = $rp$2$ph44$i;
           $z$6$ph$i = $z$1$i;
           break L284;
          }
          if ((HEAP32[$534 >> 2] | 0) >>> 0 >= 9007199) {
           $a$4$ph$i = $a$2$ph46$i;
           $e2$1$ph$i = $e2$0$i19;
           $rp$4$ph42$i = 18;
           $z$6$ph$i = $z$1$i;
           break L284;
          }
         }
         $carry1$0$i = 0;
         $k$5$in$i = $z$1$i + 127 | 0;
         $z$2$i = $z$1$i;
         while (1) {
          $k$5$i = $k$5$in$i & 127;
          $538 = $x$i + ($k$5$i << 2) | 0;
          $540 = _bitshift64Shl(HEAP32[$538 >> 2] | 0, 0, 29) | 0;
          $542 = _i64Add($540 | 0, tempRet0 | 0, $carry1$0$i | 0, 0) | 0;
          $543 = tempRet0;
          if ($543 >>> 0 > 0 | ($543 | 0) == 0 & $542 >>> 0 > 1e9) {
           $549 = ___udivdi3($542 | 0, $543 | 0, 1e9, 0) | 0;
           $551 = ___uremdi3($542 | 0, $543 | 0, 1e9, 0) | 0;
           $$sink$off0$i = $551;
           $carry1$1$i = $549;
          } else {
           $$sink$off0$i = $542;
           $carry1$1$i = 0;
          }
          HEAP32[$538 >> 2] = $$sink$off0$i;
          $556 = ($k$5$i | 0) == ($a$2$ph46$i | 0);
          $z$3$i = ($k$5$i | 0) != ($z$2$i + 127 & 127 | 0) | $556 ? $z$2$i : ($$sink$off0$i | 0) == 0 ? $k$5$i : $z$2$i;
          if ($556) {
           $carry1$1$i$lcssa = $carry1$1$i;
           $z$3$i$lcssa = $z$3$i;
           break;
          } else {
           $carry1$0$i = $carry1$1$i;
           $k$5$in$i = $k$5$i + -1 | 0;
           $z$2$i = $z$3$i;
          }
         }
         $559 = $e2$0$i19 + -29 | 0;
         if (!$carry1$1$i$lcssa) {
          $e2$0$i19 = $559;
          $z$1$i = $z$3$i$lcssa;
         } else {
          $$lcssa265 = $559;
          $carry1$1$i$lcssa$lcssa = $carry1$1$i$lcssa;
          $z$3$i$lcssa$lcssa = $z$3$i$lcssa;
          break;
         }
        }
        $563 = $a$2$ph46$i + 127 & 127;
        if (($563 | 0) == ($z$3$i$lcssa$lcssa | 0)) {
         $566 = $z$3$i$lcssa$lcssa + 127 & 127;
         $571 = $x$i + (($z$3$i$lcssa$lcssa + 126 & 127) << 2) | 0;
         HEAP32[$571 >> 2] = HEAP32[$571 >> 2] | HEAP32[$x$i + ($566 << 2) >> 2];
         $z$4$i = $566;
        } else $z$4$i = $z$3$i$lcssa$lcssa;
        HEAP32[$x$i + ($563 << 2) >> 2] = $carry1$1$i$lcssa$lcssa;
        $a$2$ph46$i = $563;
        $e2$0$ph$i = $$lcssa265;
        $rp$2$ph44$i = $rp$2$ph44$i + 9 | 0;
        $z$1$ph45$i = $z$4$i;
       }
       L302 : while (1) {
        $602 = $z$6$ph$i + 1 & 127;
        $608 = $x$i + (($z$6$ph$i + 127 & 127) << 2) | 0;
        $a$4$ph167$i = $a$4$ph$i;
        $e2$1$ph166$i = $e2$1$ph$i;
        $rp$4$ph$i = $rp$4$ph42$i;
        while (1) {
         $609 = ($rp$4$ph$i | 0) == 18;
         $$24$i = ($rp$4$ph$i | 0) > 27 ? 9 : 1;
         $$not$i = $609 ^ 1;
         $a$4$i = $a$4$ph167$i;
         $e2$1$i = $e2$1$ph166$i;
         while (1) {
          $575 = $a$4$i & 127;
          $576 = ($575 | 0) == ($z$6$ph$i | 0);
          do if ($576) label = 219; else {
           $578 = HEAP32[$x$i + ($575 << 2) >> 2] | 0;
           if ($578 >>> 0 < 9007199) {
            label = 219;
            break;
           }
           if ($578 >>> 0 > 9007199) break;
           $582 = $a$4$i + 1 & 127;
           if (($582 | 0) == ($z$6$ph$i | 0)) {
            label = 219;
            break;
           }
           $690 = HEAP32[$x$i + ($582 << 2) >> 2] | 0;
           if ($690 >>> 0 < 254740991) {
            label = 219;
            break;
           }
           if (!($690 >>> 0 > 254740991 | $$not$i)) {
            $616 = $575;
            $a$4$i251 = $a$4$i;
            $e2$1$i248 = $e2$1$i;
            $z$10$i = $z$6$ph$i;
            break L302;
           }
          } while (0);
          if ((label | 0) == 219) {
           label = 0;
           if ($609) {
            label = 220;
            break L302;
           }
          }
          $584 = $e2$1$i + $$24$i | 0;
          if (($a$4$i | 0) == ($z$6$ph$i | 0)) {
           $a$4$i = $z$6$ph$i;
           $e2$1$i = $584;
          } else {
           $$lcssa258 = $584;
           $a$4$i$lcssa250 = $a$4$i;
           break;
          }
         }
         $587 = (1 << $$24$i) + -1 | 0;
         $588 = 1e9 >>> $$24$i;
         $a$586$i = $a$4$i$lcssa250;
         $carry4$089$i = 0;
         $k$687$i = $a$4$i$lcssa250;
         $rp$585$i = $rp$4$ph$i;
         while (1) {
          $589 = $x$i + ($k$687$i << 2) | 0;
          $590 = HEAP32[$589 >> 2] | 0;
          $593 = ($590 >>> $$24$i) + $carry4$089$i | 0;
          HEAP32[$589 >> 2] = $593;
          $594 = Math_imul($590 & $587, $588) | 0;
          $or$cond25$i = ($k$687$i | 0) == ($a$586$i | 0) & ($593 | 0) == 0;
          $k$687$i = $k$687$i + 1 & 127;
          $rp$6$i = $or$cond25$i ? $rp$585$i + -9 | 0 : $rp$585$i;
          $a$6$i = $or$cond25$i ? $k$687$i : $a$586$i;
          if (($k$687$i | 0) == ($z$6$ph$i | 0)) {
           $$lcssa259 = $594;
           $a$6$i$lcssa = $a$6$i;
           $rp$6$i$lcssa = $rp$6$i;
           break;
          } else {
           $a$586$i = $a$6$i;
           $carry4$089$i = $594;
           $rp$585$i = $rp$6$i;
          }
         }
         if (!$$lcssa259) {
          $a$4$ph167$i = $a$6$i$lcssa;
          $e2$1$ph166$i = $$lcssa258;
          $rp$4$ph$i = $rp$6$i$lcssa;
          continue;
         }
         if (($602 | 0) != ($a$6$i$lcssa | 0)) {
          $$lcssa258$lcssa = $$lcssa258;
          $$lcssa259$lcssa = $$lcssa259;
          $a$6$i$lcssa$lcssa = $a$6$i$lcssa;
          $rp$6$i$lcssa$lcssa = $rp$6$i$lcssa;
          break;
         }
         HEAP32[$608 >> 2] = HEAP32[$608 >> 2] | 1;
         $a$4$ph167$i = $a$6$i$lcssa;
         $e2$1$ph166$i = $$lcssa258;
         $rp$4$ph$i = $rp$6$i$lcssa;
        }
        HEAP32[$x$i + ($z$6$ph$i << 2) >> 2] = $$lcssa259$lcssa;
        $a$4$ph$i = $a$6$i$lcssa$lcssa;
        $e2$1$ph$i = $$lcssa258$lcssa;
        $rp$4$ph42$i = $rp$6$i$lcssa$lcssa;
        $z$6$ph$i = $602;
       }
       if ((label | 0) == 220) if ($576) {
        HEAP32[$x$i + ($602 + -1 << 2) >> 2] = 0;
        $616 = $z$6$ph$i;
        $a$4$i251 = $a$4$i;
        $e2$1$i248 = $e2$1$i;
        $z$10$i = $602;
       } else {
        $616 = $575;
        $a$4$i251 = $a$4$i;
        $e2$1$i248 = $e2$1$i;
        $z$10$i = $z$6$ph$i;
       }
       $618 = +((HEAP32[$x$i + ($616 << 2) >> 2] | 0) >>> 0);
       $620 = $a$4$i251 + 1 & 127;
       if (($620 | 0) == ($z$10$i | 0)) {
        $679 = $a$4$i251 + 2 & 127;
        HEAP32[$x$i + ($679 + -1 << 2) >> 2] = 0;
        $z$10$1$i = $679;
       } else $z$10$1$i = $z$10$i;
       $642 = +($sign$0 | 0);
       $624 = $642 * ($618 * 1.0e9 + +((HEAP32[$x$i + ($620 << 2) >> 2] | 0) >>> 0));
       $662 = $e2$1$i248 + 53 | 0;
       $668 = $662 - $emin$0$ph | 0;
       $669 = ($668 | 0) < ($bits$0$ph | 0);
       $denormal$0$i = $669 & 1;
       $$012$i = $669 ? (($668 | 0) < 0 ? 0 : $668) : $bits$0$ph;
       if (($$012$i | 0) < 53) {
        $625 = +_copysignl(+_scalbn(1.0, 105 - $$012$i | 0), $624);
        $628 = +_fmodl($624, +_scalbn(1.0, 53 - $$012$i | 0));
        $bias$0$i25 = $625;
        $frac$0$i = $628;
        $y$1$i24 = $625 + ($624 - $628);
       } else {
        $bias$0$i25 = 0.0;
        $frac$0$i = 0.0;
        $y$1$i24 = $624;
       }
       $632 = $a$4$i251 + 2 & 127;
       do if (($632 | 0) == ($z$10$1$i | 0)) $frac$3$i = $frac$0$i; else {
        $635 = HEAP32[$x$i + ($632 << 2) >> 2] | 0;
        do if ($635 >>> 0 < 5e8) {
         if (!$635) if (($a$4$i251 + 3 & 127 | 0) == ($z$10$1$i | 0)) {
          $frac$1$i = $frac$0$i;
          break;
         }
         $frac$1$i = $642 * .25 + $frac$0$i;
        } else {
         if ($635 >>> 0 > 5e8) {
          $frac$1$i = $642 * .75 + $frac$0$i;
          break;
         }
         if (($a$4$i251 + 3 & 127 | 0) == ($z$10$1$i | 0)) {
          $frac$1$i = $642 * .5 + $frac$0$i;
          break;
         } else {
          $frac$1$i = $642 * .75 + $frac$0$i;
          break;
         }
        } while (0);
        if ((53 - $$012$i | 0) <= 1) {
         $frac$3$i = $frac$1$i;
         break;
        }
        if (+_fmodl($frac$1$i, 1.0) != 0.0) {
         $frac$3$i = $frac$1$i;
         break;
        }
        $frac$3$i = $frac$1$i + 1.0;
       } while (0);
       $660 = $y$1$i24 + $frac$3$i - $bias$0$i25;
       do if (($662 & 2147483647 | 0) > (-2 - $sum$i | 0)) {
        if (!(+Math_abs(+$660) >= 9007199254740992.0)) {
         $denormal$2$i = $denormal$0$i;
         $e2$3$i = $e2$1$i248;
         $y$2$i26 = $660;
        } else {
         $denormal$2$i = $669 & ($$012$i | 0) == ($668 | 0) ? 0 : $denormal$0$i;
         $e2$3$i = $e2$1$i248 + 1 | 0;
         $y$2$i26 = $660 * .5;
        }
        if (($e2$3$i + 50 | 0) <= ($330 | 0)) if (!($frac$3$i != 0.0 & ($denormal$2$i | 0) != 0)) {
         $e2$4$i = $e2$3$i;
         $y$3$i = $y$2$i26;
         break;
        }
        HEAP32[(___errno_location() | 0) >> 2] = 34;
        $e2$4$i = $e2$3$i;
        $y$3$i = $y$2$i26;
       } else {
        $e2$4$i = $e2$1$i248;
        $y$3$i = $660;
       } while (0);
       $$1$i = +_scalbnl($y$3$i, $e2$4$i);
      } while (0);
      $$0 = $$1$i;
      break L4;
      break;
     }
    default:
     {
      if (HEAP32[$1 >> 2] | 0) HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
      HEAP32[(___errno_location() | 0) >> 2] = 22;
      ___shlim($f, 0);
      $$0 = 0.0;
      break L4;
     }
    }
   }
  } while (0);
  if ((label | 0) == 23) {
   $42 = (HEAP32[$1 >> 2] | 0) == 0;
   if (!$42) HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
   if (($pok | 0) != 0 & $i$0$lcssa >>> 0 > 3) {
    $i$1 = $i$0$lcssa;
    do {
     if (!$42) HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
     $i$1 = $i$1 + -1 | 0;
    } while ($i$1 >>> 0 > 3);
   }
  }
  $$0 = +($sign$0 | 0) * inf;
 } while (0);
 STACKTOP = sp;
 return +$$0;
}

function _printf_core($f, $fmt, $ap, $nl_arg, $nl_type) {
 $f = $f | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 $nl_arg = $nl_arg | 0;
 $nl_type = $nl_type | 0;
 var $$0 = 0, $$0$i = 0, $$0$lcssa$i = 0, $$012$i = 0, $$013$i = 0, $$03$i33 = 0, $$07$i = 0.0, $$1$i = 0.0, $$114$i = 0, $$2$i = 0.0, $$20$i = 0.0, $$210$i = 0, $$23$i = 0, $$25$i = 0, $$3$i = 0.0, $$311$i = 0, $$33$i = 0, $$4$i = 0.0, $$412$lcssa$i = 0, $$41278$i = 0, $$43 = 0, $$5$lcssa$i = 0, $$589$i = 0, $$a$3$i = 0, $$a$3192$i = 0, $$fl$4 = 0, $$lcssa = 0, $$lcssa162$i = 0, $$lcssa295 = 0, $$lcssa300 = 0, $$lcssa301 = 0, $$lcssa302 = 0, $$lcssa303 = 0, $$lcssa304 = 0, $$lcssa306 = 0, $$lcssa316 = 0, $$lcssa319 = 0.0, $$lcssa321 = 0, $$p$$i = 0, $$p$5 = 0, $$p$i = 0, $$pn$i = 0, $$pr$i = 0, $$pr50$i = 0, $$pre$phi190$iZ2D = 0, $$pre171 = 0, $$pre188$i = 0, $$z$4$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $107 = 0, $108 = 0, $11 = 0, $110 = 0, $12 = 0, $13 = 0, $134 = 0, $135 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $145 = 0, $147 = 0, $149 = 0, $15 = 0, $150 = 0, $155 = 0, $158 = 0, $16 = 0, $163 = 0, $164 = 0, $169 = 0, $176 = 0, $177 = 0, $188 = 0, $2 = 0, $200 = 0, $207 = 0, $209 = 0, $212 = 0, $213 = 0, $218 = 0, $22 = 0, $224 = 0, $225 = 0, $231 = 0, $24 = 0, $244 = 0, $246 = 0, $249 = 0, $25 = 0, $254 = 0, $257 = 0, $258 = 0, $267 = 0, $270 = 0, $272 = 0, $275 = 0, $277 = 0, $278 = 0, $279 = 0, $285 = 0, $287 = 0, $288 = 0, $29 = 0, $292 = 0, $3 = 0, $30 = 0, $300 = 0, $306 = 0, $318 = 0, $321 = 0, $322 = 0, $334 = 0, $336 = 0, $341 = 0, $345 = 0, $348 = 0, $35 = 0, $358 = 0.0, $365 = 0, $369 = 0, $376 = 0, $378 = 0, $380 = 0, $381 = 0, $385 = 0, $391 = 0.0, $392 = 0, $395 = 0, $397 = 0, $4 = 0, $40 = 0, $400 = 0, $402 = 0, $406 = 0.0, $41 = 0, $416 = 0, $419 = 0, $422 = 0, $431 = 0, $433 = 0, $434 = 0, $440 = 0, $45 = 0, $452 = 0, $457 = 0, $462 = 0, $466 = 0, $47 = 0, $476 = 0, $477 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $487 = 0, $489 = 0, $492 = 0, $494 = 0, $495 = 0, $496 = 0, $498 = 0, $5 = 0, $502 = 0, $504 = 0, $508 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $518 = 0, $52 = 0, $524 = 0, $525 = 0, $526 = 0, $530 = 0, $538 = 0, $552 = 0, $553 = 0, $556 = 0, $561 = 0, $562 = 0, $564 = 0, $57 = 0, $572 = 0, $575 = 0, $578 = 0, $579 = 0, $580 = 0, $583 = 0, $587 = 0, $595 = 0, $598 = 0, $6 = 0, $60 = 0, $600 = 0, $602 = 0, $604 = 0, $609 = 0, $61 = 0, $610 = 0, $613 = 0, $615 = 0, $617 = 0, $619 = 0, $62 = 0, $630 = 0, $633 = 0, $638 = 0, $647 = 0, $648 = 0, $652 = 0, $655 = 0, $657 = 0, $659 = 0, $66 = 0, $663 = 0, $666 = 0, $670 = 0, $68 = 0, $680 = 0, $685 = 0, $692 = 0, $697 = 0, $7 = 0, $705 = 0, $715 = 0, $719 = 0, $727 = 0, $734 = 0, $736 = 0, $740 = 0, $742 = 0, $751 = 0, $757 = 0, $772 = 0, $774 = 0, $787 = 0, $798 = 0, $8 = 0, $9 = 0, $92 = 0, $93 = 0, $99 = 0, $a$0 = 0, $a$1 = 0, $a$1$lcssa$i = 0, $a$1149$i = 0, $a$2 = 0, $a$2$ph$i = 0, $a$3$lcssa$i = 0, $a$3136$i = 0, $a$5$lcssa$i = 0, $a$5111$i = 0, $a$6$i = 0, $a$8$i = 0, $a$9$ph$i = 0, $arg = 0, $argpos$0 = 0, $big$i = 0, $buf = 0, $buf$i = 0, $carry$0142$i = 0, $carry3$0130$i = 0, $cnt$0 = 0, $cnt$1 = 0, $cnt$1$lcssa = 0, $d$0141$i = 0, $d$0143$i = 0, $d$1129$i = 0, $d$2$lcssa$i = 0, $d$2110$i = 0, $d$4$i = 0, $d$584$i = 0, $d$677$i = 0, $d$788$i = 0, $e$0125$i = 0, $e$1$i = 0, $e$2106$i = 0, $e$4$i = 0, $e$5$ph$i = 0, $e2$i = 0, $ebuf0$i = 0, $estr$0$i = 0, $estr$1$lcssa$i = 0, $estr$195$i = 0, $estr$2$i = 0, $fl$0100 = 0, $fl$053 = 0, $fl$1 = 0, $fl$1$ = 0, $fl$3 = 0, $fl$4 = 0, $fl$6 = 0, $i$0$lcssa = 0, $i$0$lcssa178 = 0, $i$0105 = 0, $i$0124$i = 0, $i$03$i = 0, $i$03$i25 = 0, $i$1$lcssa$i = 0, $i$1116 = 0, $i$1118$i = 0, $i$2105$i = 0, $i$291 = 0, $i$291$lcssa = 0, $i$3101$i = 0, $i$389 = 0, $isdigittmp = 0, $isdigittmp1$i = 0, $isdigittmp1$i22 = 0, $isdigittmp11 = 0, $isdigittmp4$i = 0, $isdigittmp4$i24 = 0, $isdigittmp9 = 0, $j$0117$i = 0, $j$0119$i = 0, $j$1102$i = 0, $j$2$i = 0, $l$0 = 0, $l$0$i = 0, $l$1104 = 0, $l$2 = 0, $l10n$0 = 0, $l10n$0$lcssa = 0, $l10n$1 = 0, $l10n$2 = 0, $l10n$3 = 0, $mb = 0, $notrhs$i = 0, $p$0 = 0, $p$1 = 0, $p$2 = 0, $p$4176 = 0, $p$5 = 0, $pl$0 = 0, $pl$0$i = 0, $pl$1 = 0, $pl$1$i = 0, $pl$2 = 0, $prefix$0 = 0, $prefix$0$$i = 0, $prefix$0$i = 0, $prefix$1 = 0, $prefix$2 = 0, $r$0$a$9$i = 0, $re$171$i = 0, $round$070$i = 0.0, $round6$1$i = 0.0, $s$0 = 0, $s$0$i = 0, $s$1 = 0, $s$1$i = 0, $s$1$i$lcssa = 0, $s$2$lcssa = 0, $s$292 = 0, $s$4 = 0, $s$6 = 0, $s$7 = 0, $s$7$lcssa298 = 0, $s7$081$i = 0, $s7$1$i = 0, $s8$0$lcssa$i = 0, $s8$072$i = 0, $s9$0$i = 0, $s9$185$i = 0, $s9$2$i = 0, $small$0$i = 0.0, $small$1$i = 0.0, $st$0 = 0, $st$0$lcssa299 = 0, $storemerge = 0, $storemerge13 = 0, $storemerge851 = 0, $storemerge899 = 0, $t$0 = 0, $t$1 = 0, $w$0 = 0, $w$1 = 0, $w$2 = 0, $wc = 0, $ws$0106 = 0, $ws$1117 = 0, $z$0$i = 0, $z$0$lcssa = 0, $z$093 = 0, $z$1$lcssa$i = 0, $z$1148$i = 0, $z$2 = 0, $z$2$i = 0, $z$2$i$lcssa = 0, $z$3$lcssa$i = 0, $z$3135$i = 0, $z$4$i = 0, $z$7$$i = 0, $z$7$i = 0, $z$7$i$lcssa = 0, $z$7$ph$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 624 | 0;
 $big$i = sp + 24 | 0;
 $e2$i = sp + 16 | 0;
 $buf$i = sp + 588 | 0;
 $ebuf0$i = sp + 576 | 0;
 $arg = sp;
 $buf = sp + 536 | 0;
 $wc = sp + 8 | 0;
 $mb = sp + 528 | 0;
 $0 = ($f | 0) != 0;
 $1 = $buf + 40 | 0;
 $2 = $1;
 $3 = $buf + 39 | 0;
 $4 = $wc + 4 | 0;
 $5 = $buf$i;
 $6 = 0 - $5 | 0;
 $7 = $ebuf0$i + 12 | 0;
 $8 = $ebuf0$i + 11 | 0;
 $9 = $7;
 $10 = $9 - $5 | 0;
 $11 = -2 - $5 | 0;
 $12 = $9 + 2 | 0;
 $13 = $big$i + 288 | 0;
 $14 = $buf$i + 9 | 0;
 $15 = $14;
 $16 = $buf$i + 8 | 0;
 $cnt$0 = 0;
 $l$0 = 0;
 $l10n$0 = 0;
 $s$0 = $fmt;
 L1 : while (1) {
  do if (($cnt$0 | 0) > -1) if (($l$0 | 0) > (2147483647 - $cnt$0 | 0)) {
   HEAP32[(___errno_location() | 0) >> 2] = 75;
   $cnt$1 = -1;
   break;
  } else {
   $cnt$1 = $l$0 + $cnt$0 | 0;
   break;
  } else $cnt$1 = $cnt$0; while (0);
  $22 = HEAP8[$s$0 >> 0] | 0;
  if (!($22 << 24 >> 24)) {
   $cnt$1$lcssa = $cnt$1;
   $l10n$0$lcssa = $l10n$0;
   label = 244;
   break;
  } else {
   $24 = $22;
   $s$1 = $s$0;
  }
  L9 : while (1) {
   switch ($24 << 24 >> 24) {
   case 37:
    {
     $s$292 = $s$1;
     $z$093 = $s$1;
     label = 9;
     break L9;
     break;
    }
   case 0:
    {
     $s$2$lcssa = $s$1;
     $z$0$lcssa = $s$1;
     break L9;
     break;
    }
   default:
    {}
   }
   $25 = $s$1 + 1 | 0;
   $24 = HEAP8[$25 >> 0] | 0;
   $s$1 = $25;
  }
  L12 : do if ((label | 0) == 9) while (1) {
   label = 0;
   if ((HEAP8[$s$292 + 1 >> 0] | 0) != 37) {
    $s$2$lcssa = $s$292;
    $z$0$lcssa = $z$093;
    break L12;
   }
   $29 = $z$093 + 1 | 0;
   $30 = $s$292 + 2 | 0;
   if ((HEAP8[$30 >> 0] | 0) == 37) {
    $s$292 = $30;
    $z$093 = $29;
    label = 9;
   } else {
    $s$2$lcssa = $30;
    $z$0$lcssa = $29;
    break;
   }
  } while (0);
  $35 = $z$0$lcssa - $s$0 | 0;
  if ($0) if (!(HEAP32[$f >> 2] & 32)) ___fwritex($s$0, $35, $f) | 0;
  if (($z$0$lcssa | 0) != ($s$0 | 0)) {
   $cnt$0 = $cnt$1;
   $l$0 = $35;
   $s$0 = $s$2$lcssa;
   continue;
  }
  $40 = $s$2$lcssa + 1 | 0;
  $41 = HEAP8[$40 >> 0] | 0;
  $isdigittmp = ($41 << 24 >> 24) + -48 | 0;
  if ($isdigittmp >>> 0 < 10) {
   $45 = (HEAP8[$s$2$lcssa + 2 >> 0] | 0) == 36;
   $$43 = $45 ? $s$2$lcssa + 3 | 0 : $40;
   $48 = HEAP8[$$43 >> 0] | 0;
   $argpos$0 = $45 ? $isdigittmp : -1;
   $l10n$1 = $45 ? 1 : $l10n$0;
   $storemerge = $$43;
  } else {
   $48 = $41;
   $argpos$0 = -1;
   $l10n$1 = $l10n$0;
   $storemerge = $40;
  }
  $47 = $48 << 24 >> 24;
  L25 : do if (($47 & -32 | 0) == 32) {
   $52 = $47;
   $57 = $48;
   $fl$0100 = 0;
   $storemerge899 = $storemerge;
   while (1) {
    if (!(1 << $52 + -32 & 75913)) {
     $66 = $57;
     $fl$053 = $fl$0100;
     $storemerge851 = $storemerge899;
     break L25;
    }
    $60 = 1 << ($57 << 24 >> 24) + -32 | $fl$0100;
    $61 = $storemerge899 + 1 | 0;
    $62 = HEAP8[$61 >> 0] | 0;
    $52 = $62 << 24 >> 24;
    if (($52 & -32 | 0) != 32) {
     $66 = $62;
     $fl$053 = $60;
     $storemerge851 = $61;
     break;
    } else {
     $57 = $62;
     $fl$0100 = $60;
     $storemerge899 = $61;
    }
   }
  } else {
   $66 = $48;
   $fl$053 = 0;
   $storemerge851 = $storemerge;
  } while (0);
  do if ($66 << 24 >> 24 == 42) {
   $68 = $storemerge851 + 1 | 0;
   $isdigittmp11 = (HEAP8[$68 >> 0] | 0) + -48 | 0;
   if ($isdigittmp11 >>> 0 < 10) if ((HEAP8[$storemerge851 + 2 >> 0] | 0) == 36) {
    HEAP32[$nl_type + ($isdigittmp11 << 2) >> 2] = 10;
    $l10n$2 = 1;
    $storemerge13 = $storemerge851 + 3 | 0;
    $w$0 = HEAP32[$nl_arg + ((HEAP8[$68 >> 0] | 0) + -48 << 3) >> 2] | 0;
   } else label = 24; else label = 24;
   if ((label | 0) == 24) {
    label = 0;
    if ($l10n$1 | 0) {
     $$0 = -1;
     break L1;
    }
    if (!$0) {
     $fl$1 = $fl$053;
     $l10n$3 = 0;
     $s$4 = $68;
     $w$1 = 0;
     break;
    }
    $92 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
    $93 = HEAP32[$92 >> 2] | 0;
    HEAP32[$ap >> 2] = $92 + 4;
    $l10n$2 = 0;
    $storemerge13 = $68;
    $w$0 = $93;
   }
   if (($w$0 | 0) < 0) {
    $fl$1 = $fl$053 | 8192;
    $l10n$3 = $l10n$2;
    $s$4 = $storemerge13;
    $w$1 = 0 - $w$0 | 0;
   } else {
    $fl$1 = $fl$053;
    $l10n$3 = $l10n$2;
    $s$4 = $storemerge13;
    $w$1 = $w$0;
   }
  } else {
   $isdigittmp1$i = ($66 << 24 >> 24) + -48 | 0;
   if ($isdigittmp1$i >>> 0 < 10) {
    $101 = $storemerge851;
    $i$03$i = 0;
    $isdigittmp4$i = $isdigittmp1$i;
    while (1) {
     $99 = ($i$03$i * 10 | 0) + $isdigittmp4$i | 0;
     $100 = $101 + 1 | 0;
     $isdigittmp4$i = (HEAP8[$100 >> 0] | 0) + -48 | 0;
     if ($isdigittmp4$i >>> 0 >= 10) {
      $$lcssa = $99;
      $$lcssa295 = $100;
      break;
     } else {
      $101 = $100;
      $i$03$i = $99;
     }
    }
    if (($$lcssa | 0) < 0) {
     $$0 = -1;
     break L1;
    } else {
     $fl$1 = $fl$053;
     $l10n$3 = $l10n$1;
     $s$4 = $$lcssa295;
     $w$1 = $$lcssa;
    }
   } else {
    $fl$1 = $fl$053;
    $l10n$3 = $l10n$1;
    $s$4 = $storemerge851;
    $w$1 = 0;
   }
  } while (0);
  L46 : do if ((HEAP8[$s$4 >> 0] | 0) == 46) {
   $107 = $s$4 + 1 | 0;
   $108 = HEAP8[$107 >> 0] | 0;
   if ($108 << 24 >> 24 != 42) {
    $isdigittmp1$i22 = ($108 << 24 >> 24) + -48 | 0;
    if ($isdigittmp1$i22 >>> 0 < 10) {
     $140 = $107;
     $i$03$i25 = 0;
     $isdigittmp4$i24 = $isdigittmp1$i22;
    } else {
     $p$0 = 0;
     $s$6 = $107;
     break;
    }
    while (1) {
     $138 = ($i$03$i25 * 10 | 0) + $isdigittmp4$i24 | 0;
     $139 = $140 + 1 | 0;
     $isdigittmp4$i24 = (HEAP8[$139 >> 0] | 0) + -48 | 0;
     if ($isdigittmp4$i24 >>> 0 >= 10) {
      $p$0 = $138;
      $s$6 = $139;
      break L46;
     } else {
      $140 = $139;
      $i$03$i25 = $138;
     }
    }
   }
   $110 = $s$4 + 2 | 0;
   $isdigittmp9 = (HEAP8[$110 >> 0] | 0) + -48 | 0;
   if ($isdigittmp9 >>> 0 < 10) if ((HEAP8[$s$4 + 3 >> 0] | 0) == 36) {
    HEAP32[$nl_type + ($isdigittmp9 << 2) >> 2] = 10;
    $p$0 = HEAP32[$nl_arg + ((HEAP8[$110 >> 0] | 0) + -48 << 3) >> 2] | 0;
    $s$6 = $s$4 + 4 | 0;
    break;
   }
   if ($l10n$3 | 0) {
    $$0 = -1;
    break L1;
   }
   if ($0) {
    $134 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
    $135 = HEAP32[$134 >> 2] | 0;
    HEAP32[$ap >> 2] = $134 + 4;
    $p$0 = $135;
    $s$6 = $110;
   } else {
    $p$0 = 0;
    $s$6 = $110;
   }
  } else {
   $p$0 = -1;
   $s$6 = $s$4;
  } while (0);
  $s$7 = $s$6;
  $st$0 = 0;
  while (1) {
   $145 = (HEAP8[$s$7 >> 0] | 0) + -65 | 0;
   if ($145 >>> 0 > 57) {
    $$0 = -1;
    break L1;
   }
   $147 = $s$7 + 1 | 0;
   $149 = HEAP8[313736 + ($st$0 * 58 | 0) + $145 >> 0] | 0;
   $150 = $149 & 255;
   if (($150 + -1 | 0) >>> 0 < 8) {
    $s$7 = $147;
    $st$0 = $150;
   } else {
    $$lcssa300 = $147;
    $$lcssa301 = $149;
    $$lcssa302 = $150;
    $s$7$lcssa298 = $s$7;
    $st$0$lcssa299 = $st$0;
    break;
   }
  }
  if (!($$lcssa301 << 24 >> 24)) {
   $$0 = -1;
   break;
  }
  $155 = ($argpos$0 | 0) > -1;
  do if ($$lcssa301 << 24 >> 24 == 19) if ($155) {
   $$0 = -1;
   break L1;
  } else label = 52; else {
   if ($155) {
    HEAP32[$nl_type + ($argpos$0 << 2) >> 2] = $$lcssa302;
    $158 = $nl_arg + ($argpos$0 << 3) | 0;
    $163 = HEAP32[$158 + 4 >> 2] | 0;
    $164 = $arg;
    HEAP32[$164 >> 2] = HEAP32[$158 >> 2];
    HEAP32[$164 + 4 >> 2] = $163;
    label = 52;
    break;
   }
   if (!$0) {
    $$0 = 0;
    break L1;
   }
   _pop_arg($arg, $$lcssa302, $ap);
  } while (0);
  if ((label | 0) == 52) {
   label = 0;
   if (!$0) {
    $cnt$0 = $cnt$1;
    $l$0 = $35;
    $l10n$0 = $l10n$3;
    $s$0 = $$lcssa300;
    continue;
   }
  }
  $169 = HEAP8[$s$7$lcssa298 >> 0] | 0;
  $t$0 = ($st$0$lcssa299 | 0) != 0 & ($169 & 15 | 0) == 3 ? $169 & -33 : $169;
  $176 = $fl$1 & -65537;
  $fl$1$ = ($fl$1 & 8192 | 0) == 0 ? $fl$1 : $176;
  L75 : do switch ($t$0 | 0) {
  case 110:
   {
    switch ($st$0$lcssa299 | 0) {
    case 0:
     {
      HEAP32[HEAP32[$arg >> 2] >> 2] = $cnt$1;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    case 1:
     {
      HEAP32[HEAP32[$arg >> 2] >> 2] = $cnt$1;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    case 2:
     {
      $188 = HEAP32[$arg >> 2] | 0;
      HEAP32[$188 >> 2] = $cnt$1;
      HEAP32[$188 + 4 >> 2] = (($cnt$1 | 0) < 0) << 31 >> 31;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    case 3:
     {
      HEAP16[HEAP32[$arg >> 2] >> 1] = $cnt$1;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    case 4:
     {
      HEAP8[HEAP32[$arg >> 2] >> 0] = $cnt$1;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    case 6:
     {
      HEAP32[HEAP32[$arg >> 2] >> 2] = $cnt$1;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    case 7:
     {
      $200 = HEAP32[$arg >> 2] | 0;
      HEAP32[$200 >> 2] = $cnt$1;
      HEAP32[$200 + 4 >> 2] = (($cnt$1 | 0) < 0) << 31 >> 31;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    default:
     {
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
     }
    }
    break;
   }
  case 112:
   {
    $fl$3 = $fl$1$ | 8;
    $p$1 = $p$0 >>> 0 > 8 ? $p$0 : 8;
    $t$1 = 120;
    label = 64;
    break;
   }
  case 88:
  case 120:
   {
    $fl$3 = $fl$1$;
    $p$1 = $p$0;
    $t$1 = $t$0;
    label = 64;
    break;
   }
  case 111:
   {
    $244 = $arg;
    $246 = HEAP32[$244 >> 2] | 0;
    $249 = HEAP32[$244 + 4 >> 2] | 0;
    if (($246 | 0) == 0 & ($249 | 0) == 0) $$0$lcssa$i = $1; else {
     $$03$i33 = $1;
     $254 = $246;
     $258 = $249;
     while (1) {
      $257 = $$03$i33 + -1 | 0;
      HEAP8[$257 >> 0] = $254 & 7 | 48;
      $254 = _bitshift64Lshr($254 | 0, $258 | 0, 3) | 0;
      $258 = tempRet0;
      if (($254 | 0) == 0 & ($258 | 0) == 0) {
       $$0$lcssa$i = $257;
       break;
      } else $$03$i33 = $257;
     }
    }
    if (!($fl$1$ & 8)) {
     $a$0 = $$0$lcssa$i;
     $fl$4 = $fl$1$;
     $p$2 = $p$0;
     $pl$1 = 0;
     $prefix$1 = 314216;
     label = 77;
    } else {
     $267 = $2 - $$0$lcssa$i | 0;
     $a$0 = $$0$lcssa$i;
     $fl$4 = $fl$1$;
     $p$2 = ($p$0 | 0) > ($267 | 0) ? $p$0 : $267 + 1 | 0;
     $pl$1 = 0;
     $prefix$1 = 314216;
     label = 77;
    }
    break;
   }
  case 105:
  case 100:
   {
    $270 = $arg;
    $272 = HEAP32[$270 >> 2] | 0;
    $275 = HEAP32[$270 + 4 >> 2] | 0;
    if (($275 | 0) < 0) {
     $277 = _i64Subtract(0, 0, $272 | 0, $275 | 0) | 0;
     $278 = tempRet0;
     $279 = $arg;
     HEAP32[$279 >> 2] = $277;
     HEAP32[$279 + 4 >> 2] = $278;
     $287 = $277;
     $288 = $278;
     $pl$0 = 1;
     $prefix$0 = 314216;
     label = 76;
     break L75;
    }
    if (!($fl$1$ & 2048)) {
     $285 = $fl$1$ & 1;
     $287 = $272;
     $288 = $275;
     $pl$0 = $285;
     $prefix$0 = ($285 | 0) == 0 ? 314216 : 314218;
     label = 76;
    } else {
     $287 = $272;
     $288 = $275;
     $pl$0 = 1;
     $prefix$0 = 314217;
     label = 76;
    }
    break;
   }
  case 117:
   {
    $177 = $arg;
    $287 = HEAP32[$177 >> 2] | 0;
    $288 = HEAP32[$177 + 4 >> 2] | 0;
    $pl$0 = 0;
    $prefix$0 = 314216;
    label = 76;
    break;
   }
  case 99:
   {
    HEAP8[$3 >> 0] = HEAP32[$arg >> 2];
    $a$2 = $3;
    $fl$6 = $176;
    $p$5 = 1;
    $pl$2 = 0;
    $prefix$2 = 314216;
    $z$2 = $1;
    break;
   }
  case 109:
   {
    $a$1 = _strerror(HEAP32[(___errno_location() | 0) >> 2] | 0) | 0;
    label = 82;
    break;
   }
  case 115:
   {
    $318 = HEAP32[$arg >> 2] | 0;
    $a$1 = $318 | 0 ? $318 : 316118;
    label = 82;
    break;
   }
  case 67:
   {
    HEAP32[$wc >> 2] = HEAP32[$arg >> 2];
    HEAP32[$4 >> 2] = 0;
    HEAP32[$arg >> 2] = $wc;
    $798 = $wc;
    $p$4176 = -1;
    label = 86;
    break;
   }
  case 83:
   {
    $$pre171 = HEAP32[$arg >> 2] | 0;
    if (!$p$0) {
     _pad($f, 32, $w$1, 0, $fl$1$);
     $i$0$lcssa178 = 0;
     label = 97;
    } else {
     $798 = $$pre171;
     $p$4176 = $p$0;
     label = 86;
    }
    break;
   }
  case 65:
  case 71:
  case 70:
  case 69:
  case 97:
  case 103:
  case 102:
  case 101:
   {
    $358 = +HEAPF64[$arg >> 3];
    HEAP32[$e2$i >> 2] = 0;
    HEAPF64[tempDoublePtr >> 3] = $358;
    if ((HEAP32[tempDoublePtr + 4 >> 2] | 0) < 0) {
     $$07$i = -$358;
     $pl$0$i = 1;
     $prefix$0$i = 316125;
    } else if (!($fl$1$ & 2048)) {
     $365 = $fl$1$ & 1;
     $$07$i = $358;
     $pl$0$i = $365;
     $prefix$0$i = ($365 | 0) == 0 ? 316126 : 316131;
    } else {
     $$07$i = $358;
     $pl$0$i = 1;
     $prefix$0$i = 316128;
    }
    HEAPF64[tempDoublePtr >> 3] = $$07$i;
    $369 = HEAP32[tempDoublePtr + 4 >> 2] & 2146435072;
    do if ($369 >>> 0 < 2146435072 | ($369 | 0) == 2146435072 & 0 < 0) {
     $391 = +_frexpl($$07$i, $e2$i) * 2.0;
     $392 = $391 != 0.0;
     if ($392) HEAP32[$e2$i >> 2] = (HEAP32[$e2$i >> 2] | 0) + -1;
     $395 = $t$0 | 32;
     if (($395 | 0) == 97) {
      $397 = $t$0 & 32;
      $prefix$0$$i = ($397 | 0) == 0 ? $prefix$0$i : $prefix$0$i + 9 | 0;
      $400 = $pl$0$i | 2;
      $402 = 12 - $p$0 | 0;
      do if ($p$0 >>> 0 > 11 | ($402 | 0) == 0) $$1$i = $391; else {
       $re$171$i = $402;
       $round$070$i = 8.0;
       while (1) {
        $re$171$i = $re$171$i + -1 | 0;
        $406 = $round$070$i * 16.0;
        if (!$re$171$i) {
         $$lcssa319 = $406;
         break;
        } else $round$070$i = $406;
       }
       if ((HEAP8[$prefix$0$$i >> 0] | 0) == 45) {
        $$1$i = -($$lcssa319 + (-$391 - $$lcssa319));
        break;
       } else {
        $$1$i = $391 + $$lcssa319 - $$lcssa319;
        break;
       }
      } while (0);
      $416 = HEAP32[$e2$i >> 2] | 0;
      $419 = ($416 | 0) < 0 ? 0 - $416 | 0 : $416;
      $422 = _fmt_u($419, (($419 | 0) < 0) << 31 >> 31, $7) | 0;
      if (($422 | 0) == ($7 | 0)) {
       HEAP8[$8 >> 0] = 48;
       $estr$0$i = $8;
      } else $estr$0$i = $422;
      HEAP8[$estr$0$i + -1 >> 0] = ($416 >> 31 & 2) + 43;
      $431 = $estr$0$i + -2 | 0;
      HEAP8[$431 >> 0] = $t$0 + 15;
      $notrhs$i = ($p$0 | 0) < 1;
      $433 = ($fl$1$ & 8 | 0) == 0;
      $$2$i = $$1$i;
      $s$0$i = $buf$i;
      while (1) {
       $434 = ~~$$2$i;
       $440 = $s$0$i + 1 | 0;
       HEAP8[$s$0$i >> 0] = HEAPU8[314200 + $434 >> 0] | $397;
       $$2$i = ($$2$i - +($434 | 0)) * 16.0;
       do if (($440 - $5 | 0) == 1) {
        if ($433 & ($notrhs$i & $$2$i == 0.0)) {
         $s$1$i = $440;
         break;
        }
        HEAP8[$440 >> 0] = 46;
        $s$1$i = $s$0$i + 2 | 0;
       } else $s$1$i = $440; while (0);
       if (!($$2$i != 0.0)) {
        $s$1$i$lcssa = $s$1$i;
        break;
       } else $s$0$i = $s$1$i;
      }
      $$pre188$i = $s$1$i$lcssa;
      $452 = $431;
      $l$0$i = ($p$0 | 0) != 0 & ($11 + $$pre188$i | 0) < ($p$0 | 0) ? $12 + $p$0 - $452 | 0 : $10 - $452 + $$pre188$i | 0;
      $457 = $l$0$i + $400 | 0;
      _pad($f, 32, $w$1, $457, $fl$1$);
      if (!(HEAP32[$f >> 2] & 32)) ___fwritex($prefix$0$$i, $400, $f) | 0;
      _pad($f, 48, $w$1, $457, $fl$1$ ^ 65536);
      $462 = $$pre188$i - $5 | 0;
      if (!(HEAP32[$f >> 2] & 32)) ___fwritex($buf$i, $462, $f) | 0;
      $466 = $9 - $452 | 0;
      _pad($f, 48, $l$0$i - ($462 + $466) | 0, 0, 0);
      if (!(HEAP32[$f >> 2] & 32)) ___fwritex($431, $466, $f) | 0;
      _pad($f, 32, $w$1, $457, $fl$1$ ^ 8192);
      $$0$i = ($457 | 0) < ($w$1 | 0) ? $w$1 : $457;
      break;
     }
     $$p$i = ($p$0 | 0) < 0 ? 6 : $p$0;
     if ($392) {
      $476 = (HEAP32[$e2$i >> 2] | 0) + -28 | 0;
      HEAP32[$e2$i >> 2] = $476;
      $$3$i = $391 * 268435456.0;
      $477 = $476;
     } else {
      $$3$i = $391;
      $477 = HEAP32[$e2$i >> 2] | 0;
     }
     $$33$i = ($477 | 0) < 0 ? $big$i : $13;
     $479 = $$33$i;
     $$4$i = $$3$i;
     $z$0$i = $$33$i;
     while (1) {
      $480 = ~~$$4$i >>> 0;
      HEAP32[$z$0$i >> 2] = $480;
      $481 = $z$0$i + 4 | 0;
      $$4$i = ($$4$i - +($480 >>> 0)) * 1.0e9;
      if (!($$4$i != 0.0)) {
       $$lcssa303 = $481;
       break;
      } else $z$0$i = $481;
     }
     $$pr$i = HEAP32[$e2$i >> 2] | 0;
     if (($$pr$i | 0) > 0) {
      $487 = $$pr$i;
      $a$1149$i = $$33$i;
      $z$1148$i = $$lcssa303;
      while (1) {
       $489 = ($487 | 0) > 29 ? 29 : $487;
       $d$0141$i = $z$1148$i + -4 | 0;
       do if ($d$0141$i >>> 0 < $a$1149$i >>> 0) $a$2$ph$i = $a$1149$i; else {
        $carry$0142$i = 0;
        $d$0143$i = $d$0141$i;
        while (1) {
         $492 = _bitshift64Shl(HEAP32[$d$0143$i >> 2] | 0, 0, $489 | 0) | 0;
         $494 = _i64Add($492 | 0, tempRet0 | 0, $carry$0142$i | 0, 0) | 0;
         $495 = tempRet0;
         $496 = ___uremdi3($494 | 0, $495 | 0, 1e9, 0) | 0;
         HEAP32[$d$0143$i >> 2] = $496;
         $498 = ___udivdi3($494 | 0, $495 | 0, 1e9, 0) | 0;
         $d$0143$i = $d$0143$i + -4 | 0;
         if ($d$0143$i >>> 0 < $a$1149$i >>> 0) {
          $$lcssa304 = $498;
          break;
         } else $carry$0142$i = $498;
        }
        if (!$$lcssa304) {
         $a$2$ph$i = $a$1149$i;
         break;
        }
        $502 = $a$1149$i + -4 | 0;
        HEAP32[$502 >> 2] = $$lcssa304;
        $a$2$ph$i = $502;
       } while (0);
       $z$2$i = $z$1148$i;
       while (1) {
        if ($z$2$i >>> 0 <= $a$2$ph$i >>> 0) {
         $z$2$i$lcssa = $z$2$i;
         break;
        }
        $504 = $z$2$i + -4 | 0;
        if (!(HEAP32[$504 >> 2] | 0)) $z$2$i = $504; else {
         $z$2$i$lcssa = $z$2$i;
         break;
        }
       }
       $508 = (HEAP32[$e2$i >> 2] | 0) - $489 | 0;
       HEAP32[$e2$i >> 2] = $508;
       if (($508 | 0) > 0) {
        $487 = $508;
        $a$1149$i = $a$2$ph$i;
        $z$1148$i = $z$2$i$lcssa;
       } else {
        $$pr50$i = $508;
        $a$1$lcssa$i = $a$2$ph$i;
        $z$1$lcssa$i = $z$2$i$lcssa;
        break;
       }
      }
     } else {
      $$pr50$i = $$pr$i;
      $a$1$lcssa$i = $$33$i;
      $z$1$lcssa$i = $$lcssa303;
     }
     if (($$pr50$i | 0) < 0) {
      $513 = (($$p$i + 25 | 0) / 9 | 0) + 1 | 0;
      $514 = ($395 | 0) == 102;
      $516 = $$pr50$i;
      $a$3136$i = $a$1$lcssa$i;
      $z$3135$i = $z$1$lcssa$i;
      while (1) {
       $515 = 0 - $516 | 0;
       $518 = ($515 | 0) > 9 ? 9 : $515;
       do if ($a$3136$i >>> 0 < $z$3135$i >>> 0) {
        $524 = (1 << $518) + -1 | 0;
        $525 = 1e9 >>> $518;
        $carry3$0130$i = 0;
        $d$1129$i = $a$3136$i;
        while (1) {
         $526 = HEAP32[$d$1129$i >> 2] | 0;
         HEAP32[$d$1129$i >> 2] = ($526 >>> $518) + $carry3$0130$i;
         $530 = Math_imul($526 & $524, $525) | 0;
         $d$1129$i = $d$1129$i + 4 | 0;
         if ($d$1129$i >>> 0 >= $z$3135$i >>> 0) {
          $$lcssa306 = $530;
          break;
         } else $carry3$0130$i = $530;
        }
        $$a$3$i = (HEAP32[$a$3136$i >> 2] | 0) == 0 ? $a$3136$i + 4 | 0 : $a$3136$i;
        if (!$$lcssa306) {
         $$a$3192$i = $$a$3$i;
         $z$4$i = $z$3135$i;
         break;
        }
        HEAP32[$z$3135$i >> 2] = $$lcssa306;
        $$a$3192$i = $$a$3$i;
        $z$4$i = $z$3135$i + 4 | 0;
       } else {
        $$a$3192$i = (HEAP32[$a$3136$i >> 2] | 0) == 0 ? $a$3136$i + 4 | 0 : $a$3136$i;
        $z$4$i = $z$3135$i;
       } while (0);
       $538 = $514 ? $$33$i : $$a$3192$i;
       $$z$4$i = ($z$4$i - $538 >> 2 | 0) > ($513 | 0) ? $538 + ($513 << 2) | 0 : $z$4$i;
       $516 = (HEAP32[$e2$i >> 2] | 0) + $518 | 0;
       HEAP32[$e2$i >> 2] = $516;
       if (($516 | 0) >= 0) {
        $a$3$lcssa$i = $$a$3192$i;
        $z$3$lcssa$i = $$z$4$i;
        break;
       } else {
        $a$3136$i = $$a$3192$i;
        $z$3135$i = $$z$4$i;
       }
      }
     } else {
      $a$3$lcssa$i = $a$1$lcssa$i;
      $z$3$lcssa$i = $z$1$lcssa$i;
     }
     do if ($a$3$lcssa$i >>> 0 < $z$3$lcssa$i >>> 0) {
      $552 = ($479 - $a$3$lcssa$i >> 2) * 9 | 0;
      $553 = HEAP32[$a$3$lcssa$i >> 2] | 0;
      if ($553 >>> 0 < 10) {
       $e$1$i = $552;
       break;
      } else {
       $e$0125$i = $552;
       $i$0124$i = 10;
      }
      while (1) {
       $i$0124$i = $i$0124$i * 10 | 0;
       $556 = $e$0125$i + 1 | 0;
       if ($553 >>> 0 < $i$0124$i >>> 0) {
        $e$1$i = $556;
        break;
       } else $e$0125$i = $556;
      }
     } else $e$1$i = 0; while (0);
     $561 = ($395 | 0) == 103;
     $562 = ($$p$i | 0) != 0;
     $564 = $$p$i - (($395 | 0) != 102 ? $e$1$i : 0) + (($562 & $561) << 31 >> 31) | 0;
     if (($564 | 0) < ((($z$3$lcssa$i - $479 >> 2) * 9 | 0) + -9 | 0)) {
      $572 = $564 + 9216 | 0;
      $575 = $$33$i + 4 + ((($572 | 0) / 9 | 0) + -1024 << 2) | 0;
      $j$0117$i = (($572 | 0) % 9 | 0) + 1 | 0;
      if (($j$0117$i | 0) < 9) {
       $i$1118$i = 10;
       $j$0119$i = $j$0117$i;
       while (1) {
        $578 = $i$1118$i * 10 | 0;
        $j$0119$i = $j$0119$i + 1 | 0;
        if (($j$0119$i | 0) == 9) {
         $i$1$lcssa$i = $578;
         break;
        } else $i$1118$i = $578;
       }
      } else $i$1$lcssa$i = 10;
      $579 = HEAP32[$575 >> 2] | 0;
      $580 = ($579 >>> 0) % ($i$1$lcssa$i >>> 0) | 0;
      $583 = ($575 + 4 | 0) == ($z$3$lcssa$i | 0);
      do if ($583 & ($580 | 0) == 0) {
       $a$8$i = $a$3$lcssa$i;
       $d$4$i = $575;
       $e$4$i = $e$1$i;
      } else {
       $$20$i = ((($579 >>> 0) / ($i$1$lcssa$i >>> 0) | 0) & 1 | 0) == 0 ? 9007199254740992.0 : 9007199254740994.0;
       $587 = ($i$1$lcssa$i | 0) / 2 | 0;
       if ($580 >>> 0 < $587 >>> 0) $small$0$i = .5; else $small$0$i = $583 & ($580 | 0) == ($587 | 0) ? 1.0 : 1.5;
       do if (!$pl$0$i) {
        $round6$1$i = $$20$i;
        $small$1$i = $small$0$i;
       } else {
        if ((HEAP8[$prefix$0$i >> 0] | 0) != 45) {
         $round6$1$i = $$20$i;
         $small$1$i = $small$0$i;
         break;
        }
        $round6$1$i = -$$20$i;
        $small$1$i = -$small$0$i;
       } while (0);
       $595 = $579 - $580 | 0;
       HEAP32[$575 >> 2] = $595;
       if (!($round6$1$i + $small$1$i != $round6$1$i)) {
        $a$8$i = $a$3$lcssa$i;
        $d$4$i = $575;
        $e$4$i = $e$1$i;
        break;
       }
       $598 = $595 + $i$1$lcssa$i | 0;
       HEAP32[$575 >> 2] = $598;
       if ($598 >>> 0 > 999999999) {
        $a$5111$i = $a$3$lcssa$i;
        $d$2110$i = $575;
        while (1) {
         $600 = $d$2110$i + -4 | 0;
         HEAP32[$d$2110$i >> 2] = 0;
         if ($600 >>> 0 < $a$5111$i >>> 0) {
          $602 = $a$5111$i + -4 | 0;
          HEAP32[$602 >> 2] = 0;
          $a$6$i = $602;
         } else $a$6$i = $a$5111$i;
         $604 = (HEAP32[$600 >> 2] | 0) + 1 | 0;
         HEAP32[$600 >> 2] = $604;
         if ($604 >>> 0 > 999999999) {
          $a$5111$i = $a$6$i;
          $d$2110$i = $600;
         } else {
          $a$5$lcssa$i = $a$6$i;
          $d$2$lcssa$i = $600;
          break;
         }
        }
       } else {
        $a$5$lcssa$i = $a$3$lcssa$i;
        $d$2$lcssa$i = $575;
       }
       $609 = ($479 - $a$5$lcssa$i >> 2) * 9 | 0;
       $610 = HEAP32[$a$5$lcssa$i >> 2] | 0;
       if ($610 >>> 0 < 10) {
        $a$8$i = $a$5$lcssa$i;
        $d$4$i = $d$2$lcssa$i;
        $e$4$i = $609;
        break;
       } else {
        $e$2106$i = $609;
        $i$2105$i = 10;
       }
       while (1) {
        $i$2105$i = $i$2105$i * 10 | 0;
        $613 = $e$2106$i + 1 | 0;
        if ($610 >>> 0 < $i$2105$i >>> 0) {
         $a$8$i = $a$5$lcssa$i;
         $d$4$i = $d$2$lcssa$i;
         $e$4$i = $613;
         break;
        } else $e$2106$i = $613;
       }
      } while (0);
      $615 = $d$4$i + 4 | 0;
      $a$9$ph$i = $a$8$i;
      $e$5$ph$i = $e$4$i;
      $z$7$ph$i = $z$3$lcssa$i >>> 0 > $615 >>> 0 ? $615 : $z$3$lcssa$i;
     } else {
      $a$9$ph$i = $a$3$lcssa$i;
      $e$5$ph$i = $e$1$i;
      $z$7$ph$i = $z$3$lcssa$i;
     }
     $617 = 0 - $e$5$ph$i | 0;
     $z$7$i = $z$7$ph$i;
     while (1) {
      if ($z$7$i >>> 0 <= $a$9$ph$i >>> 0) {
       $$lcssa162$i = 0;
       $z$7$i$lcssa = $z$7$i;
       break;
      }
      $619 = $z$7$i + -4 | 0;
      if (!(HEAP32[$619 >> 2] | 0)) $z$7$i = $619; else {
       $$lcssa162$i = 1;
       $z$7$i$lcssa = $z$7$i;
       break;
      }
     }
     do if ($561) {
      $$p$$i = ($562 & 1 ^ 1) + $$p$i | 0;
      if (($$p$$i | 0) > ($e$5$ph$i | 0) & ($e$5$ph$i | 0) > -5) {
       $$013$i = $t$0 + -1 | 0;
       $$210$i = $$p$$i + -1 - $e$5$ph$i | 0;
      } else {
       $$013$i = $t$0 + -2 | 0;
       $$210$i = $$p$$i + -1 | 0;
      }
      $630 = $fl$1$ & 8;
      if ($630 | 0) {
       $$114$i = $$013$i;
       $$311$i = $$210$i;
       $$pre$phi190$iZ2D = $630;
       break;
      }
      do if ($$lcssa162$i) {
       $633 = HEAP32[$z$7$i$lcssa + -4 >> 2] | 0;
       if (!$633) {
        $j$2$i = 9;
        break;
       }
       if (!(($633 >>> 0) % 10 | 0)) {
        $i$3101$i = 10;
        $j$1102$i = 0;
       } else {
        $j$2$i = 0;
        break;
       }
       while (1) {
        $i$3101$i = $i$3101$i * 10 | 0;
        $638 = $j$1102$i + 1 | 0;
        if (($633 >>> 0) % ($i$3101$i >>> 0) | 0 | 0) {
         $j$2$i = $638;
         break;
        } else $j$1102$i = $638;
       }
      } else $j$2$i = 9; while (0);
      $647 = (($z$7$i$lcssa - $479 >> 2) * 9 | 0) + -9 | 0;
      if (($$013$i | 32 | 0) == 102) {
       $648 = $647 - $j$2$i | 0;
       $$23$i = ($648 | 0) < 0 ? 0 : $648;
       $$114$i = $$013$i;
       $$311$i = ($$210$i | 0) < ($$23$i | 0) ? $$210$i : $$23$i;
       $$pre$phi190$iZ2D = 0;
       break;
      } else {
       $652 = $647 + $e$5$ph$i - $j$2$i | 0;
       $$25$i = ($652 | 0) < 0 ? 0 : $652;
       $$114$i = $$013$i;
       $$311$i = ($$210$i | 0) < ($$25$i | 0) ? $$210$i : $$25$i;
       $$pre$phi190$iZ2D = 0;
       break;
      }
     } else {
      $$114$i = $t$0;
      $$311$i = $$p$i;
      $$pre$phi190$iZ2D = $fl$1$ & 8;
     } while (0);
     $655 = $$311$i | $$pre$phi190$iZ2D;
     $657 = ($655 | 0) != 0 & 1;
     $659 = ($$114$i | 32 | 0) == 102;
     if ($659) {
      $$pn$i = ($e$5$ph$i | 0) > 0 ? $e$5$ph$i : 0;
      $estr$2$i = 0;
     } else {
      $663 = ($e$5$ph$i | 0) < 0 ? $617 : $e$5$ph$i;
      $666 = _fmt_u($663, (($663 | 0) < 0) << 31 >> 31, $7) | 0;
      if (($9 - $666 | 0) < 2) {
       $estr$195$i = $666;
       while (1) {
        $670 = $estr$195$i + -1 | 0;
        HEAP8[$670 >> 0] = 48;
        if (($9 - $670 | 0) < 2) $estr$195$i = $670; else {
         $estr$1$lcssa$i = $670;
         break;
        }
       }
      } else $estr$1$lcssa$i = $666;
      HEAP8[$estr$1$lcssa$i + -1 >> 0] = ($e$5$ph$i >> 31 & 2) + 43;
      $680 = $estr$1$lcssa$i + -2 | 0;
      HEAP8[$680 >> 0] = $$114$i;
      $$pn$i = $9 - $680 | 0;
      $estr$2$i = $680;
     }
     $685 = $pl$0$i + 1 + $$311$i + $657 + $$pn$i | 0;
     _pad($f, 32, $w$1, $685, $fl$1$);
     if (!(HEAP32[$f >> 2] & 32)) ___fwritex($prefix$0$i, $pl$0$i, $f) | 0;
     _pad($f, 48, $w$1, $685, $fl$1$ ^ 65536);
     do if ($659) {
      $r$0$a$9$i = $a$9$ph$i >>> 0 > $$33$i >>> 0 ? $$33$i : $a$9$ph$i;
      $d$584$i = $r$0$a$9$i;
      while (1) {
       $692 = _fmt_u(HEAP32[$d$584$i >> 2] | 0, 0, $14) | 0;
       do if (($d$584$i | 0) == ($r$0$a$9$i | 0)) {
        if (($692 | 0) != ($14 | 0)) {
         $s7$1$i = $692;
         break;
        }
        HEAP8[$16 >> 0] = 48;
        $s7$1$i = $16;
       } else {
        if ($692 >>> 0 <= $buf$i >>> 0) {
         $s7$1$i = $692;
         break;
        }
        _memset($buf$i | 0, 48, $692 - $5 | 0) | 0;
        $s7$081$i = $692;
        while (1) {
         $697 = $s7$081$i + -1 | 0;
         if ($697 >>> 0 > $buf$i >>> 0) $s7$081$i = $697; else {
          $s7$1$i = $697;
          break;
         }
        }
       } while (0);
       if (!(HEAP32[$f >> 2] & 32)) ___fwritex($s7$1$i, $15 - $s7$1$i | 0, $f) | 0;
       $705 = $d$584$i + 4 | 0;
       if ($705 >>> 0 > $$33$i >>> 0) {
        $$lcssa316 = $705;
        break;
       } else $d$584$i = $705;
      }
      do if ($655 | 0) {
       if (HEAP32[$f >> 2] & 32 | 0) break;
       ___fwritex(316156, 1, $f) | 0;
      } while (0);
      if (($$311$i | 0) > 0 & $$lcssa316 >>> 0 < $z$7$i$lcssa >>> 0) {
       $$41278$i = $$311$i;
       $d$677$i = $$lcssa316;
       while (1) {
        $715 = _fmt_u(HEAP32[$d$677$i >> 2] | 0, 0, $14) | 0;
        if ($715 >>> 0 > $buf$i >>> 0) {
         _memset($buf$i | 0, 48, $715 - $5 | 0) | 0;
         $s8$072$i = $715;
         while (1) {
          $719 = $s8$072$i + -1 | 0;
          if ($719 >>> 0 > $buf$i >>> 0) $s8$072$i = $719; else {
           $s8$0$lcssa$i = $719;
           break;
          }
         }
        } else $s8$0$lcssa$i = $715;
        if (!(HEAP32[$f >> 2] & 32)) ___fwritex($s8$0$lcssa$i, ($$41278$i | 0) > 9 ? 9 : $$41278$i, $f) | 0;
        $d$677$i = $d$677$i + 4 | 0;
        $727 = $$41278$i + -9 | 0;
        if (!(($$41278$i | 0) > 9 & $d$677$i >>> 0 < $z$7$i$lcssa >>> 0)) {
         $$412$lcssa$i = $727;
         break;
        } else $$41278$i = $727;
       }
      } else $$412$lcssa$i = $$311$i;
      _pad($f, 48, $$412$lcssa$i + 9 | 0, 9, 0);
     } else {
      $z$7$$i = $$lcssa162$i ? $z$7$i$lcssa : $a$9$ph$i + 4 | 0;
      if (($$311$i | 0) > -1) {
       $734 = ($$pre$phi190$iZ2D | 0) == 0;
       $$589$i = $$311$i;
       $d$788$i = $a$9$ph$i;
       while (1) {
        $736 = _fmt_u(HEAP32[$d$788$i >> 2] | 0, 0, $14) | 0;
        if (($736 | 0) == ($14 | 0)) {
         HEAP8[$16 >> 0] = 48;
         $s9$0$i = $16;
        } else $s9$0$i = $736;
        do if (($d$788$i | 0) == ($a$9$ph$i | 0)) {
         $742 = $s9$0$i + 1 | 0;
         if (!(HEAP32[$f >> 2] & 32)) ___fwritex($s9$0$i, 1, $f) | 0;
         if ($734 & ($$589$i | 0) < 1) {
          $s9$2$i = $742;
          break;
         }
         if (HEAP32[$f >> 2] & 32 | 0) {
          $s9$2$i = $742;
          break;
         }
         ___fwritex(316156, 1, $f) | 0;
         $s9$2$i = $742;
        } else {
         if ($s9$0$i >>> 0 <= $buf$i >>> 0) {
          $s9$2$i = $s9$0$i;
          break;
         }
         _memset($buf$i | 0, 48, $s9$0$i + $6 | 0) | 0;
         $s9$185$i = $s9$0$i;
         while (1) {
          $740 = $s9$185$i + -1 | 0;
          if ($740 >>> 0 > $buf$i >>> 0) $s9$185$i = $740; else {
           $s9$2$i = $740;
           break;
          }
         }
        } while (0);
        $751 = $15 - $s9$2$i | 0;
        if (!(HEAP32[$f >> 2] & 32)) ___fwritex($s9$2$i, ($$589$i | 0) > ($751 | 0) ? $751 : $$589$i, $f) | 0;
        $757 = $$589$i - $751 | 0;
        $d$788$i = $d$788$i + 4 | 0;
        if (!($d$788$i >>> 0 < $z$7$$i >>> 0 & ($757 | 0) > -1)) {
         $$5$lcssa$i = $757;
         break;
        } else $$589$i = $757;
       }
      } else $$5$lcssa$i = $$311$i;
      _pad($f, 48, $$5$lcssa$i + 18 | 0, 18, 0);
      if (HEAP32[$f >> 2] & 32 | 0) break;
      ___fwritex($estr$2$i, $9 - $estr$2$i | 0, $f) | 0;
     } while (0);
     _pad($f, 32, $w$1, $685, $fl$1$ ^ 8192);
     $$0$i = ($685 | 0) < ($w$1 | 0) ? $w$1 : $685;
    } else {
     $376 = ($t$0 & 32 | 0) != 0;
     $378 = $$07$i != $$07$i | 0.0 != 0.0;
     $pl$1$i = $378 ? 0 : $pl$0$i;
     $380 = $pl$1$i + 3 | 0;
     _pad($f, 32, $w$1, $380, $176);
     $381 = HEAP32[$f >> 2] | 0;
     if (!($381 & 32)) {
      ___fwritex($prefix$0$i, $pl$1$i, $f) | 0;
      $385 = HEAP32[$f >> 2] | 0;
     } else $385 = $381;
     if (!($385 & 32)) ___fwritex($378 ? ($376 ? 316452 : 316152) : $376 ? 316144 : 316148, 3, $f) | 0;
     _pad($f, 32, $w$1, $380, $fl$1$ ^ 8192);
     $$0$i = ($380 | 0) < ($w$1 | 0) ? $w$1 : $380;
    } while (0);
    $cnt$0 = $cnt$1;
    $l$0 = $$0$i;
    $l10n$0 = $l10n$3;
    $s$0 = $$lcssa300;
    continue L1;
    break;
   }
  default:
   {
    $a$2 = $s$0;
    $fl$6 = $fl$1$;
    $p$5 = $p$0;
    $pl$2 = 0;
    $prefix$2 = 314216;
    $z$2 = $1;
   }
  } while (0);
  L311 : do if ((label | 0) == 64) {
   label = 0;
   $207 = $arg;
   $209 = HEAP32[$207 >> 2] | 0;
   $212 = HEAP32[$207 + 4 >> 2] | 0;
   $213 = $t$1 & 32;
   if (($209 | 0) == 0 & ($212 | 0) == 0) {
    $a$0 = $1;
    $fl$4 = $fl$3;
    $p$2 = $p$1;
    $pl$1 = 0;
    $prefix$1 = 314216;
    label = 77;
   } else {
    $$012$i = $1;
    $218 = $209;
    $225 = $212;
    while (1) {
     $224 = $$012$i + -1 | 0;
     HEAP8[$224 >> 0] = HEAPU8[314200 + ($218 & 15) >> 0] | $213;
     $218 = _bitshift64Lshr($218 | 0, $225 | 0, 4) | 0;
     $225 = tempRet0;
     if (($218 | 0) == 0 & ($225 | 0) == 0) {
      $$lcssa321 = $224;
      break;
     } else $$012$i = $224;
    }
    $231 = $arg;
    if (($fl$3 & 8 | 0) == 0 | (HEAP32[$231 >> 2] | 0) == 0 & (HEAP32[$231 + 4 >> 2] | 0) == 0) {
     $a$0 = $$lcssa321;
     $fl$4 = $fl$3;
     $p$2 = $p$1;
     $pl$1 = 0;
     $prefix$1 = 314216;
     label = 77;
    } else {
     $a$0 = $$lcssa321;
     $fl$4 = $fl$3;
     $p$2 = $p$1;
     $pl$1 = 2;
     $prefix$1 = 314216 + ($t$1 >> 4) | 0;
     label = 77;
    }
   }
  } else if ((label | 0) == 76) {
   label = 0;
   $a$0 = _fmt_u($287, $288, $1) | 0;
   $fl$4 = $fl$1$;
   $p$2 = $p$0;
   $pl$1 = $pl$0;
   $prefix$1 = $prefix$0;
   label = 77;
  } else if ((label | 0) == 82) {
   label = 0;
   $321 = _memchr($a$1, 0, $p$0) | 0;
   $322 = ($321 | 0) == 0;
   $a$2 = $a$1;
   $fl$6 = $176;
   $p$5 = $322 ? $p$0 : $321 - $a$1 | 0;
   $pl$2 = 0;
   $prefix$2 = 314216;
   $z$2 = $322 ? $a$1 + $p$0 | 0 : $321;
  } else if ((label | 0) == 86) {
   label = 0;
   $i$0105 = 0;
   $l$1104 = 0;
   $ws$0106 = $798;
   while (1) {
    $334 = HEAP32[$ws$0106 >> 2] | 0;
    if (!$334) {
     $i$0$lcssa = $i$0105;
     $l$2 = $l$1104;
     break;
    }
    $336 = _wctomb($mb, $334) | 0;
    if (($336 | 0) < 0 | $336 >>> 0 > ($p$4176 - $i$0105 | 0) >>> 0) {
     $i$0$lcssa = $i$0105;
     $l$2 = $336;
     break;
    }
    $341 = $336 + $i$0105 | 0;
    if ($p$4176 >>> 0 > $341 >>> 0) {
     $i$0105 = $341;
     $l$1104 = $336;
     $ws$0106 = $ws$0106 + 4 | 0;
    } else {
     $i$0$lcssa = $341;
     $l$2 = $336;
     break;
    }
   }
   if (($l$2 | 0) < 0) {
    $$0 = -1;
    break L1;
   }
   _pad($f, 32, $w$1, $i$0$lcssa, $fl$1$);
   if (!$i$0$lcssa) {
    $i$0$lcssa178 = 0;
    label = 97;
   } else {
    $i$1116 = 0;
    $ws$1117 = $798;
    while (1) {
     $345 = HEAP32[$ws$1117 >> 2] | 0;
     if (!$345) {
      $i$0$lcssa178 = $i$0$lcssa;
      label = 97;
      break L311;
     }
     $348 = _wctomb($mb, $345) | 0;
     $i$1116 = $348 + $i$1116 | 0;
     if (($i$1116 | 0) > ($i$0$lcssa | 0)) {
      $i$0$lcssa178 = $i$0$lcssa;
      label = 97;
      break L311;
     }
     if (!(HEAP32[$f >> 2] & 32)) ___fwritex($mb, $348, $f) | 0;
     if ($i$1116 >>> 0 >= $i$0$lcssa >>> 0) {
      $i$0$lcssa178 = $i$0$lcssa;
      label = 97;
      break;
     } else $ws$1117 = $ws$1117 + 4 | 0;
    }
   }
  } while (0);
  if ((label | 0) == 97) {
   label = 0;
   _pad($f, 32, $w$1, $i$0$lcssa178, $fl$1$ ^ 8192);
   $cnt$0 = $cnt$1;
   $l$0 = ($w$1 | 0) > ($i$0$lcssa178 | 0) ? $w$1 : $i$0$lcssa178;
   $l10n$0 = $l10n$3;
   $s$0 = $$lcssa300;
   continue;
  }
  if ((label | 0) == 77) {
   label = 0;
   $$fl$4 = ($p$2 | 0) > -1 ? $fl$4 & -65537 : $fl$4;
   $292 = $arg;
   $300 = (HEAP32[$292 >> 2] | 0) != 0 | (HEAP32[$292 + 4 >> 2] | 0) != 0;
   if (($p$2 | 0) != 0 | $300) {
    $306 = ($300 & 1 ^ 1) + ($2 - $a$0) | 0;
    $a$2 = $a$0;
    $fl$6 = $$fl$4;
    $p$5 = ($p$2 | 0) > ($306 | 0) ? $p$2 : $306;
    $pl$2 = $pl$1;
    $prefix$2 = $prefix$1;
    $z$2 = $1;
   } else {
    $a$2 = $1;
    $fl$6 = $$fl$4;
    $p$5 = 0;
    $pl$2 = $pl$1;
    $prefix$2 = $prefix$1;
    $z$2 = $1;
   }
  }
  $772 = $z$2 - $a$2 | 0;
  $$p$5 = ($p$5 | 0) < ($772 | 0) ? $772 : $p$5;
  $774 = $pl$2 + $$p$5 | 0;
  $w$2 = ($w$1 | 0) < ($774 | 0) ? $774 : $w$1;
  _pad($f, 32, $w$2, $774, $fl$6);
  if (!(HEAP32[$f >> 2] & 32)) ___fwritex($prefix$2, $pl$2, $f) | 0;
  _pad($f, 48, $w$2, $774, $fl$6 ^ 65536);
  _pad($f, 48, $$p$5, $772, 0);
  if (!(HEAP32[$f >> 2] & 32)) ___fwritex($a$2, $772, $f) | 0;
  _pad($f, 32, $w$2, $774, $fl$6 ^ 8192);
  $cnt$0 = $cnt$1;
  $l$0 = $w$2;
  $l10n$0 = $l10n$3;
  $s$0 = $$lcssa300;
 }
 L345 : do if ((label | 0) == 244) if (!$f) if (!$l10n$0$lcssa) $$0 = 0; else {
  $i$291 = 1;
  while (1) {
   $787 = HEAP32[$nl_type + ($i$291 << 2) >> 2] | 0;
   if (!$787) {
    $i$291$lcssa = $i$291;
    break;
   }
   _pop_arg($nl_arg + ($i$291 << 3) | 0, $787, $ap);
   $i$291 = $i$291 + 1 | 0;
   if (($i$291 | 0) >= 10) {
    $$0 = 1;
    break L345;
   }
  }
  if (($i$291$lcssa | 0) < 10) {
   $i$389 = $i$291$lcssa;
   while (1) {
    if (HEAP32[$nl_type + ($i$389 << 2) >> 2] | 0) {
     $$0 = -1;
     break L345;
    }
    $i$389 = $i$389 + 1 | 0;
    if (($i$389 | 0) >= 10) {
     $$0 = 1;
     break;
    }
   }
  } else $$0 = 1;
 } else $$0 = $cnt$1$lcssa; while (0);
 STACKTOP = sp;
 return $$0 | 0;
}

function _malloc($bytes) {
 $bytes = $bytes | 0;
 var $$0 = 0, $$lcssa = 0, $$lcssa141 = 0, $$lcssa142 = 0, $$lcssa144 = 0, $$lcssa147 = 0, $$lcssa149 = 0, $$lcssa151 = 0, $$lcssa153 = 0, $$lcssa155 = 0, $$lcssa157 = 0, $$pre$phi$i$iZ2D = 0, $$pre$phi$i14Z2D = 0, $$pre$phi$i17$iZ2D = 0, $$pre$phi$iZ2D = 0, $$pre$phi10$i$iZ2D = 0, $$pre$phiZ2D = 0, $$rsize$4$i = 0, $100 = 0, $1001 = 0, $1006 = 0, $101 = 0, $1012 = 0, $1015 = 0, $1016 = 0, $1034 = 0, $1036 = 0, $1043 = 0, $1044 = 0, $1045 = 0, $1053 = 0, $1055 = 0, $1056 = 0, $1057 = 0, $107 = 0, $111 = 0, $113 = 0, $114 = 0, $116 = 0, $118 = 0, $12 = 0, $120 = 0, $122 = 0, $124 = 0, $126 = 0, $128 = 0, $133 = 0, $139 = 0, $14 = 0, $142 = 0, $145 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $152 = 0, $155 = 0, $157 = 0, $16 = 0, $160 = 0, $162 = 0, $165 = 0, $168 = 0, $169 = 0, $17 = 0, $171 = 0, $172 = 0, $174 = 0, $175 = 0, $177 = 0, $178 = 0, $18 = 0, $183 = 0, $184 = 0, $193 = 0, $198 = 0, $202 = 0, $208 = 0, $215 = 0, $219 = 0, $227 = 0, $229 = 0, $230 = 0, $232 = 0, $233 = 0, $234 = 0, $238 = 0, $239 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $251 = 0, $252 = 0, $257 = 0, $258 = 0, $261 = 0, $263 = 0, $266 = 0, $271 = 0, $278 = 0, $28 = 0, $287 = 0, $288 = 0, $292 = 0, $298 = 0, $303 = 0, $306 = 0, $310 = 0, $312 = 0, $313 = 0, $315 = 0, $317 = 0, $319 = 0, $32 = 0, $321 = 0, $323 = 0, $325 = 0, $327 = 0, $337 = 0, $338 = 0, $340 = 0, $349 = 0, $35 = 0, $351 = 0, $354 = 0, $356 = 0, $359 = 0, $361 = 0, $364 = 0, $367 = 0, $368 = 0, $370 = 0, $371 = 0, $373 = 0, $374 = 0, $376 = 0, $377 = 0, $382 = 0, $383 = 0, $39 = 0, $392 = 0, $397 = 0, $4 = 0, $401 = 0, $407 = 0, $414 = 0, $418 = 0, $42 = 0, $426 = 0, $429 = 0, $430 = 0, $431 = 0, $435 = 0, $436 = 0, $442 = 0, $447 = 0, $448 = 0, $45 = 0, $451 = 0, $453 = 0, $456 = 0, $461 = 0, $467 = 0, $469 = 0, $47 = 0, $471 = 0, $472 = 0, $48 = 0, $490 = 0, $492 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $509 = 0, $511 = 0, $512 = 0, $514 = 0, $52 = 0, $523 = 0, $527 = 0, $529 = 0, $530 = 0, $531 = 0, $539 = 0, $54 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $550 = 0, $551 = 0, $553 = 0, $555 = 0, $556 = 0, $56 = 0, $562 = 0, $564 = 0, $566 = 0, $573 = 0, $575 = 0, $576 = 0, $577 = 0, $58 = 0, $585 = 0, $586 = 0, $589 = 0, $593 = 0, $597 = 0, $599 = 0, $6 = 0, $60 = 0, $605 = 0, $609 = 0, $613 = 0, $62 = 0, $622 = 0, $623 = 0, $629 = 0, $632 = 0, $635 = 0, $637 = 0, $642 = 0, $648 = 0, $65 = 0, $653 = 0, $654 = 0, $655 = 0, $661 = 0, $662 = 0, $663 = 0, $67 = 0, $678 = 0, $68 = 0, $683 = 0, $684 = 0, $686 = 0, $69 = 0, $692 = 0, $694 = 0, $7 = 0, $70 = 0, $704 = 0, $708 = 0, $71 = 0, $714 = 0, $716 = 0, $722 = 0, $726 = 0, $727 = 0, $732 = 0, $738 = 0, $743 = 0, $746 = 0, $747 = 0, $750 = 0, $752 = 0, $754 = 0, $757 = 0, $768 = 0, $773 = 0, $775 = 0, $778 = 0, $78 = 0, $780 = 0, $783 = 0, $786 = 0, $787 = 0, $788 = 0, $790 = 0, $792 = 0, $793 = 0, $795 = 0, $796 = 0, $801 = 0, $802 = 0, $811 = 0, $816 = 0, $819 = 0, $82 = 0, $820 = 0, $826 = 0, $834 = 0, $840 = 0, $843 = 0, $844 = 0, $845 = 0, $849 = 0, $85 = 0, $850 = 0, $856 = 0, $861 = 0, $862 = 0, $865 = 0, $867 = 0, $870 = 0, $875 = 0, $881 = 0, $883 = 0, $885 = 0, $886 = 0, $89 = 0, $904 = 0, $906 = 0, $91 = 0, $913 = 0, $914 = 0, $915 = 0, $92 = 0, $922 = 0, $926 = 0, $930 = 0, $932 = 0, $938 = 0, $939 = 0, $94 = 0, $941 = 0, $942 = 0, $946 = 0, $95 = 0, $951 = 0, $952 = 0, $953 = 0, $959 = 0, $96 = 0, $966 = 0, $971 = 0, $974 = 0, $975 = 0, $976 = 0, $980 = 0, $981 = 0, $987 = 0, $992 = 0, $993 = 0, $996 = 0, $998 = 0, $F$0$i$i = 0, $F1$0$i = 0, $F4$0 = 0, $F4$0$i$i = 0, $F5$0$i = 0, $I1$0$i$i = 0, $I7$0$i = 0, $I7$0$i$i = 0, $K12$0$i = 0, $K2$0$i$i = 0, $K8$0$i$i = 0, $R$1$i = 0, $R$1$i$i = 0, $R$1$i$i$lcssa = 0, $R$1$i$lcssa = 0, $R$1$i9 = 0, $R$1$i9$lcssa = 0, $R$3$i = 0, $R$3$i$i = 0, $R$3$i11 = 0, $RP$1$i = 0, $RP$1$i$i = 0, $RP$1$i$i$lcssa = 0, $RP$1$i$lcssa = 0, $RP$1$i8 = 0, $RP$1$i8$lcssa = 0, $T$0$i = 0, $T$0$i$i = 0, $T$0$i$i$lcssa = 0, $T$0$i$i$lcssa140 = 0, $T$0$i$lcssa = 0, $T$0$i$lcssa156 = 0, $T$0$i18$i = 0, $T$0$i18$i$lcssa = 0, $T$0$i18$i$lcssa139 = 0, $br$2$ph$i = 0, $i$01$i$i = 0, $idx$0$i = 0, $nb$0 = 0, $oldfirst$0$i$i = 0, $p$0$i$i = 0, $qsize$0$i$i = 0, $rsize$0$i = 0, $rsize$0$i$lcssa = 0, $rsize$0$i5 = 0, $rsize$1$i = 0, $rsize$3$i = 0, $rsize$4$lcssa$i = 0, $rsize$412$i = 0, $rst$0$i = 0, $rst$1$i = 0, $sizebits$0$i = 0, $sp$0$i$i = 0, $sp$0$i$i$i = 0, $sp$068$i = 0, $sp$068$i$lcssa = 0, $sp$167$i = 0, $sp$167$i$lcssa = 0, $ssize$0$i = 0, $ssize$2$ph$i = 0, $ssize$5$i = 0, $t$0$i = 0, $t$0$i4 = 0, $t$2$i = 0, $t$4$ph$i = 0, $t$4$v$4$i = 0, $t$411$i = 0, $tbase$746$i = 0, $tsize$745$i = 0, $v$0$i = 0, $v$0$i$lcssa = 0, $v$0$i6 = 0, $v$1$i = 0, $v$3$i = 0, $v$4$lcssa$i = 0, $v$413$i = 0, label = 0;
 do if ($bytes >>> 0 < 245) {
  $4 = $bytes >>> 0 < 11 ? 16 : $bytes + 11 & -8;
  $5 = $4 >>> 3;
  $6 = HEAP32[79268] | 0;
  $7 = $6 >>> $5;
  if ($7 & 3 | 0) {
   $12 = ($7 & 1 ^ 1) + $5 | 0;
   $14 = 317112 + ($12 << 1 << 2) | 0;
   $15 = $14 + 8 | 0;
   $16 = HEAP32[$15 >> 2] | 0;
   $17 = $16 + 8 | 0;
   $18 = HEAP32[$17 >> 2] | 0;
   do if (($14 | 0) == ($18 | 0)) HEAP32[79268] = $6 & ~(1 << $12); else {
    if ($18 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
    $25 = $18 + 12 | 0;
    if ((HEAP32[$25 >> 2] | 0) == ($16 | 0)) {
     HEAP32[$25 >> 2] = $14;
     HEAP32[$15 >> 2] = $18;
     break;
    } else _abort();
   } while (0);
   $28 = $12 << 3;
   HEAP32[$16 + 4 >> 2] = $28 | 3;
   $32 = $16 + $28 + 4 | 0;
   HEAP32[$32 >> 2] = HEAP32[$32 >> 2] | 1;
   $$0 = $17;
   return $$0 | 0;
  }
  $35 = HEAP32[79270] | 0;
  if ($4 >>> 0 > $35 >>> 0) {
   if ($7 | 0) {
    $39 = 2 << $5;
    $42 = $7 << $5 & ($39 | 0 - $39);
    $45 = ($42 & 0 - $42) + -1 | 0;
    $47 = $45 >>> 12 & 16;
    $48 = $45 >>> $47;
    $50 = $48 >>> 5 & 8;
    $52 = $48 >>> $50;
    $54 = $52 >>> 2 & 4;
    $56 = $52 >>> $54;
    $58 = $56 >>> 1 & 2;
    $60 = $56 >>> $58;
    $62 = $60 >>> 1 & 1;
    $65 = ($50 | $47 | $54 | $58 | $62) + ($60 >>> $62) | 0;
    $67 = 317112 + ($65 << 1 << 2) | 0;
    $68 = $67 + 8 | 0;
    $69 = HEAP32[$68 >> 2] | 0;
    $70 = $69 + 8 | 0;
    $71 = HEAP32[$70 >> 2] | 0;
    do if (($67 | 0) == ($71 | 0)) {
     HEAP32[79268] = $6 & ~(1 << $65);
     $89 = $35;
    } else {
     if ($71 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
     $78 = $71 + 12 | 0;
     if ((HEAP32[$78 >> 2] | 0) == ($69 | 0)) {
      HEAP32[$78 >> 2] = $67;
      HEAP32[$68 >> 2] = $71;
      $89 = HEAP32[79270] | 0;
      break;
     } else _abort();
    } while (0);
    $82 = ($65 << 3) - $4 | 0;
    HEAP32[$69 + 4 >> 2] = $4 | 3;
    $85 = $69 + $4 | 0;
    HEAP32[$85 + 4 >> 2] = $82 | 1;
    HEAP32[$85 + $82 >> 2] = $82;
    if ($89 | 0) {
     $91 = HEAP32[79273] | 0;
     $92 = $89 >>> 3;
     $94 = 317112 + ($92 << 1 << 2) | 0;
     $95 = HEAP32[79268] | 0;
     $96 = 1 << $92;
     if (!($95 & $96)) {
      HEAP32[79268] = $95 | $96;
      $$pre$phiZ2D = $94 + 8 | 0;
      $F4$0 = $94;
     } else {
      $100 = $94 + 8 | 0;
      $101 = HEAP32[$100 >> 2] | 0;
      if ($101 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
       $$pre$phiZ2D = $100;
       $F4$0 = $101;
      }
     }
     HEAP32[$$pre$phiZ2D >> 2] = $91;
     HEAP32[$F4$0 + 12 >> 2] = $91;
     HEAP32[$91 + 8 >> 2] = $F4$0;
     HEAP32[$91 + 12 >> 2] = $94;
    }
    HEAP32[79270] = $82;
    HEAP32[79273] = $85;
    $$0 = $70;
    return $$0 | 0;
   }
   $107 = HEAP32[79269] | 0;
   if (!$107) $nb$0 = $4; else {
    $111 = ($107 & 0 - $107) + -1 | 0;
    $113 = $111 >>> 12 & 16;
    $114 = $111 >>> $113;
    $116 = $114 >>> 5 & 8;
    $118 = $114 >>> $116;
    $120 = $118 >>> 2 & 4;
    $122 = $118 >>> $120;
    $124 = $122 >>> 1 & 2;
    $126 = $122 >>> $124;
    $128 = $126 >>> 1 & 1;
    $133 = HEAP32[317376 + (($116 | $113 | $120 | $124 | $128) + ($126 >>> $128) << 2) >> 2] | 0;
    $rsize$0$i = (HEAP32[$133 + 4 >> 2] & -8) - $4 | 0;
    $t$0$i = $133;
    $v$0$i = $133;
    while (1) {
     $139 = HEAP32[$t$0$i + 16 >> 2] | 0;
     if (!$139) {
      $142 = HEAP32[$t$0$i + 20 >> 2] | 0;
      if (!$142) {
       $rsize$0$i$lcssa = $rsize$0$i;
       $v$0$i$lcssa = $v$0$i;
       break;
      } else $145 = $142;
     } else $145 = $139;
     $148 = (HEAP32[$145 + 4 >> 2] & -8) - $4 | 0;
     $149 = $148 >>> 0 < $rsize$0$i >>> 0;
     $rsize$0$i = $149 ? $148 : $rsize$0$i;
     $t$0$i = $145;
     $v$0$i = $149 ? $145 : $v$0$i;
    }
    $150 = HEAP32[79272] | 0;
    if ($v$0$i$lcssa >>> 0 < $150 >>> 0) _abort();
    $152 = $v$0$i$lcssa + $4 | 0;
    if ($v$0$i$lcssa >>> 0 >= $152 >>> 0) _abort();
    $155 = HEAP32[$v$0$i$lcssa + 24 >> 2] | 0;
    $157 = HEAP32[$v$0$i$lcssa + 12 >> 2] | 0;
    do if (($157 | 0) == ($v$0$i$lcssa | 0)) {
     $168 = $v$0$i$lcssa + 20 | 0;
     $169 = HEAP32[$168 >> 2] | 0;
     if (!$169) {
      $171 = $v$0$i$lcssa + 16 | 0;
      $172 = HEAP32[$171 >> 2] | 0;
      if (!$172) {
       $R$3$i = 0;
       break;
      } else {
       $R$1$i = $172;
       $RP$1$i = $171;
      }
     } else {
      $R$1$i = $169;
      $RP$1$i = $168;
     }
     while (1) {
      $174 = $R$1$i + 20 | 0;
      $175 = HEAP32[$174 >> 2] | 0;
      if ($175 | 0) {
       $R$1$i = $175;
       $RP$1$i = $174;
       continue;
      }
      $177 = $R$1$i + 16 | 0;
      $178 = HEAP32[$177 >> 2] | 0;
      if (!$178) {
       $R$1$i$lcssa = $R$1$i;
       $RP$1$i$lcssa = $RP$1$i;
       break;
      } else {
       $R$1$i = $178;
       $RP$1$i = $177;
      }
     }
     if ($RP$1$i$lcssa >>> 0 < $150 >>> 0) _abort(); else {
      HEAP32[$RP$1$i$lcssa >> 2] = 0;
      $R$3$i = $R$1$i$lcssa;
      break;
     }
    } else {
     $160 = HEAP32[$v$0$i$lcssa + 8 >> 2] | 0;
     if ($160 >>> 0 < $150 >>> 0) _abort();
     $162 = $160 + 12 | 0;
     if ((HEAP32[$162 >> 2] | 0) != ($v$0$i$lcssa | 0)) _abort();
     $165 = $157 + 8 | 0;
     if ((HEAP32[$165 >> 2] | 0) == ($v$0$i$lcssa | 0)) {
      HEAP32[$162 >> 2] = $157;
      HEAP32[$165 >> 2] = $160;
      $R$3$i = $157;
      break;
     } else _abort();
    } while (0);
    do if ($155 | 0) {
     $183 = HEAP32[$v$0$i$lcssa + 28 >> 2] | 0;
     $184 = 317376 + ($183 << 2) | 0;
     if (($v$0$i$lcssa | 0) == (HEAP32[$184 >> 2] | 0)) {
      HEAP32[$184 >> 2] = $R$3$i;
      if (!$R$3$i) {
       HEAP32[79269] = HEAP32[79269] & ~(1 << $183);
       break;
      }
     } else {
      if ($155 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
      $193 = $155 + 16 | 0;
      if ((HEAP32[$193 >> 2] | 0) == ($v$0$i$lcssa | 0)) HEAP32[$193 >> 2] = $R$3$i; else HEAP32[$155 + 20 >> 2] = $R$3$i;
      if (!$R$3$i) break;
     }
     $198 = HEAP32[79272] | 0;
     if ($R$3$i >>> 0 < $198 >>> 0) _abort();
     HEAP32[$R$3$i + 24 >> 2] = $155;
     $202 = HEAP32[$v$0$i$lcssa + 16 >> 2] | 0;
     do if ($202 | 0) if ($202 >>> 0 < $198 >>> 0) _abort(); else {
      HEAP32[$R$3$i + 16 >> 2] = $202;
      HEAP32[$202 + 24 >> 2] = $R$3$i;
      break;
     } while (0);
     $208 = HEAP32[$v$0$i$lcssa + 20 >> 2] | 0;
     if ($208 | 0) if ($208 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
      HEAP32[$R$3$i + 20 >> 2] = $208;
      HEAP32[$208 + 24 >> 2] = $R$3$i;
      break;
     }
    } while (0);
    if ($rsize$0$i$lcssa >>> 0 < 16) {
     $215 = $rsize$0$i$lcssa + $4 | 0;
     HEAP32[$v$0$i$lcssa + 4 >> 2] = $215 | 3;
     $219 = $v$0$i$lcssa + $215 + 4 | 0;
     HEAP32[$219 >> 2] = HEAP32[$219 >> 2] | 1;
    } else {
     HEAP32[$v$0$i$lcssa + 4 >> 2] = $4 | 3;
     HEAP32[$152 + 4 >> 2] = $rsize$0$i$lcssa | 1;
     HEAP32[$152 + $rsize$0$i$lcssa >> 2] = $rsize$0$i$lcssa;
     $227 = HEAP32[79270] | 0;
     if ($227 | 0) {
      $229 = HEAP32[79273] | 0;
      $230 = $227 >>> 3;
      $232 = 317112 + ($230 << 1 << 2) | 0;
      $233 = HEAP32[79268] | 0;
      $234 = 1 << $230;
      if (!($233 & $234)) {
       HEAP32[79268] = $233 | $234;
       $$pre$phi$iZ2D = $232 + 8 | 0;
       $F1$0$i = $232;
      } else {
       $238 = $232 + 8 | 0;
       $239 = HEAP32[$238 >> 2] | 0;
       if ($239 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
        $$pre$phi$iZ2D = $238;
        $F1$0$i = $239;
       }
      }
      HEAP32[$$pre$phi$iZ2D >> 2] = $229;
      HEAP32[$F1$0$i + 12 >> 2] = $229;
      HEAP32[$229 + 8 >> 2] = $F1$0$i;
      HEAP32[$229 + 12 >> 2] = $232;
     }
     HEAP32[79270] = $rsize$0$i$lcssa;
     HEAP32[79273] = $152;
    }
    $$0 = $v$0$i$lcssa + 8 | 0;
    return $$0 | 0;
   }
  } else $nb$0 = $4;
 } else if ($bytes >>> 0 > 4294967231) $nb$0 = -1; else {
  $247 = $bytes + 11 | 0;
  $248 = $247 & -8;
  $249 = HEAP32[79269] | 0;
  if (!$249) $nb$0 = $248; else {
   $251 = 0 - $248 | 0;
   $252 = $247 >>> 8;
   if (!$252) $idx$0$i = 0; else if ($248 >>> 0 > 16777215) $idx$0$i = 31; else {
    $257 = ($252 + 1048320 | 0) >>> 16 & 8;
    $258 = $252 << $257;
    $261 = ($258 + 520192 | 0) >>> 16 & 4;
    $263 = $258 << $261;
    $266 = ($263 + 245760 | 0) >>> 16 & 2;
    $271 = 14 - ($261 | $257 | $266) + ($263 << $266 >>> 15) | 0;
    $idx$0$i = $248 >>> ($271 + 7 | 0) & 1 | $271 << 1;
   }
   $278 = HEAP32[317376 + ($idx$0$i << 2) >> 2] | 0;
   L123 : do if (!$278) {
    $rsize$3$i = $251;
    $t$2$i = 0;
    $v$3$i = 0;
    label = 86;
   } else {
    $rsize$0$i5 = $251;
    $rst$0$i = 0;
    $sizebits$0$i = $248 << (($idx$0$i | 0) == 31 ? 0 : 25 - ($idx$0$i >>> 1) | 0);
    $t$0$i4 = $278;
    $v$0$i6 = 0;
    while (1) {
     $287 = HEAP32[$t$0$i4 + 4 >> 2] & -8;
     $288 = $287 - $248 | 0;
     if ($288 >>> 0 < $rsize$0$i5 >>> 0) if (($287 | 0) == ($248 | 0)) {
      $rsize$412$i = $288;
      $t$411$i = $t$0$i4;
      $v$413$i = $t$0$i4;
      label = 90;
      break L123;
     } else {
      $rsize$1$i = $288;
      $v$1$i = $t$0$i4;
     } else {
      $rsize$1$i = $rsize$0$i5;
      $v$1$i = $v$0$i6;
     }
     $292 = HEAP32[$t$0$i4 + 20 >> 2] | 0;
     $t$0$i4 = HEAP32[$t$0$i4 + 16 + ($sizebits$0$i >>> 31 << 2) >> 2] | 0;
     $rst$1$i = ($292 | 0) == 0 | ($292 | 0) == ($t$0$i4 | 0) ? $rst$0$i : $292;
     $298 = ($t$0$i4 | 0) == 0;
     if ($298) {
      $rsize$3$i = $rsize$1$i;
      $t$2$i = $rst$1$i;
      $v$3$i = $v$1$i;
      label = 86;
      break;
     } else {
      $rsize$0$i5 = $rsize$1$i;
      $rst$0$i = $rst$1$i;
      $sizebits$0$i = $sizebits$0$i << ($298 & 1 ^ 1);
      $v$0$i6 = $v$1$i;
     }
    }
   } while (0);
   if ((label | 0) == 86) {
    if (($t$2$i | 0) == 0 & ($v$3$i | 0) == 0) {
     $303 = 2 << $idx$0$i;
     $306 = $249 & ($303 | 0 - $303);
     if (!$306) {
      $nb$0 = $248;
      break;
     }
     $310 = ($306 & 0 - $306) + -1 | 0;
     $312 = $310 >>> 12 & 16;
     $313 = $310 >>> $312;
     $315 = $313 >>> 5 & 8;
     $317 = $313 >>> $315;
     $319 = $317 >>> 2 & 4;
     $321 = $317 >>> $319;
     $323 = $321 >>> 1 & 2;
     $325 = $321 >>> $323;
     $327 = $325 >>> 1 & 1;
     $t$4$ph$i = HEAP32[317376 + (($315 | $312 | $319 | $323 | $327) + ($325 >>> $327) << 2) >> 2] | 0;
    } else $t$4$ph$i = $t$2$i;
    if (!$t$4$ph$i) {
     $rsize$4$lcssa$i = $rsize$3$i;
     $v$4$lcssa$i = $v$3$i;
    } else {
     $rsize$412$i = $rsize$3$i;
     $t$411$i = $t$4$ph$i;
     $v$413$i = $v$3$i;
     label = 90;
    }
   }
   if ((label | 0) == 90) while (1) {
    label = 0;
    $337 = (HEAP32[$t$411$i + 4 >> 2] & -8) - $248 | 0;
    $338 = $337 >>> 0 < $rsize$412$i >>> 0;
    $$rsize$4$i = $338 ? $337 : $rsize$412$i;
    $t$4$v$4$i = $338 ? $t$411$i : $v$413$i;
    $340 = HEAP32[$t$411$i + 16 >> 2] | 0;
    if ($340 | 0) {
     $rsize$412$i = $$rsize$4$i;
     $t$411$i = $340;
     $v$413$i = $t$4$v$4$i;
     label = 90;
     continue;
    }
    $t$411$i = HEAP32[$t$411$i + 20 >> 2] | 0;
    if (!$t$411$i) {
     $rsize$4$lcssa$i = $$rsize$4$i;
     $v$4$lcssa$i = $t$4$v$4$i;
     break;
    } else {
     $rsize$412$i = $$rsize$4$i;
     $v$413$i = $t$4$v$4$i;
     label = 90;
    }
   }
   if (!$v$4$lcssa$i) $nb$0 = $248; else if ($rsize$4$lcssa$i >>> 0 < ((HEAP32[79270] | 0) - $248 | 0) >>> 0) {
    $349 = HEAP32[79272] | 0;
    if ($v$4$lcssa$i >>> 0 < $349 >>> 0) _abort();
    $351 = $v$4$lcssa$i + $248 | 0;
    if ($v$4$lcssa$i >>> 0 >= $351 >>> 0) _abort();
    $354 = HEAP32[$v$4$lcssa$i + 24 >> 2] | 0;
    $356 = HEAP32[$v$4$lcssa$i + 12 >> 2] | 0;
    do if (($356 | 0) == ($v$4$lcssa$i | 0)) {
     $367 = $v$4$lcssa$i + 20 | 0;
     $368 = HEAP32[$367 >> 2] | 0;
     if (!$368) {
      $370 = $v$4$lcssa$i + 16 | 0;
      $371 = HEAP32[$370 >> 2] | 0;
      if (!$371) {
       $R$3$i11 = 0;
       break;
      } else {
       $R$1$i9 = $371;
       $RP$1$i8 = $370;
      }
     } else {
      $R$1$i9 = $368;
      $RP$1$i8 = $367;
     }
     while (1) {
      $373 = $R$1$i9 + 20 | 0;
      $374 = HEAP32[$373 >> 2] | 0;
      if ($374 | 0) {
       $R$1$i9 = $374;
       $RP$1$i8 = $373;
       continue;
      }
      $376 = $R$1$i9 + 16 | 0;
      $377 = HEAP32[$376 >> 2] | 0;
      if (!$377) {
       $R$1$i9$lcssa = $R$1$i9;
       $RP$1$i8$lcssa = $RP$1$i8;
       break;
      } else {
       $R$1$i9 = $377;
       $RP$1$i8 = $376;
      }
     }
     if ($RP$1$i8$lcssa >>> 0 < $349 >>> 0) _abort(); else {
      HEAP32[$RP$1$i8$lcssa >> 2] = 0;
      $R$3$i11 = $R$1$i9$lcssa;
      break;
     }
    } else {
     $359 = HEAP32[$v$4$lcssa$i + 8 >> 2] | 0;
     if ($359 >>> 0 < $349 >>> 0) _abort();
     $361 = $359 + 12 | 0;
     if ((HEAP32[$361 >> 2] | 0) != ($v$4$lcssa$i | 0)) _abort();
     $364 = $356 + 8 | 0;
     if ((HEAP32[$364 >> 2] | 0) == ($v$4$lcssa$i | 0)) {
      HEAP32[$361 >> 2] = $356;
      HEAP32[$364 >> 2] = $359;
      $R$3$i11 = $356;
      break;
     } else _abort();
    } while (0);
    do if ($354 | 0) {
     $382 = HEAP32[$v$4$lcssa$i + 28 >> 2] | 0;
     $383 = 317376 + ($382 << 2) | 0;
     if (($v$4$lcssa$i | 0) == (HEAP32[$383 >> 2] | 0)) {
      HEAP32[$383 >> 2] = $R$3$i11;
      if (!$R$3$i11) {
       HEAP32[79269] = HEAP32[79269] & ~(1 << $382);
       break;
      }
     } else {
      if ($354 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
      $392 = $354 + 16 | 0;
      if ((HEAP32[$392 >> 2] | 0) == ($v$4$lcssa$i | 0)) HEAP32[$392 >> 2] = $R$3$i11; else HEAP32[$354 + 20 >> 2] = $R$3$i11;
      if (!$R$3$i11) break;
     }
     $397 = HEAP32[79272] | 0;
     if ($R$3$i11 >>> 0 < $397 >>> 0) _abort();
     HEAP32[$R$3$i11 + 24 >> 2] = $354;
     $401 = HEAP32[$v$4$lcssa$i + 16 >> 2] | 0;
     do if ($401 | 0) if ($401 >>> 0 < $397 >>> 0) _abort(); else {
      HEAP32[$R$3$i11 + 16 >> 2] = $401;
      HEAP32[$401 + 24 >> 2] = $R$3$i11;
      break;
     } while (0);
     $407 = HEAP32[$v$4$lcssa$i + 20 >> 2] | 0;
     if ($407 | 0) if ($407 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
      HEAP32[$R$3$i11 + 20 >> 2] = $407;
      HEAP32[$407 + 24 >> 2] = $R$3$i11;
      break;
     }
    } while (0);
    do if ($rsize$4$lcssa$i >>> 0 < 16) {
     $414 = $rsize$4$lcssa$i + $248 | 0;
     HEAP32[$v$4$lcssa$i + 4 >> 2] = $414 | 3;
     $418 = $v$4$lcssa$i + $414 + 4 | 0;
     HEAP32[$418 >> 2] = HEAP32[$418 >> 2] | 1;
    } else {
     HEAP32[$v$4$lcssa$i + 4 >> 2] = $248 | 3;
     HEAP32[$351 + 4 >> 2] = $rsize$4$lcssa$i | 1;
     HEAP32[$351 + $rsize$4$lcssa$i >> 2] = $rsize$4$lcssa$i;
     $426 = $rsize$4$lcssa$i >>> 3;
     if ($rsize$4$lcssa$i >>> 0 < 256) {
      $429 = 317112 + ($426 << 1 << 2) | 0;
      $430 = HEAP32[79268] | 0;
      $431 = 1 << $426;
      if (!($430 & $431)) {
       HEAP32[79268] = $430 | $431;
       $$pre$phi$i14Z2D = $429 + 8 | 0;
       $F5$0$i = $429;
      } else {
       $435 = $429 + 8 | 0;
       $436 = HEAP32[$435 >> 2] | 0;
       if ($436 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
        $$pre$phi$i14Z2D = $435;
        $F5$0$i = $436;
       }
      }
      HEAP32[$$pre$phi$i14Z2D >> 2] = $351;
      HEAP32[$F5$0$i + 12 >> 2] = $351;
      HEAP32[$351 + 8 >> 2] = $F5$0$i;
      HEAP32[$351 + 12 >> 2] = $429;
      break;
     }
     $442 = $rsize$4$lcssa$i >>> 8;
     if (!$442) $I7$0$i = 0; else if ($rsize$4$lcssa$i >>> 0 > 16777215) $I7$0$i = 31; else {
      $447 = ($442 + 1048320 | 0) >>> 16 & 8;
      $448 = $442 << $447;
      $451 = ($448 + 520192 | 0) >>> 16 & 4;
      $453 = $448 << $451;
      $456 = ($453 + 245760 | 0) >>> 16 & 2;
      $461 = 14 - ($451 | $447 | $456) + ($453 << $456 >>> 15) | 0;
      $I7$0$i = $rsize$4$lcssa$i >>> ($461 + 7 | 0) & 1 | $461 << 1;
     }
     $467 = 317376 + ($I7$0$i << 2) | 0;
     HEAP32[$351 + 28 >> 2] = $I7$0$i;
     $469 = $351 + 16 | 0;
     HEAP32[$469 + 4 >> 2] = 0;
     HEAP32[$469 >> 2] = 0;
     $471 = HEAP32[79269] | 0;
     $472 = 1 << $I7$0$i;
     if (!($471 & $472)) {
      HEAP32[79269] = $471 | $472;
      HEAP32[$467 >> 2] = $351;
      HEAP32[$351 + 24 >> 2] = $467;
      HEAP32[$351 + 12 >> 2] = $351;
      HEAP32[$351 + 8 >> 2] = $351;
      break;
     }
     $K12$0$i = $rsize$4$lcssa$i << (($I7$0$i | 0) == 31 ? 0 : 25 - ($I7$0$i >>> 1) | 0);
     $T$0$i = HEAP32[$467 >> 2] | 0;
     while (1) {
      if ((HEAP32[$T$0$i + 4 >> 2] & -8 | 0) == ($rsize$4$lcssa$i | 0)) {
       $T$0$i$lcssa = $T$0$i;
       label = 148;
       break;
      }
      $490 = $T$0$i + 16 + ($K12$0$i >>> 31 << 2) | 0;
      $492 = HEAP32[$490 >> 2] | 0;
      if (!$492) {
       $$lcssa157 = $490;
       $T$0$i$lcssa156 = $T$0$i;
       label = 145;
       break;
      } else {
       $K12$0$i = $K12$0$i << 1;
       $T$0$i = $492;
      }
     }
     if ((label | 0) == 145) if ($$lcssa157 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
      HEAP32[$$lcssa157 >> 2] = $351;
      HEAP32[$351 + 24 >> 2] = $T$0$i$lcssa156;
      HEAP32[$351 + 12 >> 2] = $351;
      HEAP32[$351 + 8 >> 2] = $351;
      break;
     } else if ((label | 0) == 148) {
      $499 = $T$0$i$lcssa + 8 | 0;
      $500 = HEAP32[$499 >> 2] | 0;
      $501 = HEAP32[79272] | 0;
      if ($500 >>> 0 >= $501 >>> 0 & $T$0$i$lcssa >>> 0 >= $501 >>> 0) {
       HEAP32[$500 + 12 >> 2] = $351;
       HEAP32[$499 >> 2] = $351;
       HEAP32[$351 + 8 >> 2] = $500;
       HEAP32[$351 + 12 >> 2] = $T$0$i$lcssa;
       HEAP32[$351 + 24 >> 2] = 0;
       break;
      } else _abort();
     }
    } while (0);
    $$0 = $v$4$lcssa$i + 8 | 0;
    return $$0 | 0;
   } else $nb$0 = $248;
  }
 } while (0);
 $509 = HEAP32[79270] | 0;
 if ($509 >>> 0 >= $nb$0 >>> 0) {
  $511 = $509 - $nb$0 | 0;
  $512 = HEAP32[79273] | 0;
  if ($511 >>> 0 > 15) {
   $514 = $512 + $nb$0 | 0;
   HEAP32[79273] = $514;
   HEAP32[79270] = $511;
   HEAP32[$514 + 4 >> 2] = $511 | 1;
   HEAP32[$514 + $511 >> 2] = $511;
   HEAP32[$512 + 4 >> 2] = $nb$0 | 3;
  } else {
   HEAP32[79270] = 0;
   HEAP32[79273] = 0;
   HEAP32[$512 + 4 >> 2] = $509 | 3;
   $523 = $512 + $509 + 4 | 0;
   HEAP32[$523 >> 2] = HEAP32[$523 >> 2] | 1;
  }
  $$0 = $512 + 8 | 0;
  return $$0 | 0;
 }
 $527 = HEAP32[79271] | 0;
 if ($527 >>> 0 > $nb$0 >>> 0) {
  $529 = $527 - $nb$0 | 0;
  HEAP32[79271] = $529;
  $530 = HEAP32[79274] | 0;
  $531 = $530 + $nb$0 | 0;
  HEAP32[79274] = $531;
  HEAP32[$531 + 4 >> 2] = $529 | 1;
  HEAP32[$530 + 4 >> 2] = $nb$0 | 3;
  $$0 = $530 + 8 | 0;
  return $$0 | 0;
 }
 do if (!(HEAP32[79386] | 0)) {
  $539 = _sysconf(30) | 0;
  if (!($539 + -1 & $539)) {
   HEAP32[79388] = $539;
   HEAP32[79387] = $539;
   HEAP32[79389] = -1;
   HEAP32[79390] = -1;
   HEAP32[79391] = 0;
   HEAP32[79379] = 0;
   HEAP32[79386] = (_time(0) | 0) & -16 ^ 1431655768;
   break;
  } else _abort();
 } while (0);
 $546 = $nb$0 + 48 | 0;
 $547 = HEAP32[79388] | 0;
 $548 = $nb$0 + 47 | 0;
 $549 = $547 + $548 | 0;
 $550 = 0 - $547 | 0;
 $551 = $549 & $550;
 if ($551 >>> 0 <= $nb$0 >>> 0) {
  $$0 = 0;
  return $$0 | 0;
 }
 $553 = HEAP32[79378] | 0;
 if ($553 | 0) {
  $555 = HEAP32[79376] | 0;
  $556 = $555 + $551 | 0;
  if ($556 >>> 0 <= $555 >>> 0 | $556 >>> 0 > $553 >>> 0) {
   $$0 = 0;
   return $$0 | 0;
  }
 }
 L257 : do if (!(HEAP32[79379] & 4)) {
  $562 = HEAP32[79274] | 0;
  L259 : do if (!$562) label = 173; else {
   $sp$0$i$i = 317520;
   while (1) {
    $564 = HEAP32[$sp$0$i$i >> 2] | 0;
    if ($564 >>> 0 <= $562 >>> 0) {
     $566 = $sp$0$i$i + 4 | 0;
     if (($564 + (HEAP32[$566 >> 2] | 0) | 0) >>> 0 > $562 >>> 0) {
      $$lcssa153 = $sp$0$i$i;
      $$lcssa155 = $566;
      break;
     }
    }
    $sp$0$i$i = HEAP32[$sp$0$i$i + 8 >> 2] | 0;
    if (!$sp$0$i$i) {
     label = 173;
     break L259;
    }
   }
   $597 = $549 - (HEAP32[79271] | 0) & $550;
   if ($597 >>> 0 < 2147483647) {
    $599 = _sbrk($597 | 0) | 0;
    if (($599 | 0) == ((HEAP32[$$lcssa153 >> 2] | 0) + (HEAP32[$$lcssa155 >> 2] | 0) | 0)) {
     if (($599 | 0) != (-1 | 0)) {
      $tbase$746$i = $599;
      $tsize$745$i = $597;
      label = 193;
      break L257;
     }
    } else {
     $br$2$ph$i = $599;
     $ssize$2$ph$i = $597;
     label = 183;
    }
   }
  } while (0);
  do if ((label | 0) == 173) {
   $573 = _sbrk(0) | 0;
   if (($573 | 0) != (-1 | 0)) {
    $575 = $573;
    $576 = HEAP32[79387] | 0;
    $577 = $576 + -1 | 0;
    if (!($577 & $575)) $ssize$0$i = $551; else $ssize$0$i = $551 - $575 + ($577 + $575 & 0 - $576) | 0;
    $585 = HEAP32[79376] | 0;
    $586 = $585 + $ssize$0$i | 0;
    if ($ssize$0$i >>> 0 > $nb$0 >>> 0 & $ssize$0$i >>> 0 < 2147483647) {
     $589 = HEAP32[79378] | 0;
     if ($589 | 0) if ($586 >>> 0 <= $585 >>> 0 | $586 >>> 0 > $589 >>> 0) break;
     $593 = _sbrk($ssize$0$i | 0) | 0;
     if (($593 | 0) == ($573 | 0)) {
      $tbase$746$i = $573;
      $tsize$745$i = $ssize$0$i;
      label = 193;
      break L257;
     } else {
      $br$2$ph$i = $593;
      $ssize$2$ph$i = $ssize$0$i;
      label = 183;
     }
    }
   }
  } while (0);
  L279 : do if ((label | 0) == 183) {
   $605 = 0 - $ssize$2$ph$i | 0;
   do if ($546 >>> 0 > $ssize$2$ph$i >>> 0 & ($ssize$2$ph$i >>> 0 < 2147483647 & ($br$2$ph$i | 0) != (-1 | 0))) {
    $609 = HEAP32[79388] | 0;
    $613 = $548 - $ssize$2$ph$i + $609 & 0 - $609;
    if ($613 >>> 0 < 2147483647) if ((_sbrk($613 | 0) | 0) == (-1 | 0)) {
     _sbrk($605 | 0) | 0;
     break L279;
    } else {
     $ssize$5$i = $613 + $ssize$2$ph$i | 0;
     break;
    } else $ssize$5$i = $ssize$2$ph$i;
   } else $ssize$5$i = $ssize$2$ph$i; while (0);
   if (($br$2$ph$i | 0) != (-1 | 0)) {
    $tbase$746$i = $br$2$ph$i;
    $tsize$745$i = $ssize$5$i;
    label = 193;
    break L257;
   }
  } while (0);
  HEAP32[79379] = HEAP32[79379] | 4;
  label = 190;
 } else label = 190; while (0);
 if ((label | 0) == 190) if ($551 >>> 0 < 2147483647) {
  $622 = _sbrk($551 | 0) | 0;
  $623 = _sbrk(0) | 0;
  if ($622 >>> 0 < $623 >>> 0 & (($622 | 0) != (-1 | 0) & ($623 | 0) != (-1 | 0))) {
   $629 = $623 - $622 | 0;
   if ($629 >>> 0 > ($nb$0 + 40 | 0) >>> 0) {
    $tbase$746$i = $622;
    $tsize$745$i = $629;
    label = 193;
   }
  }
 }
 if ((label | 0) == 193) {
  $632 = (HEAP32[79376] | 0) + $tsize$745$i | 0;
  HEAP32[79376] = $632;
  if ($632 >>> 0 > (HEAP32[79377] | 0) >>> 0) HEAP32[79377] = $632;
  $635 = HEAP32[79274] | 0;
  do if (!$635) {
   $637 = HEAP32[79272] | 0;
   if (($637 | 0) == 0 | $tbase$746$i >>> 0 < $637 >>> 0) HEAP32[79272] = $tbase$746$i;
   HEAP32[79380] = $tbase$746$i;
   HEAP32[79381] = $tsize$745$i;
   HEAP32[79383] = 0;
   HEAP32[79277] = HEAP32[79386];
   HEAP32[79276] = -1;
   $i$01$i$i = 0;
   do {
    $642 = 317112 + ($i$01$i$i << 1 << 2) | 0;
    HEAP32[$642 + 12 >> 2] = $642;
    HEAP32[$642 + 8 >> 2] = $642;
    $i$01$i$i = $i$01$i$i + 1 | 0;
   } while (($i$01$i$i | 0) != 32);
   $648 = $tbase$746$i + 8 | 0;
   $653 = ($648 & 7 | 0) == 0 ? 0 : 0 - $648 & 7;
   $654 = $tbase$746$i + $653 | 0;
   $655 = $tsize$745$i + -40 - $653 | 0;
   HEAP32[79274] = $654;
   HEAP32[79271] = $655;
   HEAP32[$654 + 4 >> 2] = $655 | 1;
   HEAP32[$654 + $655 + 4 >> 2] = 40;
   HEAP32[79275] = HEAP32[79390];
  } else {
   $sp$068$i = 317520;
   do {
    $661 = HEAP32[$sp$068$i >> 2] | 0;
    $662 = $sp$068$i + 4 | 0;
    $663 = HEAP32[$662 >> 2] | 0;
    if (($tbase$746$i | 0) == ($661 + $663 | 0)) {
     $$lcssa147 = $661;
     $$lcssa149 = $662;
     $$lcssa151 = $663;
     $sp$068$i$lcssa = $sp$068$i;
     label = 203;
     break;
    }
    $sp$068$i = HEAP32[$sp$068$i + 8 >> 2] | 0;
   } while (($sp$068$i | 0) != 0);
   if ((label | 0) == 203) if (!(HEAP32[$sp$068$i$lcssa + 12 >> 2] & 8)) if ($635 >>> 0 < $tbase$746$i >>> 0 & $635 >>> 0 >= $$lcssa147 >>> 0) {
    HEAP32[$$lcssa149 >> 2] = $$lcssa151 + $tsize$745$i;
    $678 = $635 + 8 | 0;
    $683 = ($678 & 7 | 0) == 0 ? 0 : 0 - $678 & 7;
    $684 = $635 + $683 | 0;
    $686 = $tsize$745$i - $683 + (HEAP32[79271] | 0) | 0;
    HEAP32[79274] = $684;
    HEAP32[79271] = $686;
    HEAP32[$684 + 4 >> 2] = $686 | 1;
    HEAP32[$684 + $686 + 4 >> 2] = 40;
    HEAP32[79275] = HEAP32[79390];
    break;
   }
   $692 = HEAP32[79272] | 0;
   if ($tbase$746$i >>> 0 < $692 >>> 0) {
    HEAP32[79272] = $tbase$746$i;
    $757 = $tbase$746$i;
   } else $757 = $692;
   $694 = $tbase$746$i + $tsize$745$i | 0;
   $sp$167$i = 317520;
   while (1) {
    if ((HEAP32[$sp$167$i >> 2] | 0) == ($694 | 0)) {
     $$lcssa144 = $sp$167$i;
     $sp$167$i$lcssa = $sp$167$i;
     label = 211;
     break;
    }
    $sp$167$i = HEAP32[$sp$167$i + 8 >> 2] | 0;
    if (!$sp$167$i) {
     $sp$0$i$i$i = 317520;
     break;
    }
   }
   if ((label | 0) == 211) if (!(HEAP32[$sp$167$i$lcssa + 12 >> 2] & 8)) {
    HEAP32[$$lcssa144 >> 2] = $tbase$746$i;
    $704 = $sp$167$i$lcssa + 4 | 0;
    HEAP32[$704 >> 2] = (HEAP32[$704 >> 2] | 0) + $tsize$745$i;
    $708 = $tbase$746$i + 8 | 0;
    $714 = $tbase$746$i + (($708 & 7 | 0) == 0 ? 0 : 0 - $708 & 7) | 0;
    $716 = $694 + 8 | 0;
    $722 = $694 + (($716 & 7 | 0) == 0 ? 0 : 0 - $716 & 7) | 0;
    $726 = $714 + $nb$0 | 0;
    $727 = $722 - $714 - $nb$0 | 0;
    HEAP32[$714 + 4 >> 2] = $nb$0 | 3;
    do if (($722 | 0) == ($635 | 0)) {
     $732 = (HEAP32[79271] | 0) + $727 | 0;
     HEAP32[79271] = $732;
     HEAP32[79274] = $726;
     HEAP32[$726 + 4 >> 2] = $732 | 1;
    } else {
     if (($722 | 0) == (HEAP32[79273] | 0)) {
      $738 = (HEAP32[79270] | 0) + $727 | 0;
      HEAP32[79270] = $738;
      HEAP32[79273] = $726;
      HEAP32[$726 + 4 >> 2] = $738 | 1;
      HEAP32[$726 + $738 >> 2] = $738;
      break;
     }
     $743 = HEAP32[$722 + 4 >> 2] | 0;
     if (($743 & 3 | 0) == 1) {
      $746 = $743 & -8;
      $747 = $743 >>> 3;
      L331 : do if ($743 >>> 0 < 256) {
       $750 = HEAP32[$722 + 8 >> 2] | 0;
       $752 = HEAP32[$722 + 12 >> 2] | 0;
       $754 = 317112 + ($747 << 1 << 2) | 0;
       do if (($750 | 0) != ($754 | 0)) {
        if ($750 >>> 0 < $757 >>> 0) _abort();
        if ((HEAP32[$750 + 12 >> 2] | 0) == ($722 | 0)) break;
        _abort();
       } while (0);
       if (($752 | 0) == ($750 | 0)) {
        HEAP32[79268] = HEAP32[79268] & ~(1 << $747);
        break;
       }
       do if (($752 | 0) == ($754 | 0)) $$pre$phi10$i$iZ2D = $752 + 8 | 0; else {
        if ($752 >>> 0 < $757 >>> 0) _abort();
        $768 = $752 + 8 | 0;
        if ((HEAP32[$768 >> 2] | 0) == ($722 | 0)) {
         $$pre$phi10$i$iZ2D = $768;
         break;
        }
        _abort();
       } while (0);
       HEAP32[$750 + 12 >> 2] = $752;
       HEAP32[$$pre$phi10$i$iZ2D >> 2] = $750;
      } else {
       $773 = HEAP32[$722 + 24 >> 2] | 0;
       $775 = HEAP32[$722 + 12 >> 2] | 0;
       do if (($775 | 0) == ($722 | 0)) {
        $786 = $722 + 16 | 0;
        $787 = $786 + 4 | 0;
        $788 = HEAP32[$787 >> 2] | 0;
        if (!$788) {
         $790 = HEAP32[$786 >> 2] | 0;
         if (!$790) {
          $R$3$i$i = 0;
          break;
         } else {
          $R$1$i$i = $790;
          $RP$1$i$i = $786;
         }
        } else {
         $R$1$i$i = $788;
         $RP$1$i$i = $787;
        }
        while (1) {
         $792 = $R$1$i$i + 20 | 0;
         $793 = HEAP32[$792 >> 2] | 0;
         if ($793 | 0) {
          $R$1$i$i = $793;
          $RP$1$i$i = $792;
          continue;
         }
         $795 = $R$1$i$i + 16 | 0;
         $796 = HEAP32[$795 >> 2] | 0;
         if (!$796) {
          $R$1$i$i$lcssa = $R$1$i$i;
          $RP$1$i$i$lcssa = $RP$1$i$i;
          break;
         } else {
          $R$1$i$i = $796;
          $RP$1$i$i = $795;
         }
        }
        if ($RP$1$i$i$lcssa >>> 0 < $757 >>> 0) _abort(); else {
         HEAP32[$RP$1$i$i$lcssa >> 2] = 0;
         $R$3$i$i = $R$1$i$i$lcssa;
         break;
        }
       } else {
        $778 = HEAP32[$722 + 8 >> 2] | 0;
        if ($778 >>> 0 < $757 >>> 0) _abort();
        $780 = $778 + 12 | 0;
        if ((HEAP32[$780 >> 2] | 0) != ($722 | 0)) _abort();
        $783 = $775 + 8 | 0;
        if ((HEAP32[$783 >> 2] | 0) == ($722 | 0)) {
         HEAP32[$780 >> 2] = $775;
         HEAP32[$783 >> 2] = $778;
         $R$3$i$i = $775;
         break;
        } else _abort();
       } while (0);
       if (!$773) break;
       $801 = HEAP32[$722 + 28 >> 2] | 0;
       $802 = 317376 + ($801 << 2) | 0;
       do if (($722 | 0) == (HEAP32[$802 >> 2] | 0)) {
        HEAP32[$802 >> 2] = $R$3$i$i;
        if ($R$3$i$i | 0) break;
        HEAP32[79269] = HEAP32[79269] & ~(1 << $801);
        break L331;
       } else {
        if ($773 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
        $811 = $773 + 16 | 0;
        if ((HEAP32[$811 >> 2] | 0) == ($722 | 0)) HEAP32[$811 >> 2] = $R$3$i$i; else HEAP32[$773 + 20 >> 2] = $R$3$i$i;
        if (!$R$3$i$i) break L331;
       } while (0);
       $816 = HEAP32[79272] | 0;
       if ($R$3$i$i >>> 0 < $816 >>> 0) _abort();
       HEAP32[$R$3$i$i + 24 >> 2] = $773;
       $819 = $722 + 16 | 0;
       $820 = HEAP32[$819 >> 2] | 0;
       do if ($820 | 0) if ($820 >>> 0 < $816 >>> 0) _abort(); else {
        HEAP32[$R$3$i$i + 16 >> 2] = $820;
        HEAP32[$820 + 24 >> 2] = $R$3$i$i;
        break;
       } while (0);
       $826 = HEAP32[$819 + 4 >> 2] | 0;
       if (!$826) break;
       if ($826 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
        HEAP32[$R$3$i$i + 20 >> 2] = $826;
        HEAP32[$826 + 24 >> 2] = $R$3$i$i;
        break;
       }
      } while (0);
      $oldfirst$0$i$i = $722 + $746 | 0;
      $qsize$0$i$i = $746 + $727 | 0;
     } else {
      $oldfirst$0$i$i = $722;
      $qsize$0$i$i = $727;
     }
     $834 = $oldfirst$0$i$i + 4 | 0;
     HEAP32[$834 >> 2] = HEAP32[$834 >> 2] & -2;
     HEAP32[$726 + 4 >> 2] = $qsize$0$i$i | 1;
     HEAP32[$726 + $qsize$0$i$i >> 2] = $qsize$0$i$i;
     $840 = $qsize$0$i$i >>> 3;
     if ($qsize$0$i$i >>> 0 < 256) {
      $843 = 317112 + ($840 << 1 << 2) | 0;
      $844 = HEAP32[79268] | 0;
      $845 = 1 << $840;
      do if (!($844 & $845)) {
       HEAP32[79268] = $844 | $845;
       $$pre$phi$i17$iZ2D = $843 + 8 | 0;
       $F4$0$i$i = $843;
      } else {
       $849 = $843 + 8 | 0;
       $850 = HEAP32[$849 >> 2] | 0;
       if ($850 >>> 0 >= (HEAP32[79272] | 0) >>> 0) {
        $$pre$phi$i17$iZ2D = $849;
        $F4$0$i$i = $850;
        break;
       }
       _abort();
      } while (0);
      HEAP32[$$pre$phi$i17$iZ2D >> 2] = $726;
      HEAP32[$F4$0$i$i + 12 >> 2] = $726;
      HEAP32[$726 + 8 >> 2] = $F4$0$i$i;
      HEAP32[$726 + 12 >> 2] = $843;
      break;
     }
     $856 = $qsize$0$i$i >>> 8;
     do if (!$856) $I7$0$i$i = 0; else {
      if ($qsize$0$i$i >>> 0 > 16777215) {
       $I7$0$i$i = 31;
       break;
      }
      $861 = ($856 + 1048320 | 0) >>> 16 & 8;
      $862 = $856 << $861;
      $865 = ($862 + 520192 | 0) >>> 16 & 4;
      $867 = $862 << $865;
      $870 = ($867 + 245760 | 0) >>> 16 & 2;
      $875 = 14 - ($865 | $861 | $870) + ($867 << $870 >>> 15) | 0;
      $I7$0$i$i = $qsize$0$i$i >>> ($875 + 7 | 0) & 1 | $875 << 1;
     } while (0);
     $881 = 317376 + ($I7$0$i$i << 2) | 0;
     HEAP32[$726 + 28 >> 2] = $I7$0$i$i;
     $883 = $726 + 16 | 0;
     HEAP32[$883 + 4 >> 2] = 0;
     HEAP32[$883 >> 2] = 0;
     $885 = HEAP32[79269] | 0;
     $886 = 1 << $I7$0$i$i;
     if (!($885 & $886)) {
      HEAP32[79269] = $885 | $886;
      HEAP32[$881 >> 2] = $726;
      HEAP32[$726 + 24 >> 2] = $881;
      HEAP32[$726 + 12 >> 2] = $726;
      HEAP32[$726 + 8 >> 2] = $726;
      break;
     }
     $K8$0$i$i = $qsize$0$i$i << (($I7$0$i$i | 0) == 31 ? 0 : 25 - ($I7$0$i$i >>> 1) | 0);
     $T$0$i18$i = HEAP32[$881 >> 2] | 0;
     while (1) {
      if ((HEAP32[$T$0$i18$i + 4 >> 2] & -8 | 0) == ($qsize$0$i$i | 0)) {
       $T$0$i18$i$lcssa = $T$0$i18$i;
       label = 281;
       break;
      }
      $904 = $T$0$i18$i + 16 + ($K8$0$i$i >>> 31 << 2) | 0;
      $906 = HEAP32[$904 >> 2] | 0;
      if (!$906) {
       $$lcssa = $904;
       $T$0$i18$i$lcssa139 = $T$0$i18$i;
       label = 278;
       break;
      } else {
       $K8$0$i$i = $K8$0$i$i << 1;
       $T$0$i18$i = $906;
      }
     }
     if ((label | 0) == 278) if ($$lcssa >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
      HEAP32[$$lcssa >> 2] = $726;
      HEAP32[$726 + 24 >> 2] = $T$0$i18$i$lcssa139;
      HEAP32[$726 + 12 >> 2] = $726;
      HEAP32[$726 + 8 >> 2] = $726;
      break;
     } else if ((label | 0) == 281) {
      $913 = $T$0$i18$i$lcssa + 8 | 0;
      $914 = HEAP32[$913 >> 2] | 0;
      $915 = HEAP32[79272] | 0;
      if ($914 >>> 0 >= $915 >>> 0 & $T$0$i18$i$lcssa >>> 0 >= $915 >>> 0) {
       HEAP32[$914 + 12 >> 2] = $726;
       HEAP32[$913 >> 2] = $726;
       HEAP32[$726 + 8 >> 2] = $914;
       HEAP32[$726 + 12 >> 2] = $T$0$i18$i$lcssa;
       HEAP32[$726 + 24 >> 2] = 0;
       break;
      } else _abort();
     }
    } while (0);
    $$0 = $714 + 8 | 0;
    return $$0 | 0;
   } else $sp$0$i$i$i = 317520;
   while (1) {
    $922 = HEAP32[$sp$0$i$i$i >> 2] | 0;
    if ($922 >>> 0 <= $635 >>> 0) {
     $926 = $922 + (HEAP32[$sp$0$i$i$i + 4 >> 2] | 0) | 0;
     if ($926 >>> 0 > $635 >>> 0) {
      $$lcssa142 = $926;
      break;
     }
    }
    $sp$0$i$i$i = HEAP32[$sp$0$i$i$i + 8 >> 2] | 0;
   }
   $930 = $$lcssa142 + -47 | 0;
   $932 = $930 + 8 | 0;
   $938 = $930 + (($932 & 7 | 0) == 0 ? 0 : 0 - $932 & 7) | 0;
   $939 = $635 + 16 | 0;
   $941 = $938 >>> 0 < $939 >>> 0 ? $635 : $938;
   $942 = $941 + 8 | 0;
   $946 = $tbase$746$i + 8 | 0;
   $951 = ($946 & 7 | 0) == 0 ? 0 : 0 - $946 & 7;
   $952 = $tbase$746$i + $951 | 0;
   $953 = $tsize$745$i + -40 - $951 | 0;
   HEAP32[79274] = $952;
   HEAP32[79271] = $953;
   HEAP32[$952 + 4 >> 2] = $953 | 1;
   HEAP32[$952 + $953 + 4 >> 2] = 40;
   HEAP32[79275] = HEAP32[79390];
   $959 = $941 + 4 | 0;
   HEAP32[$959 >> 2] = 27;
   HEAP32[$942 >> 2] = HEAP32[79380];
   HEAP32[$942 + 4 >> 2] = HEAP32[79381];
   HEAP32[$942 + 8 >> 2] = HEAP32[79382];
   HEAP32[$942 + 12 >> 2] = HEAP32[79383];
   HEAP32[79380] = $tbase$746$i;
   HEAP32[79381] = $tsize$745$i;
   HEAP32[79383] = 0;
   HEAP32[79382] = $942;
   $p$0$i$i = $941 + 24 | 0;
   do {
    $p$0$i$i = $p$0$i$i + 4 | 0;
    HEAP32[$p$0$i$i >> 2] = 7;
   } while (($p$0$i$i + 4 | 0) >>> 0 < $$lcssa142 >>> 0);
   if (($941 | 0) != ($635 | 0)) {
    $966 = $941 - $635 | 0;
    HEAP32[$959 >> 2] = HEAP32[$959 >> 2] & -2;
    HEAP32[$635 + 4 >> 2] = $966 | 1;
    HEAP32[$941 >> 2] = $966;
    $971 = $966 >>> 3;
    if ($966 >>> 0 < 256) {
     $974 = 317112 + ($971 << 1 << 2) | 0;
     $975 = HEAP32[79268] | 0;
     $976 = 1 << $971;
     if (!($975 & $976)) {
      HEAP32[79268] = $975 | $976;
      $$pre$phi$i$iZ2D = $974 + 8 | 0;
      $F$0$i$i = $974;
     } else {
      $980 = $974 + 8 | 0;
      $981 = HEAP32[$980 >> 2] | 0;
      if ($981 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
       $$pre$phi$i$iZ2D = $980;
       $F$0$i$i = $981;
      }
     }
     HEAP32[$$pre$phi$i$iZ2D >> 2] = $635;
     HEAP32[$F$0$i$i + 12 >> 2] = $635;
     HEAP32[$635 + 8 >> 2] = $F$0$i$i;
     HEAP32[$635 + 12 >> 2] = $974;
     break;
    }
    $987 = $966 >>> 8;
    if (!$987) $I1$0$i$i = 0; else if ($966 >>> 0 > 16777215) $I1$0$i$i = 31; else {
     $992 = ($987 + 1048320 | 0) >>> 16 & 8;
     $993 = $987 << $992;
     $996 = ($993 + 520192 | 0) >>> 16 & 4;
     $998 = $993 << $996;
     $1001 = ($998 + 245760 | 0) >>> 16 & 2;
     $1006 = 14 - ($996 | $992 | $1001) + ($998 << $1001 >>> 15) | 0;
     $I1$0$i$i = $966 >>> ($1006 + 7 | 0) & 1 | $1006 << 1;
    }
    $1012 = 317376 + ($I1$0$i$i << 2) | 0;
    HEAP32[$635 + 28 >> 2] = $I1$0$i$i;
    HEAP32[$635 + 20 >> 2] = 0;
    HEAP32[$939 >> 2] = 0;
    $1015 = HEAP32[79269] | 0;
    $1016 = 1 << $I1$0$i$i;
    if (!($1015 & $1016)) {
     HEAP32[79269] = $1015 | $1016;
     HEAP32[$1012 >> 2] = $635;
     HEAP32[$635 + 24 >> 2] = $1012;
     HEAP32[$635 + 12 >> 2] = $635;
     HEAP32[$635 + 8 >> 2] = $635;
     break;
    }
    $K2$0$i$i = $966 << (($I1$0$i$i | 0) == 31 ? 0 : 25 - ($I1$0$i$i >>> 1) | 0);
    $T$0$i$i = HEAP32[$1012 >> 2] | 0;
    while (1) {
     if ((HEAP32[$T$0$i$i + 4 >> 2] & -8 | 0) == ($966 | 0)) {
      $T$0$i$i$lcssa = $T$0$i$i;
      label = 307;
      break;
     }
     $1034 = $T$0$i$i + 16 + ($K2$0$i$i >>> 31 << 2) | 0;
     $1036 = HEAP32[$1034 >> 2] | 0;
     if (!$1036) {
      $$lcssa141 = $1034;
      $T$0$i$i$lcssa140 = $T$0$i$i;
      label = 304;
      break;
     } else {
      $K2$0$i$i = $K2$0$i$i << 1;
      $T$0$i$i = $1036;
     }
    }
    if ((label | 0) == 304) if ($$lcssa141 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
     HEAP32[$$lcssa141 >> 2] = $635;
     HEAP32[$635 + 24 >> 2] = $T$0$i$i$lcssa140;
     HEAP32[$635 + 12 >> 2] = $635;
     HEAP32[$635 + 8 >> 2] = $635;
     break;
    } else if ((label | 0) == 307) {
     $1043 = $T$0$i$i$lcssa + 8 | 0;
     $1044 = HEAP32[$1043 >> 2] | 0;
     $1045 = HEAP32[79272] | 0;
     if ($1044 >>> 0 >= $1045 >>> 0 & $T$0$i$i$lcssa >>> 0 >= $1045 >>> 0) {
      HEAP32[$1044 + 12 >> 2] = $635;
      HEAP32[$1043 >> 2] = $635;
      HEAP32[$635 + 8 >> 2] = $1044;
      HEAP32[$635 + 12 >> 2] = $T$0$i$i$lcssa;
      HEAP32[$635 + 24 >> 2] = 0;
      break;
     } else _abort();
    }
   }
  } while (0);
  $1053 = HEAP32[79271] | 0;
  if ($1053 >>> 0 > $nb$0 >>> 0) {
   $1055 = $1053 - $nb$0 | 0;
   HEAP32[79271] = $1055;
   $1056 = HEAP32[79274] | 0;
   $1057 = $1056 + $nb$0 | 0;
   HEAP32[79274] = $1057;
   HEAP32[$1057 + 4 >> 2] = $1055 | 1;
   HEAP32[$1056 + 4 >> 2] = $nb$0 | 3;
   $$0 = $1056 + 8 | 0;
   return $$0 | 0;
  }
 }
 HEAP32[(___errno_location() | 0) >> 2] = 12;
 $$0 = 0;
 return $$0 | 0;
}

function _PPrintChar($doc, $c, $mode) {
 $doc = $doc | 0;
 $c = $c | 0;
 $mode = $mode | 0;
 var $$pre$i$i = 0, $$pre$i$i109 = 0, $$pre$i$i118 = 0, $$pre$i$i145 = 0, $$pre$i$i160 = 0, $$pre$i$i26 = 0, $$pre$i$i35 = 0, $$pre$i$i44 = 0, $$pre$i$i53 = 0, $$pre$i$i62 = 0, $$pre$i$i71 = 0, $$pre$i$i80 = 0, $$pre$phi$i$i104Z2D = 0, $$pre$phi$i$i128Z2D = 0, $$pre$phi$i$i134Z2D = 0, $$pre$phi$i$i140Z2D = 0, $$pre$phi$i$i155Z2D = 0, $$pre$phi$i$i170Z2D = 0, $$pre$phi$i$i90Z2D = 0, $$pre$phi$i$i96Z2D = 0, $$pre$phi$i$iZ2D = 0, $0 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $121 = 0, $125 = 0, $128 = 0, $130 = 0, $149 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $159 = 0, $16 = 0, $163 = 0, $166 = 0, $168 = 0, $17 = 0, $18 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $19 = 0, $192 = 0, $196 = 0, $199 = 0, $2 = 0, $20 = 0, $201 = 0, $21 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $224 = 0, $228 = 0, $231 = 0, $233 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $266 = 0, $270 = 0, $273 = 0, $275 = 0, $287 = 0, $288 = 0, $289 = 0, $290 = 0, $291 = 0, $292 = 0, $297 = 0, $30 = 0, $301 = 0, $304 = 0, $306 = 0, $318 = 0, $319 = 0, $320 = 0, $321 = 0, $322 = 0, $327 = 0, $33 = 0, $331 = 0, $334 = 0, $336 = 0, $35 = 0, $350 = 0, $361 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $374 = 0, $378 = 0, $381 = 0, $383 = 0, $389 = 0, $390 = 0, $4 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $413 = 0, $417 = 0, $420 = 0, $422 = 0, $431 = 0, $435 = 0, $437 = 0, $438 = 0, $439 = 0, $440 = 0, $441 = 0, $442 = 0, $447 = 0, $451 = 0, $454 = 0, $456 = 0, $469 = 0, $470 = 0, $471 = 0, $472 = 0, $473 = 0, $474 = 0, $479 = 0, $483 = 0, $486 = 0, $488 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $509 = 0, $513 = 0, $516 = 0, $518 = 0, $52 = 0, $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $535 = 0, $539 = 0, $54 = 0, $542 = 0, $544 = 0, $55 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0, $56 = 0, $564 = 0, $568 = 0, $571 = 0, $573 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $590 = 0, $591 = 0, $596 = 0, $600 = 0, $603 = 0, $605 = 0, $61 = 0, $617 = 0, $618 = 0, $619 = 0, $620 = 0, $621 = 0, $626 = 0, $630 = 0, $633 = 0, $635 = 0, $647 = 0, $65 = 0, $651 = 0, $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $663 = 0, $667 = 0, $670 = 0, $672 = 0, $68 = 0, $684 = 0, $685 = 0, $686 = 0, $687 = 0, $688 = 0, $693 = 0, $697 = 0, $70 = 0, $700 = 0, $702 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $90 = 0, $94 = 0, $97 = 0, $99 = 0, $buflen$0$i$i$i = 0, $buflen$0$i$i$i$lcssa = 0, $buflen$0$i$i$i103 = 0, $buflen$0$i$i$i103$lcssa = 0, $buflen$0$i$i$i107 = 0, $buflen$0$i$i$i107$lcssa = 0, $buflen$0$i$i$i116 = 0, $buflen$0$i$i$i116$lcssa = 0, $buflen$0$i$i$i127 = 0, $buflen$0$i$i$i127$lcssa = 0, $buflen$0$i$i$i133 = 0, $buflen$0$i$i$i133$lcssa = 0, $buflen$0$i$i$i139 = 0, $buflen$0$i$i$i139$lcssa = 0, $buflen$0$i$i$i143 = 0, $buflen$0$i$i$i143$lcssa = 0, $buflen$0$i$i$i154 = 0, $buflen$0$i$i$i154$lcssa = 0, $buflen$0$i$i$i158 = 0, $buflen$0$i$i$i158$lcssa = 0, $buflen$0$i$i$i169 = 0, $buflen$0$i$i$i169$lcssa = 0, $buflen$0$i$i$i22 = 0, $buflen$0$i$i$i22$lcssa = 0, $buflen$0$i$i$i24 = 0, $buflen$0$i$i$i24$lcssa = 0, $buflen$0$i$i$i33 = 0, $buflen$0$i$i$i33$lcssa = 0, $buflen$0$i$i$i42 = 0, $buflen$0$i$i$i42$lcssa = 0, $buflen$0$i$i$i51 = 0, $buflen$0$i$i$i51$lcssa = 0, $buflen$0$i$i$i60 = 0, $buflen$0$i$i$i60$lcssa = 0, $buflen$0$i$i$i69 = 0, $buflen$0$i$i$i69$lcssa = 0, $buflen$0$i$i$i78 = 0, $buflen$0$i$i$i78$lcssa = 0, $buflen$0$i$i$i89 = 0, $buflen$0$i$i$i89$lcssa = 0, $buflen$0$i$i$i95 = 0, $buflen$0$i$i$i95$lcssa = 0, $ent$0 = 0, $entity = 0, $i$02$i = 0, $i$02$i$lcssa = 0, $ix$01$i$i = 0, $ix$01$i$i111 = 0, $ix$01$i$i120 = 0, $ix$01$i$i147 = 0, $ix$01$i$i162 = 0, $ix$01$i$i28 = 0, $ix$01$i$i37 = 0, $ix$01$i$i46 = 0, $ix$01$i$i55 = 0, $ix$01$i$i64 = 0, $ix$01$i$i73 = 0, $ix$01$i$i82 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer10 = 0, $vararg_buffer13 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 $vararg_buffer13 = sp + 40 | 0;
 $vararg_buffer10 = sp + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $entity = sp + 48 | 0;
 $0 = $doc + 6724 | 0;
 $2 = HEAP32[$doc + 96 >> 2] | 0;
 $4 = HEAP32[$doc + 244 >> 2] | 0;
 do if (($c | 0) == 32 & ($mode & 23 | 0) == 0) {
  if (!($mode & 8)) {
   HEAP32[$doc + 6740 >> 2] = HEAP32[$doc + 6736 >> 2];
   break;
  }
  if (!(HEAP32[$doc + 240 >> 2] | 0)) if (!(HEAP32[$doc + 168 >> 2] | 0)) $ent$0 = 310715; else label = 5; else label = 5;
  if ((label | 0) == 5) $ent$0 = 310708;
  $16 = $doc + 6736 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = _prvTidytmbstrlen($ent$0) | 0;
  $19 = $18 + $17 | 0;
  $20 = $doc + 6732 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  if ($19 >>> 0 >= $21 >>> 0) {
   $buflen$0$i$i$i = ($21 | 0) == 0 ? 256 : $21;
   while (1) if ($buflen$0$i$i$i >>> 0 > $19 >>> 0) {
    $buflen$0$i$i$i$lcssa = $buflen$0$i$i$i;
    break;
   } else $buflen$0$i$i$i = $buflen$0$i$i$i << 1;
   $26 = HEAP32[$0 >> 2] | 0;
   $30 = $doc + 6728 | 0;
   $33 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$26 >> 2] | 0) + 4 >> 2] & 15]($26, HEAP32[$30 >> 2] | 0, $buflen$0$i$i$i$lcssa << 2) | 0;
   if ($33 | 0) {
    $35 = HEAP32[$20 >> 2] | 0;
    _memset($33 + ($35 << 2) | 0, 0, $buflen$0$i$i$i$lcssa - $35 << 2 | 0) | 0;
    HEAP32[$20 >> 2] = $buflen$0$i$i$i$lcssa;
    HEAP32[$30 >> 2] = $33;
   }
  }
  if ($18 | 0) {
   $$pre$i$i = HEAP32[$doc + 6728 >> 2] | 0;
   $ix$01$i$i = 0;
   do {
    HEAP32[$$pre$i$i + ($ix$01$i$i + $17 << 2) >> 2] = HEAP8[$ent$0 + $ix$01$i$i >> 0];
    $ix$01$i$i = $ix$01$i$i + 1 | 0;
   } while (($ix$01$i$i | 0) != ($18 | 0));
  }
  HEAP32[$16 >> 2] = $19;
  STACKTOP = sp;
  return;
 } while (0);
 if ($mode & 18 | 0) {
  $52 = $doc + 6736 | 0;
  $53 = HEAP32[$52 >> 2] | 0;
  $54 = $53 + 1 | 0;
  $55 = $doc + 6732 | 0;
  $56 = HEAP32[$55 >> 2] | 0;
  if ($54 >>> 0 < $56 >>> 0) $$pre$phi$i$iZ2D = $doc + 6728 | 0; else {
   $buflen$0$i$i$i22 = ($56 | 0) == 0 ? 256 : $56;
   while (1) if ($buflen$0$i$i$i22 >>> 0 > $54 >>> 0) {
    $buflen$0$i$i$i22$lcssa = $buflen$0$i$i$i22;
    break;
   } else $buflen$0$i$i$i22 = $buflen$0$i$i$i22 << 1;
   $61 = HEAP32[$0 >> 2] | 0;
   $65 = $doc + 6728 | 0;
   $68 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$61 >> 2] | 0) + 4 >> 2] & 15]($61, HEAP32[$65 >> 2] | 0, $buflen$0$i$i$i22$lcssa << 2) | 0;
   if (!$68) $$pre$phi$i$iZ2D = $65; else {
    $70 = HEAP32[$55 >> 2] | 0;
    _memset($68 + ($70 << 2) | 0, 0, $buflen$0$i$i$i22$lcssa - $70 << 2 | 0) | 0;
    HEAP32[$55 >> 2] = $buflen$0$i$i$i22$lcssa;
    HEAP32[$65 >> 2] = $68;
    $$pre$phi$i$iZ2D = $65;
   }
  }
  HEAP32[(HEAP32[$$pre$phi$i$iZ2D >> 2] | 0) + ($53 << 2) >> 2] = $c;
  HEAP32[$52 >> 2] = (HEAP32[$52 >> 2] | 0) + 1;
  STACKTOP = sp;
  return;
 }
 L37 : do if (!($mode & 16)) switch ($c | 0) {
 case 60:
  {
   $80 = $doc + 6736 | 0;
   $81 = HEAP32[$80 >> 2] | 0;
   $82 = _prvTidytmbstrlen(310722) | 0;
   $83 = $82 + $81 | 0;
   $84 = $doc + 6732 | 0;
   $85 = HEAP32[$84 >> 2] | 0;
   if ($83 >>> 0 >= $85 >>> 0) {
    $buflen$0$i$i$i24 = ($85 | 0) == 0 ? 256 : $85;
    while (1) if ($buflen$0$i$i$i24 >>> 0 > $83 >>> 0) {
     $buflen$0$i$i$i24$lcssa = $buflen$0$i$i$i24;
     break;
    } else $buflen$0$i$i$i24 = $buflen$0$i$i$i24 << 1;
    $90 = HEAP32[$0 >> 2] | 0;
    $94 = $doc + 6728 | 0;
    $97 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$90 >> 2] | 0) + 4 >> 2] & 15]($90, HEAP32[$94 >> 2] | 0, $buflen$0$i$i$i24$lcssa << 2) | 0;
    if ($97 | 0) {
     $99 = HEAP32[$84 >> 2] | 0;
     _memset($97 + ($99 << 2) | 0, 0, $buflen$0$i$i$i24$lcssa - $99 << 2 | 0) | 0;
     HEAP32[$84 >> 2] = $buflen$0$i$i$i24$lcssa;
     HEAP32[$94 >> 2] = $97;
    }
   }
   if ($82 | 0) {
    $$pre$i$i26 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i28 = 0;
    do {
     HEAP32[$$pre$i$i26 + ($ix$01$i$i28 + $81 << 2) >> 2] = HEAP8[310722 + $ix$01$i$i28 >> 0];
     $ix$01$i$i28 = $ix$01$i$i28 + 1 | 0;
    } while (($ix$01$i$i28 | 0) != ($82 | 0));
   }
   HEAP32[$80 >> 2] = $83;
   STACKTOP = sp;
   return;
  }
 case 62:
  {
   $111 = $doc + 6736 | 0;
   $112 = HEAP32[$111 >> 2] | 0;
   $113 = _prvTidytmbstrlen(310727) | 0;
   $114 = $113 + $112 | 0;
   $115 = $doc + 6732 | 0;
   $116 = HEAP32[$115 >> 2] | 0;
   if ($114 >>> 0 >= $116 >>> 0) {
    $buflen$0$i$i$i33 = ($116 | 0) == 0 ? 256 : $116;
    while (1) if ($buflen$0$i$i$i33 >>> 0 > $114 >>> 0) {
     $buflen$0$i$i$i33$lcssa = $buflen$0$i$i$i33;
     break;
    } else $buflen$0$i$i$i33 = $buflen$0$i$i$i33 << 1;
    $121 = HEAP32[$0 >> 2] | 0;
    $125 = $doc + 6728 | 0;
    $128 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$121 >> 2] | 0) + 4 >> 2] & 15]($121, HEAP32[$125 >> 2] | 0, $buflen$0$i$i$i33$lcssa << 2) | 0;
    if ($128 | 0) {
     $130 = HEAP32[$115 >> 2] | 0;
     _memset($128 + ($130 << 2) | 0, 0, $buflen$0$i$i$i33$lcssa - $130 << 2 | 0) | 0;
     HEAP32[$115 >> 2] = $buflen$0$i$i$i33$lcssa;
     HEAP32[$125 >> 2] = $128;
    }
   }
   if ($113 | 0) {
    $$pre$i$i35 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i37 = 0;
    do {
     HEAP32[$$pre$i$i35 + ($ix$01$i$i37 + $112 << 2) >> 2] = HEAP8[310727 + $ix$01$i$i37 >> 0];
     $ix$01$i$i37 = $ix$01$i$i37 + 1 | 0;
    } while (($ix$01$i$i37 | 0) != ($113 | 0));
   }
   HEAP32[$111 >> 2] = $114;
   STACKTOP = sp;
   return;
  }
 case 38:
  {
   if (!(HEAP32[$doc + 252 >> 2] | 0)) break L37;
   if (!(($mode | 0) != 4 & (HEAP32[$doc + 432 >> 2] | 0) == 0)) break L37;
   $149 = $doc + 6736 | 0;
   $150 = HEAP32[$149 >> 2] | 0;
   $151 = _prvTidytmbstrlen(310732) | 0;
   $152 = $151 + $150 | 0;
   $153 = $doc + 6732 | 0;
   $154 = HEAP32[$153 >> 2] | 0;
   if ($152 >>> 0 >= $154 >>> 0) {
    $buflen$0$i$i$i42 = ($154 | 0) == 0 ? 256 : $154;
    while (1) if ($buflen$0$i$i$i42 >>> 0 > $152 >>> 0) {
     $buflen$0$i$i$i42$lcssa = $buflen$0$i$i$i42;
     break;
    } else $buflen$0$i$i$i42 = $buflen$0$i$i$i42 << 1;
    $159 = HEAP32[$0 >> 2] | 0;
    $163 = $doc + 6728 | 0;
    $166 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$159 >> 2] | 0) + 4 >> 2] & 15]($159, HEAP32[$163 >> 2] | 0, $buflen$0$i$i$i42$lcssa << 2) | 0;
    if ($166 | 0) {
     $168 = HEAP32[$153 >> 2] | 0;
     _memset($166 + ($168 << 2) | 0, 0, $buflen$0$i$i$i42$lcssa - $168 << 2 | 0) | 0;
     HEAP32[$153 >> 2] = $buflen$0$i$i$i42$lcssa;
     HEAP32[$163 >> 2] = $166;
    }
   }
   if ($151 | 0) {
    $$pre$i$i44 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i46 = 0;
    do {
     HEAP32[$$pre$i$i44 + ($ix$01$i$i46 + $150 << 2) >> 2] = HEAP8[310732 + $ix$01$i$i46 >> 0];
     $ix$01$i$i46 = $ix$01$i$i46 + 1 | 0;
    } while (($ix$01$i$i46 | 0) != ($151 | 0));
   }
   HEAP32[$149 >> 2] = $152;
   STACKTOP = sp;
   return;
  }
 default:
  {
   $181 = ($4 | 0) != 0;
   if (($c | 0) == 34 & $181) {
    $182 = $doc + 6736 | 0;
    $183 = HEAP32[$182 >> 2] | 0;
    $184 = _prvTidytmbstrlen(310738) | 0;
    $185 = $184 + $183 | 0;
    $186 = $doc + 6732 | 0;
    $187 = HEAP32[$186 >> 2] | 0;
    if ($185 >>> 0 >= $187 >>> 0) {
     $buflen$0$i$i$i51 = ($187 | 0) == 0 ? 256 : $187;
     while (1) if ($buflen$0$i$i$i51 >>> 0 > $185 >>> 0) {
      $buflen$0$i$i$i51$lcssa = $buflen$0$i$i$i51;
      break;
     } else $buflen$0$i$i$i51 = $buflen$0$i$i$i51 << 1;
     $192 = HEAP32[$0 >> 2] | 0;
     $196 = $doc + 6728 | 0;
     $199 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$192 >> 2] | 0) + 4 >> 2] & 15]($192, HEAP32[$196 >> 2] | 0, $buflen$0$i$i$i51$lcssa << 2) | 0;
     if ($199 | 0) {
      $201 = HEAP32[$186 >> 2] | 0;
      _memset($199 + ($201 << 2) | 0, 0, $buflen$0$i$i$i51$lcssa - $201 << 2 | 0) | 0;
      HEAP32[$186 >> 2] = $buflen$0$i$i$i51$lcssa;
      HEAP32[$196 >> 2] = $199;
     }
    }
    if ($184 | 0) {
     $$pre$i$i53 = HEAP32[$doc + 6728 >> 2] | 0;
     $ix$01$i$i55 = 0;
     do {
      HEAP32[$$pre$i$i53 + ($ix$01$i$i55 + $183 << 2) >> 2] = HEAP8[310738 + $ix$01$i$i55 >> 0];
      $ix$01$i$i55 = $ix$01$i$i55 + 1 | 0;
     } while (($ix$01$i$i55 | 0) != ($184 | 0));
    }
    HEAP32[$182 >> 2] = $185;
    STACKTOP = sp;
    return;
   }
   if (($c | 0) == 39 & $181) {
    $214 = $doc + 6736 | 0;
    $215 = HEAP32[$214 >> 2] | 0;
    $216 = _prvTidytmbstrlen(310745) | 0;
    $217 = $216 + $215 | 0;
    $218 = $doc + 6732 | 0;
    $219 = HEAP32[$218 >> 2] | 0;
    if ($217 >>> 0 >= $219 >>> 0) {
     $buflen$0$i$i$i60 = ($219 | 0) == 0 ? 256 : $219;
     while (1) if ($buflen$0$i$i$i60 >>> 0 > $217 >>> 0) {
      $buflen$0$i$i$i60$lcssa = $buflen$0$i$i$i60;
      break;
     } else $buflen$0$i$i$i60 = $buflen$0$i$i$i60 << 1;
     $224 = HEAP32[$0 >> 2] | 0;
     $228 = $doc + 6728 | 0;
     $231 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$224 >> 2] | 0) + 4 >> 2] & 15]($224, HEAP32[$228 >> 2] | 0, $buflen$0$i$i$i60$lcssa << 2) | 0;
     if ($231 | 0) {
      $233 = HEAP32[$218 >> 2] | 0;
      _memset($231 + ($233 << 2) | 0, 0, $buflen$0$i$i$i60$lcssa - $233 << 2 | 0) | 0;
      HEAP32[$218 >> 2] = $buflen$0$i$i$i60$lcssa;
      HEAP32[$228 >> 2] = $231;
     }
    }
    if ($216 | 0) {
     $$pre$i$i62 = HEAP32[$doc + 6728 >> 2] | 0;
     $ix$01$i$i64 = 0;
     do {
      HEAP32[$$pre$i$i62 + ($ix$01$i$i64 + $215 << 2) >> 2] = HEAP8[310745 + $ix$01$i$i64 >> 0];
      $ix$01$i$i64 = $ix$01$i$i64 + 1 | 0;
     } while (($ix$01$i$i64 | 0) != ($216 | 0));
    }
    HEAP32[$214 >> 2] = $217;
    STACKTOP = sp;
    return;
   }
   if (!(($c | 0) == 160 & ($2 | 0) != 0)) break L37;
   if (!(HEAP32[$doc + 248 >> 2] | 0)) {
    $318 = $doc + 6736 | 0;
    $319 = HEAP32[$318 >> 2] | 0;
    $320 = $319 + 1 | 0;
    $321 = $doc + 6732 | 0;
    $322 = HEAP32[$321 >> 2] | 0;
    if ($320 >>> 0 < $322 >>> 0) $$pre$phi$i$i90Z2D = $doc + 6728 | 0; else {
     $buflen$0$i$i$i89 = ($322 | 0) == 0 ? 256 : $322;
     while (1) if ($buflen$0$i$i$i89 >>> 0 > $320 >>> 0) {
      $buflen$0$i$i$i89$lcssa = $buflen$0$i$i$i89;
      break;
     } else $buflen$0$i$i$i89 = $buflen$0$i$i$i89 << 1;
     $327 = HEAP32[$0 >> 2] | 0;
     $331 = $doc + 6728 | 0;
     $334 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$327 >> 2] | 0) + 4 >> 2] & 15]($327, HEAP32[$331 >> 2] | 0, $buflen$0$i$i$i89$lcssa << 2) | 0;
     if (!$334) $$pre$phi$i$i90Z2D = $331; else {
      $336 = HEAP32[$321 >> 2] | 0;
      _memset($334 + ($336 << 2) | 0, 0, $buflen$0$i$i$i89$lcssa - $336 << 2 | 0) | 0;
      HEAP32[$321 >> 2] = $buflen$0$i$i$i89$lcssa;
      HEAP32[$331 >> 2] = $334;
      $$pre$phi$i$i90Z2D = $331;
     }
    }
    HEAP32[(HEAP32[$$pre$phi$i$i90Z2D >> 2] | 0) + ($319 << 2) >> 2] = 160;
    HEAP32[$318 >> 2] = (HEAP32[$318 >> 2] | 0) + 1;
    STACKTOP = sp;
    return;
   }
   if (!(HEAP32[$doc + 240 >> 2] | 0)) if (!(HEAP32[$doc + 168 >> 2] | 0)) {
    $287 = $doc + 6736 | 0;
    $288 = HEAP32[$287 >> 2] | 0;
    $289 = _prvTidytmbstrlen(310715) | 0;
    $290 = $289 + $288 | 0;
    $291 = $doc + 6732 | 0;
    $292 = HEAP32[$291 >> 2] | 0;
    if ($290 >>> 0 >= $292 >>> 0) {
     $buflen$0$i$i$i78 = ($292 | 0) == 0 ? 256 : $292;
     while (1) if ($buflen$0$i$i$i78 >>> 0 > $290 >>> 0) {
      $buflen$0$i$i$i78$lcssa = $buflen$0$i$i$i78;
      break;
     } else $buflen$0$i$i$i78 = $buflen$0$i$i$i78 << 1;
     $297 = HEAP32[$0 >> 2] | 0;
     $301 = $doc + 6728 | 0;
     $304 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$297 >> 2] | 0) + 4 >> 2] & 15]($297, HEAP32[$301 >> 2] | 0, $buflen$0$i$i$i78$lcssa << 2) | 0;
     if ($304 | 0) {
      $306 = HEAP32[$291 >> 2] | 0;
      _memset($304 + ($306 << 2) | 0, 0, $buflen$0$i$i$i78$lcssa - $306 << 2 | 0) | 0;
      HEAP32[$291 >> 2] = $buflen$0$i$i$i78$lcssa;
      HEAP32[$301 >> 2] = $304;
     }
    }
    if ($289 | 0) {
     $$pre$i$i80 = HEAP32[$doc + 6728 >> 2] | 0;
     $ix$01$i$i82 = 0;
     do {
      HEAP32[$$pre$i$i80 + ($ix$01$i$i82 + $288 << 2) >> 2] = HEAP8[310715 + $ix$01$i$i82 >> 0];
      $ix$01$i$i82 = $ix$01$i$i82 + 1 | 0;
     } while (($ix$01$i$i82 | 0) != ($289 | 0));
    }
    HEAP32[$287 >> 2] = $290;
    STACKTOP = sp;
    return;
   }
   $256 = $doc + 6736 | 0;
   $257 = HEAP32[$256 >> 2] | 0;
   $258 = _prvTidytmbstrlen(310708) | 0;
   $259 = $258 + $257 | 0;
   $260 = $doc + 6732 | 0;
   $261 = HEAP32[$260 >> 2] | 0;
   if ($259 >>> 0 >= $261 >>> 0) {
    $buflen$0$i$i$i69 = ($261 | 0) == 0 ? 256 : $261;
    while (1) if ($buflen$0$i$i$i69 >>> 0 > $259 >>> 0) {
     $buflen$0$i$i$i69$lcssa = $buflen$0$i$i$i69;
     break;
    } else $buflen$0$i$i$i69 = $buflen$0$i$i$i69 << 1;
    $266 = HEAP32[$0 >> 2] | 0;
    $270 = $doc + 6728 | 0;
    $273 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$266 >> 2] | 0) + 4 >> 2] & 15]($266, HEAP32[$270 >> 2] | 0, $buflen$0$i$i$i69$lcssa << 2) | 0;
    if ($273 | 0) {
     $275 = HEAP32[$260 >> 2] | 0;
     _memset($273 + ($275 << 2) | 0, 0, $buflen$0$i$i$i69$lcssa - $275 << 2 | 0) | 0;
     HEAP32[$260 >> 2] = $buflen$0$i$i$i69$lcssa;
     HEAP32[$270 >> 2] = $273;
    }
   }
   if ($258 | 0) {
    $$pre$i$i71 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i73 = 0;
    do {
     HEAP32[$$pre$i$i71 + ($ix$01$i$i73 + $257 << 2) >> 2] = HEAP8[310708 + $ix$01$i$i73 >> 0];
     $ix$01$i$i73 = $ix$01$i$i73 + 1 | 0;
    } while (($ix$01$i$i73 | 0) != ($258 | 0));
   }
   HEAP32[$256 >> 2] = $259;
   STACKTOP = sp;
   return;
  }
 } while (0);
 L161 : do switch ($2 | 0) {
 case 10:
 case 9:
 case 11:
 case 4:
  {
   L163 : do if (!($mode & 1)) if (!($c >>> 0 < 8192 | (HEAP32[$doc + 416 >> 2] | 0) == 0)) {
    $350 = 8192;
    $i$02$i = 0;
    while (1) {
     if (($350 | 0) == ($c | 0)) {
      $i$02$i$lcssa = $i$02$i;
      break;
     }
     $i$02$i = $i$02$i + 1 | 0;
     $350 = HEAP32[64072 + ($i$02$i << 3) >> 2] | 0;
     if (($i$02$i | 0) == 246 | $350 >>> 0 > $c >>> 0) break L163;
    }
    $361 = HEAP32[$doc + 6736 >> 2] | 0;
    if ((HEAP32[64072 + ($i$02$i$lcssa << 3) + 4 >> 2] & -2 | 0) == 4) {
     HEAP32[$doc + 6740 >> 2] = $361;
     break;
    } else {
     HEAP32[$doc + 6740 >> 2] = $361 + 1;
     break;
    }
   } while (0);
   switch ($2 | 0) {
   case 3:
    {
     label = 131;
     break L161;
     break;
    }
   case 4:
    break;
   default:
    break L161;
   }
   $526 = $doc + 6736 | 0;
   $527 = HEAP32[$526 >> 2] | 0;
   $528 = $527 + 1 | 0;
   $529 = $doc + 6732 | 0;
   $530 = HEAP32[$529 >> 2] | 0;
   if ($528 >>> 0 < $530 >>> 0) $$pre$phi$i$i134Z2D = $doc + 6728 | 0; else {
    $buflen$0$i$i$i133 = ($530 | 0) == 0 ? 256 : $530;
    while (1) if ($buflen$0$i$i$i133 >>> 0 > $528 >>> 0) {
     $buflen$0$i$i$i133$lcssa = $buflen$0$i$i$i133;
     break;
    } else $buflen$0$i$i$i133 = $buflen$0$i$i$i133 << 1;
    $535 = HEAP32[$0 >> 2] | 0;
    $539 = $doc + 6728 | 0;
    $542 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$535 >> 2] | 0) + 4 >> 2] & 15]($535, HEAP32[$539 >> 2] | 0, $buflen$0$i$i$i133$lcssa << 2) | 0;
    if (!$542) $$pre$phi$i$i134Z2D = $539; else {
     $544 = HEAP32[$529 >> 2] | 0;
     _memset($542 + ($544 << 2) | 0, 0, $buflen$0$i$i$i133$lcssa - $544 << 2 | 0) | 0;
     HEAP32[$529 >> 2] = $buflen$0$i$i$i133$lcssa;
     HEAP32[$539 >> 2] = $542;
     $$pre$phi$i$i134Z2D = $539;
    }
   }
   HEAP32[(HEAP32[$$pre$phi$i$i134Z2D >> 2] | 0) + ($527 << 2) >> 2] = $c;
   HEAP32[$526 >> 2] = (HEAP32[$526 >> 2] | 0) + 1;
   STACKTOP = sp;
   return;
  }
 case 12:
  {
   $365 = $doc + 6736 | 0;
   $366 = HEAP32[$365 >> 2] | 0;
   $367 = $366 + 1 | 0;
   $368 = $doc + 6732 | 0;
   $369 = HEAP32[$368 >> 2] | 0;
   if ($367 >>> 0 < $369 >>> 0) $$pre$phi$i$i96Z2D = $doc + 6728 | 0; else {
    $buflen$0$i$i$i95 = ($369 | 0) == 0 ? 256 : $369;
    while (1) if ($buflen$0$i$i$i95 >>> 0 > $367 >>> 0) {
     $buflen$0$i$i$i95$lcssa = $buflen$0$i$i$i95;
     break;
    } else $buflen$0$i$i$i95 = $buflen$0$i$i$i95 << 1;
    $374 = HEAP32[$0 >> 2] | 0;
    $378 = $doc + 6728 | 0;
    $381 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$374 >> 2] | 0) + 4 >> 2] & 15]($374, HEAP32[$378 >> 2] | 0, $buflen$0$i$i$i95$lcssa << 2) | 0;
    if (!$381) $$pre$phi$i$i96Z2D = $378; else {
     $383 = HEAP32[$368 >> 2] | 0;
     _memset($381 + ($383 << 2) | 0, 0, $buflen$0$i$i$i95$lcssa - $383 << 2 | 0) | 0;
     HEAP32[$368 >> 2] = $buflen$0$i$i$i95$lcssa;
     HEAP32[$378 >> 2] = $381;
     $$pre$phi$i$i96Z2D = $378;
    }
   }
   HEAP32[(HEAP32[$$pre$phi$i$i96Z2D >> 2] | 0) + ($366 << 2) >> 2] = $c;
   $389 = HEAP32[$365 >> 2] | 0;
   $390 = $389 + 1 | 0;
   HEAP32[$365 >> 2] = $390;
   if ($mode & 1 | 0) {
    STACKTOP = sp;
    return;
   }
   if (!(($c & 65280 | 0) == 41216 & (HEAP32[$doc + 416 >> 2] | 0) != 0)) {
    STACKTOP = sp;
    return;
   }
   if (($c + -41309 | 0) >>> 0 > 79 | ($c & 1 | 0) == 0) {
    HEAP32[$doc + 6740 >> 2] = $389 + 2;
    STACKTOP = sp;
    return;
   } else {
    HEAP32[$doc + 6740 >> 2] = $390;
    STACKTOP = sp;
    return;
   }
   break;
  }
 case 0:
 case 5:
 case 13:
  {
   $404 = $doc + 6736 | 0;
   $405 = HEAP32[$404 >> 2] | 0;
   $406 = $405 + 1 | 0;
   $407 = $doc + 6732 | 0;
   $408 = HEAP32[$407 >> 2] | 0;
   if ($406 >>> 0 < $408 >>> 0) $$pre$phi$i$i104Z2D = $doc + 6728 | 0; else {
    $buflen$0$i$i$i103 = ($408 | 0) == 0 ? 256 : $408;
    while (1) if ($buflen$0$i$i$i103 >>> 0 > $406 >>> 0) {
     $buflen$0$i$i$i103$lcssa = $buflen$0$i$i$i103;
     break;
    } else $buflen$0$i$i$i103 = $buflen$0$i$i$i103 << 1;
    $413 = HEAP32[$0 >> 2] | 0;
    $417 = $doc + 6728 | 0;
    $420 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$413 >> 2] | 0) + 4 >> 2] & 15]($413, HEAP32[$417 >> 2] | 0, $buflen$0$i$i$i103$lcssa << 2) | 0;
    if (!$420) $$pre$phi$i$i104Z2D = $417; else {
     $422 = HEAP32[$407 >> 2] | 0;
     _memset($420 + ($422 << 2) | 0, 0, $buflen$0$i$i$i103$lcssa - $422 << 2 | 0) | 0;
     HEAP32[$407 >> 2] = $buflen$0$i$i$i103$lcssa;
     HEAP32[$417 >> 2] = $420;
     $$pre$phi$i$i104Z2D = $417;
    }
   }
   HEAP32[(HEAP32[$$pre$phi$i$i104Z2D >> 2] | 0) + ($405 << 2) >> 2] = $c;
   HEAP32[$404 >> 2] = (HEAP32[$404 >> 2] | 0) + 1;
   STACKTOP = sp;
   return;
  }
 case 3:
  {
   label = 131;
   break;
  }
 default:
  {}
 } while (0);
 if ((label | 0) == 131) {
  if ($c >>> 0 > 255) {
   $431 = _prvTidyHTMLVersion($doc) | 0;
   if (!(HEAP32[$doc + 240 >> 2] | 0)) {
    $435 = _prvTidyEntityName($c, $431) | 0;
    if (!$435) label = 135; else {
     HEAP32[$vararg_buffer >> 2] = $435;
     _prvTidytmbsnprintf($entity, 128, 310751, $vararg_buffer) | 0;
    }
   } else label = 135;
   if ((label | 0) == 135) {
    HEAP32[$vararg_buffer1 >> 2] = $c;
    _prvTidytmbsnprintf($entity, 128, 310756, $vararg_buffer1) | 0;
   }
   $437 = $doc + 6736 | 0;
   $438 = HEAP32[$437 >> 2] | 0;
   $439 = _prvTidytmbstrlen($entity) | 0;
   $440 = $439 + $438 | 0;
   $441 = $doc + 6732 | 0;
   $442 = HEAP32[$441 >> 2] | 0;
   if ($440 >>> 0 >= $442 >>> 0) {
    $buflen$0$i$i$i107 = ($442 | 0) == 0 ? 256 : $442;
    while (1) if ($buflen$0$i$i$i107 >>> 0 > $440 >>> 0) {
     $buflen$0$i$i$i107$lcssa = $buflen$0$i$i$i107;
     break;
    } else $buflen$0$i$i$i107 = $buflen$0$i$i$i107 << 1;
    $447 = HEAP32[$0 >> 2] | 0;
    $451 = $doc + 6728 | 0;
    $454 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$447 >> 2] | 0) + 4 >> 2] & 15]($447, HEAP32[$451 >> 2] | 0, $buflen$0$i$i$i107$lcssa << 2) | 0;
    if ($454 | 0) {
     $456 = HEAP32[$441 >> 2] | 0;
     _memset($454 + ($456 << 2) | 0, 0, $buflen$0$i$i$i107$lcssa - $456 << 2 | 0) | 0;
     HEAP32[$441 >> 2] = $buflen$0$i$i$i107$lcssa;
     HEAP32[$451 >> 2] = $454;
    }
   }
   if ($439 | 0) {
    $$pre$i$i109 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i111 = 0;
    do {
     HEAP32[$$pre$i$i109 + ($ix$01$i$i111 + $438 << 2) >> 2] = HEAP8[$entity + $ix$01$i$i111 >> 0];
     $ix$01$i$i111 = $ix$01$i$i111 + 1 | 0;
    } while (($ix$01$i$i111 | 0) != ($439 | 0));
   }
   HEAP32[$437 >> 2] = $440;
   STACKTOP = sp;
   return;
  }
  if (($c + -127 | 0) >>> 0 >= 33) {
   $500 = $doc + 6736 | 0;
   $501 = HEAP32[$500 >> 2] | 0;
   $502 = $501 + 1 | 0;
   $503 = $doc + 6732 | 0;
   $504 = HEAP32[$503 >> 2] | 0;
   if ($502 >>> 0 < $504 >>> 0) $$pre$phi$i$i128Z2D = $doc + 6728 | 0; else {
    $buflen$0$i$i$i127 = ($504 | 0) == 0 ? 256 : $504;
    while (1) if ($buflen$0$i$i$i127 >>> 0 > $502 >>> 0) {
     $buflen$0$i$i$i127$lcssa = $buflen$0$i$i$i127;
     break;
    } else $buflen$0$i$i$i127 = $buflen$0$i$i$i127 << 1;
    $509 = HEAP32[$0 >> 2] | 0;
    $513 = $doc + 6728 | 0;
    $516 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$509 >> 2] | 0) + 4 >> 2] & 15]($509, HEAP32[$513 >> 2] | 0, $buflen$0$i$i$i127$lcssa << 2) | 0;
    if (!$516) $$pre$phi$i$i128Z2D = $513; else {
     $518 = HEAP32[$503 >> 2] | 0;
     _memset($516 + ($518 << 2) | 0, 0, $buflen$0$i$i$i127$lcssa - $518 << 2 | 0) | 0;
     HEAP32[$503 >> 2] = $buflen$0$i$i$i127$lcssa;
     HEAP32[$513 >> 2] = $516;
     $$pre$phi$i$i128Z2D = $513;
    }
   }
   HEAP32[(HEAP32[$$pre$phi$i$i128Z2D >> 2] | 0) + ($501 << 2) >> 2] = $c;
   HEAP32[$500 >> 2] = (HEAP32[$500 >> 2] | 0) + 1;
   STACKTOP = sp;
   return;
  }
  HEAP32[$vararg_buffer4 >> 2] = $c;
  _prvTidytmbsnprintf($entity, 128, 310756, $vararg_buffer4) | 0;
  $469 = $doc + 6736 | 0;
  $470 = HEAP32[$469 >> 2] | 0;
  $471 = _prvTidytmbstrlen($entity) | 0;
  $472 = $471 + $470 | 0;
  $473 = $doc + 6732 | 0;
  $474 = HEAP32[$473 >> 2] | 0;
  if ($472 >>> 0 >= $474 >>> 0) {
   $buflen$0$i$i$i116 = ($474 | 0) == 0 ? 256 : $474;
   while (1) if ($buflen$0$i$i$i116 >>> 0 > $472 >>> 0) {
    $buflen$0$i$i$i116$lcssa = $buflen$0$i$i$i116;
    break;
   } else $buflen$0$i$i$i116 = $buflen$0$i$i$i116 << 1;
   $479 = HEAP32[$0 >> 2] | 0;
   $483 = $doc + 6728 | 0;
   $486 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$479 >> 2] | 0) + 4 >> 2] & 15]($479, HEAP32[$483 >> 2] | 0, $buflen$0$i$i$i116$lcssa << 2) | 0;
   if ($486 | 0) {
    $488 = HEAP32[$473 >> 2] | 0;
    _memset($486 + ($488 << 2) | 0, 0, $buflen$0$i$i$i116$lcssa - $488 << 2 | 0) | 0;
    HEAP32[$473 >> 2] = $buflen$0$i$i$i116$lcssa;
    HEAP32[$483 >> 2] = $486;
   }
  }
  if ($471 | 0) {
   $$pre$i$i118 = HEAP32[$doc + 6728 >> 2] | 0;
   $ix$01$i$i120 = 0;
   do {
    HEAP32[$$pre$i$i118 + ($ix$01$i$i120 + $470 << 2) >> 2] = HEAP8[$entity + $ix$01$i$i120 >> 0];
    $ix$01$i$i120 = $ix$01$i$i120 + 1 | 0;
   } while (($ix$01$i$i120 | 0) != ($471 | 0));
  }
  HEAP32[$469 >> 2] = $472;
  STACKTOP = sp;
  return;
 }
 if (($2 | 0) == 10 | ($2 | 2 | 0) == 11) {
  $555 = $doc + 6736 | 0;
  $556 = HEAP32[$555 >> 2] | 0;
  $557 = $556 + 1 | 0;
  $558 = $doc + 6732 | 0;
  $559 = HEAP32[$558 >> 2] | 0;
  if ($557 >>> 0 < $559 >>> 0) $$pre$phi$i$i140Z2D = $doc + 6728 | 0; else {
   $buflen$0$i$i$i139 = ($559 | 0) == 0 ? 256 : $559;
   while (1) if ($buflen$0$i$i$i139 >>> 0 > $557 >>> 0) {
    $buflen$0$i$i$i139$lcssa = $buflen$0$i$i$i139;
    break;
   } else $buflen$0$i$i$i139 = $buflen$0$i$i$i139 << 1;
   $564 = HEAP32[$0 >> 2] | 0;
   $568 = $doc + 6728 | 0;
   $571 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$564 >> 2] | 0) + 4 >> 2] & 15]($564, HEAP32[$568 >> 2] | 0, $buflen$0$i$i$i139$lcssa << 2) | 0;
   if (!$571) $$pre$phi$i$i140Z2D = $568; else {
    $573 = HEAP32[$558 >> 2] | 0;
    _memset($571 + ($573 << 2) | 0, 0, $buflen$0$i$i$i139$lcssa - $573 << 2 | 0) | 0;
    HEAP32[$558 >> 2] = $buflen$0$i$i$i139$lcssa;
    HEAP32[$568 >> 2] = $571;
    $$pre$phi$i$i140Z2D = $568;
   }
  }
  HEAP32[(HEAP32[$$pre$phi$i$i140Z2D >> 2] | 0) + ($556 << 2) >> 2] = $c;
  HEAP32[$555 >> 2] = (HEAP32[$555 >> 2] | 0) + 1;
  STACKTOP = sp;
  return;
 }
 if (HEAP32[$doc + 168 >> 2] | 0) {
  if (!($c >>> 0 > 127 & ($2 | 0) == 1)) {
   $617 = $doc + 6736 | 0;
   $618 = HEAP32[$617 >> 2] | 0;
   $619 = $618 + 1 | 0;
   $620 = $doc + 6732 | 0;
   $621 = HEAP32[$620 >> 2] | 0;
   if ($619 >>> 0 < $621 >>> 0) $$pre$phi$i$i155Z2D = $doc + 6728 | 0; else {
    $buflen$0$i$i$i154 = ($621 | 0) == 0 ? 256 : $621;
    while (1) if ($buflen$0$i$i$i154 >>> 0 > $619 >>> 0) {
     $buflen$0$i$i$i154$lcssa = $buflen$0$i$i$i154;
     break;
    } else $buflen$0$i$i$i154 = $buflen$0$i$i$i154 << 1;
    $626 = HEAP32[$0 >> 2] | 0;
    $630 = $doc + 6728 | 0;
    $633 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$626 >> 2] | 0) + 4 >> 2] & 15]($626, HEAP32[$630 >> 2] | 0, $buflen$0$i$i$i154$lcssa << 2) | 0;
    if (!$633) $$pre$phi$i$i155Z2D = $630; else {
     $635 = HEAP32[$620 >> 2] | 0;
     _memset($633 + ($635 << 2) | 0, 0, $buflen$0$i$i$i154$lcssa - $635 << 2 | 0) | 0;
     HEAP32[$620 >> 2] = $buflen$0$i$i$i154$lcssa;
     HEAP32[$630 >> 2] = $633;
     $$pre$phi$i$i155Z2D = $630;
    }
   }
   HEAP32[(HEAP32[$$pre$phi$i$i155Z2D >> 2] | 0) + ($618 << 2) >> 2] = $c;
   HEAP32[$617 >> 2] = (HEAP32[$617 >> 2] | 0) + 1;
   STACKTOP = sp;
   return;
  }
  HEAP32[$vararg_buffer7 >> 2] = $c;
  _prvTidytmbsnprintf($entity, 128, 310756, $vararg_buffer7) | 0;
  $586 = $doc + 6736 | 0;
  $587 = HEAP32[$586 >> 2] | 0;
  $588 = _prvTidytmbstrlen($entity) | 0;
  $589 = $588 + $587 | 0;
  $590 = $doc + 6732 | 0;
  $591 = HEAP32[$590 >> 2] | 0;
  if ($589 >>> 0 >= $591 >>> 0) {
   $buflen$0$i$i$i143 = ($591 | 0) == 0 ? 256 : $591;
   while (1) if ($buflen$0$i$i$i143 >>> 0 > $589 >>> 0) {
    $buflen$0$i$i$i143$lcssa = $buflen$0$i$i$i143;
    break;
   } else $buflen$0$i$i$i143 = $buflen$0$i$i$i143 << 1;
   $596 = HEAP32[$0 >> 2] | 0;
   $600 = $doc + 6728 | 0;
   $603 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$596 >> 2] | 0) + 4 >> 2] & 15]($596, HEAP32[$600 >> 2] | 0, $buflen$0$i$i$i143$lcssa << 2) | 0;
   if ($603 | 0) {
    $605 = HEAP32[$590 >> 2] | 0;
    _memset($603 + ($605 << 2) | 0, 0, $buflen$0$i$i$i143$lcssa - $605 << 2 | 0) | 0;
    HEAP32[$590 >> 2] = $buflen$0$i$i$i143$lcssa;
    HEAP32[$600 >> 2] = $603;
   }
  }
  if ($588 | 0) {
   $$pre$i$i145 = HEAP32[$doc + 6728 >> 2] | 0;
   $ix$01$i$i147 = 0;
   do {
    HEAP32[$$pre$i$i145 + ($ix$01$i$i147 + $587 << 2) >> 2] = HEAP8[$entity + $ix$01$i$i147 >> 0];
    $ix$01$i$i147 = $ix$01$i$i147 + 1 | 0;
   } while (($ix$01$i$i147 | 0) != ($588 | 0));
  }
  HEAP32[$586 >> 2] = $589;
  STACKTOP = sp;
  return;
 }
 do if (($2 | 0) == 1) {
  if ($c >>> 0 <= 126) if (!($c >>> 0 < 32 & ($c | 0) != 9)) break;
  $647 = _prvTidyHTMLVersion($doc) | 0;
  if (!(HEAP32[$doc + 240 >> 2] | 0)) {
   $651 = _prvTidyEntityName($c, $647) | 0;
   if (!$651) label = 201; else {
    HEAP32[$vararg_buffer10 >> 2] = $651;
    _prvTidytmbsnprintf($entity, 128, 310751, $vararg_buffer10) | 0;
   }
  } else label = 201;
  if ((label | 0) == 201) {
   HEAP32[$vararg_buffer13 >> 2] = $c;
   _prvTidytmbsnprintf($entity, 128, 310756, $vararg_buffer13) | 0;
  }
  $653 = $doc + 6736 | 0;
  $654 = HEAP32[$653 >> 2] | 0;
  $655 = _prvTidytmbstrlen($entity) | 0;
  $656 = $655 + $654 | 0;
  $657 = $doc + 6732 | 0;
  $658 = HEAP32[$657 >> 2] | 0;
  if ($656 >>> 0 >= $658 >>> 0) {
   $buflen$0$i$i$i158 = ($658 | 0) == 0 ? 256 : $658;
   while (1) if ($buflen$0$i$i$i158 >>> 0 > $656 >>> 0) {
    $buflen$0$i$i$i158$lcssa = $buflen$0$i$i$i158;
    break;
   } else $buflen$0$i$i$i158 = $buflen$0$i$i$i158 << 1;
   $663 = HEAP32[$0 >> 2] | 0;
   $667 = $doc + 6728 | 0;
   $670 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$663 >> 2] | 0) + 4 >> 2] & 15]($663, HEAP32[$667 >> 2] | 0, $buflen$0$i$i$i158$lcssa << 2) | 0;
   if ($670 | 0) {
    $672 = HEAP32[$657 >> 2] | 0;
    _memset($670 + ($672 << 2) | 0, 0, $buflen$0$i$i$i158$lcssa - $672 << 2 | 0) | 0;
    HEAP32[$657 >> 2] = $buflen$0$i$i$i158$lcssa;
    HEAP32[$667 >> 2] = $670;
   }
  }
  if ($655 | 0) {
   $$pre$i$i160 = HEAP32[$doc + 6728 >> 2] | 0;
   $ix$01$i$i162 = 0;
   do {
    HEAP32[$$pre$i$i160 + ($ix$01$i$i162 + $654 << 2) >> 2] = HEAP8[$entity + $ix$01$i$i162 >> 0];
    $ix$01$i$i162 = $ix$01$i$i162 + 1 | 0;
   } while (($ix$01$i$i162 | 0) != ($655 | 0));
  }
  HEAP32[$653 >> 2] = $656;
  STACKTOP = sp;
  return;
 } while (0);
 $684 = $doc + 6736 | 0;
 $685 = HEAP32[$684 >> 2] | 0;
 $686 = $685 + 1 | 0;
 $687 = $doc + 6732 | 0;
 $688 = HEAP32[$687 >> 2] | 0;
 if ($686 >>> 0 < $688 >>> 0) $$pre$phi$i$i170Z2D = $doc + 6728 | 0; else {
  $buflen$0$i$i$i169 = ($688 | 0) == 0 ? 256 : $688;
  while (1) if ($buflen$0$i$i$i169 >>> 0 > $686 >>> 0) {
   $buflen$0$i$i$i169$lcssa = $buflen$0$i$i$i169;
   break;
  } else $buflen$0$i$i$i169 = $buflen$0$i$i$i169 << 1;
  $693 = HEAP32[$0 >> 2] | 0;
  $697 = $doc + 6728 | 0;
  $700 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$693 >> 2] | 0) + 4 >> 2] & 15]($693, HEAP32[$697 >> 2] | 0, $buflen$0$i$i$i169$lcssa << 2) | 0;
  if (!$700) $$pre$phi$i$i170Z2D = $697; else {
   $702 = HEAP32[$687 >> 2] | 0;
   _memset($700 + ($702 << 2) | 0, 0, $buflen$0$i$i$i169$lcssa - $702 << 2 | 0) | 0;
   HEAP32[$687 >> 2] = $buflen$0$i$i$i169$lcssa;
   HEAP32[$697 >> 2] = $700;
   $$pre$phi$i$i170Z2D = $697;
  }
 }
 HEAP32[(HEAP32[$$pre$phi$i$i170Z2D >> 2] | 0) + ($685 << 2) >> 2] = $c;
 HEAP32[$684 >> 2] = (HEAP32[$684 >> 2] | 0) + 1;
 STACKTOP = sp;
 return;
}

function _prvTidyParseInline($doc, $element, $mode) {
 $doc = $doc | 0;
 $element = $element | 0;
 $mode = $mode | 0;
 var $$0$be = 0, $$0$lcssa = 0, $$0$pn = 0, $$0125 = 0, $$0125$lcssa = 0, $$0125$lcssa367 = 0, $$0125$lcssa368 = 0, $$0125$lcssa369 = 0, $$0125$lcssa370 = 0, $$0125$lcssa371 = 0, $$0125$lcssa372 = 0, $$0125$lcssa373 = 0, $$0125$lcssa374 = 0, $$lcssa = 0, $$lcssa358 = 0, $$lcssa359 = 0, $$lcssa361 = 0, $$lcssa362 = 0, $$lcssa363 = 0, $$lcssa378 = 0, $$lcssa380 = 0, $$lcssa386 = 0, $$lcssa396 = 0, $$lcssa400 = 0, $$lcssa403 = 0, $$lcssa406 = 0, $$lcssa407 = 0, $$lcssa409 = 0, $$lcssa410 = 0, $$pr65 = 0, $$pre$phi$i35Z2D = 0, $$pre$phi$i38Z2D = 0, $$pre$phi$i41Z2D = 0, $$pre$phi$i45Z2D = 0, $$pre$phi$iZ2D = 0, $$pre186 = 0, $$pre188 = 0, $0 = 0, $1 = 0, $10 = 0, $117 = 0, $125 = 0, $133 = 0, $134 = 0, $141 = 0, $143 = 0, $147 = 0, $151 = 0, $157 = 0, $163 = 0, $167 = 0, $171 = 0, $172 = 0, $178 = 0, $181 = 0, $185 = 0, $186 = 0, $19 = 0, $2 = 0, $200 = 0, $205 = 0, $207 = 0, $208 = 0, $214 = 0, $22 = 0, $221 = 0, $225 = 0, $231 = 0, $232 = 0, $238 = 0, $239 = 0, $247 = 0, $25 = 0, $261 = 0, $268 = 0, $272 = 0, $281 = 0, $29 = 0, $292 = 0, $293 = 0, $300 = 0, $306 = 0, $31 = 0, $318 = 0, $320 = 0, $33 = 0, $332 = 0, $333 = 0, $336 = 0, $339 = 0, $34 = 0, $341 = 0, $342 = 0, $345 = 0, $347 = 0, $348 = 0, $35 = 0, $351 = 0, $353 = 0, $356 = 0, $357 = 0, $36 = 0, $362 = 0, $363 = 0, $364 = 0, $37 = 0, $374 = 0, $375 = 0, $377 = 0, $379 = 0, $38 = 0, $380 = 0, $383 = 0, $387 = 0, $39 = 0, $390 = 0, $391 = 0, $396 = 0, $397 = 0, $399 = 0, $402 = 0, $403 = 0, $41 = 0, $414 = 0, $417 = 0, $418 = 0, $42 = 0, $420 = 0, $422 = 0, $423 = 0, $426 = 0, $429 = 0, $43 = 0, $430 = 0, $437 = 0, $440 = 0, $441 = 0, $446 = 0, $447 = 0, $453 = 0, $454 = 0, $456 = 0, $459 = 0, $460 = 0, $483 = 0, $485 = 0, $486 = 0, $49 = 0, $494 = 0, $496 = 0, $499 = 0, $509 = 0, $510 = 0, $511 = 0, $512 = 0, $517 = 0, $519 = 0, $521 = 0, $523 = 0, $526 = 0, $53 = 0, $533 = 0, $537 = 0, $538 = 0, $54 = 0, $544 = 0, $545 = 0, $548 = 0, $559 = 0, $56 = 0, $60 = 0, $65 = 0, $68 = 0, $71 = 0, $84 = 0, $98 = 0, $mode$ = 0, $parent$02$i = 0, $parent$02$i14 = 0, $parent$02$i25 = 0, $parent$03$i = 0, $parent$03$i15 = 0, $parent$03$i26 = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $element + 28 | 0;
 if (HEAP32[(HEAP32[$2 >> 2] | 0) + 16 >> 2] & 1 | 0) return;
 if (!(_prvTidynodeHasCM($element, 8) | 0)) {
  $10 = HEAP32[$2 >> 2] | 0;
  if (!$10) label = 7; else if ((HEAP32[$10 >> 2] | 0) == 32) label = 5; else label = 7;
 } else label = 5;
 if ((label | 0) == 5) if (!(_prvTidynodeHasCM($element, 131072) | 0)) _prvTidyInlineDup($doc, 0) | 0; else label = 7;
 if ((label | 0) == 7) if (_prvTidynodeHasCM($element, 16) | 0) _prvTidyPushInline($doc, $element);
 L14 : do if ($element | 0) {
  $19 = HEAP32[$2 >> 2] | 0;
  if ($19 | 0) switch (HEAP32[$19 >> 2] | 0) {
  case 70:
   {
    $22 = $doc + 6840 | 0;
    HEAP32[$22 >> 2] = HEAP32[$22 >> 2] | 4;
    break L14;
    break;
   }
  case 36:
   {
    $25 = $doc + 6840 | 0;
    HEAP32[$25 >> 2] = HEAP32[$25 >> 2] | 8;
    break L14;
    break;
   }
  default:
   break L14;
  }
 } while (0);
 $mode$ = ($mode | 0) == 2 ? 2 : 1;
 $29 = _prvTidyGetToken($doc, $mode$) | 0;
 L21 : do if (!$29) $$0$lcssa = $element; else {
  $31 = $doc + 156 | 0;
  $33 = ($mode$ & 2 | 0) == 0;
  $34 = $doc + 6856 | 0;
  $35 = $1 + 24 | 0;
  $$0125 = $element;
  $37 = $29;
  L23 : while (1) {
   $36 = $37 + 28 | 0;
   $38 = HEAP32[$36 >> 2] | 0;
   $39 = $$0125 + 28 | 0;
   $41 = ($38 | 0) == (HEAP32[$39 >> 2] | 0);
   $42 = $37 + 44 | 0;
   $43 = HEAP32[$42 >> 2] | 0;
   if ($41 & ($43 | 0) == 6) {
    $$0125$lcssa = $$0125;
    $$lcssa = $37;
    $$lcssa386 = $38;
    $$lcssa396 = $39;
    label = 17;
    break;
   }
   L26 : do if (($43 | 0) != 5 | $41 ^ 1) label = 46; else if (!(_prvTidyIsPushed($doc, $37) | 0)) label = 46; else if (!(HEAP32[$37 + 60 >> 2] | 0)) if (!(HEAP32[$$0125 + 60 >> 2] | 0)) {
    $84 = HEAP32[$36 >> 2] | 0;
    if (!$84) label = 46; else if (!(HEAP32[$84 + 16 >> 2] & 16)) label = 46; else {
     switch (HEAP32[$84 >> 2] | 0) {
     case 100:
     case 85:
     case 105:
     case 104:
     case 98:
     case 13:
     case 36:
     case 1:
      {
       label = 46;
       break L26;
       break;
      }
     default:
      {}
     }
     if (!(HEAP32[$31 >> 2] | 0)) label = 46; else {
      $$pre188 = $37 + 20 | 0;
      if (HEAP32[$$0125 + 12 >> 2] | 0) if (!(HEAP32[$$pre188 >> 2] | 0)) {
       $98 = $$0125 + 16 | 0;
       if (_prvTidynodeIsText(HEAP32[$98 >> 2] | 0) | 0) if (!(_prvTidyTextNodeEndWithSpace(HEAP32[$0 >> 2] | 0, HEAP32[$98 >> 2] | 0) | 0)) {
        _prvTidyReportWarning($doc, $$0125, $37, 285);
        HEAP32[$42 >> 2] = 6;
        _prvTidyUngetToken($doc);
        $$0$be = $$0125;
        break;
       }
      }
      if (HEAP32[$$pre188 >> 2] | 0) if (HEAP32[$$0125 + 20 >> 2] | 0) {
       label = 52;
       break;
      }
      _prvTidyReportWarning($doc, $$0125, $37, 209);
      label = 52;
     }
    }
   } else label = 46; else label = 46; while (0);
   if ((label | 0) == 46) {
    label = 0;
    if (!(_prvTidyIsPushed($doc, $37) | 0)) label = 52; else if ((HEAP32[$42 >> 2] | 0) == 5) {
     $117 = HEAP32[$36 >> 2] | 0;
     if (!$117) label = 52; else if ((HEAP32[$117 >> 2] | 0) == 85) if ((_prvTidyHTMLVersion($doc) | 0) == 131072) label = 52; else {
      _prvTidyReportWarning($doc, $$0125, $37, 240);
      label = 52;
     } else label = 52;
    } else label = 52;
   }
   L51 : do if ((label | 0) == 52) {
    label = 0;
    if (_prvTidynodeIsText($37) | 0) {
     $125 = $$0125 + 12 | 0;
     if ($33 & (HEAP32[$125 >> 2] | 0) == 0) _TrimSpaces($doc, $$0125);
     if ((HEAP32[$37 + 36 >> 2] | 0) >>> 0 >= (HEAP32[$37 + 40 >> 2] | 0) >>> 0) {
      _prvTidyFreeNode($doc, $37);
      $$0$be = $$0125;
      break;
     }
     HEAP32[$37 >> 2] = $$0125;
     $133 = $$0125 + 16 | 0;
     $134 = HEAP32[$133 >> 2] | 0;
     HEAP32[$37 + 4 >> 2] = $134;
     if (!$134) HEAP32[$125 >> 2] = $37; else HEAP32[$134 + 8 >> 2] = $37;
     HEAP32[$133 >> 2] = $37;
     $$0$be = $$0125;
     break;
    }
    if (!(_InsertMisc($$0125, $37) | 0)) {
     $141 = HEAP32[$36 >> 2] | 0;
     L67 : do if ($141 | 0) {
      $143 = HEAP32[$141 >> 2] | 0;
      if (($143 | 0) == 48) {
       if (!(_prvTidynodeIsElement($37) | 0)) {
        $$0125$lcssa374 = $$0125;
        label = 66;
        break L23;
       }
       _prvTidyReportError($doc, $$0125, $37, 208);
       _prvTidyFreeNode($doc, $37);
       $$0$be = $$0125;
       break L51;
      }
      $147 = ($143 | 0) == 80;
      L73 : do if ($147) {
       L75 : do if ((HEAP32[$42 >> 2] | 0) == 5) {
        L77 : do if ($33) {
         do if ($$0125 | 0) {
          $151 = HEAP32[$39 >> 2] | 0;
          if (!$151) break;
          if ((HEAP32[$151 >> 2] | 0) == 32) break L77;
         } while (0);
         $parent$02$i = HEAP32[$$0125 >> 2] | 0;
         if ($parent$02$i | 0) {
          $parent$03$i = $parent$02$i;
          do {
           $157 = HEAP32[$parent$03$i + 28 >> 2] | 0;
           if ($157 | 0) if ((HEAP32[$157 >> 2] | 0) == 32) break L77;
           $parent$03$i = HEAP32[$parent$03$i >> 2] | 0;
          } while (($parent$03$i | 0) != 0);
         }
         if ($147) break L75; else {
          label = 90;
          break L73;
         }
        } while (0);
        HEAP32[$36 >> 2] = _prvTidyLookupTagDef(17) | 0;
        $163 = HEAP32[$34 >> 2] | 0;
        $167 = $37 + 32 | 0;
        FUNCTION_TABLE_vii[HEAP32[(HEAP32[$163 >> 2] | 0) + 8 >> 2] & 15]($163, HEAP32[$167 >> 2] | 0);
        HEAP32[$167 >> 2] = _prvTidytmbstrdup(HEAP32[$34 >> 2] | 0, 308174) | 0;
        _TrimSpaces($doc, $$0125);
        HEAP32[$37 >> 2] = $$0125;
        $171 = $$0125 + 16 | 0;
        $172 = HEAP32[$171 >> 2] | 0;
        HEAP32[$37 + 4 >> 2] = $172;
        if (!$172) HEAP32[$$0125 + 12 >> 2] = $37; else HEAP32[$172 + 8 >> 2] = $37;
        HEAP32[$171 >> 2] = $37;
        $$0$be = $$0125;
        break L51;
       } while (0);
       $178 = HEAP32[$42 >> 2] | 0;
       if (($$0125 | 0) != 0 & ($178 | 0) == 5) {
        $181 = HEAP32[$39 >> 2] | 0;
        if (!$181) label = 94; else if ((HEAP32[$181 >> 2] | 0) == 4) {
         _prvTidyConstrainVersion($doc, -293);
         HEAP32[$37 >> 2] = $$0125;
         $185 = $$0125 + 16 | 0;
         $186 = HEAP32[$185 >> 2] | 0;
         HEAP32[$37 + 4 >> 2] = $186;
         if (!$186) HEAP32[$$0125 + 12 >> 2] = $37; else HEAP32[$186 + 8 >> 2] = $37;
         HEAP32[$185 >> 2] = $37;
         FUNCTION_TABLE_viii[HEAP32[(HEAP32[$36 >> 2] | 0) + 20 >> 2] & 63]($doc, $37, $mode$);
         $$0$be = $$0125;
         break L51;
        } else label = 94;
       } else {
        $$pr65 = $178;
        label = 95;
       }
      } else label = 90; while (0);
      L103 : do if ((label | 0) == 90) {
       label = 0;
       switch ($143 | 0) {
       case 81:
        {
         break L67;
         break;
        }
       case 17:
        break;
       default:
        {
         label = 94;
         break L103;
        }
       }
       if ((HEAP32[$42 >> 2] | 0) == 6) HEAP32[$42 >> 2] = 5;
      } while (0);
      if ((label | 0) == 94) {
       label = 0;
       $$pr65 = HEAP32[$42 >> 2] | 0;
       label = 95;
      }
      L109 : do if ((label | 0) == 95) {
       label = 0;
       if (($$pr65 | 0) == 6) {
        if ($147) {
         $parent$02$i14 = HEAP32[$$0125 >> 2] | 0;
         if ($parent$02$i14 | 0) {
          $parent$03$i15 = $parent$02$i14;
          do {
           $200 = HEAP32[$parent$03$i15 + 28 >> 2] | 0;
           if ($200 | 0) if ((HEAP32[$200 >> 2] | 0) == 80) break L109;
           $parent$03$i15 = HEAP32[$parent$03$i15 >> 2] | 0;
          } while (($parent$03$i15 | 0) != 0);
         }
         $205 = _prvTidyLookupTagDef(17) | 0;
         $207 = _prvTidyInferredTag($doc, HEAP32[$205 >> 2] | 0) | 0;
         _prvTidyReportNotice($doc, $37, $207, 283);
         $208 = HEAP32[$34 >> 2] | 0;
         FUNCTION_TABLE_vii[HEAP32[(HEAP32[$208 >> 2] | 0) + 8 >> 2] & 15]($208, HEAP32[$207 + 32 >> 2] | 0);
         $214 = HEAP32[$34 >> 2] | 0;
         FUNCTION_TABLE_vii[HEAP32[(HEAP32[$214 >> 2] | 0) + 8 >> 2] & 15]($214, $207);
         HEAP32[$37 + 24 >> 2] = HEAP32[$36 >> 2];
         HEAP32[$36 >> 2] = $205;
         HEAP32[$42 >> 2] = 5;
         HEAP32[$37 + 60 >> 2] = 1;
         $221 = HEAP32[$34 >> 2] | 0;
         $225 = $37 + 32 | 0;
         FUNCTION_TABLE_vii[HEAP32[(HEAP32[$221 >> 2] | 0) + 8 >> 2] & 15]($221, HEAP32[$225 >> 2] | 0);
         HEAP32[$225 >> 2] = _prvTidytmbstrdup(HEAP32[$34 >> 2] | 0, HEAP32[$205 + 4 >> 2] | 0) | 0;
         _TrimSpaces($doc, $$0125);
         HEAP32[$37 >> 2] = $$0125;
         $231 = $$0125 + 16 | 0;
         $232 = HEAP32[$231 >> 2] | 0;
         HEAP32[$37 + 4 >> 2] = $232;
         if (!$232) HEAP32[$$0125 + 12 >> 2] = $37; else HEAP32[$232 + 8 >> 2] = $37;
         HEAP32[$231 >> 2] = $37;
         $238 = _prvTidyInferredTag($doc, 17) | 0;
         HEAP32[$238 >> 2] = $$0125;
         $239 = HEAP32[$231 >> 2] | 0;
         HEAP32[$238 + 4 >> 2] = $239;
         if (!$239) HEAP32[$$0125 + 12 >> 2] = $238; else HEAP32[$239 + 8 >> 2] = $238;
         HEAP32[$231 >> 2] = $238;
         $$0$be = $$0125;
         break L51;
        }
        do if (_prvTidynodeHasCM($37, 16) | 0) {
         $247 = HEAP32[$36 >> 2] | 0;
         if ($247 | 0) if ((HEAP32[$247 >> 2] | 0) == 1) break;
         if (_prvTidynodeHasCM($37, 2048) | 0) break;
         if (!(_prvTidynodeHasCM($$0125, 16) | 0)) break;
         $$pre186 = HEAP32[$39 >> 2] | 0;
         do if (!$$0125) {
          $261 = $$pre186;
          label = 116;
         } else {
          if (!$$pre186) {
           $261 = 0;
           label = 116;
           break;
          }
          if ((HEAP32[$$pre186 >> 2] | 0) != 1) {
           $261 = $$pre186;
           label = 116;
          }
         } while (0);
         do if ((label | 0) == 116) {
          label = 0;
          if ((HEAP32[$36 >> 2] | 0) == ($261 | 0)) break;
          if (!(_prvTidyIsPushed($doc, $37) | 0)) break;
          if (!(_prvTidyIsPushed($doc, $$0125) | 0)) break;
          if (_prvTidySwitchInline($doc, $$0125, $37) | 0) {
           $$0125$lcssa367 = $$0125;
           $$lcssa358 = $37;
           label = 120;
           break L23;
          }
         } while (0);
         _prvTidyPopInline($doc, $$0125);
         $268 = HEAP32[$39 >> 2] | 0;
         if (!$268) {
          $$0125$lcssa368 = $$0125;
          $$lcssa359 = $37;
          $$lcssa378 = $36;
          $$lcssa406 = $268;
          label = 124;
          break L23;
         }
         if ((HEAP32[$268 >> 2] | 0) != 1) {
          $$0125$lcssa368 = $$0125;
          $$lcssa359 = $37;
          $$lcssa378 = $36;
          $$lcssa406 = $268;
          label = 124;
          break L23;
         }
         _prvTidyReportError($doc, $$0125, $37, 208);
         _prvTidyFreeNode($doc, $37);
         $$0$be = $$0125;
         break L51;
        } while (0);
        if (HEAP32[$35 >> 2] | 0) {
         if (_prvTidynodeHasCM($37, 128) | 0) {
          $$0125$lcssa369 = $$0125;
          label = 135;
          break L23;
         }
         $281 = HEAP32[$36 >> 2] | 0;
         if (!$281) break;
         if ((HEAP32[$281 >> 2] | 0) == 107) {
          $$0125$lcssa369 = $$0125;
          label = 135;
          break L23;
         }
        }
       }
      } while (0);
      if (_prvTidynodeHasCM($37, 16384) | 0) if (_prvTidynodeHasCM($$0125, 16384) | 0) {
       $$0125$lcssa370 = $$0125;
       $$lcssa361 = $37;
       $$lcssa380 = $36;
       $$lcssa400 = $39;
       label = 138;
       break L23;
      }
      $292 = HEAP32[$36 >> 2] | 0;
      $293 = ($292 | 0) == 0;
      L156 : do if (!$293) if ((HEAP32[$292 >> 2] | 0) == 1) if (!(HEAP32[$37 + 60 >> 2] | 0)) {
       do if (!$$0125) label = 149; else {
        $300 = HEAP32[$39 >> 2] | 0;
        if (!$300) {
         label = 149;
         break;
        }
        if ((HEAP32[$300 >> 2] | 0) != 1) label = 149;
       } while (0);
       L163 : do if ((label | 0) == 149) {
        label = 0;
        $parent$02$i25 = HEAP32[$$0125 >> 2] | 0;
        if (!$parent$02$i25) break L156; else $parent$03$i26 = $parent$02$i25;
        while (1) {
         $306 = HEAP32[$parent$03$i26 + 28 >> 2] | 0;
         if ($306 | 0) if ((HEAP32[$306 >> 2] | 0) == 1) break L163;
         $parent$03$i26 = HEAP32[$parent$03$i26 >> 2] | 0;
         if (!$parent$03$i26) break L156;
        }
       } while (0);
       if ((HEAP32[$42 >> 2] | 0) == 6) {
        $$0125$lcssa371 = $$0125;
        $$lcssa362 = $37;
        label = 157;
        break L23;
       }
       if (HEAP32[$37 + 20 >> 2] | 0) {
        $$0125$lcssa371 = $$0125;
        $$lcssa362 = $37;
        label = 157;
        break L23;
       }
       if (!(HEAP32[$31 >> 2] | 0)) {
        $$0125$lcssa371 = $$0125;
        $$lcssa362 = $37;
        label = 157;
        break L23;
       }
       HEAP32[$42 >> 2] = 6;
       _prvTidyReportError($doc, $$0125, $37, 224);
       _prvTidyUngetToken($doc);
       $$0$be = $$0125;
       break L51;
      } while (0);
      $318 = HEAP32[$39 >> 2] | 0;
      $320 = HEAP32[$318 + 16 >> 2] | 0;
      L175 : do if (!(($320 & 16384 | 0) == 0 | $293)) {
       switch (HEAP32[$292 >> 2] | 0) {
       case 30:
       case 20:
        break;
       case 47:
        {
         if (!(_prvTidynodeIsElement($37) | 0)) {
          _prvTidyReportError($doc, $$0125, $37, 208);
          _prvTidyFreeNode($doc, $37);
          $$0$be = $$0125;
          break L51;
         }
         _prvTidyReportError($doc, $$0125, $37, 211);
         $374 = (HEAP32[$$0125 + 12 >> 2] | 0) == 0;
         $375 = HEAP32[$$0125 >> 2] | 0;
         HEAP32[$37 >> 2] = $375;
         if ($374) {
          HEAP32[$37 + 8 >> 2] = $$0125;
          $377 = $$0125 + 4 | 0;
          $379 = $37 + 4 | 0;
          HEAP32[$379 >> 2] = HEAP32[$377 >> 2];
          HEAP32[$377 >> 2] = $37;
          $380 = HEAP32[$379 >> 2] | 0;
          if ($380 | 0) HEAP32[$380 + 8 >> 2] = $37;
          $383 = $375 + 12 | 0;
          if ((HEAP32[$383 >> 2] | 0) != ($$0125 | 0)) {
           $$0$be = $$0125;
           break L51;
          }
          HEAP32[$383 >> 2] = $37;
          $$0$be = $$0125;
          break L51;
         }
         do if (!$375) label = 193; else {
          $387 = $375 + 16 | 0;
          if ((HEAP32[$387 >> 2] | 0) != ($$0125 | 0)) {
           label = 193;
           break;
          }
          HEAP32[$387 >> 2] = $37;
          $$pre$phi$i35Z2D = $$0125 + 8 | 0;
         } while (0);
         do if ((label | 0) == 193) {
          label = 0;
          $390 = $$0125 + 8 | 0;
          $391 = HEAP32[$390 >> 2] | 0;
          HEAP32[$37 + 8 >> 2] = $391;
          if (!$391) {
           $$pre$phi$i35Z2D = $390;
           break;
          }
          HEAP32[$391 + 4 >> 2] = $37;
          $$pre$phi$i35Z2D = $390;
         } while (0);
         HEAP32[$$pre$phi$i35Z2D >> 2] = $37;
         HEAP32[$37 + 4 >> 2] = $$0125;
         if ($33) _TrimSpaces($doc, $$0125);
         $396 = _prvTidyCloneNode($doc, $$0125) | 0;
         $397 = HEAP32[$37 >> 2] | 0;
         HEAP32[$396 >> 2] = $397;
         do if (!$397) label = 200; else {
          $399 = $397 + 16 | 0;
          if ((HEAP32[$399 >> 2] | 0) != ($37 | 0)) {
           label = 200;
           break;
          }
          HEAP32[$399 >> 2] = $396;
          $$pre$phi$i41Z2D = $37 + 8 | 0;
         } while (0);
         do if ((label | 0) == 200) {
          label = 0;
          $402 = $37 + 8 | 0;
          $403 = HEAP32[$402 >> 2] | 0;
          HEAP32[$396 + 8 >> 2] = $403;
          if (!$403) {
           $$pre$phi$i41Z2D = $402;
           break;
          }
          HEAP32[$403 + 4 >> 2] = $396;
          $$pre$phi$i41Z2D = $402;
         } while (0);
         HEAP32[$$pre$phi$i41Z2D >> 2] = $396;
         HEAP32[$396 + 4 >> 2] = $37;
         $$0$be = $396;
         break L51;
         break;
        }
       default:
        break L175;
       }
       if (!(_prvTidynodeIsElement($37) | 0)) {
        _prvTidyReportError($doc, $$0125, $37, 208);
        _prvTidyFreeNode($doc, $37);
        $$0$be = $$0125;
        break L51;
       }
       _prvTidyReportError($doc, $$0125, $37, 211);
       if (!(HEAP32[$$0125 + 12 >> 2] | 0)) {
        HEAP32[$37 + 12 >> 2] = $$0125;
        HEAP32[$37 + 16 >> 2] = $$0125;
        HEAP32[$37 >> 2] = HEAP32[$$0125 >> 2];
        HEAP32[$$0125 >> 2] = $37;
        $332 = HEAP32[$37 >> 2] | 0;
        $333 = $332 + 12 | 0;
        if ((HEAP32[$333 >> 2] | 0) == ($$0125 | 0)) HEAP32[$333 >> 2] = $37;
        $336 = $332 + 16 | 0;
        if ((HEAP32[$336 >> 2] | 0) == ($$0125 | 0)) HEAP32[$336 >> 2] = $37;
        $339 = $$0125 + 4 | 0;
        $341 = $37 + 4 | 0;
        HEAP32[$341 >> 2] = HEAP32[$339 >> 2];
        HEAP32[$339 >> 2] = 0;
        $342 = HEAP32[$341 >> 2] | 0;
        if ($342 | 0) HEAP32[$342 + 8 >> 2] = $37;
        $345 = $$0125 + 8 | 0;
        $347 = $37 + 8 | 0;
        HEAP32[$347 >> 2] = HEAP32[$345 >> 2];
        HEAP32[$345 >> 2] = 0;
        $348 = HEAP32[$347 >> 2] | 0;
        if (!$348) {
         $$0$be = $$0125;
         break L51;
        }
        HEAP32[$348 + 4 >> 2] = $37;
        $$0$be = $$0125;
        break L51;
       }
       $351 = HEAP32[$$0125 >> 2] | 0;
       HEAP32[$37 >> 2] = $351;
       do if (!$351) label = 175; else {
        $353 = $351 + 16 | 0;
        if ((HEAP32[$353 >> 2] | 0) != ($$0125 | 0)) {
         label = 175;
         break;
        }
        HEAP32[$353 >> 2] = $37;
        $$pre$phi$iZ2D = $$0125 + 8 | 0;
       } while (0);
       do if ((label | 0) == 175) {
        label = 0;
        $356 = $$0125 + 8 | 0;
        $357 = HEAP32[$356 >> 2] | 0;
        HEAP32[$37 + 8 >> 2] = $357;
        if (!$357) {
         $$pre$phi$iZ2D = $356;
         break;
        }
        HEAP32[$357 + 4 >> 2] = $37;
        $$pre$phi$iZ2D = $356;
       } while (0);
       HEAP32[$$pre$phi$iZ2D >> 2] = $37;
       HEAP32[$37 + 4 >> 2] = $$0125;
       if ($33) _TrimSpaces($doc, $$0125);
       $362 = _prvTidyCloneNode($doc, $$0125) | 0;
       HEAP32[$362 >> 2] = $37;
       $363 = $37 + 16 | 0;
       $364 = HEAP32[$363 >> 2] | 0;
       HEAP32[$362 + 4 >> 2] = $364;
       if (!$364) HEAP32[$37 + 12 >> 2] = $362; else HEAP32[$364 + 8 >> 2] = $362;
       HEAP32[$363 >> 2] = $362;
       $$0$be = $362;
       break L51;
      } while (0);
      do if ($318 | 0) {
       if ((HEAP32[$318 >> 2] | 0) != 32 | $293) break;
       if ((HEAP32[$292 >> 2] | 0) != 47) break;
       if (!(_prvTidynodeIsElement($37) | 0)) {
        _prvTidyReportError($doc, $$0125, $37, 208);
        _prvTidyFreeNode($doc, $37);
        $$0$be = $$0125;
        break L51;
       }
       _prvTidyReportError($doc, $$0125, $37, 211);
       $414 = _prvTidyInferredTag($doc, 26) | 0;
       $417 = (HEAP32[$$0125 + 12 >> 2] | 0) == 0;
       $418 = HEAP32[$$0125 >> 2] | 0;
       HEAP32[$414 >> 2] = $418;
       if ($417) {
        HEAP32[$414 + 8 >> 2] = $$0125;
        $420 = $$0125 + 4 | 0;
        $422 = $414 + 4 | 0;
        HEAP32[$422 >> 2] = HEAP32[$420 >> 2];
        HEAP32[$420 >> 2] = $414;
        $423 = HEAP32[$422 >> 2] | 0;
        if ($423 | 0) HEAP32[$423 + 8 >> 2] = $414;
        $426 = $418 + 12 | 0;
        if ((HEAP32[$426 >> 2] | 0) == ($$0125 | 0)) HEAP32[$426 >> 2] = $414;
        HEAP32[$37 >> 2] = $414;
        $429 = $414 + 16 | 0;
        $430 = HEAP32[$429 >> 2] | 0;
        HEAP32[$37 + 4 >> 2] = $430;
        if (!$430) HEAP32[$414 + 12 >> 2] = $37; else HEAP32[$430 + 8 >> 2] = $37;
        HEAP32[$429 >> 2] = $37;
        $$0$be = $$0125;
        break L51;
       }
       do if (!$418) label = 220; else {
        $437 = $418 + 16 | 0;
        if ((HEAP32[$437 >> 2] | 0) != ($$0125 | 0)) {
         label = 220;
         break;
        }
        HEAP32[$437 >> 2] = $414;
        $$pre$phi$i45Z2D = $$0125 + 8 | 0;
       } while (0);
       do if ((label | 0) == 220) {
        label = 0;
        $440 = $$0125 + 8 | 0;
        $441 = HEAP32[$440 >> 2] | 0;
        HEAP32[$414 + 8 >> 2] = $441;
        if (!$441) {
         $$pre$phi$i45Z2D = $440;
         break;
        }
        HEAP32[$441 + 4 >> 2] = $414;
        $$pre$phi$i45Z2D = $440;
       } while (0);
       HEAP32[$$pre$phi$i45Z2D >> 2] = $414;
       HEAP32[$414 + 4 >> 2] = $$0125;
       HEAP32[$37 >> 2] = $414;
       $446 = $414 + 16 | 0;
       $447 = HEAP32[$446 >> 2] | 0;
       HEAP32[$37 + 4 >> 2] = $447;
       if (!$447) HEAP32[$414 + 12 >> 2] = $37; else HEAP32[$447 + 8 >> 2] = $37;
       HEAP32[$446 >> 2] = $37;
       if ($33) _TrimSpaces($doc, $$0125);
       $453 = _prvTidyCloneNode($doc, $$0125) | 0;
       $454 = HEAP32[$414 >> 2] | 0;
       HEAP32[$453 >> 2] = $454;
       do if (!$454) label = 230; else {
        $456 = $454 + 16 | 0;
        if ((HEAP32[$456 >> 2] | 0) != ($414 | 0)) {
         label = 230;
         break;
        }
        HEAP32[$456 >> 2] = $453;
        $$pre$phi$i38Z2D = $414 + 8 | 0;
       } while (0);
       do if ((label | 0) == 230) {
        label = 0;
        $459 = $414 + 8 | 0;
        $460 = HEAP32[$459 >> 2] | 0;
        HEAP32[$453 + 8 >> 2] = $460;
        if (!$460) {
         $$pre$phi$i38Z2D = $459;
         break;
        }
        HEAP32[$460 + 4 >> 2] = $453;
        $$pre$phi$i38Z2D = $459;
       } while (0);
       HEAP32[$$pre$phi$i38Z2D >> 2] = $453;
       HEAP32[$453 + 4 >> 2] = $414;
       $$0$be = $453;
       break L51;
      } while (0);
      L280 : do if ((HEAP32[$42 >> 2] | 0) == 6) {
       $$0$pn = $$0125;
       while (1) {
        $$0$pn = HEAP32[$$0$pn >> 2] | 0;
        if (!$$0$pn) break L280;
        if (($292 | 0) == (HEAP32[$$0$pn + 28 >> 2] | 0)) {
         $$0125$lcssa372 = $$0125;
         $$lcssa363 = $37;
         $$lcssa407 = $320;
         label = 236;
         break L23;
        }
       }
      } while (0);
      $483 = (HEAP32[$292 + 16 >> 2] & 16 | $320 & 131072 | 0) == 0;
      $485 = (_prvTidynodeIsElement($37) | 0) == 0;
      if ($483) {
       if ($485) {
        _prvTidyReportError($doc, $$0125, $37, 208);
        _prvTidyFreeNode($doc, $37);
        $$0$be = $$0125;
        break L51;
       }
       $486 = HEAP32[$39 >> 2] | 0;
       do if (!$486) label = 249; else {
        if ((HEAP32[$486 >> 2] | 0) != 129) {
         label = 249;
         break;
        }
        _prvTidyConstrainVersion($doc, -393217);
       } while (0);
       do if ((label | 0) == 249) {
        label = 0;
        if (HEAP32[$486 + 16 >> 2] & 32768 | 0) break;
        _prvTidyReportError($doc, $$0125, $37, 207);
       } while (0);
       $494 = HEAP32[$36 >> 2] | 0;
       $496 = HEAP32[$494 + 16 >> 2] | 0;
       if (($496 & 12 | 0) != 4) {
        $$0125$lcssa373 = $$0125;
        $$lcssa403 = $39;
        $$lcssa409 = $494;
        $$lcssa410 = $496;
        label = 253;
        break L23;
       }
       _MoveToHead($doc, $$0125, $37);
       $$0$be = $$0125;
       break L51;
      }
      if ($485) {
       _prvTidyReportError($doc, $$0125, $37, 208);
       _prvTidyFreeNode($doc, $37);
       $$0$be = $$0125;
       break L51;
      }
      if (HEAP32[$37 + 60 >> 2] | 0) _prvTidyReportError($doc, $$0125, $37, 215);
      $533 = HEAP32[$36 >> 2] | 0;
      do if ($533 | 0) {
       if ((HEAP32[$533 >> 2] | 0) != 17) break;
       _TrimSpaces($doc, $$0125);
      } while (0);
      HEAP32[$37 >> 2] = $$0125;
      $537 = $$0125 + 16 | 0;
      $538 = HEAP32[$537 >> 2] | 0;
      HEAP32[$37 + 4 >> 2] = $538;
      if (!$538) HEAP32[$$0125 + 12 >> 2] = $37; else HEAP32[$538 + 8 >> 2] = $37;
      HEAP32[$537 >> 2] = $37;
      $544 = HEAP32[$0 >> 2] | 0;
      $545 = HEAP32[$36 >> 2] | 0;
      if (!$545) {
       $$0$be = $$0125;
       break L51;
      }
      $548 = HEAP32[$545 + 16 >> 2] | 0;
      do if (!($548 & 1)) {
       if ($548 & 16 | 0) break;
       HEAP32[$544 + 16 >> 2] = 0;
      } else {
       HEAP32[$544 + 8 >> 2] = 0;
       if (!(HEAP32[$545 + 20 >> 2] | 0)) {
        $$0$be = $$0125;
        break L51;
       }
      } while (0);
      $559 = HEAP32[$545 + 20 >> 2] | 0;
      if (!$559) {
       $$0$be = $$0125;
       break L51;
      }
      if ((HEAP32[$42 >> 2] | 0) == 7) {
       $$0$be = $$0125;
       break L51;
      }
      HEAP32[$544 + 72 >> 2] = $37;
      FUNCTION_TABLE_viii[$559 & 63]($doc, $37, $mode$);
      $$0$be = $$0125;
      break L51;
     } while (0);
     _prvTidyReportError($doc, $$0125, $37, 208);
     _prvTidyFreeNode($doc, $37);
     $$0$be = $$0125;
    } else $$0$be = $$0125;
   } while (0);
   $37 = _prvTidyGetToken($doc, $mode$) | 0;
   if (!$37) {
    $$0$lcssa = $$0$be;
    break L21;
   } else $$0125 = $$0$be;
  }
  if ((label | 0) == 17) {
   if (HEAP32[$$lcssa386 + 16 >> 2] & 16 | 0) _prvTidyPopInline($doc, $$lcssa);
   _prvTidyFreeNode($doc, $$lcssa);
   if ($33) _TrimSpaces($doc, $$0125$lcssa);
   $49 = HEAP32[$$lcssa396 >> 2] | 0;
   if ($49 | 0) if ((HEAP32[$49 >> 2] | 0) == 36) {
    $53 = $$0125$lcssa + 12 | 0;
    $54 = HEAP32[$53 >> 2] | 0;
    if ($54 | 0) {
     $56 = $$0125$lcssa + 16 | 0;
     if (($54 | 0) == (HEAP32[$56 >> 2] | 0)) {
      $60 = HEAP32[$54 + 28 >> 2] | 0;
      if ($60 | 0) if ((HEAP32[$60 >> 2] | 0) == 1) {
       HEAP32[$54 >> 2] = HEAP32[$$0125$lcssa >> 2];
       $65 = $$0125$lcssa + 8 | 0;
       HEAP32[$54 + 8 >> 2] = HEAP32[$65 >> 2];
       $68 = $$0125$lcssa + 4 | 0;
       HEAP32[$54 + 4 >> 2] = HEAP32[$68 >> 2];
       HEAP32[$65 >> 2] = 0;
       HEAP32[$68 >> 2] = 0;
       HEAP32[$$0125$lcssa >> 2] = $54;
       $71 = $54 + 12 | 0;
       HEAP32[$53 >> 2] = HEAP32[$71 >> 2];
       HEAP32[$56 >> 2] = HEAP32[$54 + 16 >> 2];
       HEAP32[$71 >> 2] = $$0125$lcssa;
       _prvTidyFixNodeLinks($54);
       _prvTidyFixNodeLinks($$0125$lcssa);
      }
     }
    }
   }
   HEAP32[$$0125$lcssa + 56 >> 2] = 1;
   _TrimSpaces($doc, $$0125$lcssa);
   return;
  } else if ((label | 0) == 66) {
   _prvTidyUngetToken($doc);
   if (!$33) return;
   _TrimSpaces($doc, $$0125$lcssa374);
   return;
  } else if ((label | 0) == 120) {
   _prvTidyReportError($doc, $$0125$lcssa367, $$lcssa358, 210);
   _prvTidyUngetToken($doc);
   _prvTidyInlineDup1($doc, 0, $$0125$lcssa367) | 0;
   if (!$33) return;
   _TrimSpaces($doc, $$0125$lcssa367);
   return;
  } else if ((label | 0) == 124) {
   $272 = HEAP32[$$lcssa378 >> 2] | 0;
   if (!$272) label = 127; else if ((HEAP32[$272 >> 2] | 0) != 1 | ($272 | 0) == ($$lcssa406 | 0)) label = 127; else {
    _prvTidyReportError($doc, $$0125$lcssa368, $$lcssa359, 207);
    _prvTidyUngetToken($doc);
   }
   if ((label | 0) == 127) {
    _prvTidyReportError($doc, $$0125$lcssa368, $$lcssa359, 210);
    _prvTidyFreeNode($doc, $$lcssa359);
   }
   if (!$33) return;
   _TrimSpaces($doc, $$0125$lcssa368);
   return;
  } else if ((label | 0) == 135) {
   _prvTidyUngetToken($doc);
   _TrimSpaces($doc, $$0125$lcssa369);
   return;
  } else if ((label | 0) == 138) {
   if ((HEAP32[$$lcssa380 >> 2] | 0) == (HEAP32[$$lcssa400 >> 2] | 0)) {
    _prvTidyReportError($doc, $$0125$lcssa370, $$lcssa361, 210);
    _prvTidyFreeNode($doc, $$lcssa361);
   } else {
    _prvTidyReportError($doc, $$0125$lcssa370, $$lcssa361, 207);
    _prvTidyUngetToken($doc);
   }
   if (!$33) return;
   _TrimSpaces($doc, $$0125$lcssa370);
   return;
  } else if ((label | 0) == 157) {
   _prvTidyUngetToken($doc);
   _prvTidyReportError($doc, $$0125$lcssa371, $$lcssa362, 207);
   if (!$33) return;
   _TrimSpaces($doc, $$0125$lcssa371);
   return;
  } else if ((label | 0) == 236) {
   if (!($$lcssa407 & 32768)) if (!(HEAP32[$$0125$lcssa372 + 60 >> 2] | 0)) _prvTidyReportError($doc, $$0125$lcssa372, $$lcssa363, 207);
   if (_prvTidyIsPushedLast($doc, $$0125$lcssa372, $$lcssa363) | 0) _prvTidyPopInline($doc, $$0125$lcssa372);
   _prvTidyUngetToken($doc);
   if (!$33) return;
   _TrimSpaces($doc, $$0125$lcssa372);
   return;
  } else if ((label | 0) == 253) {
   $499 = HEAP32[$$lcssa403 >> 2] | 0;
   do if ($499 | 0) if ((HEAP32[$499 >> 2] | 0) == 1) {
    if (($$lcssa409 | 0) != 0 & ($$lcssa410 & 16384 | 0) == 0) {
     _prvTidyPopInline($doc, $$0125$lcssa373);
     break;
    }
    if (!(HEAP32[$$0125$lcssa373 + 12 >> 2] | 0)) {
     $509 = $$0125$lcssa373 + 8 | 0;
     $510 = HEAP32[$509 >> 2] | 0;
     $511 = $$0125$lcssa373 + 4 | 0;
     $512 = HEAP32[$511 >> 2] | 0;
     if (!$512) $517 = $510; else {
      HEAP32[$512 + 8 >> 2] = $510;
      $517 = HEAP32[$509 >> 2] | 0;
     }
     $519 = $517;
     if ($517 | 0) HEAP32[$517 + 4 >> 2] = $512;
     $521 = HEAP32[$$0125$lcssa373 >> 2] | 0;
     if ($521 | 0) {
      $523 = $521 + 12 | 0;
      if ((HEAP32[$523 >> 2] | 0) == ($$0125$lcssa373 | 0)) HEAP32[$523 >> 2] = $519;
      $526 = $521 + 16 | 0;
      if ((HEAP32[$526 >> 2] | 0) == ($$0125$lcssa373 | 0)) HEAP32[$526 >> 2] = HEAP32[$511 >> 2];
     }
     HEAP32[$509 >> 2] = 0;
     HEAP32[$511 >> 2] = 0;
     HEAP32[$$0125$lcssa373 >> 2] = 0;
     _prvTidyFreeNode($doc, $$0125$lcssa373);
     _prvTidyUngetToken($doc);
     return;
    }
   } while (0);
   _prvTidyUngetToken($doc);
   if (!$33) return;
   _TrimSpaces($doc, $$0125$lcssa373);
   return;
  }
 } while (0);
 if (HEAP32[(HEAP32[$$0$lcssa + 28 >> 2] | 0) + 16 >> 2] & 32768 | 0) return;
 _prvTidyReportError($doc, $$0$lcssa, 0, 206);
 return;
}

function _vfscanf($f, $fmt, $ap) {
 $f = $f | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 var $$ = 0, $$lcssa = 0, $$lcssa386 = 0, $$lcssa40 = 0, $$pre$phi184Z2D = 0, $$size$0 = 0, $0 = 0, $10 = 0, $104 = 0, $105 = 0, $107 = 0, $109 = 0, $11 = 0, $112 = 0, $115 = 0, $117 = 0, $12 = 0, $125 = 0, $129 = 0, $13 = 0, $136 = 0, $14 = 0, $142 = 0, $148 = 0, $15 = 0, $150 = 0, $151 = 0, $156 = 0, $160 = 0, $164 = 0, $166 = 0, $17 = 0, $172 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $180 = 0, $185 = 0, $189 = 0, $194 = 0, $195 = 0, $196 = 0, $198 = 0, $20 = 0, $200 = 0, $201 = 0, $209 = 0, $219 = 0, $221 = 0, $225 = 0, $227 = 0, $235 = 0, $243 = 0, $244 = 0, $247 = 0, $249 = 0, $25 = 0, $255 = 0, $262 = 0, $264 = 0, $270 = 0, $277 = 0, $282 = 0, $283 = 0, $290 = 0, $303 = 0, $307 = 0.0, $32 = 0, $326 = 0, $38 = 0, $44 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $51 = 0, $52 = 0, $61 = 0, $7 = 0, $8 = 0, $81 = 0, $82 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $alloc$0 = 0, $alloc$0402 = 0, $alloc$1 = 0, $alloc$2 = 0, $ap2$i = 0, $base$0 = 0, $c$0102 = 0, $dest$0 = 0, $i$0$i = 0, $i$0$ph = 0, $i$0$ph$phi = 0, $i$0$ph22 = 0, $i$0$ph22$lcssa = 0, $i$1 = 0, $i$2 = 0, $i$2$ph = 0, $i$2$ph$phi = 0, $i$3 = 0, $i$4 = 0, $invert$0 = 0, $isdigittmp = 0, $k$0$ph = 0, $k$1$ph = 0, $matches$0107 = 0, $matches$0107$lcssa = 0, $matches$0107371 = 0, $matches$1 = 0, $matches$2 = 0, $matches$3 = 0, $p$0110 = 0, $p$1 = 0, $p$1$lcssa = 0, $p$10 = 0, $p$11 = 0, $p$2 = 0, $p$3$lcssa = 0, $p$398 = 0, $p$4 = 0, $p$5 = 0, $p$6 = 0, $p$7 = 0, $p$7$ph = 0, $p$8 = 0, $p$9 = 0, $pos$0111 = 0, $pos$1 = 0, $pos$2 = 0, $s$0105 = 0, $s$0105$lcssa = 0, $s$1 = 0, $s$2$ph = 0, $s$4 = 0, $s$5 = 0, $s$6 = 0, $s$7 = 0, $s$8 = 0, $s$9 = 0, $scanset = 0, $size$0 = 0, $st = 0, $wc = 0, $wcs$0106 = 0, $wcs$0106$lcssa = 0, $wcs$1 = 0, $wcs$10 = 0, $wcs$2 = 0, $wcs$3$ph = 0, $wcs$3$ph$lcssa = 0, $wcs$5 = 0, $wcs$6 = 0, $wcs$7 = 0, $wcs$8 = 0, $wcs$9 = 0, $width$0$lcssa = 0, $width$099 = 0, $width$1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 304 | 0;
 $ap2$i = sp + 16 | 0;
 $st = sp + 8 | 0;
 $scanset = sp + 33 | 0;
 $wc = sp;
 $0 = sp + 32 | 0;
 if ((HEAP32[$f + 76 >> 2] | 0) > -1) $326 = ___lockfile($f) | 0; else $326 = 0;
 $5 = HEAP8[$fmt >> 0] | 0;
 L4 : do if (!($5 << 24 >> 24)) $matches$3 = 0; else {
  $7 = $f + 4 | 0;
  $8 = $f + 100 | 0;
  $9 = $f + 108 | 0;
  $10 = $f + 8 | 0;
  $11 = $scanset + 10 | 0;
  $12 = $scanset + 33 | 0;
  $13 = $st + 4 | 0;
  $14 = $scanset + 46 | 0;
  $15 = $scanset + 94 | 0;
  $17 = $5;
  $matches$0107 = 0;
  $p$0110 = $fmt;
  $pos$0111 = 0;
  $s$0105 = 0;
  $wcs$0106 = 0;
  L6 : while (1) {
   L8 : do if (!(_isspace($17 & 255) | 0)) {
    $47 = (HEAP8[$p$0110 >> 0] | 0) == 37;
    L10 : do if ($47) {
     $48 = $p$0110 + 1 | 0;
     $49 = HEAP8[$48 >> 0] | 0;
     L12 : do switch ($49 << 24 >> 24) {
     case 37:
      {
       break L10;
       break;
      }
     case 42:
      {
       $dest$0 = 0;
       $p$2 = $p$0110 + 2 | 0;
       break;
      }
     default:
      {
       $isdigittmp = ($49 & 255) + -48 | 0;
       if ($isdigittmp >>> 0 < 10) if ((HEAP8[$p$0110 + 2 >> 0] | 0) == 36) {
        HEAP32[$ap2$i >> 2] = HEAP32[$ap >> 2];
        $i$0$i = $isdigittmp;
        while (1) {
         $81 = (HEAP32[$ap2$i >> 2] | 0) + (4 - 1) & ~(4 - 1);
         $82 = HEAP32[$81 >> 2] | 0;
         HEAP32[$ap2$i >> 2] = $81 + 4;
         if ($i$0$i >>> 0 > 1) $i$0$i = $i$0$i + -1 | 0; else {
          $$lcssa = $82;
          break;
         }
        }
        $dest$0 = $$lcssa;
        $p$2 = $p$0110 + 3 | 0;
        break L12;
       }
       $90 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
       $91 = HEAP32[$90 >> 2] | 0;
       HEAP32[$ap >> 2] = $90 + 4;
       $dest$0 = $91;
       $p$2 = $48;
      }
     } while (0);
     $92 = HEAP8[$p$2 >> 0] | 0;
     $93 = $92 & 255;
     if (($93 + -48 | 0) >>> 0 < 10) {
      $97 = $93;
      $p$398 = $p$2;
      $width$099 = 0;
      while (1) {
       $96 = ($width$099 * 10 | 0) + -48 + $97 | 0;
       $98 = $p$398 + 1 | 0;
       $99 = HEAP8[$98 >> 0] | 0;
       $97 = $99 & 255;
       if (($97 + -48 | 0) >>> 0 >= 10) {
        $$lcssa40 = $99;
        $p$3$lcssa = $98;
        $width$0$lcssa = $96;
        break;
       } else {
        $p$398 = $98;
        $width$099 = $96;
       }
      }
     } else {
      $$lcssa40 = $92;
      $p$3$lcssa = $p$2;
      $width$0$lcssa = 0;
     }
     if ($$lcssa40 << 24 >> 24 == 109) {
      $104 = $p$3$lcssa + 1 | 0;
      $107 = HEAP8[$104 >> 0] | 0;
      $alloc$0 = ($dest$0 | 0) != 0 & 1;
      $p$4 = $104;
      $s$1 = 0;
      $wcs$1 = 0;
     } else {
      $107 = $$lcssa40;
      $alloc$0 = 0;
      $p$4 = $p$3$lcssa;
      $s$1 = $s$0105;
      $wcs$1 = $wcs$0106;
     }
     $105 = $p$4 + 1 | 0;
     switch ($107 & 255 | 0) {
     case 104:
      {
       $109 = (HEAP8[$105 >> 0] | 0) == 104;
       $p$5 = $109 ? $p$4 + 2 | 0 : $105;
       $size$0 = $109 ? -2 : -1;
       break;
      }
     case 108:
      {
       $112 = (HEAP8[$105 >> 0] | 0) == 108;
       $p$5 = $112 ? $p$4 + 2 | 0 : $105;
       $size$0 = $112 ? 3 : 1;
       break;
      }
     case 106:
      {
       $p$5 = $105;
       $size$0 = 3;
       break;
      }
     case 116:
     case 122:
      {
       $p$5 = $105;
       $size$0 = 1;
       break;
      }
     case 76:
      {
       $p$5 = $105;
       $size$0 = 2;
       break;
      }
     case 110:
     case 112:
     case 67:
     case 83:
     case 91:
     case 99:
     case 115:
     case 88:
     case 71:
     case 70:
     case 69:
     case 65:
     case 103:
     case 102:
     case 101:
     case 97:
     case 120:
     case 117:
     case 111:
     case 105:
     case 100:
      {
       $p$5 = $p$4;
       $size$0 = 0;
       break;
      }
     default:
      {
       $alloc$0402 = $alloc$0;
       $matches$0107371 = $matches$0107;
       $s$7 = $s$1;
       $wcs$8 = $wcs$1;
       label = 154;
       break L6;
      }
     }
     $115 = HEAPU8[$p$5 >> 0] | 0;
     $117 = ($115 & 47 | 0) == 3;
     $$ = $117 ? $115 | 32 : $115;
     $$size$0 = $117 ? 1 : $size$0;
     switch ($$ | 0) {
     case 99:
      {
       $pos$1 = $pos$0111;
       $width$1 = ($width$0$lcssa | 0) < 1 ? 1 : $width$0$lcssa;
       break;
      }
     case 91:
      {
       $pos$1 = $pos$0111;
       $width$1 = $width$0$lcssa;
       break;
      }
     case 110:
      {
       if (!$dest$0) {
        $matches$1 = $matches$0107;
        $p$11 = $p$5;
        $pos$2 = $pos$0111;
        $s$6 = $s$1;
        $wcs$7 = $wcs$1;
        break L8;
       }
       switch ($$size$0 | 0) {
       case -2:
        {
         HEAP8[$dest$0 >> 0] = $pos$0111;
         $matches$1 = $matches$0107;
         $p$11 = $p$5;
         $pos$2 = $pos$0111;
         $s$6 = $s$1;
         $wcs$7 = $wcs$1;
         break L8;
         break;
        }
       case -1:
        {
         HEAP16[$dest$0 >> 1] = $pos$0111;
         $matches$1 = $matches$0107;
         $p$11 = $p$5;
         $pos$2 = $pos$0111;
         $s$6 = $s$1;
         $wcs$7 = $wcs$1;
         break L8;
         break;
        }
       case 0:
        {
         HEAP32[$dest$0 >> 2] = $pos$0111;
         $matches$1 = $matches$0107;
         $p$11 = $p$5;
         $pos$2 = $pos$0111;
         $s$6 = $s$1;
         $wcs$7 = $wcs$1;
         break L8;
         break;
        }
       case 1:
        {
         HEAP32[$dest$0 >> 2] = $pos$0111;
         $matches$1 = $matches$0107;
         $p$11 = $p$5;
         $pos$2 = $pos$0111;
         $s$6 = $s$1;
         $wcs$7 = $wcs$1;
         break L8;
         break;
        }
       case 3:
        {
         $125 = $dest$0;
         HEAP32[$125 >> 2] = $pos$0111;
         HEAP32[$125 + 4 >> 2] = (($pos$0111 | 0) < 0) << 31 >> 31;
         $matches$1 = $matches$0107;
         $p$11 = $p$5;
         $pos$2 = $pos$0111;
         $s$6 = $s$1;
         $wcs$7 = $wcs$1;
         break L8;
         break;
        }
       default:
        {
         $matches$1 = $matches$0107;
         $p$11 = $p$5;
         $pos$2 = $pos$0111;
         $s$6 = $s$1;
         $wcs$7 = $wcs$1;
         break L8;
        }
       }
       break;
      }
     default:
      {
       ___shlim($f, 0);
       do {
        $129 = HEAP32[$7 >> 2] | 0;
        if ($129 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {
         HEAP32[$7 >> 2] = $129 + 1;
         $136 = HEAPU8[$129 >> 0] | 0;
        } else $136 = ___shgetc($f) | 0;
       } while ((_isspace($136) | 0) != 0);
       if (!(HEAP32[$8 >> 2] | 0)) $148 = HEAP32[$7 >> 2] | 0; else {
        $142 = (HEAP32[$7 >> 2] | 0) + -1 | 0;
        HEAP32[$7 >> 2] = $142;
        $148 = $142;
       }
       $pos$1 = (HEAP32[$9 >> 2] | 0) + $pos$0111 + $148 - (HEAP32[$10 >> 2] | 0) | 0;
       $width$1 = $width$0$lcssa;
      }
     }
     ___shlim($f, $width$1);
     $150 = HEAP32[$7 >> 2] | 0;
     $151 = HEAP32[$8 >> 2] | 0;
     if ($150 >>> 0 < $151 >>> 0) {
      HEAP32[$7 >> 2] = $150 + 1;
      $156 = $151;
     } else {
      if ((___shgetc($f) | 0) < 0) {
       $alloc$0402 = $alloc$0;
       $matches$0107371 = $matches$0107;
       $s$7 = $s$1;
       $wcs$8 = $wcs$1;
       label = 154;
       break L6;
      }
      $156 = HEAP32[$8 >> 2] | 0;
     }
     if ($156 | 0) HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + -1;
     L68 : do switch ($$ | 0) {
     case 91:
     case 99:
     case 115:
      {
       $160 = ($$ | 0) == 99;
       L70 : do if (($$ | 16 | 0) == 115) {
        _memset($scanset | 0, -1, 257) | 0;
        HEAP8[$scanset >> 0] = 0;
        if (($$ | 0) == 115) {
         HEAP8[$12 >> 0] = 0;
         HEAP8[$11 >> 0] = 0;
         HEAP8[$11 + 1 >> 0] = 0;
         HEAP8[$11 + 2 >> 0] = 0;
         HEAP8[$11 + 3 >> 0] = 0;
         HEAP8[$11 + 4 >> 0] = 0;
         $p$9 = $p$5;
        } else $p$9 = $p$5;
       } else {
        $164 = $p$5 + 1 | 0;
        $166 = (HEAP8[$164 >> 0] | 0) == 94;
        $invert$0 = $166 & 1;
        $p$6 = $166 ? $p$5 + 2 | 0 : $164;
        _memset($scanset | 0, $166 & 1 | 0, 257) | 0;
        HEAP8[$scanset >> 0] = 0;
        switch (HEAP8[$p$6 >> 0] | 0) {
        case 45:
         {
          $172 = ($invert$0 ^ 1) & 255;
          HEAP8[$14 >> 0] = $172;
          $$pre$phi184Z2D = $172;
          $p$7$ph = $p$6 + 1 | 0;
          break;
         }
        case 93:
         {
          $175 = ($invert$0 ^ 1) & 255;
          HEAP8[$15 >> 0] = $175;
          $$pre$phi184Z2D = $175;
          $p$7$ph = $p$6 + 1 | 0;
          break;
         }
        default:
         {
          $$pre$phi184Z2D = ($invert$0 ^ 1) & 255;
          $p$7$ph = $p$6;
         }
        }
        $p$7 = $p$7$ph;
        while (1) {
         $176 = HEAP8[$p$7 >> 0] | 0;
         L81 : do switch ($176 << 24 >> 24) {
         case 0:
          {
           $alloc$0402 = $alloc$0;
           $matches$0107371 = $matches$0107;
           $s$7 = $s$1;
           $wcs$8 = $wcs$1;
           label = 154;
           break L6;
           break;
          }
         case 93:
          {
           $p$9 = $p$7;
           break L70;
           break;
          }
         case 45:
          {
           $177 = $p$7 + 1 | 0;
           $178 = HEAP8[$177 >> 0] | 0;
           switch ($178 << 24 >> 24) {
           case 93:
           case 0:
            {
             $189 = 45;
             $p$8 = $p$7;
             break L81;
             break;
            }
           default:
            {}
           }
           $180 = HEAP8[$p$7 + -1 >> 0] | 0;
           if (($180 & 255) < ($178 & 255)) {
            $c$0102 = $180 & 255;
            do {
             $c$0102 = $c$0102 + 1 | 0;
             HEAP8[$scanset + $c$0102 >> 0] = $$pre$phi184Z2D;
             $185 = HEAP8[$177 >> 0] | 0;
            } while (($c$0102 | 0) < ($185 & 255 | 0));
            $189 = $185;
            $p$8 = $177;
           } else {
            $189 = $178;
            $p$8 = $177;
           }
           break;
          }
         default:
          {
           $189 = $176;
           $p$8 = $p$7;
          }
         } while (0);
         HEAP8[$scanset + (($189 & 255) + 1) >> 0] = $$pre$phi184Z2D;
         $p$7 = $p$8 + 1 | 0;
        }
       } while (0);
       $194 = $160 ? $width$1 + 1 | 0 : 31;
       $195 = ($$size$0 | 0) == 1;
       $196 = ($alloc$0 | 0) != 0;
       L89 : do if ($195) {
        if ($196) {
         $198 = _malloc($194 << 2) | 0;
         if (!$198) {
          $alloc$0402 = $alloc$0;
          $matches$0107371 = $matches$0107;
          $s$7 = 0;
          $wcs$8 = $198;
          label = 154;
          break L6;
         } else $wcs$2 = $198;
        } else $wcs$2 = $dest$0;
        HEAP32[$st >> 2] = 0;
        HEAP32[$13 >> 2] = 0;
        $i$0$ph = 0;
        $k$0$ph = $194;
        $wcs$3$ph = $wcs$2;
        L95 : while (1) {
         $200 = ($wcs$3$ph | 0) == 0;
         $i$0$ph22 = $i$0$ph;
         while (1) {
          L99 : while (1) {
           $201 = HEAP32[$7 >> 2] | 0;
           if ($201 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {
            HEAP32[$7 >> 2] = $201 + 1;
            $209 = HEAPU8[$201 >> 0] | 0;
           } else $209 = ___shgetc($f) | 0;
           if (!(HEAP8[$scanset + ($209 + 1) >> 0] | 0)) {
            $i$0$ph22$lcssa = $i$0$ph22;
            $wcs$3$ph$lcssa = $wcs$3$ph;
            break L95;
           }
           HEAP8[$0 >> 0] = $209;
           switch (_mbrtowc($wc, $0, 1, $st) | 0) {
           case -1:
            {
             $alloc$0402 = $alloc$0;
             $matches$0107371 = $matches$0107;
             $s$7 = 0;
             $wcs$8 = $wcs$3$ph;
             label = 154;
             break L6;
             break;
            }
           case -2:
            break;
           default:
            break L99;
           }
          }
          if ($200) $i$1 = $i$0$ph22; else {
           HEAP32[$wcs$3$ph + ($i$0$ph22 << 2) >> 2] = HEAP32[$wc >> 2];
           $i$1 = $i$0$ph22 + 1 | 0;
          }
          if ($196 & ($i$1 | 0) == ($k$0$ph | 0)) break; else $i$0$ph22 = $i$1;
         }
         $219 = $k$0$ph << 1 | 1;
         $221 = _realloc($wcs$3$ph, $219 << 2) | 0;
         if (!$221) {
          $alloc$0402 = $alloc$0;
          $matches$0107371 = $matches$0107;
          $s$7 = 0;
          $wcs$8 = $wcs$3$ph;
          label = 154;
          break L6;
         } else {
          $i$0$ph$phi = $k$0$ph;
          $k$0$ph = $219;
          $wcs$3$ph = $221;
          $i$0$ph = $i$0$ph$phi;
         }
        }
        if (!(_mbsinit($st) | 0)) {
         $alloc$0402 = $alloc$0;
         $matches$0107371 = $matches$0107;
         $s$7 = 0;
         $wcs$8 = $wcs$3$ph$lcssa;
         label = 154;
         break L6;
        } else {
         $i$4 = $i$0$ph22$lcssa;
         $s$4 = 0;
         $wcs$5 = $wcs$3$ph$lcssa;
        }
       } else {
        if ($196) {
         $225 = _malloc($194) | 0;
         if (!$225) {
          $alloc$0402 = $alloc$0;
          $matches$0107371 = $matches$0107;
          $s$7 = 0;
          $wcs$8 = 0;
          label = 154;
          break L6;
         } else {
          $i$2$ph = 0;
          $k$1$ph = $194;
          $s$2$ph = $225;
         }
         while (1) {
          $i$2 = $i$2$ph;
          do {
           $227 = HEAP32[$7 >> 2] | 0;
           if ($227 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {
            HEAP32[$7 >> 2] = $227 + 1;
            $235 = HEAPU8[$227 >> 0] | 0;
           } else $235 = ___shgetc($f) | 0;
           if (!(HEAP8[$scanset + ($235 + 1) >> 0] | 0)) {
            $i$4 = $i$2;
            $s$4 = $s$2$ph;
            $wcs$5 = 0;
            break L89;
           }
           HEAP8[$s$2$ph + $i$2 >> 0] = $235;
           $i$2 = $i$2 + 1 | 0;
          } while (($i$2 | 0) != ($k$1$ph | 0));
          $243 = $k$1$ph << 1 | 1;
          $244 = _realloc($s$2$ph, $243) | 0;
          if (!$244) {
           $alloc$0402 = $alloc$0;
           $matches$0107371 = $matches$0107;
           $s$7 = $s$2$ph;
           $wcs$8 = 0;
           label = 154;
           break L6;
          } else {
           $i$2$ph$phi = $k$1$ph;
           $k$1$ph = $243;
           $s$2$ph = $244;
           $i$2$ph = $i$2$ph$phi;
          }
         }
        }
        if (!$dest$0) {
         $264 = $156;
         while (1) {
          $262 = HEAP32[$7 >> 2] | 0;
          if ($262 >>> 0 < $264 >>> 0) {
           HEAP32[$7 >> 2] = $262 + 1;
           $270 = HEAPU8[$262 >> 0] | 0;
          } else $270 = ___shgetc($f) | 0;
          if (!(HEAP8[$scanset + ($270 + 1) >> 0] | 0)) {
           $i$4 = 0;
           $s$4 = 0;
           $wcs$5 = 0;
           break L89;
          }
          $264 = HEAP32[$8 >> 2] | 0;
         }
        } else {
         $249 = $156;
         $i$3 = 0;
         while (1) {
          $247 = HEAP32[$7 >> 2] | 0;
          if ($247 >>> 0 < $249 >>> 0) {
           HEAP32[$7 >> 2] = $247 + 1;
           $255 = HEAPU8[$247 >> 0] | 0;
          } else $255 = ___shgetc($f) | 0;
          if (!(HEAP8[$scanset + ($255 + 1) >> 0] | 0)) {
           $i$4 = $i$3;
           $s$4 = $dest$0;
           $wcs$5 = 0;
           break L89;
          }
          HEAP8[$dest$0 + $i$3 >> 0] = $255;
          $249 = HEAP32[$8 >> 2] | 0;
          $i$3 = $i$3 + 1 | 0;
         }
        }
       } while (0);
       if (!(HEAP32[$8 >> 2] | 0)) $282 = HEAP32[$7 >> 2] | 0; else {
        $277 = (HEAP32[$7 >> 2] | 0) + -1 | 0;
        HEAP32[$7 >> 2] = $277;
        $282 = $277;
       }
       $283 = $282 - (HEAP32[$10 >> 2] | 0) + (HEAP32[$9 >> 2] | 0) | 0;
       if (!$283) {
        $alloc$2 = $alloc$0;
        $matches$2 = $matches$0107;
        $s$9 = $s$4;
        $wcs$10 = $wcs$5;
        break L6;
       }
       if (!(($283 | 0) == ($width$1 | 0) | $160 ^ 1)) {
        $alloc$2 = $alloc$0;
        $matches$2 = $matches$0107;
        $s$9 = $s$4;
        $wcs$10 = $wcs$5;
        break L6;
       }
       do if ($196) if ($195) {
        HEAP32[$dest$0 >> 2] = $wcs$5;
        break;
       } else {
        HEAP32[$dest$0 >> 2] = $s$4;
        break;
       } while (0);
       if ($160) {
        $p$10 = $p$9;
        $s$5 = $s$4;
        $wcs$6 = $wcs$5;
       } else {
        if ($wcs$5 | 0) HEAP32[$wcs$5 + ($i$4 << 2) >> 2] = 0;
        if (!$s$4) {
         $p$10 = $p$9;
         $s$5 = 0;
         $wcs$6 = $wcs$5;
         break L68;
        }
        HEAP8[$s$4 + $i$4 >> 0] = 0;
        $p$10 = $p$9;
        $s$5 = $s$4;
        $wcs$6 = $wcs$5;
       }
       break;
      }
     case 120:
     case 88:
     case 112:
      {
       $base$0 = 16;
       label = 136;
       break;
      }
     case 111:
      {
       $base$0 = 8;
       label = 136;
       break;
      }
     case 117:
     case 100:
      {
       $base$0 = 10;
       label = 136;
       break;
      }
     case 105:
      {
       $base$0 = 0;
       label = 136;
       break;
      }
     case 71:
     case 103:
     case 70:
     case 102:
     case 69:
     case 101:
     case 65:
     case 97:
      {
       $307 = +___floatscan($f, $$size$0, 0);
       if ((HEAP32[$9 >> 2] | 0) == ((HEAP32[$10 >> 2] | 0) - (HEAP32[$7 >> 2] | 0) | 0)) {
        $alloc$2 = $alloc$0;
        $matches$2 = $matches$0107;
        $s$9 = $s$1;
        $wcs$10 = $wcs$1;
        break L6;
       }
       if (!$dest$0) {
        $p$10 = $p$5;
        $s$5 = $s$1;
        $wcs$6 = $wcs$1;
       } else switch ($$size$0 | 0) {
       case 0:
        {
         HEAPF32[$dest$0 >> 2] = $307;
         $p$10 = $p$5;
         $s$5 = $s$1;
         $wcs$6 = $wcs$1;
         break L68;
         break;
        }
       case 1:
        {
         HEAPF64[$dest$0 >> 3] = $307;
         $p$10 = $p$5;
         $s$5 = $s$1;
         $wcs$6 = $wcs$1;
         break L68;
         break;
        }
       case 2:
        {
         HEAPF64[$dest$0 >> 3] = $307;
         $p$10 = $p$5;
         $s$5 = $s$1;
         $wcs$6 = $wcs$1;
         break L68;
         break;
        }
       default:
        {
         $p$10 = $p$5;
         $s$5 = $s$1;
         $wcs$6 = $wcs$1;
         break L68;
        }
       }
       break;
      }
     default:
      {
       $p$10 = $p$5;
       $s$5 = $s$1;
       $wcs$6 = $wcs$1;
      }
     } while (0);
     L169 : do if ((label | 0) == 136) {
      label = 0;
      $290 = ___intscan($f, $base$0, 0, -1, -1) | 0;
      if ((HEAP32[$9 >> 2] | 0) == ((HEAP32[$10 >> 2] | 0) - (HEAP32[$7 >> 2] | 0) | 0)) {
       $alloc$2 = $alloc$0;
       $matches$2 = $matches$0107;
       $s$9 = $s$1;
       $wcs$10 = $wcs$1;
       break L6;
      }
      if (($dest$0 | 0) != 0 & ($$ | 0) == 112) {
       HEAP32[$dest$0 >> 2] = $290;
       $p$10 = $p$5;
       $s$5 = $s$1;
       $wcs$6 = $wcs$1;
       break;
      }
      if (!$dest$0) {
       $p$10 = $p$5;
       $s$5 = $s$1;
       $wcs$6 = $wcs$1;
      } else switch ($$size$0 | 0) {
      case -2:
       {
        HEAP8[$dest$0 >> 0] = $290;
        $p$10 = $p$5;
        $s$5 = $s$1;
        $wcs$6 = $wcs$1;
        break L169;
        break;
       }
      case -1:
       {
        HEAP16[$dest$0 >> 1] = $290;
        $p$10 = $p$5;
        $s$5 = $s$1;
        $wcs$6 = $wcs$1;
        break L169;
        break;
       }
      case 0:
       {
        HEAP32[$dest$0 >> 2] = $290;
        $p$10 = $p$5;
        $s$5 = $s$1;
        $wcs$6 = $wcs$1;
        break L169;
        break;
       }
      case 1:
       {
        HEAP32[$dest$0 >> 2] = $290;
        $p$10 = $p$5;
        $s$5 = $s$1;
        $wcs$6 = $wcs$1;
        break L169;
        break;
       }
      case 3:
       {
        $303 = $dest$0;
        HEAP32[$303 >> 2] = $290;
        HEAP32[$303 + 4 >> 2] = tempRet0;
        $p$10 = $p$5;
        $s$5 = $s$1;
        $wcs$6 = $wcs$1;
        break L169;
        break;
       }
      default:
       {
        $p$10 = $p$5;
        $s$5 = $s$1;
        $wcs$6 = $wcs$1;
        break L169;
       }
      }
     } while (0);
     $matches$1 = (($dest$0 | 0) != 0 & 1) + $matches$0107 | 0;
     $p$11 = $p$10;
     $pos$2 = (HEAP32[$9 >> 2] | 0) + $pos$1 + (HEAP32[$7 >> 2] | 0) - (HEAP32[$10 >> 2] | 0) | 0;
     $s$6 = $s$5;
     $wcs$7 = $wcs$6;
     break L8;
    } while (0);
    $51 = $p$0110 + ($47 & 1) | 0;
    ___shlim($f, 0);
    $52 = HEAP32[$7 >> 2] | 0;
    if ($52 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {
     HEAP32[$7 >> 2] = $52 + 1;
     $61 = HEAPU8[$52 >> 0] | 0;
    } else $61 = ___shgetc($f) | 0;
    if (($61 | 0) != (HEAPU8[$51 >> 0] | 0)) {
     $$lcssa386 = $61;
     $matches$0107$lcssa = $matches$0107;
     $s$0105$lcssa = $s$0105;
     $wcs$0106$lcssa = $wcs$0106;
     label = 22;
     break L6;
    }
    $matches$1 = $matches$0107;
    $p$11 = $51;
    $pos$2 = $pos$0111 + 1 | 0;
    $s$6 = $s$0105;
    $wcs$7 = $wcs$0106;
   } else {
    $p$1 = $p$0110;
    while (1) {
     $20 = $p$1 + 1 | 0;
     if (!(_isspace(HEAPU8[$20 >> 0] | 0) | 0)) {
      $p$1$lcssa = $p$1;
      break;
     } else $p$1 = $20;
    }
    ___shlim($f, 0);
    do {
     $25 = HEAP32[$7 >> 2] | 0;
     if ($25 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {
      HEAP32[$7 >> 2] = $25 + 1;
      $32 = HEAPU8[$25 >> 0] | 0;
     } else $32 = ___shgetc($f) | 0;
    } while ((_isspace($32) | 0) != 0);
    if (!(HEAP32[$8 >> 2] | 0)) $44 = HEAP32[$7 >> 2] | 0; else {
     $38 = (HEAP32[$7 >> 2] | 0) + -1 | 0;
     HEAP32[$7 >> 2] = $38;
     $44 = $38;
    }
    $matches$1 = $matches$0107;
    $p$11 = $p$1$lcssa;
    $pos$2 = (HEAP32[$9 >> 2] | 0) + $pos$0111 + $44 - (HEAP32[$10 >> 2] | 0) | 0;
    $s$6 = $s$0105;
    $wcs$7 = $wcs$0106;
   } while (0);
   $p$0110 = $p$11 + 1 | 0;
   $17 = HEAP8[$p$0110 >> 0] | 0;
   if (!($17 << 24 >> 24)) {
    $matches$3 = $matches$1;
    break L4;
   } else {
    $matches$0107 = $matches$1;
    $pos$0111 = $pos$2;
    $s$0105 = $s$6;
    $wcs$0106 = $wcs$7;
   }
  }
  if ((label | 0) == 22) {
   if (HEAP32[$8 >> 2] | 0) HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + -1;
   if (($matches$0107$lcssa | 0) != 0 | ($$lcssa386 | 0) > -1) {
    $matches$3 = $matches$0107$lcssa;
    break;
   } else {
    $alloc$1 = 0;
    $s$8 = $s$0105$lcssa;
    $wcs$9 = $wcs$0106$lcssa;
    label = 155;
   }
  } else if ((label | 0) == 154) if (!$matches$0107371) {
   $alloc$1 = $alloc$0402;
   $s$8 = $s$7;
   $wcs$9 = $wcs$8;
   label = 155;
  } else {
   $alloc$2 = $alloc$0402;
   $matches$2 = $matches$0107371;
   $s$9 = $s$7;
   $wcs$10 = $wcs$8;
  }
  if ((label | 0) == 155) {
   $alloc$2 = $alloc$1;
   $matches$2 = -1;
   $s$9 = $s$8;
   $wcs$10 = $wcs$9;
  }
  if (!$alloc$2) $matches$3 = $matches$2; else {
   _free($s$9);
   _free($wcs$10);
   $matches$3 = $matches$2;
  }
 } while (0);
 if ($326 | 0) ___unlockfile($f);
 STACKTOP = sp;
 return $matches$3 | 0;
}

function _prvTidyPPrintXMLTree($doc, $mode, $indent, $node) {
 $doc = $doc | 0;
 $mode = $mode | 0;
 $indent = $indent | 0;
 $node = $node | 0;
 var $$090 = 0, $$091$ph$ph = 0, $$indent = 0, $$ph$ph = 0, $$pre$i$i12 = 0, $$pre$i$i21 = 0, $$pre$i$i30 = 0, $$pre$i$i39 = 0, $$pre$i$i48 = 0, $$pre$i$i57 = 0, $$pre$i$i66 = 0, $$pre$i$i75 = 0, $$pre$i$i8 = 0, $$pre$i$i84 = 0, $$pre$phi$i$iZ2D = 0, $1 = 0, $100 = 0, $105 = 0, $109 = 0, $112 = 0, $114 = 0, $121 = 0, $13 = 0, $134 = 0, $143 = 0, $146 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $159 = 0, $163 = 0, $166 = 0, $168 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $189 = 0, $193 = 0, $196 = 0, $198 = 0, $210 = 0, $213 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $23 = 0, $231 = 0, $235 = 0, $238 = 0, $240 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $26 = 0, $261 = 0, $265 = 0, $268 = 0, $270 = 0, $282 = 0, $283 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $299 = 0, $30 = 0, $303 = 0, $306 = 0, $308 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $332 = 0, $336 = 0, $339 = 0, $341 = 0, $353 = 0, $356 = 0, $358 = 0, $359 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $369 = 0, $37 = 0, $373 = 0, $376 = 0, $378 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $399 = 0, $4 = 0, $403 = 0, $406 = 0, $408 = 0, $41 = 0, $42 = 0, $43 = 0, $433 = 0, $436 = 0, $44 = 0, $440 = 0, $441 = 0, $447 = 0, $455 = 0, $458 = 0, $463 = 0, $474 = 0, $49 = 0, $490 = 0, $495 = 0, $53 = 0, $56 = 0, $58 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $78 = 0, $82 = 0, $85 = 0, $87 = 0, $99 = 0, $buflen$0$i$i$i = 0, $buflen$0$i$i$i$lcssa = 0, $buflen$0$i$i$i10 = 0, $buflen$0$i$i$i10$lcssa = 0, $buflen$0$i$i$i19 = 0, $buflen$0$i$i$i19$lcssa = 0, $buflen$0$i$i$i28 = 0, $buflen$0$i$i$i28$lcssa = 0, $buflen$0$i$i$i37 = 0, $buflen$0$i$i$i37$lcssa = 0, $buflen$0$i$i$i46 = 0, $buflen$0$i$i$i46$lcssa = 0, $buflen$0$i$i$i55 = 0, $buflen$0$i$i$i55$lcssa = 0, $buflen$0$i$i$i64 = 0, $buflen$0$i$i$i64$lcssa = 0, $buflen$0$i$i$i7 = 0, $buflen$0$i$i$i7$lcssa = 0, $buflen$0$i$i$i73 = 0, $buflen$0$i$i$i73$lcssa = 0, $buflen$0$i$i$i82 = 0, $buflen$0$i$i$i82$lcssa = 0, $cindent$092 = 0, $cindent$093$ph$ph = 0, $content$0101 = 0, $content$0102 = 0, $content1$096 = 0, $content1$097 = 0, $content1$194$pr = 0, $content1$195 = 0, $ix$01$i$i = 0, $ix$01$i$i14 = 0, $ix$01$i$i23 = 0, $ix$01$i$i32 = 0, $ix$01$i$i41 = 0, $ix$01$i$i50 = 0, $ix$01$i$i59 = 0, $ix$01$i$i68 = 0, $ix$01$i$i77 = 0, $ix$01$i$i86 = 0, $mixed$0 = 0, label = 0;
 $1 = HEAP32[$doc + 176 >> 2] | 0;
 if (!$node) return;
 $4 = HEAP32[$doc + 6804 >> 2] | 0;
 if ($4 | 0) FUNCTION_TABLE_viiii[$4 & 0]($doc, HEAP32[$node + 48 >> 2] | 0, HEAP32[$node + 52 >> 2] | 0, (HEAP32[$doc + 6744 >> 2] | 0) + 1 | 0);
 $13 = $node + 44 | 0;
 do switch (HEAP32[$13 >> 2] | 0) {
 case 4:
  {
   _PPrintText($doc, $mode, $indent, $node);
   return;
  }
 case 2:
  {
   $15 = $doc + 6736 | 0;
   if (HEAP32[$15 >> 2] | 0) {
    _PFlushLineImpl($doc);
    if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
     _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
     $23 = $doc + 6744 | 0;
     HEAP32[$23 >> 2] = (HEAP32[$23 >> 2] | 0) + 1;
    }
   }
   $26 = $doc + 6752 | 0;
   if ((HEAP32[$26 >> 2] | 0) != ($indent | 0)) HEAP32[$26 >> 2] = $indent;
   $29 = $doc + 6724 | 0;
   $30 = HEAP32[$15 >> 2] | 0;
   if (($30 + $indent | 0) >>> 0 < (HEAP32[$doc + 80 >> 2] | 0) >>> 0) {
    if (($indent | 0) < 0) HEAP32[$26 >> 2] = $indent;
    HEAP32[$doc + 6740 >> 2] = $30;
   } else {
    $37 = $doc + 6748 | 0;
    if (!(HEAP32[$37 >> 2] | 0)) {
     HEAP32[$doc + 6764 >> 2] = $indent;
     HEAP32[$37 >> 2] = 1;
    }
   }
   $41 = _prvTidytmbstrlen(310762) | 0;
   $42 = $41 + $30 | 0;
   $43 = $doc + 6732 | 0;
   $44 = HEAP32[$43 >> 2] | 0;
   if ($42 >>> 0 >= $44 >>> 0) {
    $buflen$0$i$i$i7 = ($44 | 0) == 0 ? 256 : $44;
    while (1) if ($buflen$0$i$i$i7 >>> 0 > $42 >>> 0) {
     $buflen$0$i$i$i7$lcssa = $buflen$0$i$i$i7;
     break;
    } else $buflen$0$i$i$i7 = $buflen$0$i$i$i7 << 1;
    $49 = HEAP32[$29 >> 2] | 0;
    $53 = $doc + 6728 | 0;
    $56 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$49 >> 2] | 0) + 4 >> 2] & 15]($49, HEAP32[$53 >> 2] | 0, $buflen$0$i$i$i7$lcssa << 2) | 0;
    if ($56 | 0) {
     $58 = HEAP32[$43 >> 2] | 0;
     _memset($56 + ($58 << 2) | 0, 0, $buflen$0$i$i$i7$lcssa - $58 << 2 | 0) | 0;
     HEAP32[$43 >> 2] = $buflen$0$i$i$i7$lcssa;
     HEAP32[$53 >> 2] = $56;
    }
   }
   if ($41 | 0) {
    $$pre$i$i8 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i = 0;
    do {
     HEAP32[$$pre$i$i8 + ($ix$01$i$i + $30 << 2) >> 2] = HEAP8[310762 + $ix$01$i$i >> 0];
     $ix$01$i$i = $ix$01$i$i + 1 | 0;
    } while (($ix$01$i$i | 0) != ($41 | 0));
   }
   HEAP32[$15 >> 2] = $42;
   _PPrintText($doc, 2, 0, $node);
   $70 = HEAP32[$15 >> 2] | 0;
   $71 = _prvTidytmbstrlen(310767) | 0;
   $72 = $71 + $70 | 0;
   $73 = HEAP32[$43 >> 2] | 0;
   if ($72 >>> 0 >= $73 >>> 0) {
    $buflen$0$i$i$i10 = ($73 | 0) == 0 ? 256 : $73;
    while (1) if ($buflen$0$i$i$i10 >>> 0 > $72 >>> 0) {
     $buflen$0$i$i$i10$lcssa = $buflen$0$i$i$i10;
     break;
    } else $buflen$0$i$i$i10 = $buflen$0$i$i$i10 << 1;
    $78 = HEAP32[$29 >> 2] | 0;
    $82 = $doc + 6728 | 0;
    $85 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$78 >> 2] | 0) + 4 >> 2] & 15]($78, HEAP32[$82 >> 2] | 0, $buflen$0$i$i$i10$lcssa << 2) | 0;
    if ($85 | 0) {
     $87 = HEAP32[$43 >> 2] | 0;
     _memset($85 + ($87 << 2) | 0, 0, $buflen$0$i$i$i10$lcssa - $87 << 2 | 0) | 0;
     HEAP32[$43 >> 2] = $buflen$0$i$i$i10$lcssa;
     HEAP32[$82 >> 2] = $85;
    }
   }
   if ($71 | 0) {
    $$pre$i$i12 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i14 = 0;
    do {
     HEAP32[$$pre$i$i12 + ($ix$01$i$i14 + $70 << 2) >> 2] = HEAP8[310767 + $ix$01$i$i14 >> 0];
     $ix$01$i$i14 = $ix$01$i$i14 + 1 | 0;
    } while (($ix$01$i$i14 | 0) != ($71 | 0));
   }
   HEAP32[$15 >> 2] = $72;
   $99 = $72 + 1 | 0;
   $100 = HEAP32[$43 >> 2] | 0;
   if ($99 >>> 0 < $100 >>> 0) $$pre$phi$i$iZ2D = $doc + 6728 | 0; else {
    $buflen$0$i$i$i = ($100 | 0) == 0 ? 256 : $100;
    while (1) if ($buflen$0$i$i$i >>> 0 > $99 >>> 0) {
     $buflen$0$i$i$i$lcssa = $buflen$0$i$i$i;
     break;
    } else $buflen$0$i$i$i = $buflen$0$i$i$i << 1;
    $105 = HEAP32[$29 >> 2] | 0;
    $109 = $doc + 6728 | 0;
    $112 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$105 >> 2] | 0) + 4 >> 2] & 15]($105, HEAP32[$109 >> 2] | 0, $buflen$0$i$i$i$lcssa << 2) | 0;
    if (!$112) $$pre$phi$i$iZ2D = $109; else {
     $114 = HEAP32[$43 >> 2] | 0;
     _memset($112 + ($114 << 2) | 0, 0, $buflen$0$i$i$i$lcssa - $114 << 2 | 0) | 0;
     HEAP32[$43 >> 2] = $buflen$0$i$i$i$lcssa;
     HEAP32[$109 >> 2] = $112;
     $$pre$phi$i$iZ2D = $109;
    }
   }
   HEAP32[(HEAP32[$$pre$phi$i$iZ2D >> 2] | 0) + ($72 << 2) >> 2] = 62;
   $121 = (HEAP32[$15 >> 2] | 0) + 1 | 0;
   HEAP32[$15 >> 2] = $121;
   if (!(HEAP32[$node + 64 >> 2] | 0)) return;
   if (!(HEAP32[$node + 8 >> 2] | 0)) return;
   if ($121 | 0) _PFlushLineImpl($doc);
   if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
    _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
    $134 = $doc + 6744 | 0;
    HEAP32[$134 >> 2] = (HEAP32[$134 >> 2] | 0) + 1;
   }
   if ((HEAP32[$26 >> 2] | 0) == ($indent | 0)) return;
   HEAP32[$26 >> 2] = $indent;
   return;
  }
 case 0:
  {
   $content$0101 = HEAP32[$node + 12 >> 2] | 0;
   if (!$content$0101) return; else $content$0102 = $content$0101;
   do {
    _prvTidyPPrintXMLTree($doc, $mode, $indent, $content$0102);
    $content$0102 = HEAP32[$content$0102 + 8 >> 2] | 0;
   } while (($content$0102 | 0) != 0);
   return;
  }
 case 1:
  {
   _PPrintDocType($doc, $indent, $node);
   return;
  }
 case 3:
  {
   _PPrintPI($doc, $indent, $node);
   return;
  }
 case 13:
  {
   _PPrintXmlDecl($doc, $indent, $node);
   return;
  }
 case 8:
  {
   _PPrintCDATA($doc, $indent, $node);
   return;
  }
 case 9:
  {
   $143 = $doc + 6724 | 0;
   $146 = (HEAP32[$doc + 264 >> 2] | 0) != 0;
   $148 = HEAP32[$doc + 80 >> 2] | 0;
   if (!$146) _prvTidySetOptionInt($doc, 2, -1) | 0;
   $149 = $doc + 6736 | 0;
   $150 = HEAP32[$149 >> 2] | 0;
   $151 = _prvTidytmbstrlen(310853) | 0;
   $152 = $151 + $150 | 0;
   $153 = $doc + 6732 | 0;
   $154 = HEAP32[$153 >> 2] | 0;
   if ($152 >>> 0 >= $154 >>> 0) {
    $buflen$0$i$i$i28 = ($154 | 0) == 0 ? 256 : $154;
    while (1) if ($buflen$0$i$i$i28 >>> 0 > $152 >>> 0) {
     $buflen$0$i$i$i28$lcssa = $buflen$0$i$i$i28;
     break;
    } else $buflen$0$i$i$i28 = $buflen$0$i$i$i28 << 1;
    $159 = HEAP32[$143 >> 2] | 0;
    $163 = $doc + 6728 | 0;
    $166 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$159 >> 2] | 0) + 4 >> 2] & 15]($159, HEAP32[$163 >> 2] | 0, $buflen$0$i$i$i28$lcssa << 2) | 0;
    if ($166 | 0) {
     $168 = HEAP32[$153 >> 2] | 0;
     _memset($166 + ($168 << 2) | 0, 0, $buflen$0$i$i$i28$lcssa - $168 << 2 | 0) | 0;
     HEAP32[$153 >> 2] = $buflen$0$i$i$i28$lcssa;
     HEAP32[$163 >> 2] = $166;
    }
   }
   if ($151 | 0) {
    $$pre$i$i30 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i32 = 0;
    do {
     HEAP32[$$pre$i$i30 + ($ix$01$i$i32 + $150 << 2) >> 2] = HEAP8[310853 + $ix$01$i$i32 >> 0];
     $ix$01$i$i32 = $ix$01$i$i32 + 1 | 0;
    } while (($ix$01$i$i32 | 0) != ($151 | 0));
   }
   HEAP32[$149 >> 2] = $152;
   _PPrintText($doc, $146 ? 16 : 2, $indent, $node);
   $181 = HEAP32[$149 >> 2] | 0;
   $182 = _prvTidytmbstrlen(310857) | 0;
   $183 = $182 + $181 | 0;
   $184 = HEAP32[$153 >> 2] | 0;
   if ($183 >>> 0 >= $184 >>> 0) {
    $buflen$0$i$i$i19 = ($184 | 0) == 0 ? 256 : $184;
    while (1) if ($buflen$0$i$i$i19 >>> 0 > $183 >>> 0) {
     $buflen$0$i$i$i19$lcssa = $buflen$0$i$i$i19;
     break;
    } else $buflen$0$i$i$i19 = $buflen$0$i$i$i19 << 1;
    $189 = HEAP32[$143 >> 2] | 0;
    $193 = $doc + 6728 | 0;
    $196 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$189 >> 2] | 0) + 4 >> 2] & 15]($189, HEAP32[$193 >> 2] | 0, $buflen$0$i$i$i19$lcssa << 2) | 0;
    if ($196 | 0) {
     $198 = HEAP32[$153 >> 2] | 0;
     _memset($196 + ($198 << 2) | 0, 0, $buflen$0$i$i$i19$lcssa - $198 << 2 | 0) | 0;
     HEAP32[$153 >> 2] = $buflen$0$i$i$i19$lcssa;
     HEAP32[$193 >> 2] = $196;
    }
   }
   if ($182 | 0) {
    $$pre$i$i21 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i23 = 0;
    do {
     HEAP32[$$pre$i$i21 + ($ix$01$i$i23 + $181 << 2) >> 2] = HEAP8[310857 + $ix$01$i$i23 >> 0];
     $ix$01$i$i23 = $ix$01$i$i23 + 1 | 0;
    } while (($ix$01$i$i23 | 0) != ($182 | 0));
   }
   HEAP32[$149 >> 2] = $183;
   _prvTidySetOptionInt($doc, 2, $148) | 0;
   return;
  }
 case 10:
  {
   $210 = $doc + 6724 | 0;
   $213 = (HEAP32[$doc + 268 >> 2] | 0) != 0;
   if ($213) {
    $220 = HEAP32[$doc + 80 >> 2] | 0;
    if (!(HEAP32[$doc + 272 >> 2] | 0)) {
     $495 = $220;
     label = 75;
    } else $282 = $220;
   } else {
    $495 = HEAP32[$doc + 80 >> 2] | 0;
    label = 75;
   }
   if ((label | 0) == 75) {
    _prvTidySetOptionInt($doc, 2, -1) | 0;
    $282 = $495;
   }
   $221 = $doc + 6736 | 0;
   $222 = HEAP32[$221 >> 2] | 0;
   $223 = _prvTidytmbstrlen(310860) | 0;
   $224 = $223 + $222 | 0;
   $225 = $doc + 6732 | 0;
   $226 = HEAP32[$225 >> 2] | 0;
   if ($224 >>> 0 >= $226 >>> 0) {
    $buflen$0$i$i$i46 = ($226 | 0) == 0 ? 256 : $226;
    while (1) if ($buflen$0$i$i$i46 >>> 0 > $224 >>> 0) {
     $buflen$0$i$i$i46$lcssa = $buflen$0$i$i$i46;
     break;
    } else $buflen$0$i$i$i46 = $buflen$0$i$i$i46 << 1;
    $231 = HEAP32[$210 >> 2] | 0;
    $235 = $doc + 6728 | 0;
    $238 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$231 >> 2] | 0) + 4 >> 2] & 15]($231, HEAP32[$235 >> 2] | 0, $buflen$0$i$i$i46$lcssa << 2) | 0;
    if ($238 | 0) {
     $240 = HEAP32[$225 >> 2] | 0;
     _memset($238 + ($240 << 2) | 0, 0, $buflen$0$i$i$i46$lcssa - $240 << 2 | 0) | 0;
     HEAP32[$225 >> 2] = $buflen$0$i$i$i46$lcssa;
     HEAP32[$235 >> 2] = $238;
    }
   }
   if ($223 | 0) {
    $$pre$i$i48 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i50 = 0;
    do {
     HEAP32[$$pre$i$i48 + ($ix$01$i$i50 + $222 << 2) >> 2] = HEAP8[310860 + $ix$01$i$i50 >> 0];
     $ix$01$i$i50 = $ix$01$i$i50 + 1 | 0;
    } while (($ix$01$i$i50 | 0) != ($223 | 0));
   }
   HEAP32[$221 >> 2] = $224;
   _PPrintText($doc, $213 ? 16 : 2, $indent, $node);
   $253 = HEAP32[$221 >> 2] | 0;
   $254 = _prvTidytmbstrlen(310863) | 0;
   $255 = $254 + $253 | 0;
   $256 = HEAP32[$225 >> 2] | 0;
   if ($255 >>> 0 >= $256 >>> 0) {
    $buflen$0$i$i$i37 = ($256 | 0) == 0 ? 256 : $256;
    while (1) if ($buflen$0$i$i$i37 >>> 0 > $255 >>> 0) {
     $buflen$0$i$i$i37$lcssa = $buflen$0$i$i$i37;
     break;
    } else $buflen$0$i$i$i37 = $buflen$0$i$i$i37 << 1;
    $261 = HEAP32[$210 >> 2] | 0;
    $265 = $doc + 6728 | 0;
    $268 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$261 >> 2] | 0) + 4 >> 2] & 15]($261, HEAP32[$265 >> 2] | 0, $buflen$0$i$i$i37$lcssa << 2) | 0;
    if ($268 | 0) {
     $270 = HEAP32[$225 >> 2] | 0;
     _memset($268 + ($270 << 2) | 0, 0, $buflen$0$i$i$i37$lcssa - $270 << 2 | 0) | 0;
     HEAP32[$225 >> 2] = $buflen$0$i$i$i37$lcssa;
     HEAP32[$265 >> 2] = $268;
    }
   }
   if ($254 | 0) {
    $$pre$i$i39 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i41 = 0;
    do {
     HEAP32[$$pre$i$i39 + ($ix$01$i$i41 + $253 << 2) >> 2] = HEAP8[310863 + $ix$01$i$i41 >> 0];
     $ix$01$i$i41 = $ix$01$i$i41 + 1 | 0;
    } while (($ix$01$i$i41 | 0) != ($254 | 0));
   }
   HEAP32[$221 >> 2] = $255;
   _prvTidySetOptionInt($doc, 2, $282) | 0;
   return;
  }
 case 11:
  {
   $283 = $doc + 6724 | 0;
   $288 = HEAP32[$doc + 80 >> 2] | 0;
   if (!(HEAP32[$doc + 268 >> 2] | 0)) _prvTidySetOptionInt($doc, 2, -1) | 0;
   $289 = $doc + 6736 | 0;
   $290 = HEAP32[$289 >> 2] | 0;
   $291 = _prvTidytmbstrlen(310866) | 0;
   $292 = $291 + $290 | 0;
   $293 = $doc + 6732 | 0;
   $294 = HEAP32[$293 >> 2] | 0;
   if ($292 >>> 0 >= $294 >>> 0) {
    $buflen$0$i$i$i64 = ($294 | 0) == 0 ? 256 : $294;
    while (1) if ($buflen$0$i$i$i64 >>> 0 > $292 >>> 0) {
     $buflen$0$i$i$i64$lcssa = $buflen$0$i$i$i64;
     break;
    } else $buflen$0$i$i$i64 = $buflen$0$i$i$i64 << 1;
    $299 = HEAP32[$283 >> 2] | 0;
    $303 = $doc + 6728 | 0;
    $306 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$299 >> 2] | 0) + 4 >> 2] & 15]($299, HEAP32[$303 >> 2] | 0, $buflen$0$i$i$i64$lcssa << 2) | 0;
    if ($306 | 0) {
     $308 = HEAP32[$293 >> 2] | 0;
     _memset($306 + ($308 << 2) | 0, 0, $buflen$0$i$i$i64$lcssa - $308 << 2 | 0) | 0;
     HEAP32[$293 >> 2] = $buflen$0$i$i$i64$lcssa;
     HEAP32[$303 >> 2] = $306;
    }
   }
   if ($291 | 0) {
    $$pre$i$i66 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i68 = 0;
    do {
     HEAP32[$$pre$i$i66 + ($ix$01$i$i68 + $290 << 2) >> 2] = HEAP8[310866 + $ix$01$i$i68 >> 0];
     $ix$01$i$i68 = $ix$01$i$i68 + 1 | 0;
    } while (($ix$01$i$i68 | 0) != ($291 | 0));
   }
   HEAP32[$289 >> 2] = $292;
   _PPrintText($doc, HEAP32[$doc + 272 >> 2] | 0 ? 16 : 2, $indent, $node);
   $324 = HEAP32[$289 >> 2] | 0;
   $325 = _prvTidytmbstrlen(310869) | 0;
   $326 = $325 + $324 | 0;
   $327 = HEAP32[$293 >> 2] | 0;
   if ($326 >>> 0 >= $327 >>> 0) {
    $buflen$0$i$i$i55 = ($327 | 0) == 0 ? 256 : $327;
    while (1) if ($buflen$0$i$i$i55 >>> 0 > $326 >>> 0) {
     $buflen$0$i$i$i55$lcssa = $buflen$0$i$i$i55;
     break;
    } else $buflen$0$i$i$i55 = $buflen$0$i$i$i55 << 1;
    $332 = HEAP32[$283 >> 2] | 0;
    $336 = $doc + 6728 | 0;
    $339 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$332 >> 2] | 0) + 4 >> 2] & 15]($332, HEAP32[$336 >> 2] | 0, $buflen$0$i$i$i55$lcssa << 2) | 0;
    if ($339 | 0) {
     $341 = HEAP32[$293 >> 2] | 0;
     _memset($339 + ($341 << 2) | 0, 0, $buflen$0$i$i$i55$lcssa - $341 << 2 | 0) | 0;
     HEAP32[$293 >> 2] = $buflen$0$i$i$i55$lcssa;
     HEAP32[$336 >> 2] = $339;
    }
   }
   if ($325 | 0) {
    $$pre$i$i57 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i59 = 0;
    do {
     HEAP32[$$pre$i$i57 + ($ix$01$i$i59 + $324 << 2) >> 2] = HEAP8[310869 + $ix$01$i$i59 >> 0];
     $ix$01$i$i59 = $ix$01$i$i59 + 1 | 0;
    } while (($ix$01$i$i59 | 0) != ($325 | 0));
   }
   HEAP32[$289 >> 2] = $326;
   _prvTidySetOptionInt($doc, 2, $288) | 0;
   return;
  }
 case 12:
  {
   $353 = $doc + 6724 | 0;
   $356 = (HEAP32[$doc + 276 >> 2] | 0) != 0;
   $358 = HEAP32[$doc + 80 >> 2] | 0;
   if (!$356) _prvTidySetOptionInt($doc, 2, -1) | 0;
   $359 = $doc + 6736 | 0;
   $360 = HEAP32[$359 >> 2] | 0;
   $361 = _prvTidytmbstrlen(310813) | 0;
   $362 = $361 + $360 | 0;
   $363 = $doc + 6732 | 0;
   $364 = HEAP32[$363 >> 2] | 0;
   if ($362 >>> 0 >= $364 >>> 0) {
    $buflen$0$i$i$i82 = ($364 | 0) == 0 ? 256 : $364;
    while (1) if ($buflen$0$i$i$i82 >>> 0 > $362 >>> 0) {
     $buflen$0$i$i$i82$lcssa = $buflen$0$i$i$i82;
     break;
    } else $buflen$0$i$i$i82 = $buflen$0$i$i$i82 << 1;
    $369 = HEAP32[$353 >> 2] | 0;
    $373 = $doc + 6728 | 0;
    $376 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$369 >> 2] | 0) + 4 >> 2] & 15]($369, HEAP32[$373 >> 2] | 0, $buflen$0$i$i$i82$lcssa << 2) | 0;
    if ($376 | 0) {
     $378 = HEAP32[$363 >> 2] | 0;
     _memset($376 + ($378 << 2) | 0, 0, $buflen$0$i$i$i82$lcssa - $378 << 2 | 0) | 0;
     HEAP32[$363 >> 2] = $buflen$0$i$i$i82$lcssa;
     HEAP32[$373 >> 2] = $376;
    }
   }
   if ($361 | 0) {
    $$pre$i$i84 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i86 = 0;
    do {
     HEAP32[$$pre$i$i84 + ($ix$01$i$i86 + $360 << 2) >> 2] = HEAP8[310813 + $ix$01$i$i86 >> 0];
     $ix$01$i$i86 = $ix$01$i$i86 + 1 | 0;
    } while (($ix$01$i$i86 | 0) != ($361 | 0));
   }
   HEAP32[$359 >> 2] = $362;
   _PPrintText($doc, $356 ? 16 : 2, $indent, $node);
   $391 = HEAP32[$359 >> 2] | 0;
   $392 = _prvTidytmbstrlen(310872) | 0;
   $393 = $392 + $391 | 0;
   $394 = HEAP32[$363 >> 2] | 0;
   if ($393 >>> 0 >= $394 >>> 0) {
    $buflen$0$i$i$i73 = ($394 | 0) == 0 ? 256 : $394;
    while (1) if ($buflen$0$i$i$i73 >>> 0 > $393 >>> 0) {
     $buflen$0$i$i$i73$lcssa = $buflen$0$i$i$i73;
     break;
    } else $buflen$0$i$i$i73 = $buflen$0$i$i$i73 << 1;
    $399 = HEAP32[$353 >> 2] | 0;
    $403 = $doc + 6728 | 0;
    $406 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$399 >> 2] | 0) + 4 >> 2] & 15]($399, HEAP32[$403 >> 2] | 0, $buflen$0$i$i$i73$lcssa << 2) | 0;
    if ($406 | 0) {
     $408 = HEAP32[$363 >> 2] | 0;
     _memset($406 + ($408 << 2) | 0, 0, $buflen$0$i$i$i73$lcssa - $408 << 2 | 0) | 0;
     HEAP32[$363 >> 2] = $buflen$0$i$i$i73$lcssa;
     HEAP32[$403 >> 2] = $406;
    }
   }
   if ($392 | 0) {
    $$pre$i$i75 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i77 = 0;
    do {
     HEAP32[$$pre$i$i75 + ($ix$01$i$i77 + $391 << 2) >> 2] = HEAP8[310872 + $ix$01$i$i77 >> 0];
     $ix$01$i$i77 = $ix$01$i$i77 + 1 | 0;
    } while (($ix$01$i$i77 | 0) != ($392 | 0));
   }
   HEAP32[$359 >> 2] = $393;
   _prvTidySetOptionInt($doc, 2, $358) | 0;
   return;
  }
 default:
  {
   if (!(_prvTidynodeHasCM($node, 1) | 0)) if (($1 | 0) != 0 | (HEAP32[$13 >> 2] | 0) != 7) {
    $440 = HEAP32[$doc + 76 >> 2] | 0;
    $441 = $node + 12 | 0;
    $content1$096 = HEAP32[$441 >> 2] | 0;
    L12 : do if (!$content1$096) $mixed$0 = 0; else {
     $content1$097 = $content1$096;
     while (1) {
      if (_prvTidynodeIsText($content1$097) | 0) {
       $mixed$0 = 1;
       break L12;
      }
      $content1$097 = HEAP32[$content1$097 + 8 >> 2] | 0;
      if (!$content1$097) {
       $mixed$0 = 0;
       break;
      }
     }
    } while (0);
    $447 = $doc + 6736 | 0;
    if (HEAP32[$447 >> 2] | 0) {
     _PFlushLineImpl($doc);
     if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
      _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
      $455 = $doc + 6744 | 0;
      HEAP32[$455 >> 2] = (HEAP32[$455 >> 2] | 0) + 1;
     }
    }
    $458 = $doc + 6752 | 0;
    if ((HEAP32[$458 >> 2] | 0) != ($indent | 0)) HEAP32[$458 >> 2] = $indent;
    if (!(_prvTidyXMLPreserveWhiteSpace($doc, $node) | 0)) {
     $463 = ($mixed$0 | 0) == 0;
     $$indent = ($463 ? $440 : 0) + $indent | 0;
     _PPrintTag($doc, $mode, $indent, $node);
     if ($463) {
      $$090 = $indent;
      $cindent$092 = $$indent;
      label = 150;
     } else {
      $$091$ph$ph = $indent;
      $$ph$ph = 1;
      $cindent$093$ph$ph = $$indent;
      label = 157;
     }
    } else {
     _PPrintTag($doc, $mode, 0, $node);
     $$090 = 0;
     $cindent$092 = 0;
     label = 150;
    }
    if ((label | 0) == 150) if (HEAP32[$441 >> 2] | 0) {
     if (HEAP32[$447 >> 2] | 0) _PFlushLineImpl($doc);
     if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
      _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
      $474 = $doc + 6744 | 0;
      HEAP32[$474 >> 2] = (HEAP32[$474 >> 2] | 0) + 1;
     }
     if ((HEAP32[$458 >> 2] | 0) == ($cindent$092 | 0)) {
      $$091$ph$ph = $$090;
      $$ph$ph = 0;
      $cindent$093$ph$ph = $cindent$092;
      label = 157;
     } else {
      HEAP32[$458 >> 2] = $cindent$092;
      $$091$ph$ph = $$090;
      $$ph$ph = 0;
      $cindent$093$ph$ph = $cindent$092;
      label = 157;
     }
    }
    if ((label | 0) == 157) {
     $content1$194$pr = HEAP32[$441 >> 2] | 0;
     if ($content1$194$pr | 0) {
      $content1$195 = $content1$194$pr;
      do {
       _prvTidyPPrintXMLTree($doc, $mode, $cindent$093$ph$ph, $content1$195);
       $content1$195 = HEAP32[$content1$195 + 8 >> 2] | 0;
      } while (($content1$195 | 0) != 0);
     }
     if (!$$ph$ph) if (HEAP32[$441 >> 2] | 0) {
      if (HEAP32[$447 >> 2] | 0) {
       _PFlushLineImpl($doc);
       if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
        _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
        $490 = $doc + 6744 | 0;
        HEAP32[$490 >> 2] = (HEAP32[$490 >> 2] | 0) + 1;
       }
      }
      if ((HEAP32[$458 >> 2] | 0) != ($$091$ph$ph | 0)) HEAP32[$458 >> 2] = $$091$ph$ph;
     }
    }
    _PPrintEndTag($doc, HEAP32[$node + 32 >> 2] | 0);
    return;
   }
   if (HEAP32[$doc + 6736 >> 2] | 0) {
    _PFlushLineImpl($doc);
    if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
     _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
     $433 = $doc + 6744 | 0;
     HEAP32[$433 >> 2] = (HEAP32[$433 >> 2] | 0) + 1;
    }
   }
   $436 = $doc + 6752 | 0;
   if ((HEAP32[$436 >> 2] | 0) != ($indent | 0)) HEAP32[$436 >> 2] = $indent;
   _PPrintTag($doc, $mode, $indent, $node);
   return;
  }
 } while (0);
}

function _CleanNode_1662($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$01$i$i$i = 0, $$0160 = 0, $$0160$lcssa = 0, $$lcssa = 0, $$lcssa157 = 0, $$lcssa161 = 0, $$lcssa162 = 0, $$lcssa163 = 0, $$lcssa164 = 0, $$lcssa165 = 0, $$lcssa2$i$i = 0, $$lcssa2$i$i20 = 0, $$lcssa2$i$i8 = 0, $$ph37$ph = 0, $$pre94 = 0, $$pre95 = 0, $1 = 0, $10 = 0, $104 = 0, $11 = 0, $113 = 0, $114 = 0, $126 = 0, $127 = 0, $131 = 0, $14 = 0, $142 = 0, $145 = 0, $15 = 0, $152 = 0, $156 = 0, $160 = 0, $163 = 0, $168 = 0, $170 = 0, $174 = 0, $179 = 0, $183 = 0, $184 = 0, $190 = 0, $192 = 0, $197 = 0, $198 = 0, $199 = 0, $209 = 0, $21 = 0, $210 = 0, $220 = 0, $224 = 0, $225 = 0, $231 = 0, $233 = 0, $238 = 0, $239 = 0, $240 = 0, $250 = 0, $251 = 0, $259 = 0, $270 = 0, $273 = 0, $276 = 0, $282 = 0, $283 = 0, $285 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $295 = 0, $3 = 0, $301 = 0, $302 = 0, $308 = 0, $309 = 0, $311 = 0, $312 = 0, $313 = 0, $316 = 0, $318 = 0, $320 = 0, $323 = 0, $324 = 0, $33 = 0, $331 = 0, $336 = 0, $347 = 0, $350 = 0, $352 = 0, $356 = 0, $362 = 0, $363 = 0, $367 = 0, $37 = 0, $376 = 0, $38 = 0, $4 = 0, $47 = 0, $48 = 0, $53 = 0, $54 = 0, $59 = 0, $62 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $7 = 0, $70 = 0, $75 = 0, $79 = 0, $8 = 0, $83 = 0, $86 = 0, $9 = 0, $93 = 0, $95 = 0, $96 = 0, $98 = 0, $av$0$i$i = 0, $av$0$ph5$i = 0, $av$03$i = 0, $av$03$i$i = 0, $av$03$i$lcssa = 0, $av$05$i$i = 0, $av$05$i$i$lcssa = 0, $buf$i$i$i = 0, $child$01$i$i = 0, $child$01$i$i21 = 0, $child$01$i$i26 = 0, $child$01$i$i9 = 0, $child$01$i1$i = 0, $child$01$i1$i30 = 0, $child$01$i6$i = 0, $child$01$i8$i = 0, $child$02$i$i = 0, $child$02$i$i10 = 0, $child$02$i$i22 = 0, $child$02$i$i27 = 0, $child$02$i2$i = 0, $child$02$i2$i31 = 0, $child$02$i7$i = 0, $child$02$i9$i = 0, $i$0$lcssa$i$i$i = 0, $i$02$i$i$i = 0, $next$sroa$0$059 = 0, $next$sroa$0$3 = 0, $next$sroa$0$4 = 0, $node$01$i$i = 0, $node$02$i$i = 0, $prev$04$i$i = 0, $prev$04$i$i$lcssa = 0, $prev$04$i$i$phi = 0, $style$0$ph$lcssa$i = 0, $style$0$ph6$i = 0, $vararg_buffer = 0, label = 0, sp = 0, $av$03$i$looptemp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 272 | 0;
 $vararg_buffer = sp;
 $buf$i$i$i = sp + 8 | 0;
 $1 = HEAP32[$doc + 424 >> 2] | 0;
 $3 = HEAP32[$doc + 440 >> 2] | 0;
 $4 = $node;
 if (!(_prvTidynodeIsElement($node) | 0)) {
  $next$sroa$0$4 = $4;
  $376 = $next$sroa$0$4;
  STACKTOP = sp;
  return $376 | 0;
 }
 $7 = $doc + 6856 | 0;
 $8 = $doc + 216 | 0;
 $$0160 = $node;
 $next$sroa$0$059 = $4;
 L4 : while (1) {
  $9 = ($$0160 | 0) == 0;
  L6 : do if ($9) {
   $$ph37$ph = 0;
   label = 50;
  } else {
   $10 = $$0160 + 28 | 0;
   $11 = HEAP32[$10 >> 2] | 0;
   if (!$11) {
    $$ph37$ph = 1;
    label = 50;
   } else {
    switch (HEAP32[$11 >> 2] | 0) {
    case 77:
    case 118:
    case 29:
     {
      $14 = $$0160 + 12 | 0;
      $15 = HEAP32[$14 >> 2] | 0;
      if ($15 | 0) if (!(HEAP32[$15 + 8 >> 2] | 0)) {
       $21 = HEAP32[$15 + 28 >> 2] | 0;
       if ($21 | 0) if ((HEAP32[$21 >> 2] | 0) == 61) if (HEAP32[$15 + 60 >> 2] | 0) {
        HEAP32[$10 >> 2] = _prvTidyLookupTagDef(30) | 0;
        $29 = HEAP32[$7 >> 2] | 0;
        $33 = $$0160 + 32 | 0;
        FUNCTION_TABLE_vii[HEAP32[(HEAP32[$29 >> 2] | 0) + 8 >> 2] & 15]($29, HEAP32[$33 >> 2] | 0);
        HEAP32[$33 >> 2] = _prvTidytmbstrdup(HEAP32[$7 >> 2] | 0, 310957) | 0;
        _prvTidyAddStyleProperty($doc, $$0160, 310961);
        $37 = HEAP32[$14 >> 2] | 0;
        $38 = $37 + 12 | 0;
        HEAP32[$14 >> 2] = HEAP32[$38 >> 2];
        HEAP32[$$0160 + 16 >> 2] = HEAP32[$37 + 16 >> 2];
        HEAP32[$38 >> 2] = 0;
        _prvTidyFreeNode($doc, $37);
        $child$01$i$i = HEAP32[$14 >> 2] | 0;
        if (!$child$01$i$i) {
         $next$sroa$0$3 = $next$sroa$0$059;
         break L6;
        } else $child$02$i$i = $child$01$i$i;
        while (1) {
         HEAP32[$child$02$i$i >> 2] = $$0160;
         $child$02$i$i = HEAP32[$child$02$i$i + 8 >> 2] | 0;
         if (!$child$02$i$i) {
          $next$sroa$0$3 = $next$sroa$0$059;
          break L6;
         }
        }
       }
      }
      break;
     }
    default:
     {}
    }
    switch (HEAP32[$11 >> 2] | 0) {
    case 77:
    case 118:
     {
      $47 = $$0160 + 12 | 0;
      $48 = HEAP32[$47 >> 2] | 0;
      if ($48 | 0) if (!(HEAP32[$48 + 8 >> 2] | 0)) {
       $53 = $48 + 12 | 0;
       $54 = HEAP32[$53 >> 2] | 0;
       if ($54 | 0) if ((HEAP32[$54 + 28 >> 2] | 0) == ($11 | 0)) {
        $59 = $54 + 8 | 0;
        if (!(HEAP32[$59 >> 2] | 0)) {
         $$0160$lcssa = $$0160;
         $$lcssa161 = $47;
         $$lcssa162 = $48;
         $$lcssa163 = $53;
         $$lcssa164 = $54;
         $$lcssa165 = $59;
         label = 19;
         break L4;
        }
       }
      }
      break;
     }
    default:
     {}
    }
    if ((HEAP32[$11 >> 2] | 0) == 20) {
     $126 = _prvTidyLookupTagDef(30) | 0;
     $127 = HEAP32[$7 >> 2] | 0;
     $131 = $$0160 + 32 | 0;
     FUNCTION_TABLE_vii[HEAP32[(HEAP32[$127 >> 2] | 0) + 8 >> 2] & 15]($127, HEAP32[$131 >> 2] | 0);
     HEAP32[$131 >> 2] = _prvTidytmbstrdup(HEAP32[$7 >> 2] | 0, HEAP32[$126 + 4 >> 2] | 0) | 0;
     HEAP32[$10 >> 2] = $126;
     _prvTidyAddStyleProperty($doc, $$0160, 310978);
     $next$sroa$0$3 = $next$sroa$0$059;
    } else {
     $$ph37$ph = 1;
     label = 50;
    }
   }
  } while (0);
  L27 : do if ((label | 0) == 50) {
   label = 0;
   if (!(_MergeNestedElements($doc, 30, $1, $$0160) | 0)) if (!(_MergeNestedElements($doc, 100, $3, $$0160) | 0)) {
    L31 : do if ($$ph37$ph) {
     $142 = HEAP32[$$0160 + 28 >> 2] | 0;
     if ($142 | 0) {
      switch (HEAP32[$142 >> 2] | 0) {
      case 115:
      case 112:
      case 109:
      case 107:
       break;
      default:
       break L31;
      }
      $145 = _prvTidyAttrGetById($$0160, 14) | 0;
      if ($145 | 0) {
       HEAP32[$vararg_buffer >> 2] = HEAP32[$145 + 24 >> 2];
       _prvTidytmbsnprintf($buf$i$i$i, 256, 310997, $vararg_buffer) | 0;
       _prvTidyRemoveAttribute($doc, $$0160, $145);
       _prvTidyAddStyleProperty($doc, $$0160, $buf$i$i$i);
      }
     }
    } while (0);
    L39 : do if (!(_prvTidynodeHasCM($$0160, 232) | 0)) label = 90; else {
     if (!$9) {
      $152 = HEAP32[$$0160 + 28 >> 2] | 0;
      if ($152 | 0) switch (HEAP32[$152 >> 2] | 0) {
      case 61:
      case 115:
      case 107:
      case 80:
      case 30:
       {
        $220 = $152;
        label = 92;
        break L39;
        break;
       }
      default:
       {}
      }
     }
     if ($$ph37$ph) {
      $156 = HEAP32[$$0160 + 28 >> 2] | 0;
      if (!$156) label = 65; else if ((HEAP32[$156 >> 2] | 0) != 19) label = 65;
     } else label = 65;
     L48 : do if ((label | 0) == 65) {
      label = 0;
      $160 = $$0160 + 20 | 0;
      $av$03$i$i = HEAP32[$160 >> 2] | 0;
      if ($av$03$i$i | 0) {
       $av$05$i$i = $av$03$i$i;
       $prev$04$i$i = 0;
       while (1) {
        $163 = HEAP32[$av$05$i$i + 4 >> 2] | 0;
        if ($163 | 0) if ((HEAP32[$163 >> 2] | 0) == 7) {
         $av$05$i$i$lcssa = $av$05$i$i;
         $prev$04$i$i$lcssa = $prev$04$i$i;
         break;
        }
        $av$0$i$i = HEAP32[$av$05$i$i >> 2] | 0;
        if (!$av$0$i$i) break L48; else {
         $prev$04$i$i$phi = $av$05$i$i;
         $av$05$i$i = $av$0$i$i;
         $prev$04$i$i = $prev$04$i$i$phi;
        }
       }
       $168 = HEAP32[$av$05$i$i$lcssa >> 2] | 0;
       if (!$prev$04$i$i$lcssa) HEAP32[$160 >> 2] = $168; else HEAP32[$prev$04$i$i$lcssa >> 2] = $168;
       $170 = HEAP32[$av$05$i$i$lcssa + 24 >> 2] | 0;
       if ($170 | 0) {
        _prvTidytmbstrcpy($buf$i$i$i, 311018) | 0;
        $$01$i$i$i = $170;
        $i$02$i$i$i = 12;
        while (1) {
         $174 = _prvTidyToLower(HEAP8[$$01$i$i$i >> 0] | 0) | 0;
         HEAP8[$buf$i$i$i + $i$02$i$i$i >> 0] = $174;
         if (!($174 & 255)) {
          $i$0$lcssa$i$i$i = $i$02$i$i$i;
          break;
         }
         $179 = $i$02$i$i$i + 1 | 0;
         if ($179 >>> 0 < 127) {
          $$01$i$i$i = $$01$i$i$i + 1 | 0;
          $i$02$i$i$i = $179;
         } else {
          $i$0$lcssa$i$i$i = $179;
          break;
         }
        }
        HEAP8[$buf$i$i$i + $i$0$lcssa$i$i$i >> 0] = 0;
        _prvTidyAddStyleProperty($doc, $$0160, $buf$i$i$i);
       }
       _prvTidyFreeAttribute($doc, $av$05$i$i$lcssa);
      }
     } while (0);
     $183 = $$0160 + 12 | 0;
     $184 = HEAP32[$183 >> 2] | 0;
     if (!$184) label = 90; else if (!(HEAP32[$184 + 8 >> 2] | 0)) {
      $190 = HEAP32[$184 + 28 >> 2] | 0;
      if (!$190) label = 90; else {
       $192 = HEAP32[$190 >> 2] | 0;
       L71 : do if (($192 | 0) == 8) $$lcssa2$i$i8 = 66052; else if (($192 | 0) == 49) $$lcssa2$i$i8 = 66064; else if (($192 | 0) == 92) $$lcssa2$i$i8 = 66076; else if (($192 | 0) == 101) $$lcssa2$i$i8 = 66088; else {
        switch ($192 | 0) {
        case 117:
         {
          $$lcssa2$i$i8 = 66100;
          break L71;
          break;
         }
        case 36:
         break;
        default:
         {
          label = 90;
          break L39;
         }
        }
        _MergeStyles($doc, $$0160, $184);
        _AddFontStyles($doc, $$0160, HEAP32[$184 + 20 >> 2] | 0);
        $209 = HEAP32[$183 >> 2] | 0;
        $210 = $209 + 12 | 0;
        HEAP32[$183 >> 2] = HEAP32[$210 >> 2];
        HEAP32[$$0160 + 16 >> 2] = HEAP32[$209 + 16 >> 2];
        HEAP32[$210 >> 2] = 0;
        _prvTidyFreeNode($doc, $209);
        $child$01$i8$i = HEAP32[$183 >> 2] | 0;
        if (!$child$01$i8$i) {
         $next$sroa$0$3 = $next$sroa$0$059;
         break L27;
        } else $child$02$i9$i = $child$01$i8$i;
        while (1) {
         HEAP32[$child$02$i9$i >> 2] = $$0160;
         $child$02$i9$i = HEAP32[$child$02$i9$i + 8 >> 2] | 0;
         if (!$child$02$i9$i) {
          $next$sroa$0$3 = $next$sroa$0$059;
          break L27;
         }
        }
       } while (0);
       $197 = HEAP32[$$lcssa2$i$i8 >> 2] | 0;
       _MergeStyles($doc, $$0160, $184);
       _prvTidyAddStyleProperty($doc, $$0160, $197);
       $198 = HEAP32[$183 >> 2] | 0;
       $199 = $198 + 12 | 0;
       HEAP32[$183 >> 2] = HEAP32[$199 >> 2];
       HEAP32[$$0160 + 16 >> 2] = HEAP32[$198 + 16 >> 2];
       HEAP32[$199 >> 2] = 0;
       _prvTidyFreeNode($doc, $198);
       $child$01$i$i9 = HEAP32[$183 >> 2] | 0;
       if (!$child$01$i$i9) {
        $next$sroa$0$3 = $next$sroa$0$059;
        break L27;
       } else $child$02$i$i10 = $child$01$i$i9;
       while (1) {
        HEAP32[$child$02$i$i10 >> 2] = $$0160;
        $child$02$i$i10 = HEAP32[$child$02$i$i10 + 8 >> 2] | 0;
        if (!$child$02$i$i10) {
         $next$sroa$0$3 = $next$sroa$0$059;
         break L27;
        }
       }
      }
     } else label = 90;
    } while (0);
    if ((label | 0) == 90) {
     label = 0;
     if ($9) label = 93; else {
      $$pre95 = HEAP32[$$0160 + 28 >> 2] | 0;
      if (!$$pre95) label = 93; else {
       $220 = $$pre95;
       label = 92;
      }
     }
    }
    if ((label | 0) == 92) {
     label = 0;
     if ((HEAP32[$220 >> 2] | 0) != 36) label = 93;
    }
    L87 : do if ((label | 0) == 93) {
     label = 0;
     if (_prvTidynodeHasCM($$0160, 528) | 0) {
      $224 = $$0160 + 12 | 0;
      $225 = HEAP32[$224 >> 2] | 0;
      if ($225 | 0) if (!(HEAP32[$225 + 8 >> 2] | 0)) {
       $231 = HEAP32[$225 + 28 >> 2] | 0;
       if ($231 | 0) {
        $233 = HEAP32[$231 >> 2] | 0;
        L93 : do if (($233 | 0) == 8) $$lcssa2$i$i20 = 66052; else if (($233 | 0) == 49) $$lcssa2$i$i20 = 66064; else if (($233 | 0) == 92) $$lcssa2$i$i20 = 66076; else if (($233 | 0) == 101) $$lcssa2$i$i20 = 66088; else {
         switch ($233 | 0) {
         case 117:
          {
           $$lcssa2$i$i20 = 66100;
           break L93;
           break;
          }
         case 36:
          break;
         default:
          break L87;
         }
         _MergeStyles($doc, $$0160, $225);
         _AddFontStyles($doc, $$0160, HEAP32[$225 + 20 >> 2] | 0);
         $250 = HEAP32[$224 >> 2] | 0;
         $251 = $250 + 12 | 0;
         HEAP32[$224 >> 2] = HEAP32[$251 >> 2];
         HEAP32[$$0160 + 16 >> 2] = HEAP32[$250 + 16 >> 2];
         HEAP32[$251 >> 2] = 0;
         _prvTidyFreeNode($doc, $250);
         $child$01$i$i21 = HEAP32[$224 >> 2] | 0;
         if (!$child$01$i$i21) {
          $next$sroa$0$3 = $next$sroa$0$059;
          break L27;
         } else $child$02$i$i22 = $child$01$i$i21;
         while (1) {
          HEAP32[$child$02$i$i22 >> 2] = $$0160;
          $child$02$i$i22 = HEAP32[$child$02$i$i22 + 8 >> 2] | 0;
          if (!$child$02$i$i22) {
           $next$sroa$0$3 = $next$sroa$0$059;
           break L27;
          }
         }
        } while (0);
        $238 = HEAP32[$$lcssa2$i$i20 >> 2] | 0;
        _MergeStyles($doc, $$0160, $225);
        _prvTidyAddStyleProperty($doc, $$0160, $238);
        $239 = HEAP32[$224 >> 2] | 0;
        $240 = $239 + 12 | 0;
        HEAP32[$224 >> 2] = HEAP32[$240 >> 2];
        HEAP32[$$0160 + 16 >> 2] = HEAP32[$239 + 16 >> 2];
        HEAP32[$240 >> 2] = 0;
        _prvTidyFreeNode($doc, $239);
        $child$01$i1$i = HEAP32[$224 >> 2] | 0;
        if (!$child$01$i1$i) {
         $next$sroa$0$3 = $next$sroa$0$059;
         break L27;
        } else $child$02$i2$i = $child$01$i1$i;
        while (1) {
         HEAP32[$child$02$i2$i >> 2] = $$0160;
         $child$02$i2$i = HEAP32[$child$02$i2$i + 8 >> 2] | 0;
         if (!$child$02$i2$i) {
          $next$sroa$0$3 = $next$sroa$0$059;
          break L27;
         }
        }
       }
      }
     }
    } while (0);
    $259 = HEAP32[$$0160 >> 2] | 0;
    L105 : do if ((HEAP32[$259 + 12 >> 2] | 0) == ($$0160 | 0)) if (!(HEAP32[$$0160 + 8 >> 2] | 0)) {
     if (_prvTidynodeHasCM($259, 232) | 0) {
      if (!$259) break;
      $270 = HEAP32[$259 + 28 >> 2] | 0;
      if (!$270) break;
      switch (HEAP32[$270 >> 2] | 0) {
      case 61:
      case 115:
      case 107:
      case 80:
      case 30:
       break;
      default:
       break L105;
      }
     }
     $273 = HEAP32[$$0160 >> 2] | 0;
     if ($273 | 0) {
      $276 = HEAP32[$273 + 28 >> 2] | 0;
      if ($276 | 0) if ((HEAP32[$276 >> 2] | 0) == 36) {
       label = 116;
       break;
      }
     }
     if (!(_prvTidynodeHasCM($273, 528) | 0)) label = 116;
    } else label = 116; else label = 116; while (0);
    do if ((label | 0) == 116) {
     label = 0;
     $282 = $$0160 + 28 | 0;
     $283 = HEAP32[$282 >> 2] | 0;
     if ($283 | 0) {
      $285 = HEAP32[$283 >> 2] | 0;
      if (($285 | 0) == 92) $$lcssa2$i$i = 66076; else if (($285 | 0) == 101) $$lcssa2$i$i = 66088; else if (($285 | 0) == 117) $$lcssa2$i$i = 66100; else break;
      $289 = HEAP32[$$lcssa2$i$i >> 2] | 0;
      $290 = _prvTidyLookupTagDef(100) | 0;
      $291 = HEAP32[$7 >> 2] | 0;
      $295 = $$0160 + 32 | 0;
      FUNCTION_TABLE_vii[HEAP32[(HEAP32[$291 >> 2] | 0) + 8 >> 2] & 15]($291, HEAP32[$295 >> 2] | 0);
      HEAP32[$295 >> 2] = _prvTidytmbstrdup(HEAP32[$7 >> 2] | 0, HEAP32[$290 + 4 >> 2] | 0) | 0;
      HEAP32[$282 >> 2] = $290;
      _prvTidyAddStyleProperty($doc, $$0160, $289);
      $next$sroa$0$3 = $next$sroa$0$059;
      break L27;
     }
    } while (0);
    $301 = $$0160 + 28 | 0;
    $302 = HEAP32[$301 >> 2] | 0;
    if (!$302) {
     $next$sroa$0$4 = $next$sroa$0$059;
     label = 149;
     break L4;
    }
    if ((HEAP32[$302 >> 2] | 0) != 36) {
     $next$sroa$0$4 = $next$sroa$0$059;
     label = 149;
     break L4;
    }
    if (HEAP32[$8 >> 2] | 0) {
     $308 = $$0160 + 12 | 0;
     $309 = HEAP32[$308 >> 2] | 0;
     $311 = $309;
     if (!$309) {
      $next$sroa$0$3 = _prvTidyDiscardElement($doc, $$0160) | 0;
      break;
     }
     $312 = HEAP32[$$0160 >> 2] | 0;
     $313 = $$0160 + 8 | 0;
     $316 = HEAP32[$$0160 + 16 >> 2] | 0;
     HEAP32[$316 + 8 >> 2] = HEAP32[$313 >> 2];
     $318 = HEAP32[$313 >> 2] | 0;
     $320 = $316;
     if (!$318) HEAP32[$312 + 16 >> 2] = $320; else HEAP32[$318 + 4 >> 2] = $320;
     $323 = $$0160 + 4 | 0;
     $324 = HEAP32[$323 >> 2] | 0;
     if (!$324) HEAP32[$312 + 12 >> 2] = $311; else {
      HEAP32[$309 + 4 >> 2] = $324;
      HEAP32[(HEAP32[$323 >> 2] | 0) + 8 >> 2] = $311;
     }
     $node$01$i$i = HEAP32[$308 >> 2] | 0;
     $331 = $node$01$i$i;
     if ($node$01$i$i | 0) {
      $node$02$i$i = $node$01$i$i;
      do {
       HEAP32[$node$02$i$i >> 2] = $312;
       $node$02$i$i = HEAP32[$node$02$i$i + 8 >> 2] | 0;
      } while (($node$02$i$i | 0) != 0);
     }
     HEAP32[$308 >> 2] = 0;
     HEAP32[$313 >> 2] = 0;
     _prvTidyFreeNode($doc, $$0160);
     $next$sroa$0$3 = $331;
     break;
    }
    $336 = HEAP32[$$0160 >> 2] | 0;
    if ((HEAP32[$336 + 12 >> 2] | 0) == ($$0160 | 0)) if (!(HEAP32[$$0160 + 8 >> 2] | 0)) if (_prvTidynodeHasCM($336, 232) | 0) {
     if (!$336) {
      $next$sroa$0$4 = $next$sroa$0$059;
      label = 149;
      break L4;
     }
     $347 = HEAP32[$336 + 28 >> 2] | 0;
     if (!$347) {
      $next$sroa$0$4 = $next$sroa$0$059;
      label = 149;
      break L4;
     }
     switch (HEAP32[$347 >> 2] | 0) {
     case 61:
     case 115:
     case 107:
     case 80:
     case 30:
      break;
     default:
      {
       $next$sroa$0$4 = $next$sroa$0$059;
       label = 149;
       break L4;
      }
     }
    }
    $350 = $$0160 + 20 | 0;
    _AddFontStyles($doc, $$0160, HEAP32[$350 >> 2] | 0);
    $352 = HEAP32[$350 >> 2] | 0;
    L152 : do if (!$352) $style$0$ph$lcssa$i = 0; else {
     $av$0$ph5$i = $352;
     $style$0$ph6$i = 0;
     while (1) {
      $av$03$i = $av$0$ph5$i;
      while (1) {
       $av$03$i$looptemp = $av$03$i;
       $av$03$i = HEAP32[$av$03$i >> 2] | 0;
       $356 = HEAP32[$av$03$i$looptemp + 4 >> 2] | 0;
       if ($356 | 0) if ((HEAP32[$356 >> 2] | 0) == 143) {
        $$lcssa = $av$03$i$looptemp;
        $$lcssa157 = $av$03$i;
        $av$03$i$lcssa = $av$03$i$looptemp;
        break;
       }
       _prvTidyFreeAttribute($doc, $av$03$i$looptemp);
       if (!$av$03$i) {
        $style$0$ph$lcssa$i = $style$0$ph6$i;
        break L152;
       }
      }
      HEAP32[$$lcssa >> 2] = 0;
      if (!$$lcssa157) {
       $style$0$ph$lcssa$i = $av$03$i$lcssa;
       break;
      } else {
       $av$0$ph5$i = $$lcssa157;
       $style$0$ph6$i = $av$03$i$lcssa;
      }
     }
    } while (0);
    HEAP32[$350 >> 2] = $style$0$ph$lcssa$i;
    $362 = _prvTidyLookupTagDef(100) | 0;
    $363 = HEAP32[$7 >> 2] | 0;
    $367 = $$0160 + 32 | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$363 >> 2] | 0) + 8 >> 2] & 15]($363, HEAP32[$367 >> 2] | 0);
    HEAP32[$367 >> 2] = _prvTidytmbstrdup(HEAP32[$7 >> 2] | 0, HEAP32[$362 + 4 >> 2] | 0) | 0;
    HEAP32[$301 >> 2] = $362;
    $next$sroa$0$3 = $next$sroa$0$059;
   } else $next$sroa$0$3 = $next$sroa$0$059; else $next$sroa$0$3 = $next$sroa$0$059;
  } while (0);
  $$0160 = $next$sroa$0$3;
  if (!(_prvTidynodeIsElement($$0160) | 0)) {
   $next$sroa$0$4 = $next$sroa$0$3;
   label = 149;
   break;
  } else $next$sroa$0$059 = $next$sroa$0$3;
 }
 if ((label | 0) == 19) {
  $62 = $$lcssa164;
  $64 = HEAP32[$$0160$lcssa + 4 >> 2] | 0;
  $65 = $$lcssa164 + 4 | 0;
  HEAP32[$65 >> 2] = $64;
  $66 = $$0160$lcssa + 8 | 0;
  $67 = HEAP32[$66 >> 2] | 0;
  HEAP32[$$lcssa165 >> 2] = $67;
  $68 = HEAP32[$$0160$lcssa >> 2] | 0;
  HEAP32[$$lcssa164 >> 2] = $68;
  $70 = $68;
  if (!$64) {
   HEAP32[$70 + 12 >> 2] = $$lcssa164;
   $75 = $67;
  } else {
   HEAP32[$64 + 8 >> 2] = $$lcssa164;
   $75 = HEAP32[$$lcssa165 >> 2] | 0;
  }
  if (!$75) HEAP32[$70 + 16 >> 2] = $$lcssa164; else HEAP32[$75 + 4 >> 2] = $$lcssa164;
  $79 = $$lcssa164 + 12 | 0;
  $child$01$i$i26 = HEAP32[$79 >> 2] | 0;
  if ($child$01$i$i26 | 0) {
   $child$02$i$i27 = $child$01$i$i26;
   do {
    HEAP32[$child$02$i$i27 >> 2] = $$lcssa164;
    $child$02$i$i27 = HEAP32[$child$02$i$i27 + 8 >> 2] | 0;
   } while (($child$02$i$i27 | 0) != 0);
  }
  HEAP32[$$lcssa163 >> 2] = 0;
  _prvTidyFreeNode($doc, $$lcssa162);
  HEAP32[$$lcssa161 >> 2] = 0;
  HEAP32[$66 >> 2] = 0;
  _prvTidyFreeNode($doc, $$0160$lcssa);
  $83 = HEAP32[$65 >> 2] | 0;
  if (!$83) {
   $next$sroa$0$4 = $62;
   $376 = $next$sroa$0$4;
   STACKTOP = sp;
   return $376 | 0;
  }
  $86 = HEAP32[$83 + 28 >> 2] | 0;
  if (!$86) {
   $next$sroa$0$4 = $62;
   $376 = $next$sroa$0$4;
   STACKTOP = sp;
   return $376 | 0;
  }
  if ((HEAP32[$86 >> 2] | 0) != 118) if ((HEAP32[$86 >> 2] | 0) != 77) {
   $next$sroa$0$4 = $62;
   $376 = $next$sroa$0$4;
   STACKTOP = sp;
   return $376 | 0;
  }
  $93 = HEAP32[$83 + 16 >> 2] | 0;
  if (!$93) {
   $next$sroa$0$4 = $62;
   $376 = $next$sroa$0$4;
   STACKTOP = sp;
   return $376 | 0;
  }
  $95 = HEAP32[$$lcssa165 >> 2] | 0;
  $96 = $83 + 8 | 0;
  HEAP32[$96 >> 2] = $95;
  $98 = HEAP32[$83 + 4 >> 2] | 0;
  if (!$98) {
   HEAP32[(HEAP32[$83 >> 2] | 0) + 12 >> 2] = $83;
   $104 = $95;
  } else {
   HEAP32[$98 + 8 >> 2] = $83;
   $104 = HEAP32[$96 >> 2] | 0;
  }
  if (!$104) HEAP32[(HEAP32[$83 >> 2] | 0) + 16 >> 2] = $83; else HEAP32[$104 + 4 >> 2] = $83;
  $child$01$i1$i30 = HEAP32[$83 + 12 >> 2] | 0;
  if ($child$01$i1$i30 | 0) {
   $child$02$i2$i31 = $child$01$i1$i30;
   do {
    HEAP32[$child$02$i2$i31 >> 2] = $83;
    $child$02$i2$i31 = HEAP32[$child$02$i2$i31 + 8 >> 2] | 0;
   } while (($child$02$i2$i31 | 0) != 0);
  }
  HEAP32[$$lcssa164 >> 2] = $93;
  HEAP32[$$lcssa165 >> 2] = 0;
  $113 = $93 + 16 | 0;
  $114 = HEAP32[$113 >> 2] | 0;
  HEAP32[$65 >> 2] = $114;
  if (!$114) {
   HEAP32[$93 + 12 >> 2] = $$lcssa164;
   label = 44;
  } else {
   HEAP32[$114 + 8 >> 2] = $$lcssa164;
   $$pre94 = HEAP32[$$lcssa165 >> 2] | 0;
   if (!$$pre94) label = 44; else HEAP32[$$pre94 + 4 >> 2] = $$lcssa164;
  }
  if ((label | 0) == 44) HEAP32[$113 >> 2] = $$lcssa164;
  $child$01$i6$i = HEAP32[$79 >> 2] | 0;
  if ($child$01$i6$i | 0) {
   $child$02$i7$i = $child$01$i6$i;
   do {
    HEAP32[$child$02$i7$i >> 2] = $$lcssa164;
    $child$02$i7$i = HEAP32[$child$02$i7$i + 8 >> 2] | 0;
   } while (($child$02$i7$i | 0) != 0);
  }
  _CleanNode_1662($doc, $$lcssa164) | 0;
  $next$sroa$0$4 = $62;
  $376 = $next$sroa$0$4;
  STACKTOP = sp;
  return $376 | 0;
 } else if ((label | 0) == 149) {
  $376 = $next$sroa$0$4;
  STACKTOP = sp;
  return $376 | 0;
 }
 return 0;
}
function _PPrintTag($doc, $mode, $indent, $node) {
 $doc = $doc | 0;
 $mode = $mode | 0;
 $indent = $indent | 0;
 $node = $node | 0;
 var $$idx$i = 0, $$idx$val$i = 0, $$pre$i$i1$i = 0, $$pre$i$i11 = 0, $$pre$i$i13$i = 0, $$pre$i$i22$i = 0, $$pre$i$i31$i = 0, $$pre$i$i9$i = 0, $$pre$phi$i$i21Z2D = 0, $$pre$phi$i$i27Z2D = 0, $$pre$phi$i$i33Z2D = 0, $$pre$phi$i$i9Z2D = 0, $$pre$phi$i$iZ2D = 0, $0 = 0, $10 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $11 = 0, $110 = 0, $116 = 0, $118 = 0, $12 = 0, $124 = 0, $13 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $149 = 0, $152 = 0, $153 = 0, $154 = 0, $159 = 0, $165 = 0, $167 = 0, $174 = 0, $175 = 0, $177 = 0, $18 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $190 = 0, $196 = 0, $198 = 0, $2 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $218 = 0, $22 = 0, $224 = 0, $226 = 0, $237 = 0, $238 = 0, $241 = 0, $242 = 0, $243 = 0, $248 = 0, $25 = 0, $254 = 0, $256 = 0, $263 = 0, $264 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $276 = 0, $282 = 0, $284 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $304 = 0, $310 = 0, $312 = 0, $324 = 0, $33 = 0, $331 = 0, $332 = 0, $333 = 0, $338 = 0, $34 = 0, $342 = 0, $345 = 0, $347 = 0, $35 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $361 = 0, $365 = 0, $368 = 0, $370 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $385 = 0, $389 = 0, $39 = 0, $392 = 0, $394 = 0, $4 = 0, $407 = 0, $416 = 0, $424 = 0, $428 = 0, $433 = 0, $438 = 0, $44 = 0, $446 = 0, $451 = 0, $455 = 0, $462 = 0, $467 = 0, $468 = 0, $469 = 0, $48 = 0, $5 = 0, $51 = 0, $53 = 0, $6 = 0, $60 = 0, $62 = 0, $65 = 0, $66 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $77 = 0, $8 = 0, $83 = 0, $85 = 0, $9 = 0, $91 = 0, $97 = 0, $98 = 0, $av$037$i = 0, $av$038$i = 0, $buflen$0$i$i$i = 0, $buflen$0$i$i$i$i = 0, $buflen$0$i$i$i$i$lcssa = 0, $buflen$0$i$i$i$lcssa = 0, $buflen$0$i$i$i11$i = 0, $buflen$0$i$i$i11$i$lcssa = 0, $buflen$0$i$i$i14 = 0, $buflen$0$i$i$i14$lcssa = 0, $buflen$0$i$i$i14$us = 0, $buflen$0$i$i$i14$us$lcssa = 0, $buflen$0$i$i$i20 = 0, $buflen$0$i$i$i20$i = 0, $buflen$0$i$i$i20$i$lcssa = 0, $buflen$0$i$i$i20$lcssa = 0, $buflen$0$i$i$i26 = 0, $buflen$0$i$i$i26$lcssa = 0, $buflen$0$i$i$i29$i = 0, $buflen$0$i$i$i29$i$lcssa = 0, $buflen$0$i$i$i32 = 0, $buflen$0$i$i$i32$lcssa = 0, $buflen$0$i$i$i4$i = 0, $buflen$0$i$i$i4$i$lcssa = 0, $buflen$0$i$i$i8 = 0, $buflen$0$i$i$i8$i = 0, $buflen$0$i$i$i8$i$lcssa = 0, $buflen$0$i$i$i8$lcssa = 0, $c = 0, $ix$01$i$i$i = 0, $ix$01$i$i15$i = 0, $ix$01$i$i24$i = 0, $ix$01$i$i33$i = 0, $s$036 = 0, $s$036$us = 0, $s$1 = 0, $s$1$us = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 $0 = $doc + 6724 | 0;
 $2 = HEAP32[$doc + 188 >> 2] | 0;
 $4 = HEAP32[$doc + 176 >> 2] | 0;
 $5 = $doc + 172 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $node + 32 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $doc + 6736 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10 + 1 | 0;
 $12 = $doc + 6732 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 if ($11 >>> 0 < $13 >>> 0) $$pre$phi$i$iZ2D = $doc + 6728 | 0; else {
  $buflen$0$i$i$i = ($13 | 0) == 0 ? 256 : $13;
  while (1) if ($buflen$0$i$i$i >>> 0 > $11 >>> 0) {
   $buflen$0$i$i$i$lcssa = $buflen$0$i$i$i;
   break;
  } else $buflen$0$i$i$i = $buflen$0$i$i$i << 1;
  $18 = HEAP32[$0 >> 2] | 0;
  $22 = $doc + 6728 | 0;
  $25 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$18 >> 2] | 0) + 4 >> 2] & 15]($18, HEAP32[$22 >> 2] | 0, $buflen$0$i$i$i$lcssa << 2) | 0;
  if (!$25) $$pre$phi$i$iZ2D = $22; else {
   $27 = HEAP32[$12 >> 2] | 0;
   _memset($25 + ($27 << 2) | 0, 0, $buflen$0$i$i$i$lcssa - $27 << 2 | 0) | 0;
   HEAP32[$12 >> 2] = $buflen$0$i$i$i$lcssa;
   HEAP32[$22 >> 2] = $25;
   $$pre$phi$i$iZ2D = $22;
  }
 }
 HEAP32[(HEAP32[$$pre$phi$i$iZ2D >> 2] | 0) + ($10 << 2) >> 2] = 60;
 $33 = HEAP32[$9 >> 2] | 0;
 $34 = $33 + 1 | 0;
 HEAP32[$9 >> 2] = $34;
 $35 = $node + 44 | 0;
 if ((HEAP32[$35 >> 2] | 0) == 6) {
  $38 = $33 + 2 | 0;
  $39 = HEAP32[$12 >> 2] | 0;
  if ($38 >>> 0 < $39 >>> 0) $$pre$phi$i$i9Z2D = $doc + 6728 | 0; else {
   $buflen$0$i$i$i8 = ($39 | 0) == 0 ? 256 : $39;
   while (1) if ($buflen$0$i$i$i8 >>> 0 > $38 >>> 0) {
    $buflen$0$i$i$i8$lcssa = $buflen$0$i$i$i8;
    break;
   } else $buflen$0$i$i$i8 = $buflen$0$i$i$i8 << 1;
   $44 = HEAP32[$0 >> 2] | 0;
   $48 = $doc + 6728 | 0;
   $51 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$44 >> 2] | 0) + 4 >> 2] & 15]($44, HEAP32[$48 >> 2] | 0, $buflen$0$i$i$i8$lcssa << 2) | 0;
   if (!$51) $$pre$phi$i$i9Z2D = $48; else {
    $53 = HEAP32[$12 >> 2] | 0;
    _memset($51 + ($53 << 2) | 0, 0, $buflen$0$i$i$i8$lcssa - $53 << 2 | 0) | 0;
    HEAP32[$12 >> 2] = $buflen$0$i$i$i8$lcssa;
    HEAP32[$48 >> 2] = $51;
    $$pre$phi$i$i9Z2D = $48;
   }
  }
  HEAP32[(HEAP32[$$pre$phi$i$i9Z2D >> 2] | 0) + ($34 << 2) >> 2] = 47;
  $60 = (HEAP32[$9 >> 2] | 0) + 1 | 0;
  HEAP32[$9 >> 2] = $60;
  $467 = $60;
 } else $467 = $34;
 L20 : do if ($8 | 0) {
  $62 = HEAP8[$8 >> 0] | 0;
  if ($62 << 24 >> 24) {
   $$pre$i$i11 = $doc + 6728 | 0;
   if (!$2) {
    $468 = $467;
    $66 = $62;
    $s$036$us = $8;
    while (1) {
     $65 = $66 & 255;
     HEAP32[$c >> 2] = $65;
     if ($66 << 24 >> 24 < 0) {
      $69 = $s$036$us + (_prvTidyGetUTF8($s$036$us, $c) | 0) | 0;
      $71 = HEAP32[$9 >> 2] | 0;
      $91 = HEAP32[$c >> 2] | 0;
      $s$1$us = $69;
     } else {
      $71 = $468;
      $91 = $65;
      $s$1$us = $s$036$us;
     }
     $70 = $71 + 1 | 0;
     $72 = HEAP32[$12 >> 2] | 0;
     if ($70 >>> 0 >= $72 >>> 0) {
      $buflen$0$i$i$i14$us = ($72 | 0) == 0 ? 256 : $72;
      while (1) if ($buflen$0$i$i$i14$us >>> 0 > $70 >>> 0) {
       $buflen$0$i$i$i14$us$lcssa = $buflen$0$i$i$i14$us;
       break;
      } else $buflen$0$i$i$i14$us = $buflen$0$i$i$i14$us << 1;
      $77 = HEAP32[$0 >> 2] | 0;
      $83 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$77 >> 2] | 0) + 4 >> 2] & 15]($77, HEAP32[$$pre$i$i11 >> 2] | 0, $buflen$0$i$i$i14$us$lcssa << 2) | 0;
      if ($83 | 0) {
       $85 = HEAP32[$12 >> 2] | 0;
       _memset($83 + ($85 << 2) | 0, 0, $buflen$0$i$i$i14$us$lcssa - $85 << 2 | 0) | 0;
       HEAP32[$12 >> 2] = $buflen$0$i$i$i14$us$lcssa;
       HEAP32[$$pre$i$i11 >> 2] = $83;
      }
     }
     HEAP32[(HEAP32[$$pre$i$i11 >> 2] | 0) + ($71 << 2) >> 2] = $91;
     $468 = (HEAP32[$9 >> 2] | 0) + 1 | 0;
     HEAP32[$9 >> 2] = $468;
     $s$036$us = $s$1$us + 1 | 0;
     $66 = HEAP8[$s$036$us >> 0] | 0;
     if (!($66 << 24 >> 24)) break L20;
    }
   } else {
    $98 = $62;
    $s$036 = $8;
   }
   do {
    $97 = $98 & 255;
    HEAP32[$c >> 2] = $97;
    if ($98 << 24 >> 24 < 0) {
     $101 = $s$036 + (_prvTidyGetUTF8($s$036, $c) | 0) | 0;
     $124 = HEAP32[$c >> 2] | 0;
     $s$1 = $101;
    } else {
     $102 = _prvTidyToUpper($97) | 0;
     HEAP32[$c >> 2] = $102;
     $124 = $102;
     $s$1 = $s$036;
    }
    $103 = HEAP32[$9 >> 2] | 0;
    $104 = $103 + 1 | 0;
    $105 = HEAP32[$12 >> 2] | 0;
    if ($104 >>> 0 >= $105 >>> 0) {
     $buflen$0$i$i$i14 = ($105 | 0) == 0 ? 256 : $105;
     while (1) if ($buflen$0$i$i$i14 >>> 0 > $104 >>> 0) {
      $buflen$0$i$i$i14$lcssa = $buflen$0$i$i$i14;
      break;
     } else $buflen$0$i$i$i14 = $buflen$0$i$i$i14 << 1;
     $110 = HEAP32[$0 >> 2] | 0;
     $116 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$110 >> 2] | 0) + 4 >> 2] & 15]($110, HEAP32[$$pre$i$i11 >> 2] | 0, $buflen$0$i$i$i14$lcssa << 2) | 0;
     if ($116 | 0) {
      $118 = HEAP32[$12 >> 2] | 0;
      _memset($116 + ($118 << 2) | 0, 0, $buflen$0$i$i$i14$lcssa - $118 << 2 | 0) | 0;
      HEAP32[$12 >> 2] = $buflen$0$i$i$i14$lcssa;
      HEAP32[$$pre$i$i11 >> 2] = $116;
     }
    }
    HEAP32[(HEAP32[$$pre$i$i11 >> 2] | 0) + ($103 << 2) >> 2] = $124;
    HEAP32[$9 >> 2] = (HEAP32[$9 >> 2] | 0) + 1;
    $s$036 = $s$1 + 1 | 0;
    $98 = HEAP8[$s$036 >> 0] | 0;
   } while ($98 << 24 >> 24 != 0);
  }
 } while (0);
 if (HEAP32[$5 >> 2] | 0) if (HEAP32[$doc + 292 >> 2] | 0) if (!(_prvTidyGetAttrByName($node, 310875) | 0)) if (_prvTidyXMLPreserveWhiteSpace($doc, $node) | 0) _prvTidyAddAttribute($doc, $node, 310875, 310885) | 0;
 $av$037$i = HEAP32[$node + 20 >> 2] | 0;
 if ($av$037$i | 0) {
  $$pre$i$i1$i = $doc + 6728 | 0;
  $141 = $doc + 276 | 0;
  $142 = $doc + 80 | 0;
  $143 = $doc + 6724 | 0;
  $144 = $doc + 268 | 0;
  $145 = $doc + 272 | 0;
  $av$038$i = $av$037$i;
  do {
   do if (!(HEAP32[$av$038$i + 20 >> 2] | 0)) {
    $149 = $av$038$i + 8 | 0;
    if (!(HEAP32[$149 >> 2] | 0)) {
     $238 = $av$038$i + 12 | 0;
     if (!(HEAP32[$238 >> 2] | 0)) break;
     $241 = HEAP32[$9 >> 2] | 0;
     $242 = $241 + 1 | 0;
     $243 = HEAP32[$12 >> 2] | 0;
     if ($242 >>> 0 >= $243 >>> 0) {
      $buflen$0$i$i$i4$i = ($243 | 0) == 0 ? 256 : $243;
      while (1) if ($buflen$0$i$i$i4$i >>> 0 > $242 >>> 0) {
       $buflen$0$i$i$i4$i$lcssa = $buflen$0$i$i$i4$i;
       break;
      } else $buflen$0$i$i$i4$i = $buflen$0$i$i$i4$i << 1;
      $248 = HEAP32[$143 >> 2] | 0;
      $254 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$248 >> 2] | 0) + 4 >> 2] & 15]($248, HEAP32[$$pre$i$i1$i >> 2] | 0, $buflen$0$i$i$i4$i$lcssa << 2) | 0;
      if ($254 | 0) {
       $256 = HEAP32[$12 >> 2] | 0;
       _memset($254 + ($256 << 2) | 0, 0, $buflen$0$i$i$i4$i$lcssa - $256 << 2 | 0) | 0;
       HEAP32[$12 >> 2] = $buflen$0$i$i$i4$i$lcssa;
       HEAP32[$$pre$i$i1$i >> 2] = $254;
      }
     }
     HEAP32[(HEAP32[$$pre$i$i1$i >> 2] | 0) + ($241 << 2) >> 2] = 32;
     $263 = (HEAP32[$9 >> 2] | 0) + 1 | 0;
     HEAP32[$9 >> 2] = $263;
     $264 = HEAP32[$238 >> 2] | 0;
     $266 = (HEAP32[$141 >> 2] | 0) != 0;
     $267 = HEAP32[$142 >> 2] | 0;
     if ($266) $270 = $263; else {
      _prvTidySetOptionInt($doc, 2, -1) | 0;
      $270 = HEAP32[$9 >> 2] | 0;
     }
     $268 = _prvTidytmbstrlen(310813) | 0;
     $269 = $268 + $270 | 0;
     $271 = HEAP32[$12 >> 2] | 0;
     if ($269 >>> 0 >= $271 >>> 0) {
      $buflen$0$i$i$i29$i = ($271 | 0) == 0 ? 256 : $271;
      while (1) if ($buflen$0$i$i$i29$i >>> 0 > $269 >>> 0) {
       $buflen$0$i$i$i29$i$lcssa = $buflen$0$i$i$i29$i;
       break;
      } else $buflen$0$i$i$i29$i = $buflen$0$i$i$i29$i << 1;
      $276 = HEAP32[$143 >> 2] | 0;
      $282 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$276 >> 2] | 0) + 4 >> 2] & 15]($276, HEAP32[$$pre$i$i1$i >> 2] | 0, $buflen$0$i$i$i29$i$lcssa << 2) | 0;
      if ($282 | 0) {
       $284 = HEAP32[$12 >> 2] | 0;
       _memset($282 + ($284 << 2) | 0, 0, $buflen$0$i$i$i29$i$lcssa - $284 << 2 | 0) | 0;
       HEAP32[$12 >> 2] = $buflen$0$i$i$i29$i$lcssa;
       HEAP32[$$pre$i$i1$i >> 2] = $282;
      }
     }
     if ($268 | 0) {
      $$pre$i$i31$i = HEAP32[$$pre$i$i1$i >> 2] | 0;
      $ix$01$i$i33$i = 0;
      do {
       HEAP32[$$pre$i$i31$i + ($ix$01$i$i33$i + $270 << 2) >> 2] = HEAP8[310813 + $ix$01$i$i33$i >> 0];
       $ix$01$i$i33$i = $ix$01$i$i33$i + 1 | 0;
      } while (($ix$01$i$i33$i | 0) != ($268 | 0));
     }
     HEAP32[$9 >> 2] = $269;
     _PPrintText($doc, $266 ? 16 : 2, $indent, $264);
     $296 = HEAP32[$9 >> 2] | 0;
     $297 = _prvTidytmbstrlen(310872) | 0;
     $298 = $297 + $296 | 0;
     $299 = HEAP32[$12 >> 2] | 0;
     if ($298 >>> 0 >= $299 >>> 0) {
      $buflen$0$i$i$i20$i = ($299 | 0) == 0 ? 256 : $299;
      while (1) if ($buflen$0$i$i$i20$i >>> 0 > $298 >>> 0) {
       $buflen$0$i$i$i20$i$lcssa = $buflen$0$i$i$i20$i;
       break;
      } else $buflen$0$i$i$i20$i = $buflen$0$i$i$i20$i << 1;
      $304 = HEAP32[$143 >> 2] | 0;
      $310 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$304 >> 2] | 0) + 4 >> 2] & 15]($304, HEAP32[$$pre$i$i1$i >> 2] | 0, $buflen$0$i$i$i20$i$lcssa << 2) | 0;
      if ($310 | 0) {
       $312 = HEAP32[$12 >> 2] | 0;
       _memset($310 + ($312 << 2) | 0, 0, $buflen$0$i$i$i20$i$lcssa - $312 << 2 | 0) | 0;
       HEAP32[$12 >> 2] = $buflen$0$i$i$i20$i$lcssa;
       HEAP32[$$pre$i$i1$i >> 2] = $310;
      }
     }
     if ($297 | 0) {
      $$pre$i$i22$i = HEAP32[$$pre$i$i1$i >> 2] | 0;
      $ix$01$i$i24$i = 0;
      do {
       HEAP32[$$pre$i$i22$i + ($ix$01$i$i24$i + $296 << 2) >> 2] = HEAP8[310872 + $ix$01$i$i24$i >> 0];
       $ix$01$i$i24$i = $ix$01$i$i24$i + 1 | 0;
      } while (($ix$01$i$i24$i | 0) != ($297 | 0));
     }
     HEAP32[$9 >> 2] = $298;
     _prvTidySetOptionInt($doc, 2, $267) | 0;
     break;
    }
    $152 = HEAP32[$9 >> 2] | 0;
    $153 = $152 + 1 | 0;
    $154 = HEAP32[$12 >> 2] | 0;
    if ($153 >>> 0 >= $154 >>> 0) {
     $buflen$0$i$i$i$i = ($154 | 0) == 0 ? 256 : $154;
     while (1) if ($buflen$0$i$i$i$i >>> 0 > $153 >>> 0) {
      $buflen$0$i$i$i$i$lcssa = $buflen$0$i$i$i$i;
      break;
     } else $buflen$0$i$i$i$i = $buflen$0$i$i$i$i << 1;
     $159 = HEAP32[$143 >> 2] | 0;
     $165 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$159 >> 2] | 0) + 4 >> 2] & 15]($159, HEAP32[$$pre$i$i1$i >> 2] | 0, $buflen$0$i$i$i$i$lcssa << 2) | 0;
     if ($165 | 0) {
      $167 = HEAP32[$12 >> 2] | 0;
      _memset($165 + ($167 << 2) | 0, 0, $buflen$0$i$i$i$i$lcssa - $167 << 2 | 0) | 0;
      HEAP32[$12 >> 2] = $buflen$0$i$i$i$i$lcssa;
      HEAP32[$$pre$i$i1$i >> 2] = $165;
     }
    }
    HEAP32[(HEAP32[$$pre$i$i1$i >> 2] | 0) + ($152 << 2) >> 2] = 32;
    $174 = (HEAP32[$9 >> 2] | 0) + 1 | 0;
    HEAP32[$9 >> 2] = $174;
    $175 = HEAP32[$149 >> 2] | 0;
    $177 = (HEAP32[$144 >> 2] | 0) != 0;
    if ($177) {
     $181 = HEAP32[$142 >> 2] | 0;
     if (!(HEAP32[$145 >> 2] | 0)) {
      $469 = $181;
      label = 53;
     } else {
      $184 = $174;
      $237 = $181;
     }
    } else {
     $469 = HEAP32[$142 >> 2] | 0;
     label = 53;
    }
    if ((label | 0) == 53) {
     label = 0;
     _prvTidySetOptionInt($doc, 2, -1) | 0;
     $184 = HEAP32[$9 >> 2] | 0;
     $237 = $469;
    }
    $182 = _prvTidytmbstrlen(310860) | 0;
    $183 = $182 + $184 | 0;
    $185 = HEAP32[$12 >> 2] | 0;
    if ($183 >>> 0 >= $185 >>> 0) {
     $buflen$0$i$i$i11$i = ($185 | 0) == 0 ? 256 : $185;
     while (1) if ($buflen$0$i$i$i11$i >>> 0 > $183 >>> 0) {
      $buflen$0$i$i$i11$i$lcssa = $buflen$0$i$i$i11$i;
      break;
     } else $buflen$0$i$i$i11$i = $buflen$0$i$i$i11$i << 1;
     $190 = HEAP32[$143 >> 2] | 0;
     $196 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$190 >> 2] | 0) + 4 >> 2] & 15]($190, HEAP32[$$pre$i$i1$i >> 2] | 0, $buflen$0$i$i$i11$i$lcssa << 2) | 0;
     if ($196 | 0) {
      $198 = HEAP32[$12 >> 2] | 0;
      _memset($196 + ($198 << 2) | 0, 0, $buflen$0$i$i$i11$i$lcssa - $198 << 2 | 0) | 0;
      HEAP32[$12 >> 2] = $buflen$0$i$i$i11$i$lcssa;
      HEAP32[$$pre$i$i1$i >> 2] = $196;
     }
    }
    if ($182 | 0) {
     $$pre$i$i13$i = HEAP32[$$pre$i$i1$i >> 2] | 0;
     $ix$01$i$i15$i = 0;
     do {
      HEAP32[$$pre$i$i13$i + ($ix$01$i$i15$i + $184 << 2) >> 2] = HEAP8[310860 + $ix$01$i$i15$i >> 0];
      $ix$01$i$i15$i = $ix$01$i$i15$i + 1 | 0;
     } while (($ix$01$i$i15$i | 0) != ($182 | 0));
    }
    HEAP32[$9 >> 2] = $183;
    _PPrintText($doc, $177 ? 16 : 2, $indent, $175);
    $210 = HEAP32[$9 >> 2] | 0;
    $211 = _prvTidytmbstrlen(310863) | 0;
    $212 = $211 + $210 | 0;
    $213 = HEAP32[$12 >> 2] | 0;
    if ($212 >>> 0 >= $213 >>> 0) {
     $buflen$0$i$i$i8$i = ($213 | 0) == 0 ? 256 : $213;
     while (1) if ($buflen$0$i$i$i8$i >>> 0 > $212 >>> 0) {
      $buflen$0$i$i$i8$i$lcssa = $buflen$0$i$i$i8$i;
      break;
     } else $buflen$0$i$i$i8$i = $buflen$0$i$i$i8$i << 1;
     $218 = HEAP32[$143 >> 2] | 0;
     $224 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$218 >> 2] | 0) + 4 >> 2] & 15]($218, HEAP32[$$pre$i$i1$i >> 2] | 0, $buflen$0$i$i$i8$i$lcssa << 2) | 0;
     if ($224 | 0) {
      $226 = HEAP32[$12 >> 2] | 0;
      _memset($224 + ($226 << 2) | 0, 0, $buflen$0$i$i$i8$i$lcssa - $226 << 2 | 0) | 0;
      HEAP32[$12 >> 2] = $buflen$0$i$i$i8$i$lcssa;
      HEAP32[$$pre$i$i1$i >> 2] = $224;
     }
    }
    if ($211 | 0) {
     $$pre$i$i9$i = HEAP32[$$pre$i$i1$i >> 2] | 0;
     $ix$01$i$i$i = 0;
     do {
      HEAP32[$$pre$i$i9$i + ($ix$01$i$i$i + $210 << 2) >> 2] = HEAP8[310863 + $ix$01$i$i$i >> 0];
      $ix$01$i$i$i = $ix$01$i$i$i + 1 | 0;
     } while (($ix$01$i$i$i | 0) != ($211 | 0));
    }
    HEAP32[$9 >> 2] = $212;
    _prvTidySetOptionInt($doc, 2, $237) | 0;
   } else _PPrintAttribute($doc, $indent, $node, $av$038$i); while (0);
   $av$038$i = HEAP32[$av$038$i >> 2] | 0;
  } while (($av$038$i | 0) != 0);
 }
 $324 = ($4 | 0) != 0;
 do if ($6 | $4 | 0) {
  if ((HEAP32[$35 >> 2] | 0) != 7) if (!(_prvTidynodeCMIsEmpty($node) | 0)) break;
  $331 = HEAP32[$9 >> 2] | 0;
  $332 = $331 + 1 | 0;
  $333 = HEAP32[$12 >> 2] | 0;
  if ($332 >>> 0 < $333 >>> 0) $$pre$phi$i$i21Z2D = $doc + 6728 | 0; else {
   $buflen$0$i$i$i20 = ($333 | 0) == 0 ? 256 : $333;
   while (1) if ($buflen$0$i$i$i20 >>> 0 > $332 >>> 0) {
    $buflen$0$i$i$i20$lcssa = $buflen$0$i$i$i20;
    break;
   } else $buflen$0$i$i$i20 = $buflen$0$i$i$i20 << 1;
   $338 = HEAP32[$0 >> 2] | 0;
   $342 = $doc + 6728 | 0;
   $345 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$338 >> 2] | 0) + 4 >> 2] & 15]($338, HEAP32[$342 >> 2] | 0, $buflen$0$i$i$i20$lcssa << 2) | 0;
   if (!$345) $$pre$phi$i$i21Z2D = $342; else {
    $347 = HEAP32[$12 >> 2] | 0;
    _memset($345 + ($347 << 2) | 0, 0, $buflen$0$i$i$i20$lcssa - $347 << 2 | 0) | 0;
    HEAP32[$12 >> 2] = $buflen$0$i$i$i20$lcssa;
    HEAP32[$342 >> 2] = $345;
    $$pre$phi$i$i21Z2D = $342;
   }
  }
  HEAP32[(HEAP32[$$pre$phi$i$i21Z2D >> 2] | 0) + ($331 << 2) >> 2] = 32;
  $353 = HEAP32[$9 >> 2] | 0;
  $354 = $353 + 1 | 0;
  HEAP32[$9 >> 2] = $354;
  $355 = $353 + 2 | 0;
  $356 = HEAP32[$12 >> 2] | 0;
  if ($355 >>> 0 < $356 >>> 0) $$pre$phi$i$i27Z2D = $doc + 6728 | 0; else {
   $buflen$0$i$i$i26 = ($356 | 0) == 0 ? 256 : $356;
   while (1) if ($buflen$0$i$i$i26 >>> 0 > $355 >>> 0) {
    $buflen$0$i$i$i26$lcssa = $buflen$0$i$i$i26;
    break;
   } else $buflen$0$i$i$i26 = $buflen$0$i$i$i26 << 1;
   $361 = HEAP32[$0 >> 2] | 0;
   $365 = $doc + 6728 | 0;
   $368 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$361 >> 2] | 0) + 4 >> 2] & 15]($361, HEAP32[$365 >> 2] | 0, $buflen$0$i$i$i26$lcssa << 2) | 0;
   if (!$368) $$pre$phi$i$i27Z2D = $365; else {
    $370 = HEAP32[$12 >> 2] | 0;
    _memset($368 + ($370 << 2) | 0, 0, $buflen$0$i$i$i26$lcssa - $370 << 2 | 0) | 0;
    HEAP32[$12 >> 2] = $buflen$0$i$i$i26$lcssa;
    HEAP32[$365 >> 2] = $368;
    $$pre$phi$i$i27Z2D = $365;
   }
  }
  HEAP32[(HEAP32[$$pre$phi$i$i27Z2D >> 2] | 0) + ($354 << 2) >> 2] = 47;
  HEAP32[$9 >> 2] = (HEAP32[$9 >> 2] | 0) + 1;
 } while (0);
 $378 = HEAP32[$9 >> 2] | 0;
 $379 = $378 + 1 | 0;
 $380 = HEAP32[$12 >> 2] | 0;
 if ($379 >>> 0 < $380 >>> 0) $$pre$phi$i$i33Z2D = $doc + 6728 | 0; else {
  $buflen$0$i$i$i32 = ($380 | 0) == 0 ? 256 : $380;
  while (1) if ($buflen$0$i$i$i32 >>> 0 > $379 >>> 0) {
   $buflen$0$i$i$i32$lcssa = $buflen$0$i$i$i32;
   break;
  } else $buflen$0$i$i$i32 = $buflen$0$i$i$i32 << 1;
  $385 = HEAP32[$0 >> 2] | 0;
  $389 = $doc + 6728 | 0;
  $392 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$385 >> 2] | 0) + 4 >> 2] & 15]($385, HEAP32[$389 >> 2] | 0, $buflen$0$i$i$i32$lcssa << 2) | 0;
  if (!$392) $$pre$phi$i$i33Z2D = $389; else {
   $394 = HEAP32[$12 >> 2] | 0;
   _memset($392 + ($394 << 2) | 0, 0, $buflen$0$i$i$i32$lcssa - $394 << 2 | 0) | 0;
   HEAP32[$12 >> 2] = $buflen$0$i$i$i32$lcssa;
   HEAP32[$389 >> 2] = $392;
   $$pre$phi$i$i33Z2D = $389;
  }
 }
 HEAP32[(HEAP32[$$pre$phi$i$i33Z2D >> 2] | 0) + ($378 << 2) >> 2] = 62;
 HEAP32[$9 >> 2] = (HEAP32[$9 >> 2] | 0) + 1;
 if ((HEAP32[$35 >> 2] | 0) == 7) {
  L172 : do if ((_prvTidyHTMLVersion($doc) | 0) == 131072) {
   $407 = HEAP32[$node + 28 >> 2] | 0;
   if ($407 | 0) switch (HEAP32[$407 >> 2] | 0) {
   case 120:
   case 149:
   case 145:
   case 81:
   case 68:
   case 62:
   case 53:
   case 57:
   case 52:
   case 47:
   case 34:
   case 23:
   case 128:
   case 17:
   case 9:
   case 7:
    {
     break L172;
     break;
    }
   default:
    {}
   }
   _PPrintEndTag($doc, HEAP32[$7 >> 2] | 0);
  } while (0);
  if ($324 | (HEAP32[$35 >> 2] | 0) != 7) label = 126; else if (!(($mode & 1 | 0) == 0 & (_prvTidyHTMLVersion($doc) | 0) == 131072)) {
   STACKTOP = sp;
   return;
  }
 } else label = 126;
 if ((label | 0) == 126) if ($mode & 1 | 0) {
  STACKTOP = sp;
  return;
 }
 $416 = HEAP32[$doc + 80 >> 2] | 0;
 $$idx$i = $doc + 6752 | 0;
 $$idx$val$i = HEAP32[$$idx$i >> 2] | 0;
 if (((($$idx$val$i | 0) < 0 ? 0 : $$idx$val$i) + (HEAP32[$9 >> 2] | 0) | 0) >>> 0 >= $416 >>> 0) {
  _WrapLine($doc);
  if ((HEAP32[$$idx$i >> 2] | 0) < 0) HEAP32[$$idx$i >> 2] = $indent;
 }
 $424 = HEAP32[$9 >> 2] | 0;
 $428 = ($mode & 8 | 0) != 0;
 if (($424 + $indent | 0) >>> 0 < $416 >>> 0) {
  if ($428) {
   STACKTOP = sp;
   return;
  }
  if (_prvTidynodeCMIsInline($node) | 0) {
   if (!$node) {
    STACKTOP = sp;
    return;
   }
   $433 = HEAP32[$node + 28 >> 2] | 0;
   if (!$433) {
    STACKTOP = sp;
    return;
   }
   if ((HEAP32[$433 >> 2] | 0) != 17) {
    STACKTOP = sp;
    return;
   }
  }
  $438 = HEAP32[$doc + 68 >> 2] | 0;
  if (!(_AfterSpaceImp($438, $node, _prvTidynodeCMIsEmpty($node) | 0) | 0)) {
   STACKTOP = sp;
   return;
  }
  HEAP32[$doc + 6740 >> 2] = HEAP32[$9 >> 2];
  STACKTOP = sp;
  return;
 }
 do if ($428) $455 = $424; else {
  if ($node | 0) {
   $446 = HEAP32[$node + 28 >> 2] | 0;
   if ($446 | 0) if ((HEAP32[$446 >> 2] | 0) == 17) {
    $455 = $424;
    break;
   }
  }
  $451 = HEAP32[$doc + 68 >> 2] | 0;
  if (!(_AfterSpaceImp($451, $node, _prvTidynodeCMIsEmpty($node) | 0) | 0)) {
   STACKTOP = sp;
   return;
  } else {
   $455 = HEAP32[$9 >> 2] | 0;
   break;
  }
 } while (0);
 if ($455 | 0) {
  _PFlushLineImpl($doc);
  if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
   _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
   $462 = $doc + 6744 | 0;
   HEAP32[$462 >> 2] = (HEAP32[$462 >> 2] | 0) + 1;
  }
 }
 if ((HEAP32[$$idx$i >> 2] | 0) == ($indent | 0)) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$$idx$i >> 2] = $indent;
 STACKTOP = sp;
 return;
}

function _PPrintAttrValue($doc, $indent, $value, $delim, $wrappable, $scriptAttr) {
 $doc = $doc | 0;
 $indent = $indent | 0;
 $value = $value | 0;
 $delim = $delim | 0;
 $wrappable = $wrappable | 0;
 $scriptAttr = $scriptAttr | 0;
 var $$ = 0, $$063 = 0, $$1 = 0, $$2 = 0, $$67 = 0, $$68 = 0, $$delim = 0, $$idx$i = 0, $$idx$val = 0, $$idx$val$i = 0, $$idx1$val$i = 0, $$idx2$val$i = 0, $$idx3$val$i$i = 0, $$idx5$val$i$i = 0, $$pre$i$i33 = 0, $$pre$i$i37 = 0, $$pre$i$i53 = 0, $$pre$phi$i$i16Z2D = 0, $$pre$phi$i$i22Z2D = 0, $$pre$phi$i$iZ2D = 0, $0 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $111 = 0, $112 = 0, $114 = 0, $115 = 0, $116 = 0, $118 = 0, $124 = 0, $126 = 0, $127 = 0, $13 = 0, $130 = 0, $134 = 0, $136 = 0, $14 = 0, $147 = 0, $15 = 0, $158 = 0, $16 = 0, $164 = 0, $165 = 0, $169 = 0, $17 = 0, $170 = 0, $172 = 0, $173 = 0, $174 = 0, $180 = 0, $181 = 0, $182 = 0, $189 = 0, $190 = 0, $193 = 0, $195 = 0, $198 = 0, $2 = 0, $204 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $210 = 0, $211 = 0, $216 = 0, $22 = 0, $222 = 0, $224 = 0, $238 = 0, $239 = 0, $240 = 0, $241 = 0, $246 = 0, $252 = 0, $254 = 0, $26 = 0, $265 = 0, $266 = 0, $271 = 0, $277 = 0, $279 = 0, $287 = 0, $289 = 0, $29 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $304 = 0, $31 = 0, $310 = 0, $312 = 0, $323 = 0, $324 = 0, $329 = 0, $335 = 0, $337 = 0, $345 = 0, $347 = 0, $353 = 0, $354 = 0, $355 = 0, $367 = 0, $374 = 0, $375 = 0, $376 = 0, $38 = 0, $381 = 0, $385 = 0, $388 = 0, $390 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $4 = 0, $47 = 0, $49 = 0, $53 = 0, $63 = 0, $64 = 0, $65 = 0, $70 = 0, $74 = 0, $77 = 0, $79 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $94 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $buflen$0$i$i$i = 0, $buflen$0$i$i$i$lcssa = 0, $buflen$0$i$i$i15 = 0, $buflen$0$i$i$i15$lcssa = 0, $buflen$0$i$i$i21 = 0, $buflen$0$i$i$i21$lcssa = 0, $buflen$0$i$i$i27 = 0, $buflen$0$i$i$i27$lcssa = 0, $buflen$0$i$i$i32 = 0, $buflen$0$i$i$i32$lcssa = 0, $buflen$0$i$i$i35 = 0, $buflen$0$i$i$i35$lcssa = 0, $buflen$0$i$i$i46 = 0, $buflen$0$i$i$i46$lcssa = 0, $buflen$0$i$i$i51 = 0, $buflen$0$i$i$i51$lcssa = 0, $c = 0, $i$08$i = 0, $i$17$i = 0, $ix$01$i$i = 0, $ix$01$i$i39 = 0, $ix$01$i$i55 = 0, $mode$0 = 0, $or$cond5 = 0, $or$cond9 = 0, $p$03$i$i = 0, $pprint$idx1$val$i$i = 0, $q$04$i$i = 0, $q$1$ph$i$i = 0, $q$12$i$i = 0, $storemerge$i$i = 0, $strStart$062 = 0, $strStart$1 = 0, $strStart$2 = 0, $strStart$3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 $0 = $doc + 6724 | 0;
 $2 = HEAP32[$doc + 260 >> 2] | 0;
 $3 = ($wrappable | 0) != 0;
 $$ = $3 ? 4 : 5;
 $4 = ($value | 0) != 0;
 L1 : do if ($4) if ((HEAP8[$value >> 0] | 0) == 60) {
  switch (HEAP8[$value + 1 >> 0] | 0) {
  case 64:
  case 37:
   break;
  default:
   if (_prvTidytmbstrncmp($value, 310822, 5) | 0) {
    $mode$0 = $$;
    break L1;
   }
  }
  $mode$0 = $$ | 16;
 } else $mode$0 = $$; else $mode$0 = $$; while (0);
 $$delim = ($delim | 0) == 0 ? 34 : $delim;
 $13 = $doc + 6736 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $14 + 1 | 0;
 $16 = $doc + 6732 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 if ($15 >>> 0 < $17 >>> 0) $$pre$phi$i$iZ2D = $doc + 6728 | 0; else {
  $buflen$0$i$i$i = ($17 | 0) == 0 ? 256 : $17;
  while (1) if ($buflen$0$i$i$i >>> 0 > $15 >>> 0) {
   $buflen$0$i$i$i$lcssa = $buflen$0$i$i$i;
   break;
  } else $buflen$0$i$i$i = $buflen$0$i$i$i << 1;
  $22 = HEAP32[$0 >> 2] | 0;
  $26 = $doc + 6728 | 0;
  $29 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$22 >> 2] | 0) + 4 >> 2] & 15]($22, HEAP32[$26 >> 2] | 0, $buflen$0$i$i$i$lcssa << 2) | 0;
  if (!$29) $$pre$phi$i$iZ2D = $26; else {
   $31 = HEAP32[$16 >> 2] | 0;
   _memset($29 + ($31 << 2) | 0, 0, $buflen$0$i$i$i$lcssa - $31 << 2 | 0) | 0;
   HEAP32[$16 >> 2] = $buflen$0$i$i$i$lcssa;
   HEAP32[$26 >> 2] = $29;
   $$pre$phi$i$iZ2D = $26;
  }
 }
 HEAP32[(HEAP32[$$pre$phi$i$iZ2D >> 2] | 0) + ($14 << 2) >> 2] = 61;
 $38 = (HEAP32[$13 >> 2] | 0) + 1 | 0;
 HEAP32[$13 >> 2] = $38;
 if (!(HEAP32[$doc + 172 >> 2] | 0)) label = 14; else if (HEAP32[$doc + 176 >> 2] | 0) label = 14;
 if ((label | 0) == 14) {
  $47 = HEAP32[$doc + 80 >> 2] | 0;
  if (($38 + $indent | 0) >>> 0 < $47 >>> 0) {
   $49 = $doc + 6752 | 0;
   if ((HEAP32[$49 >> 2] | 0) < 0) HEAP32[$49 >> 2] = $indent;
   HEAP32[$doc + 6740 >> 2] = $38;
  } else {
   $53 = $doc + 6748 | 0;
   if (!(HEAP32[$53 >> 2] | 0)) {
    HEAP32[$doc + 6764 >> 2] = $indent;
    HEAP32[$53 >> 2] = 1;
   }
  }
  $$idx$i = $doc + 6752 | 0;
  $$idx$val$i = HEAP32[$$idx$i >> 2] | 0;
  if (((($$idx$val$i | 0) < 0 ? 0 : $$idx$val$i) + $38 | 0) >>> 0 >= $47 >>> 0) {
   _WrapLine($doc);
   if ((HEAP32[$$idx$i >> 2] | 0) < 0) HEAP32[$$idx$i >> 2] = $indent;
  }
 }
 $63 = HEAP32[$13 >> 2] | 0;
 $64 = $63 + 1 | 0;
 $65 = HEAP32[$16 >> 2] | 0;
 if ($64 >>> 0 < $65 >>> 0) $$pre$phi$i$i22Z2D = $doc + 6728 | 0; else {
  $buflen$0$i$i$i21 = ($65 | 0) == 0 ? 256 : $65;
  while (1) if ($buflen$0$i$i$i21 >>> 0 > $64 >>> 0) {
   $buflen$0$i$i$i21$lcssa = $buflen$0$i$i$i21;
   break;
  } else $buflen$0$i$i$i21 = $buflen$0$i$i$i21 << 1;
  $70 = HEAP32[$0 >> 2] | 0;
  $74 = $doc + 6728 | 0;
  $77 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$70 >> 2] | 0) + 4 >> 2] & 15]($70, HEAP32[$74 >> 2] | 0, $buflen$0$i$i$i21$lcssa << 2) | 0;
  if (!$77) $$pre$phi$i$i22Z2D = $74; else {
   $79 = HEAP32[$16 >> 2] | 0;
   _memset($77 + ($79 << 2) | 0, 0, $buflen$0$i$i$i21$lcssa - $79 << 2 | 0) | 0;
   HEAP32[$16 >> 2] = $buflen$0$i$i$i21$lcssa;
   HEAP32[$74 >> 2] = $77;
   $$pre$phi$i$i22Z2D = $74;
  }
 }
 HEAP32[(HEAP32[$$pre$phi$i$i22Z2D >> 2] | 0) + ($63 << 2) >> 2] = $$delim;
 $86 = (HEAP32[$13 >> 2] | 0) + 1 | 0;
 HEAP32[$13 >> 2] = $86;
 if ($4) {
  $87 = $doc + 80 | 0;
  $88 = HEAP32[$87 >> 2] | 0;
  $89 = $doc + 6748 | 0;
  HEAP32[$doc + 6752 + ((HEAP32[$89 >> 2] | 0) * 12 | 0) + 4 >> 2] = $86;
  HEAP32[$doc + 6752 + ((HEAP32[$89 >> 2] | 0) * 12 | 0) + 8 >> 2] = -1;
  $94 = HEAP8[$value >> 0] | 0;
  if ($94 << 24 >> 24) {
   $96 = $doc + 6752 | 0;
   $97 = $doc + 6740 | 0;
   $98 = $doc + 6764 | 0;
   $99 = $doc + 6760 | 0;
   $100 = $doc + 6772 | 0;
   $101 = $doc + 6756 | 0;
   $102 = $doc + 6768 | 0;
   $103 = $doc + 284 | 0;
   $104 = $doc + 6780 | 0;
   $105 = $doc + 6744 | 0;
   $106 = $doc + 6728 | 0;
   $107 = $doc + 6752 | 0;
   $108 = $doc + 6764 | 0;
   $109 = $doc + 244 | 0;
   $111 = ($scriptAttr | 0) != 0;
   $112 = ($2 | 0) != 0;
   $or$cond5 = ($$delim | 0) == 39 & $111 & $112;
   $or$cond9 = ($$delim | 0) == 34 & $111 & $112;
   $114 = $doc + 324 | 0;
   $$063 = $value;
   $116 = $94;
   $strStart$062 = -1;
   while (1) {
    $115 = $116 << 24 >> 24;
    HEAP32[$c >> 2] = $115;
    if ($3 & $116 << 24 >> 24 == 32) {
     $118 = HEAP32[$13 >> 2] | 0;
     if (($118 + $indent | 0) >>> 0 < (HEAP32[$87 >> 2] | 0) >>> 0) {
      if ((HEAP32[$96 >> 2] | 0) < 0) HEAP32[$96 >> 2] = $indent;
      HEAP32[$97 >> 2] = $118;
      $134 = HEAP32[$89 >> 2] | 0;
     } else {
      $124 = HEAP32[$89 >> 2] | 0;
      if (!$124) {
       HEAP32[$98 >> 2] = $indent;
       HEAP32[$89 >> 2] = 1;
       $126 = HEAP32[$97 >> 2] | 0;
       $127 = HEAP32[$99 >> 2] | 0;
       if (($127 | 0) > ($126 | 0)) {
        HEAP32[$100 >> 2] = $127 - $126;
        HEAP32[$99 >> 2] = -1;
       }
       $130 = HEAP32[$101 >> 2] | 0;
       if (($130 | 0) > ($126 | 0)) {
        HEAP32[$102 >> 2] = $130 - $126;
        HEAP32[$101 >> 2] = -1;
        $134 = 1;
       } else $134 = 1;
      } else $134 = $124;
     }
     HEAP32[$doc + 6752 + ($134 * 12 | 0) + 4 >> 2] = $86;
     HEAP32[$doc + 6752 + ($134 * 12 | 0) + 8 >> 2] = $strStart$062;
    }
    if ($3) {
     $136 = HEAP32[$97 >> 2] | 0;
     if (!$136) $204 = $115; else {
      $$idx$val = HEAP32[$96 >> 2] | 0;
      if (((($$idx$val | 0) < 0 ? 0 : $$idx$val) + (HEAP32[$13 >> 2] | 0) | 0) >>> 0 < $88 >>> 0) $204 = $115; else {
       if (($$idx$val | 0) > 0) {
        $$idx3$val$i$i = HEAP32[$101 >> 2] | 0;
        if (!$$idx3$val$i$i) $147 = 0; else $147 = ($$idx3$val$i$i | 0) < 1 | ($$idx3$val$i$i | 0) >= ($136 | 0);
        if ((HEAP32[$103 >> 2] | 0) != 0 | $147) {
         $$idx5$val$i$i = HEAP32[$99 >> 2] | 0;
         if (!$$idx5$val$i$i) {
          $i$17$i = 0;
          label = 54;
         } else if (($$idx5$val$i$i | 0) < 1 | ($$idx5$val$i$i | 0) >= ($136 | 0)) {
          $i$08$i = 0;
          do {
           _prvTidyWriteChar(HEAP32[16017] | 0, HEAP32[$104 >> 2] | 0);
           $i$08$i = $i$08$i + 1 | 0;
          } while (($i$08$i | 0) != ($$idx$val | 0));
          if (!(HEAP32[$97 >> 2] | 0)) $$idx1$val$i = 0; else {
           $i$17$i = 0;
           label = 54;
          }
         } else {
          $i$17$i = 0;
          label = 54;
         }
        } else {
         $i$17$i = 0;
         label = 54;
        }
       } else {
        $i$17$i = 0;
        label = 54;
       }
       if ((label | 0) == 54) while (1) {
        label = 0;
        _prvTidyWriteChar(HEAP32[(HEAP32[$106 >> 2] | 0) + ($i$17$i << 2) >> 2] | 0, HEAP32[$104 >> 2] | 0);
        $i$17$i = $i$17$i + 1 | 0;
        $158 = HEAP32[$97 >> 2] | 0;
        if ($i$17$i >>> 0 >= $158 >>> 0) {
         $$idx1$val$i = $158;
         break;
        } else label = 54;
       }
       $$idx2$val$i = HEAP32[$99 >> 2] | 0;
       if (!$$idx2$val$i) {
        $165 = HEAP32[$104 >> 2] | 0;
        label = 58;
       } else {
        $164 = HEAP32[$104 >> 2] | 0;
        if (($$idx2$val$i | 0) > 0 & ($$idx2$val$i | 0) < ($$idx1$val$i | 0)) {
         $165 = $164;
         label = 58;
        } else _prvTidyWriteChar(32, $164);
       }
       if ((label | 0) == 58) {
        label = 0;
        _prvTidyWriteChar(92, $165);
       }
       _prvTidyWriteChar(10, HEAP32[$104 >> 2] | 0);
       HEAP32[$105 >> 2] = (HEAP32[$105 >> 2] | 0) + 1;
       $169 = HEAP32[$13 >> 2] | 0;
       $170 = HEAP32[$97 >> 2] | 0;
       if ($169 >>> 0 > $170 >>> 0) {
        $172 = HEAP32[$106 >> 2] | 0;
        $173 = $172 + ($170 << 2) | 0;
        $174 = $172 + ($169 << 2) | 0;
        $pprint$idx1$val$i$i = HEAP32[$101 >> 2] | 0;
        L87 : do if (!$pprint$idx1$val$i$i) {
         $398 = $170;
         $q$1$ph$i$i = $173;
        } else {
         if (($170 | 0) < ($169 | 0) & (($pprint$idx1$val$i$i | 0) >= ($170 | 0) | ($pprint$idx1$val$i$i | 0) < 1)) {
          $182 = $170;
          $q$04$i$i = $173;
         } else {
          $398 = $170;
          $q$1$ph$i$i = $173;
          break;
         }
         while (1) {
          if ((HEAP32[$q$04$i$i >> 2] | 0) != 32) {
           $398 = $182;
           $q$1$ph$i$i = $q$04$i$i;
           break L87;
          }
          $180 = $q$04$i$i + 4 | 0;
          $181 = $182 + 1 | 0;
          HEAP32[$97 >> 2] = $181;
          if ($180 >>> 0 < $174 >>> 0) {
           $182 = $181;
           $q$04$i$i = $180;
          } else {
           $398 = $181;
           $q$1$ph$i$i = $180;
           break;
          }
         }
        } while (0);
        if ($q$1$ph$i$i >>> 0 < $174 >>> 0) {
         $p$03$i$i = $172;
         $q$12$i$i = $q$1$ph$i$i;
         while (1) {
          HEAP32[$p$03$i$i >> 2] = HEAP32[$q$12$i$i >> 2];
          $q$12$i$i = $q$12$i$i + 4 | 0;
          if ($q$12$i$i >>> 0 >= $174 >>> 0) break; else $p$03$i$i = $p$03$i$i + 4 | 0;
         }
         $189 = HEAP32[$97 >> 2] | 0;
         $190 = HEAP32[$13 >> 2] | 0;
        } else {
         $189 = $398;
         $190 = $169;
        }
        $193 = $189;
        $storemerge$i$i = $190 - $189 | 0;
       } else {
        $193 = $170;
        $storemerge$i$i = 0;
       }
       HEAP32[$13 >> 2] = $storemerge$i$i;
       if (HEAP32[$89 >> 2] | 0) {
        HEAP32[$107 >> 2] = HEAP32[$108 >> 2];
        HEAP32[$107 + 4 >> 2] = HEAP32[$108 + 4 >> 2];
        HEAP32[$107 + 8 >> 2] = HEAP32[$108 + 8 >> 2];
        HEAP32[$108 >> 2] = -1;
        HEAP32[$102 >> 2] = -1;
        HEAP32[$100 >> 2] = -1;
       }
       $195 = HEAP32[$99 >> 2] | 0;
       do if (!$193) {
        if (($195 | 0) > 0) HEAP32[$99 >> 2] = 0;
        if ((HEAP32[$101 >> 2] | 0) <= 0) break;
        HEAP32[$101 >> 2] = 0;
       } else {
        if (($195 | 0) > ($193 | 0)) HEAP32[$99 >> 2] = $195 - $193;
        $198 = HEAP32[$101 >> 2] | 0;
        if (($198 | 0) <= ($193 | 0)) break;
        HEAP32[$101 >> 2] = $198 - $193;
       } while (0);
       HEAP32[$89 >> 2] = 0;
       HEAP32[$97 >> 2] = 0;
       $204 = HEAP32[$c >> 2] | 0;
      }
     }
    } else $204 = $115;
    $206 = ($204 | 0) == 34;
    do if (($204 | 0) == ($$delim | 0)) {
     $207 = $206 ? 310738 : 310745;
     $208 = HEAP32[$13 >> 2] | 0;
     $209 = _prvTidytmbstrlen($207) | 0;
     $210 = $209 + $208 | 0;
     $211 = HEAP32[$16 >> 2] | 0;
     if ($210 >>> 0 >= $211 >>> 0) {
      $buflen$0$i$i$i32 = ($211 | 0) == 0 ? 256 : $211;
      while (1) if ($buflen$0$i$i$i32 >>> 0 > $210 >>> 0) {
       $buflen$0$i$i$i32$lcssa = $buflen$0$i$i$i32;
       break;
      } else $buflen$0$i$i$i32 = $buflen$0$i$i$i32 << 1;
      $216 = HEAP32[$0 >> 2] | 0;
      $222 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$216 >> 2] | 0) + 4 >> 2] & 15]($216, HEAP32[$106 >> 2] | 0, $buflen$0$i$i$i32$lcssa << 2) | 0;
      if ($222 | 0) {
       $224 = HEAP32[$16 >> 2] | 0;
       _memset($222 + ($224 << 2) | 0, 0, $buflen$0$i$i$i32$lcssa - $224 << 2 | 0) | 0;
       HEAP32[$16 >> 2] = $buflen$0$i$i$i32$lcssa;
       HEAP32[$106 >> 2] = $222;
      }
     }
     if ($209 | 0) {
      $$pre$i$i33 = HEAP32[$106 >> 2] | 0;
      $ix$01$i$i = 0;
      do {
       HEAP32[$$pre$i$i33 + ($ix$01$i$i + $208 << 2) >> 2] = HEAP8[$207 + $ix$01$i$i >> 0];
       $ix$01$i$i = $ix$01$i$i + 1 | 0;
      } while (($ix$01$i$i | 0) != ($209 | 0));
     }
     HEAP32[$13 >> 2] = $210;
     $$2 = $$063 + 1 | 0;
     $strStart$3 = $strStart$062;
    } else {
     if ($206) {
      $238 = HEAP32[$13 >> 2] | 0;
      if (!(HEAP32[$109 >> 2] | 0)) {
       $265 = $238 + 1 | 0;
       $266 = HEAP32[$16 >> 2] | 0;
       if ($265 >>> 0 >= $266 >>> 0) {
        $buflen$0$i$i$i46 = ($266 | 0) == 0 ? 256 : $266;
        while (1) if ($buflen$0$i$i$i46 >>> 0 > $265 >>> 0) {
         $buflen$0$i$i$i46$lcssa = $buflen$0$i$i$i46;
         break;
        } else $buflen$0$i$i$i46 = $buflen$0$i$i$i46 << 1;
        $271 = HEAP32[$0 >> 2] | 0;
        $277 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$271 >> 2] | 0) + 4 >> 2] & 15]($271, HEAP32[$106 >> 2] | 0, $buflen$0$i$i$i46$lcssa << 2) | 0;
        if ($277 | 0) {
         $279 = HEAP32[$16 >> 2] | 0;
         _memset($277 + ($279 << 2) | 0, 0, $buflen$0$i$i$i46$lcssa - $279 << 2 | 0) | 0;
         HEAP32[$16 >> 2] = $buflen$0$i$i$i46$lcssa;
         HEAP32[$106 >> 2] = $277;
        }
       }
       HEAP32[(HEAP32[$106 >> 2] | 0) + ($238 << 2) >> 2] = 34;
       $287 = (HEAP32[$13 >> 2] | 0) + 1 | 0;
      } else {
       $239 = _prvTidytmbstrlen(310738) | 0;
       $240 = $239 + $238 | 0;
       $241 = HEAP32[$16 >> 2] | 0;
       if ($240 >>> 0 >= $241 >>> 0) {
        $buflen$0$i$i$i35 = ($241 | 0) == 0 ? 256 : $241;
        while (1) if ($buflen$0$i$i$i35 >>> 0 > $240 >>> 0) {
         $buflen$0$i$i$i35$lcssa = $buflen$0$i$i$i35;
         break;
        } else $buflen$0$i$i$i35 = $buflen$0$i$i$i35 << 1;
        $246 = HEAP32[$0 >> 2] | 0;
        $252 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$246 >> 2] | 0) + 4 >> 2] & 15]($246, HEAP32[$106 >> 2] | 0, $buflen$0$i$i$i35$lcssa << 2) | 0;
        if ($252 | 0) {
         $254 = HEAP32[$16 >> 2] | 0;
         _memset($252 + ($254 << 2) | 0, 0, $buflen$0$i$i$i35$lcssa - $254 << 2 | 0) | 0;
         HEAP32[$16 >> 2] = $buflen$0$i$i$i35$lcssa;
         HEAP32[$106 >> 2] = $252;
        }
       }
       if (!$239) $287 = $240; else {
        $$pre$i$i37 = HEAP32[$106 >> 2] | 0;
        $ix$01$i$i39 = 0;
        do {
         HEAP32[$$pre$i$i37 + ($ix$01$i$i39 + $238 << 2) >> 2] = HEAP8[310738 + $ix$01$i$i39 >> 0];
         $ix$01$i$i39 = $ix$01$i$i39 + 1 | 0;
        } while (($ix$01$i$i39 | 0) != ($239 | 0));
        $287 = $240;
       }
      }
      HEAP32[$13 >> 2] = $287;
      if ($or$cond5) {
       $289 = $doc + 6752 + ((HEAP32[$89 >> 2] | 0) * 12 | 0) + 8 | 0;
       $$67 = (HEAP32[$289 >> 2] | 0) > -1 ? -1 : $287;
       HEAP32[$289 >> 2] = $$67;
       $strStart$1 = $$67;
      } else $strStart$1 = $strStart$062;
      $$2 = $$063 + 1 | 0;
      $strStart$3 = $strStart$1;
      break;
     }
     if (($204 | 0) != 39) {
      if ($204 >>> 0 > 127) {
       $353 = $$063 + (_prvTidyGetUTF8($$063, $c) | 0) | 0;
       $$1 = $353;
       $355 = HEAP32[$c >> 2] | 0;
      } else {
       $$1 = $$063;
       $355 = $204;
      }
      $354 = $$1 + 1 | 0;
      if (($355 | 0) != 10) {
       _PPrintChar($doc, $355, $mode$0);
       $$2 = $354;
       $strStart$3 = $strStart$062;
       break;
      }
      if (($strStart$062 | 0) < 0) $367 = HEAP32[$114 >> 2] | 0 ? 0 : $indent; else $367 = 0;
      if (HEAP32[$13 >> 2] | 0) _PFlushLineImpl($doc);
      _prvTidyWriteChar(10, HEAP32[$104 >> 2] | 0);
      HEAP32[$105 >> 2] = (HEAP32[$105 >> 2] | 0) + 1;
      if ((HEAP32[$96 >> 2] | 0) == ($367 | 0)) {
       $$2 = $354;
       $strStart$3 = $strStart$062;
       break;
      }
      HEAP32[$96 >> 2] = $367;
      $$2 = $354;
      $strStart$3 = $strStart$062;
      break;
     }
     $296 = HEAP32[$13 >> 2] | 0;
     if (!(HEAP32[$109 >> 2] | 0)) {
      $323 = $296 + 1 | 0;
      $324 = HEAP32[$16 >> 2] | 0;
      if ($323 >>> 0 >= $324 >>> 0) {
       $buflen$0$i$i$i27 = ($324 | 0) == 0 ? 256 : $324;
       while (1) if ($buflen$0$i$i$i27 >>> 0 > $323 >>> 0) {
        $buflen$0$i$i$i27$lcssa = $buflen$0$i$i$i27;
        break;
       } else $buflen$0$i$i$i27 = $buflen$0$i$i$i27 << 1;
       $329 = HEAP32[$0 >> 2] | 0;
       $335 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$329 >> 2] | 0) + 4 >> 2] & 15]($329, HEAP32[$106 >> 2] | 0, $buflen$0$i$i$i27$lcssa << 2) | 0;
       if ($335 | 0) {
        $337 = HEAP32[$16 >> 2] | 0;
        _memset($335 + ($337 << 2) | 0, 0, $buflen$0$i$i$i27$lcssa - $337 << 2 | 0) | 0;
        HEAP32[$16 >> 2] = $buflen$0$i$i$i27$lcssa;
        HEAP32[$106 >> 2] = $335;
       }
      }
      HEAP32[(HEAP32[$106 >> 2] | 0) + ($296 << 2) >> 2] = 39;
      $345 = (HEAP32[$13 >> 2] | 0) + 1 | 0;
     } else {
      $297 = _prvTidytmbstrlen(310745) | 0;
      $298 = $297 + $296 | 0;
      $299 = HEAP32[$16 >> 2] | 0;
      if ($298 >>> 0 >= $299 >>> 0) {
       $buflen$0$i$i$i51 = ($299 | 0) == 0 ? 256 : $299;
       while (1) if ($buflen$0$i$i$i51 >>> 0 > $298 >>> 0) {
        $buflen$0$i$i$i51$lcssa = $buflen$0$i$i$i51;
        break;
       } else $buflen$0$i$i$i51 = $buflen$0$i$i$i51 << 1;
       $304 = HEAP32[$0 >> 2] | 0;
       $310 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$304 >> 2] | 0) + 4 >> 2] & 15]($304, HEAP32[$106 >> 2] | 0, $buflen$0$i$i$i51$lcssa << 2) | 0;
       if ($310 | 0) {
        $312 = HEAP32[$16 >> 2] | 0;
        _memset($310 + ($312 << 2) | 0, 0, $buflen$0$i$i$i51$lcssa - $312 << 2 | 0) | 0;
        HEAP32[$16 >> 2] = $buflen$0$i$i$i51$lcssa;
        HEAP32[$106 >> 2] = $310;
       }
      }
      if (!$297) $345 = $298; else {
       $$pre$i$i53 = HEAP32[$106 >> 2] | 0;
       $ix$01$i$i55 = 0;
       do {
        HEAP32[$$pre$i$i53 + ($ix$01$i$i55 + $296 << 2) >> 2] = HEAP8[310745 + $ix$01$i$i55 >> 0];
        $ix$01$i$i55 = $ix$01$i$i55 + 1 | 0;
       } while (($ix$01$i$i55 | 0) != ($297 | 0));
       $345 = $298;
      }
     }
     HEAP32[$13 >> 2] = $345;
     if ($or$cond9) {
      $347 = $doc + 6752 + ((HEAP32[$89 >> 2] | 0) * 12 | 0) + 8 | 0;
      $$68 = (HEAP32[$347 >> 2] | 0) > -1 ? -1 : $345;
      HEAP32[$347 >> 2] = $$68;
      $strStart$2 = $$68;
     } else $strStart$2 = $strStart$062;
     $$2 = $$063 + 1 | 0;
     $strStart$3 = $strStart$2;
    } while (0);
    $116 = HEAP8[$$2 >> 0] | 0;
    if (!($116 << 24 >> 24)) break; else {
     $$063 = $$2;
     $strStart$062 = $strStart$3;
    }
   }
  }
  HEAP32[$doc + 6752 + ((HEAP32[$89 >> 2] | 0) * 12 | 0) + 4 >> 2] = -1;
  HEAP32[$doc + 6752 + ((HEAP32[$89 >> 2] | 0) * 12 | 0) + 8 >> 2] = -1;
  $375 = HEAP32[$13 >> 2] | 0;
 } else $375 = $86;
 $374 = $375 + 1 | 0;
 $376 = HEAP32[$16 >> 2] | 0;
 if ($374 >>> 0 < $376 >>> 0) {
  $$pre$phi$i$i16Z2D = $doc + 6728 | 0;
  $394 = HEAP32[$$pre$phi$i$i16Z2D >> 2] | 0;
  $395 = $394 + ($375 << 2) | 0;
  HEAP32[$395 >> 2] = $$delim;
  $396 = HEAP32[$13 >> 2] | 0;
  $397 = $396 + 1 | 0;
  HEAP32[$13 >> 2] = $397;
  STACKTOP = sp;
  return;
 }
 $buflen$0$i$i$i15 = ($376 | 0) == 0 ? 256 : $376;
 while (1) if ($buflen$0$i$i$i15 >>> 0 > $374 >>> 0) {
  $buflen$0$i$i$i15$lcssa = $buflen$0$i$i$i15;
  break;
 } else $buflen$0$i$i$i15 = $buflen$0$i$i$i15 << 1;
 $381 = HEAP32[$0 >> 2] | 0;
 $385 = $doc + 6728 | 0;
 $388 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$381 >> 2] | 0) + 4 >> 2] & 15]($381, HEAP32[$385 >> 2] | 0, $buflen$0$i$i$i15$lcssa << 2) | 0;
 if (!$388) {
  $$pre$phi$i$i16Z2D = $385;
  $394 = HEAP32[$$pre$phi$i$i16Z2D >> 2] | 0;
  $395 = $394 + ($375 << 2) | 0;
  HEAP32[$395 >> 2] = $$delim;
  $396 = HEAP32[$13 >> 2] | 0;
  $397 = $396 + 1 | 0;
  HEAP32[$13 >> 2] = $397;
  STACKTOP = sp;
  return;
 }
 $390 = HEAP32[$16 >> 2] | 0;
 _memset($388 + ($390 << 2) | 0, 0, $buflen$0$i$i$i15$lcssa - $390 << 2 | 0) | 0;
 HEAP32[$16 >> 2] = $buflen$0$i$i$i15$lcssa;
 HEAP32[$385 >> 2] = $388;
 $$pre$phi$i$i16Z2D = $385;
 $394 = HEAP32[$$pre$phi$i$i16Z2D >> 2] | 0;
 $395 = $394 + ($375 << 2) | 0;
 HEAP32[$395 >> 2] = $$delim;
 $396 = HEAP32[$13 >> 2] | 0;
 $397 = $396 + 1 | 0;
 HEAP32[$13 >> 2] = $397;
 STACKTOP = sp;
 return;
}

function _PPrintDocType($doc, $indent, $node) {
 $doc = $doc | 0;
 $indent = $indent | 0;
 $node = $node | 0;
 var $$phi$trans$insert = 0, $$pre$i$i = 0, $$pre$i$i16 = 0, $$pre$i$i28 = 0, $$pre$i$i50 = 0, $$pre$i$i65 = 0, $$pre$i$i7 = 0, $$pre$phi$i$i38Z2D = 0, $$pre$phi$i$i45Z2D = 0, $$pre$phi$i$i60Z2D = 0, $$pre$phi$i$i75Z2D = 0, $$pre$phi$i$i82Z2D = 0, $$pre$phi$i$i88Z2D = 0, $$pre$phi$i$i95Z2D = 0, $$pre$phi$i$iZ2D = 0, $0 = 0, $1 = 0, $104 = 0, $107 = 0, $108 = 0, $109 = 0, $110 = 0, $115 = 0, $119 = 0, $12 = 0, $122 = 0, $124 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $144 = 0, $148 = 0, $151 = 0, $153 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $169 = 0, $173 = 0, $176 = 0, $178 = 0, $190 = 0, $191 = 0, $192 = 0, $197 = 0, $2 = 0, $201 = 0, $204 = 0, $206 = 0, $212 = 0, $213 = 0, $216 = 0, $217 = 0, $219 = 0, $220 = 0, $221 = 0, $238 = 0, $243 = 0, $245 = 0, $246 = 0, $251 = 0, $255 = 0, $258 = 0, $26 = 0, $260 = 0, $267 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $279 = 0, $283 = 0, $286 = 0, $288 = 0, $29 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $311 = 0, $315 = 0, $318 = 0, $32 = 0, $320 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $336 = 0, $34 = 0, $340 = 0, $343 = 0, $345 = 0, $35 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $364 = 0, $368 = 0, $371 = 0, $373 = 0, $380 = 0, $381 = 0, $384 = 0, $391 = 0, $396 = 0, $397 = 0, $398 = 0, $4 = 0, $403 = 0, $407 = 0, $41 = 0, $410 = 0, $412 = 0, $421 = 0, $422 = 0, $423 = 0, $428 = 0, $432 = 0, $435 = 0, $437 = 0, $444 = 0, $446 = 0, $45 = 0, $451 = 0, $455 = 0, $456 = 0, $461 = 0, $465 = 0, $468 = 0, $470 = 0, $477 = 0, $48 = 0, $484 = 0, $489 = 0, $5 = 0, $50 = 0, $6 = 0, $68 = 0, $7 = 0, $73 = 0, $75 = 0, $76 = 0, $77 = 0, $8 = 0, $82 = 0, $86 = 0, $89 = 0, $91 = 0, $buflen$0$i$i$i = 0, $buflen$0$i$i$i$lcssa = 0, $buflen$0$i$i$i14 = 0, $buflen$0$i$i$i14$lcssa = 0, $buflen$0$i$i$i24 = 0, $buflen$0$i$i$i24$lcssa = 0, $buflen$0$i$i$i26 = 0, $buflen$0$i$i$i26$lcssa = 0, $buflen$0$i$i$i37 = 0, $buflen$0$i$i$i37$lcssa = 0, $buflen$0$i$i$i44 = 0, $buflen$0$i$i$i44$lcssa = 0, $buflen$0$i$i$i48 = 0, $buflen$0$i$i$i48$lcssa = 0, $buflen$0$i$i$i5 = 0, $buflen$0$i$i$i5$lcssa = 0, $buflen$0$i$i$i59 = 0, $buflen$0$i$i$i59$lcssa = 0, $buflen$0$i$i$i63 = 0, $buflen$0$i$i$i63$lcssa = 0, $buflen$0$i$i$i74 = 0, $buflen$0$i$i$i74$lcssa = 0, $buflen$0$i$i$i81 = 0, $buflen$0$i$i$i81$lcssa = 0, $buflen$0$i$i$i87 = 0, $buflen$0$i$i$i87$lcssa = 0, $buflen$0$i$i$i94 = 0, $buflen$0$i$i$i94$lcssa = 0, $i$0 = 0, $ix$01$i$i = 0, $ix$01$i$i18 = 0, $ix$01$i$i30 = 0, $ix$01$i$i52 = 0, $ix$01$i$i67 = 0, $ix$01$i$i9 = 0, label = 0;
 $0 = $doc + 6724 | 0;
 $1 = $doc + 80 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 $4 = HEAP32[$doc + 76 >> 2] | 0;
 $5 = _prvTidyGetAttrByName($node, 310770) | 0;
 $6 = _prvTidyGetAttrByName($node, 310777) | 0;
 $7 = $doc + 6736 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 if (($8 + $indent | 0) >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
  $12 = $doc + 6752 | 0;
  if ((HEAP32[$12 >> 2] | 0) < 0) HEAP32[$12 >> 2] = $indent;
  HEAP32[$doc + 6740 >> 2] = $8;
 } else {
  $16 = $doc + 6748 | 0;
  if (!(HEAP32[$16 >> 2] | 0)) {
   HEAP32[$doc + 6764 >> 2] = $indent;
   HEAP32[$16 >> 2] = 1;
  }
 }
 if ($8 | 0) {
  _PFlushLineImpl($doc);
  if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
   _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
   $26 = $doc + 6744 | 0;
   HEAP32[$26 >> 2] = (HEAP32[$26 >> 2] | 0) + 1;
  }
 }
 $29 = $doc + 6752 | 0;
 if ((HEAP32[$29 >> 2] | 0) != ($indent | 0)) HEAP32[$29 >> 2] = $indent;
 $32 = HEAP32[$7 >> 2] | 0;
 $33 = _prvTidytmbstrlen(310784) | 0;
 $34 = $33 + $32 | 0;
 $35 = $doc + 6732 | 0;
 $36 = HEAP32[$35 >> 2] | 0;
 if ($34 >>> 0 >= $36 >>> 0) {
  $buflen$0$i$i$i = ($36 | 0) == 0 ? 256 : $36;
  while (1) if ($buflen$0$i$i$i >>> 0 > $34 >>> 0) {
   $buflen$0$i$i$i$lcssa = $buflen$0$i$i$i;
   break;
  } else $buflen$0$i$i$i = $buflen$0$i$i$i << 1;
  $41 = HEAP32[$0 >> 2] | 0;
  $45 = $doc + 6728 | 0;
  $48 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$41 >> 2] | 0) + 4 >> 2] & 15]($41, HEAP32[$45 >> 2] | 0, $buflen$0$i$i$i$lcssa << 2) | 0;
  if ($48 | 0) {
   $50 = HEAP32[$35 >> 2] | 0;
   _memset($48 + ($50 << 2) | 0, 0, $buflen$0$i$i$i$lcssa - $50 << 2 | 0) | 0;
   HEAP32[$35 >> 2] = $buflen$0$i$i$i$lcssa;
   HEAP32[$45 >> 2] = $48;
  }
 }
 if ($33 | 0) {
  $$pre$i$i = HEAP32[$doc + 6728 >> 2] | 0;
  $ix$01$i$i = 0;
  do {
   HEAP32[$$pre$i$i + ($ix$01$i$i + $32 << 2) >> 2] = HEAP8[310784 + $ix$01$i$i >> 0];
   $ix$01$i$i = $ix$01$i$i + 1 | 0;
  } while (($ix$01$i$i | 0) != ($33 | 0));
 }
 HEAP32[$7 >> 2] = $34;
 if (($34 + $indent | 0) >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
  if ((HEAP32[$29 >> 2] | 0) < 0) HEAP32[$29 >> 2] = $indent;
  HEAP32[$doc + 6740 >> 2] = $34;
 } else {
  $68 = $doc + 6748 | 0;
  if (!(HEAP32[$68 >> 2] | 0)) {
   HEAP32[$doc + 6764 >> 2] = $indent;
   HEAP32[$68 >> 2] = 1;
  }
 }
 $73 = HEAP32[$node + 32 >> 2] | 0;
 if (!$73) $109 = $34; else {
  $75 = _prvTidytmbstrlen($73) | 0;
  $76 = $75 + $34 | 0;
  $77 = HEAP32[$35 >> 2] | 0;
  if ($76 >>> 0 >= $77 >>> 0) {
   $buflen$0$i$i$i5 = ($77 | 0) == 0 ? 256 : $77;
   while (1) if ($buflen$0$i$i$i5 >>> 0 > $76 >>> 0) {
    $buflen$0$i$i$i5$lcssa = $buflen$0$i$i$i5;
    break;
   } else $buflen$0$i$i$i5 = $buflen$0$i$i$i5 << 1;
   $82 = HEAP32[$0 >> 2] | 0;
   $86 = $doc + 6728 | 0;
   $89 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$82 >> 2] | 0) + 4 >> 2] & 15]($82, HEAP32[$86 >> 2] | 0, $buflen$0$i$i$i5$lcssa << 2) | 0;
   if ($89 | 0) {
    $91 = HEAP32[$35 >> 2] | 0;
    _memset($89 + ($91 << 2) | 0, 0, $buflen$0$i$i$i5$lcssa - $91 << 2 | 0) | 0;
    HEAP32[$35 >> 2] = $buflen$0$i$i$i5$lcssa;
    HEAP32[$86 >> 2] = $89;
   }
  }
  if ($75 | 0) {
   $$pre$i$i7 = HEAP32[$doc + 6728 >> 2] | 0;
   $ix$01$i$i9 = 0;
   do {
    HEAP32[$$pre$i$i7 + ($ix$01$i$i9 + $34 << 2) >> 2] = HEAP8[$73 + $ix$01$i$i9 >> 0];
    $ix$01$i$i9 = $ix$01$i$i9 + 1 | 0;
   } while (($ix$01$i$i9 | 0) != ($75 | 0));
  }
  HEAP32[$7 >> 2] = $76;
  $109 = $76;
 }
 do if (!$5) {
  $489 = $109;
  label = 85;
 } else {
  $104 = $5 + 24 | 0;
  if (!(HEAP32[$104 >> 2] | 0)) {
   $489 = $109;
   label = 85;
  } else {
   $107 = _prvTidytmbstrlen(310795) | 0;
   $108 = $107 + $109 | 0;
   $110 = HEAP32[$35 >> 2] | 0;
   if ($108 >>> 0 >= $110 >>> 0) {
    $buflen$0$i$i$i14 = ($110 | 0) == 0 ? 256 : $110;
    while (1) if ($buflen$0$i$i$i14 >>> 0 > $108 >>> 0) {
     $buflen$0$i$i$i14$lcssa = $buflen$0$i$i$i14;
     break;
    } else $buflen$0$i$i$i14 = $buflen$0$i$i$i14 << 1;
    $115 = HEAP32[$0 >> 2] | 0;
    $119 = $doc + 6728 | 0;
    $122 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$115 >> 2] | 0) + 4 >> 2] & 15]($115, HEAP32[$119 >> 2] | 0, $buflen$0$i$i$i14$lcssa << 2) | 0;
    if ($122 | 0) {
     $124 = HEAP32[$35 >> 2] | 0;
     _memset($122 + ($124 << 2) | 0, 0, $buflen$0$i$i$i14$lcssa - $124 << 2 | 0) | 0;
     HEAP32[$35 >> 2] = $buflen$0$i$i$i14$lcssa;
     HEAP32[$119 >> 2] = $122;
    }
   }
   if ($107 | 0) {
    $$pre$i$i16 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i18 = 0;
    do {
     HEAP32[$$pre$i$i16 + ($ix$01$i$i18 + $109 << 2) >> 2] = HEAP8[310795 + $ix$01$i$i18 >> 0];
     $ix$01$i$i18 = $ix$01$i$i18 + 1 | 0;
    } while (($ix$01$i$i18 | 0) != ($107 | 0));
   }
   HEAP32[$7 >> 2] = $108;
   $136 = $5 + 16 | 0;
   $137 = HEAP32[$136 >> 2] | 0;
   $138 = $108 + 1 | 0;
   $139 = HEAP32[$35 >> 2] | 0;
   if ($138 >>> 0 < $139 >>> 0) $$pre$phi$i$iZ2D = $doc + 6728 | 0; else {
    $buflen$0$i$i$i24 = ($139 | 0) == 0 ? 256 : $139;
    while (1) if ($buflen$0$i$i$i24 >>> 0 > $138 >>> 0) {
     $buflen$0$i$i$i24$lcssa = $buflen$0$i$i$i24;
     break;
    } else $buflen$0$i$i$i24 = $buflen$0$i$i$i24 << 1;
    $144 = HEAP32[$0 >> 2] | 0;
    $148 = $doc + 6728 | 0;
    $151 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$144 >> 2] | 0) + 4 >> 2] & 15]($144, HEAP32[$148 >> 2] | 0, $buflen$0$i$i$i24$lcssa << 2) | 0;
    if (!$151) $$pre$phi$i$iZ2D = $148; else {
     $153 = HEAP32[$35 >> 2] | 0;
     _memset($151 + ($153 << 2) | 0, 0, $buflen$0$i$i$i24$lcssa - $153 << 2 | 0) | 0;
     HEAP32[$35 >> 2] = $buflen$0$i$i$i24$lcssa;
     HEAP32[$148 >> 2] = $151;
     $$pre$phi$i$iZ2D = $148;
    }
   }
   HEAP32[(HEAP32[$$pre$phi$i$iZ2D >> 2] | 0) + ($108 << 2) >> 2] = $137;
   $160 = (HEAP32[$7 >> 2] | 0) + 1 | 0;
   HEAP32[$7 >> 2] = $160;
   $161 = HEAP32[$104 >> 2] | 0;
   $162 = _prvTidytmbstrlen($161) | 0;
   $163 = $162 + $160 | 0;
   $164 = HEAP32[$35 >> 2] | 0;
   if ($163 >>> 0 >= $164 >>> 0) {
    $buflen$0$i$i$i26 = ($164 | 0) == 0 ? 256 : $164;
    while (1) if ($buflen$0$i$i$i26 >>> 0 > $163 >>> 0) {
     $buflen$0$i$i$i26$lcssa = $buflen$0$i$i$i26;
     break;
    } else $buflen$0$i$i$i26 = $buflen$0$i$i$i26 << 1;
    $169 = HEAP32[$0 >> 2] | 0;
    $173 = $doc + 6728 | 0;
    $176 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$169 >> 2] | 0) + 4 >> 2] & 15]($169, HEAP32[$173 >> 2] | 0, $buflen$0$i$i$i26$lcssa << 2) | 0;
    if ($176 | 0) {
     $178 = HEAP32[$35 >> 2] | 0;
     _memset($176 + ($178 << 2) | 0, 0, $buflen$0$i$i$i26$lcssa - $178 << 2 | 0) | 0;
     HEAP32[$35 >> 2] = $buflen$0$i$i$i26$lcssa;
     HEAP32[$173 >> 2] = $176;
    }
   }
   if ($162 | 0) {
    $$pre$i$i28 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i30 = 0;
    do {
     HEAP32[$$pre$i$i28 + ($ix$01$i$i30 + $160 << 2) >> 2] = HEAP8[$161 + $ix$01$i$i30 >> 0];
     $ix$01$i$i30 = $ix$01$i$i30 + 1 | 0;
    } while (($ix$01$i$i30 | 0) != ($162 | 0));
   }
   HEAP32[$7 >> 2] = $163;
   $190 = HEAP32[$136 >> 2] | 0;
   $191 = $163 + 1 | 0;
   $192 = HEAP32[$35 >> 2] | 0;
   if ($191 >>> 0 < $192 >>> 0) $$pre$phi$i$i38Z2D = $doc + 6728 | 0; else {
    $buflen$0$i$i$i37 = ($192 | 0) == 0 ? 256 : $192;
    while (1) if ($buflen$0$i$i$i37 >>> 0 > $191 >>> 0) {
     $buflen$0$i$i$i37$lcssa = $buflen$0$i$i$i37;
     break;
    } else $buflen$0$i$i$i37 = $buflen$0$i$i$i37 << 1;
    $197 = HEAP32[$0 >> 2] | 0;
    $201 = $doc + 6728 | 0;
    $204 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$197 >> 2] | 0) + 4 >> 2] & 15]($197, HEAP32[$201 >> 2] | 0, $buflen$0$i$i$i37$lcssa << 2) | 0;
    if (!$204) $$pre$phi$i$i38Z2D = $201; else {
     $206 = HEAP32[$35 >> 2] | 0;
     _memset($204 + ($206 << 2) | 0, 0, $buflen$0$i$i$i37$lcssa - $206 << 2 | 0) | 0;
     HEAP32[$35 >> 2] = $buflen$0$i$i$i37$lcssa;
     HEAP32[$201 >> 2] = $204;
     $$pre$phi$i$i38Z2D = $201;
    }
   }
   HEAP32[(HEAP32[$$pre$phi$i$i38Z2D >> 2] | 0) + ($163 << 2) >> 2] = $190;
   $212 = HEAP32[$7 >> 2] | 0;
   $213 = $212 + 1 | 0;
   HEAP32[$7 >> 2] = $213;
   if (($6 | 0) != 0 & (HEAP32[$104 >> 2] | 0) != 0) {
    $216 = $6 + 24 | 0;
    $217 = HEAP32[$216 >> 2] | 0;
    if (!$217) {
     $273 = $213;
     label = 86;
    } else {
     $219 = _prvTidytmbstrlen($217) | 0;
     $220 = $212 + -2 | 0;
     $221 = $220 - $219 | 0;
     do if (($220 | 0) == ($219 | 0)) label = 71; else {
      if (($221 + 2 + (_prvTidytmbstrlen(HEAP32[$216 >> 2] | 0) | 0) | 0) >>> 0 >= $2 >>> 0) {
       label = 71;
       break;
      }
      if ($221 >>> 0 > ($4 | 0 ? $4 << 1 : 4) >>> 0) label = 71; else $i$0 = $221;
     } while (0);
     if ((label | 0) == 71) $i$0 = 0;
     do if (HEAP32[$7 >> 2] | 0) {
      _PFlushLineImpl($doc);
      if ((HEAP32[$doc + 412 >> 2] | 0) == 2) break;
      _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
      $238 = $doc + 6744 | 0;
      HEAP32[$238 >> 2] = (HEAP32[$238 >> 2] | 0) + 1;
     } while (0);
     if ((HEAP32[$29 >> 2] | 0) != ($i$0 | 0)) HEAP32[$29 >> 2] = $i$0;
     $243 = HEAP32[$7 >> 2] | 0;
     if (!$243) {
      $305 = 0;
      label = 96;
      break;
     }
     $245 = $243 + 1 | 0;
     $246 = HEAP32[$35 >> 2] | 0;
     do if ($245 >>> 0 < $246 >>> 0) $$pre$phi$i$i45Z2D = $doc + 6728 | 0; else {
      $buflen$0$i$i$i44 = ($246 | 0) == 0 ? 256 : $246;
      while (1) if ($buflen$0$i$i$i44 >>> 0 > $245 >>> 0) {
       $buflen$0$i$i$i44$lcssa = $buflen$0$i$i$i44;
       break;
      } else $buflen$0$i$i$i44 = $buflen$0$i$i$i44 << 1;
      $251 = HEAP32[$0 >> 2] | 0;
      $255 = $doc + 6728 | 0;
      $258 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$251 >> 2] | 0) + 4 >> 2] & 15]($251, HEAP32[$255 >> 2] | 0, $buflen$0$i$i$i44$lcssa << 2) | 0;
      if (!$258) {
       $$pre$phi$i$i45Z2D = $255;
       break;
      }
      $260 = HEAP32[$35 >> 2] | 0;
      _memset($258 + ($260 << 2) | 0, 0, $buflen$0$i$i$i44$lcssa - $260 << 2 | 0) | 0;
      HEAP32[$35 >> 2] = $buflen$0$i$i$i44$lcssa;
      HEAP32[$255 >> 2] = $258;
      $$pre$phi$i$i45Z2D = $255;
     } while (0);
     HEAP32[(HEAP32[$$pre$phi$i$i45Z2D >> 2] | 0) + ($243 << 2) >> 2] = 32;
     $267 = (HEAP32[$7 >> 2] | 0) + 1 | 0;
     HEAP32[$7 >> 2] = $267;
     $305 = $267;
     label = 96;
    }
   } else {
    $489 = $213;
    label = 85;
   }
  }
 } while (0);
 if ((label | 0) == 85) if (!$6) $384 = $489; else {
  $273 = $489;
  label = 86;
 }
 if ((label | 0) == 86) if (!(HEAP32[$6 + 24 >> 2] | 0)) $384 = $273; else {
  $271 = _prvTidytmbstrlen(310804) | 0;
  $272 = $271 + $273 | 0;
  $274 = HEAP32[$35 >> 2] | 0;
  if ($272 >>> 0 >= $274 >>> 0) {
   $buflen$0$i$i$i48 = ($274 | 0) == 0 ? 256 : $274;
   while (1) if ($buflen$0$i$i$i48 >>> 0 > $272 >>> 0) {
    $buflen$0$i$i$i48$lcssa = $buflen$0$i$i$i48;
    break;
   } else $buflen$0$i$i$i48 = $buflen$0$i$i$i48 << 1;
   $279 = HEAP32[$0 >> 2] | 0;
   $283 = $doc + 6728 | 0;
   $286 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$279 >> 2] | 0) + 4 >> 2] & 15]($279, HEAP32[$283 >> 2] | 0, $buflen$0$i$i$i48$lcssa << 2) | 0;
   if ($286 | 0) {
    $288 = HEAP32[$35 >> 2] | 0;
    _memset($286 + ($288 << 2) | 0, 0, $buflen$0$i$i$i48$lcssa - $288 << 2 | 0) | 0;
    HEAP32[$35 >> 2] = $buflen$0$i$i$i48$lcssa;
    HEAP32[$283 >> 2] = $286;
   }
  }
  if ($271 | 0) {
   $$pre$i$i50 = HEAP32[$doc + 6728 >> 2] | 0;
   $ix$01$i$i52 = 0;
   do {
    HEAP32[$$pre$i$i50 + ($ix$01$i$i52 + $273 << 2) >> 2] = HEAP8[310804 + $ix$01$i$i52 >> 0];
    $ix$01$i$i52 = $ix$01$i$i52 + 1 | 0;
   } while (($ix$01$i$i52 | 0) != ($271 | 0));
  }
  HEAP32[$7 >> 2] = $272;
  $305 = $272;
  label = 96;
 }
 if ((label | 0) == 96) if (!$6) $384 = $305; else {
  $$phi$trans$insert = $6 + 24 | 0;
  if (!(HEAP32[$$phi$trans$insert >> 2] | 0)) $384 = $305; else {
   $302 = $6 + 16 | 0;
   $303 = HEAP32[$302 >> 2] | 0;
   $304 = $305 + 1 | 0;
   $306 = HEAP32[$35 >> 2] | 0;
   if ($304 >>> 0 < $306 >>> 0) $$pre$phi$i$i60Z2D = $doc + 6728 | 0; else {
    $buflen$0$i$i$i59 = ($306 | 0) == 0 ? 256 : $306;
    while (1) if ($buflen$0$i$i$i59 >>> 0 > $304 >>> 0) {
     $buflen$0$i$i$i59$lcssa = $buflen$0$i$i$i59;
     break;
    } else $buflen$0$i$i$i59 = $buflen$0$i$i$i59 << 1;
    $311 = HEAP32[$0 >> 2] | 0;
    $315 = $doc + 6728 | 0;
    $318 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$311 >> 2] | 0) + 4 >> 2] & 15]($311, HEAP32[$315 >> 2] | 0, $buflen$0$i$i$i59$lcssa << 2) | 0;
    if (!$318) $$pre$phi$i$i60Z2D = $315; else {
     $320 = HEAP32[$35 >> 2] | 0;
     _memset($318 + ($320 << 2) | 0, 0, $buflen$0$i$i$i59$lcssa - $320 << 2 | 0) | 0;
     HEAP32[$35 >> 2] = $buflen$0$i$i$i59$lcssa;
     HEAP32[$315 >> 2] = $318;
     $$pre$phi$i$i60Z2D = $315;
    }
   }
   HEAP32[(HEAP32[$$pre$phi$i$i60Z2D >> 2] | 0) + ($305 << 2) >> 2] = $303;
   $327 = (HEAP32[$7 >> 2] | 0) + 1 | 0;
   HEAP32[$7 >> 2] = $327;
   $328 = HEAP32[$$phi$trans$insert >> 2] | 0;
   $329 = _prvTidytmbstrlen($328) | 0;
   $330 = $329 + $327 | 0;
   $331 = HEAP32[$35 >> 2] | 0;
   if ($330 >>> 0 >= $331 >>> 0) {
    $buflen$0$i$i$i63 = ($331 | 0) == 0 ? 256 : $331;
    while (1) if ($buflen$0$i$i$i63 >>> 0 > $330 >>> 0) {
     $buflen$0$i$i$i63$lcssa = $buflen$0$i$i$i63;
     break;
    } else $buflen$0$i$i$i63 = $buflen$0$i$i$i63 << 1;
    $336 = HEAP32[$0 >> 2] | 0;
    $340 = $doc + 6728 | 0;
    $343 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$336 >> 2] | 0) + 4 >> 2] & 15]($336, HEAP32[$340 >> 2] | 0, $buflen$0$i$i$i63$lcssa << 2) | 0;
    if ($343 | 0) {
     $345 = HEAP32[$35 >> 2] | 0;
     _memset($343 + ($345 << 2) | 0, 0, $buflen$0$i$i$i63$lcssa - $345 << 2 | 0) | 0;
     HEAP32[$35 >> 2] = $buflen$0$i$i$i63$lcssa;
     HEAP32[$340 >> 2] = $343;
    }
   }
   if ($329 | 0) {
    $$pre$i$i65 = HEAP32[$doc + 6728 >> 2] | 0;
    $ix$01$i$i67 = 0;
    do {
     HEAP32[$$pre$i$i65 + ($ix$01$i$i67 + $327 << 2) >> 2] = HEAP8[$328 + $ix$01$i$i67 >> 0];
     $ix$01$i$i67 = $ix$01$i$i67 + 1 | 0;
    } while (($ix$01$i$i67 | 0) != ($329 | 0));
   }
   HEAP32[$7 >> 2] = $330;
   $357 = HEAP32[$302 >> 2] | 0;
   $358 = $330 + 1 | 0;
   $359 = HEAP32[$35 >> 2] | 0;
   if ($358 >>> 0 < $359 >>> 0) $$pre$phi$i$i75Z2D = $doc + 6728 | 0; else {
    $buflen$0$i$i$i74 = ($359 | 0) == 0 ? 256 : $359;
    while (1) if ($buflen$0$i$i$i74 >>> 0 > $358 >>> 0) {
     $buflen$0$i$i$i74$lcssa = $buflen$0$i$i$i74;
     break;
    } else $buflen$0$i$i$i74 = $buflen$0$i$i$i74 << 1;
    $364 = HEAP32[$0 >> 2] | 0;
    $368 = $doc + 6728 | 0;
    $371 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$364 >> 2] | 0) + 4 >> 2] & 15]($364, HEAP32[$368 >> 2] | 0, $buflen$0$i$i$i74$lcssa << 2) | 0;
    if (!$371) $$pre$phi$i$i75Z2D = $368; else {
     $373 = HEAP32[$35 >> 2] | 0;
     _memset($371 + ($373 << 2) | 0, 0, $buflen$0$i$i$i74$lcssa - $373 << 2 | 0) | 0;
     HEAP32[$35 >> 2] = $buflen$0$i$i$i74$lcssa;
     HEAP32[$368 >> 2] = $371;
     $$pre$phi$i$i75Z2D = $368;
    }
   }
   HEAP32[(HEAP32[$$pre$phi$i$i75Z2D >> 2] | 0) + ($330 << 2) >> 2] = $357;
   $380 = (HEAP32[$7 >> 2] | 0) + 1 | 0;
   HEAP32[$7 >> 2] = $380;
   $384 = $380;
  }
 }
 $381 = $node + 12 | 0;
 if (!(HEAP32[$381 >> 2] | 0)) $446 = $384; else {
  if ($384 | 0) {
   _PFlushLineImpl($doc);
   if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
    _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
    $391 = $doc + 6744 | 0;
    HEAP32[$391 >> 2] = (HEAP32[$391 >> 2] | 0) + 1;
   }
  }
  if ((HEAP32[$29 >> 2] | 0) != ($indent | 0)) HEAP32[$29 >> 2] = $indent;
  $396 = HEAP32[$7 >> 2] | 0;
  $397 = $396 + 1 | 0;
  $398 = HEAP32[$35 >> 2] | 0;
  if ($397 >>> 0 < $398 >>> 0) $$pre$phi$i$i82Z2D = $doc + 6728 | 0; else {
   $buflen$0$i$i$i81 = ($398 | 0) == 0 ? 256 : $398;
   while (1) if ($buflen$0$i$i$i81 >>> 0 > $397 >>> 0) {
    $buflen$0$i$i$i81$lcssa = $buflen$0$i$i$i81;
    break;
   } else $buflen$0$i$i$i81 = $buflen$0$i$i$i81 << 1;
   $403 = HEAP32[$0 >> 2] | 0;
   $407 = $doc + 6728 | 0;
   $410 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$403 >> 2] | 0) + 4 >> 2] & 15]($403, HEAP32[$407 >> 2] | 0, $buflen$0$i$i$i81$lcssa << 2) | 0;
   if (!$410) $$pre$phi$i$i82Z2D = $407; else {
    $412 = HEAP32[$35 >> 2] | 0;
    _memset($410 + ($412 << 2) | 0, 0, $buflen$0$i$i$i81$lcssa - $412 << 2 | 0) | 0;
    HEAP32[$35 >> 2] = $buflen$0$i$i$i81$lcssa;
    HEAP32[$407 >> 2] = $410;
    $$pre$phi$i$i82Z2D = $407;
   }
  }
  HEAP32[(HEAP32[$$pre$phi$i$i82Z2D >> 2] | 0) + ($396 << 2) >> 2] = 91;
  HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + 1;
  _PPrintText($doc, 16, 0, HEAP32[$381 >> 2] | 0);
  $421 = HEAP32[$7 >> 2] | 0;
  $422 = $421 + 1 | 0;
  $423 = HEAP32[$35 >> 2] | 0;
  if ($422 >>> 0 < $423 >>> 0) $$pre$phi$i$i88Z2D = $doc + 6728 | 0; else {
   $buflen$0$i$i$i87 = ($423 | 0) == 0 ? 256 : $423;
   while (1) if ($buflen$0$i$i$i87 >>> 0 > $422 >>> 0) {
    $buflen$0$i$i$i87$lcssa = $buflen$0$i$i$i87;
    break;
   } else $buflen$0$i$i$i87 = $buflen$0$i$i$i87 << 1;
   $428 = HEAP32[$0 >> 2] | 0;
   $432 = $doc + 6728 | 0;
   $435 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$428 >> 2] | 0) + 4 >> 2] & 15]($428, HEAP32[$432 >> 2] | 0, $buflen$0$i$i$i87$lcssa << 2) | 0;
   if (!$435) $$pre$phi$i$i88Z2D = $432; else {
    $437 = HEAP32[$35 >> 2] | 0;
    _memset($435 + ($437 << 2) | 0, 0, $buflen$0$i$i$i87$lcssa - $437 << 2 | 0) | 0;
    HEAP32[$35 >> 2] = $buflen$0$i$i$i87$lcssa;
    HEAP32[$432 >> 2] = $435;
    $$pre$phi$i$i88Z2D = $432;
   }
  }
  HEAP32[(HEAP32[$$pre$phi$i$i88Z2D >> 2] | 0) + ($421 << 2) >> 2] = 93;
  $444 = (HEAP32[$7 >> 2] | 0) + 1 | 0;
  HEAP32[$7 >> 2] = $444;
  $446 = $444;
 }
 if ($446 >>> 0 < (HEAP32[$1 >> 2] | 0) >>> 0) {
  if ((HEAP32[$29 >> 2] | 0) < 0) HEAP32[$29 >> 2] = 0;
  HEAP32[$doc + 6740 >> 2] = $446;
 } else {
  $451 = $doc + 6748 | 0;
  if (!(HEAP32[$451 >> 2] | 0)) {
   HEAP32[$doc + 6764 >> 2] = 0;
   HEAP32[$451 >> 2] = 1;
  }
 }
 $455 = $446 + 1 | 0;
 $456 = HEAP32[$35 >> 2] | 0;
 if ($455 >>> 0 < $456 >>> 0) $$pre$phi$i$i95Z2D = $doc + 6728 | 0; else {
  $buflen$0$i$i$i94 = ($456 | 0) == 0 ? 256 : $456;
  while (1) if ($buflen$0$i$i$i94 >>> 0 > $455 >>> 0) {
   $buflen$0$i$i$i94$lcssa = $buflen$0$i$i$i94;
   break;
  } else $buflen$0$i$i$i94 = $buflen$0$i$i$i94 << 1;
  $461 = HEAP32[$0 >> 2] | 0;
  $465 = $doc + 6728 | 0;
  $468 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$461 >> 2] | 0) + 4 >> 2] & 15]($461, HEAP32[$465 >> 2] | 0, $buflen$0$i$i$i94$lcssa << 2) | 0;
  if (!$468) $$pre$phi$i$i95Z2D = $465; else {
   $470 = HEAP32[$35 >> 2] | 0;
   _memset($468 + ($470 << 2) | 0, 0, $buflen$0$i$i$i94$lcssa - $470 << 2 | 0) | 0;
   HEAP32[$35 >> 2] = $buflen$0$i$i$i94$lcssa;
   HEAP32[$465 >> 2] = $468;
   $$pre$phi$i$i95Z2D = $465;
  }
 }
 HEAP32[(HEAP32[$$pre$phi$i$i95Z2D >> 2] | 0) + ($446 << 2) >> 2] = 62;
 $477 = (HEAP32[$7 >> 2] | 0) + 1 | 0;
 HEAP32[$7 >> 2] = $477;
 if ($477 | 0) {
  _PFlushLineImpl($doc);
  if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
   _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
   $484 = $doc + 6744 | 0;
   HEAP32[$484 >> 2] = (HEAP32[$484 >> 2] | 0) + 1;
  }
 }
 if ((HEAP32[$29 >> 2] | 0) == ($indent | 0)) return;
 HEAP32[$29 >> 2] = $indent;
 return;
}

function _prvTidyParseBlock($doc, $element, $mode) {
 $doc = $doc | 0;
 $element = $element | 0;
 $mode = $mode | 0;
 var $$0$be = 0, $$0$ph = 0, $$093 = 0, $$093$lcssa226 = 0, $$1 = 0, $$lcssa = 0, $$lcssa208 = 0, $$lcssa211 = 0, $$lcssa228 = 0, $$lcssa229 = 0, $0 = 0, $1 = 0, $101 = 0, $106 = 0, $111 = 0, $118 = 0, $123 = 0, $129 = 0, $13 = 0, $138 = 0, $144 = 0, $147 = 0, $154 = 0, $161 = 0, $173 = 0, $178 = 0, $182 = 0, $185 = 0, $19 = 0, $197 = 0, $198 = 0, $2 = 0, $202 = 0, $21 = 0, $214 = 0, $217 = 0, $22 = 0, $222 = 0, $229 = 0, $232 = 0, $246 = 0, $248 = 0, $256 = 0, $263 = 0, $264 = 0, $269 = 0, $274 = 0, $28 = 0, $288 = 0, $3 = 0, $305 = 0, $309 = 0, $31 = 0, $317 = 0, $318 = 0, $321 = 0, $33 = 0, $332 = 0, $34 = 0, $343 = 0, $346 = 0, $348 = 0, $35 = 0, $350 = 0, $352 = 0, $358 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $60 = 0, $62 = 0, $74 = 0, $78 = 0, $87 = 0, $checkstack$0$be = 0, $checkstack$095 = 0, $checkstack$3 = 0, $istackbase$0 = 0, $node$0 = 0, $node$1 = 0, $node$157 = 0, $node$157$lcssa = 0, $node$158 = 0, $parent$02$i = 0, $parent$02$i16 = 0, $parent$02$i28 = 0, $parent$03$i = 0, $parent$03$i17 = 0, $parent$03$i29 = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $element + 28 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 $5 = HEAP32[$3 + 16 >> 2] | 0;
 if ($5 & 1 | 0) return;
 L4 : do if (!$3) $19 = $5; else if ((HEAP32[$3 >> 2] | 0) == 37) {
  $parent$02$i = HEAP32[$element >> 2] | 0;
  if (!$parent$02$i) $19 = $5; else {
   $parent$03$i = $parent$02$i;
   while (1) {
    $13 = HEAP32[$parent$03$i + 28 >> 2] | 0;
    if ($13 | 0) if ((HEAP32[$13 >> 2] | 0) == 37) break;
    $parent$03$i = HEAP32[$parent$03$i >> 2] | 0;
    if (!$parent$03$i) {
     $19 = $5;
     break L4;
    }
   }
   _prvTidyReportError($doc, $element, 0, 225);
   $19 = HEAP32[(HEAP32[$2 >> 2] | 0) + 16 >> 2] | 0;
  }
 } else $19 = $5; while (0);
 if (!($19 & 2048)) $istackbase$0 = 0; else {
  $21 = $1 + 116 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  HEAP32[$21 >> 2] = HEAP32[$1 + 112 >> 2];
  $istackbase$0 = $22;
 }
 if (!($19 & 131072)) {
  _prvTidyInlineDup($doc, 0) | 0;
  $28 = HEAP32[(HEAP32[$2 >> 2] | 0) + 16 >> 2] | 0;
 } else $28 = $19;
 $$0$ph = ($28 & 1040 | 0) == 16 ? (($mode | 0) == 0 ? 1 : $mode) : 0;
 $31 = _prvTidyGetToken($doc, $$0$ph) | 0;
 L20 : do if (!$31) $346 = 0; else {
  $33 = $element + 24 | 0;
  $34 = $1 + 24 | 0;
  $35 = $element + 16 | 0;
  $36 = $element + 12 | 0;
  $37 = $doc + 6848 | 0;
  $38 = $element + 60 | 0;
  $39 = $doc + 428 | 0;
  $40 = $doc + 200 | 0;
  $41 = $doc + 6856 | 0;
  $42 = $1 + 20 | 0;
  $43 = $doc + 156 | 0;
  $$093 = $$0$ph;
  $45 = $31;
  $checkstack$095 = 1;
  L22 : while (1) {
   $44 = $45 + 44 | 0;
   $47 = (HEAP32[$44 >> 2] | 0) == 6;
   $48 = $45 + 28 | 0;
   $49 = HEAP32[$48 >> 2] | 0;
   $50 = ($49 | 0) == 0;
   do if ($47) {
    if ($50) {
     _prvTidyReportError($doc, $element, $45, 208);
     _prvTidyFreeNode($doc, $45);
     $$0$be = $$093;
     $checkstack$0$be = $checkstack$095;
     break;
    }
    if (($49 | 0) == (HEAP32[$2 >> 2] | 0)) {
     $$lcssa = $45;
     label = 19;
     break L22;
    }
    if ((HEAP32[$33 >> 2] | 0) == ($49 | 0)) {
     $$lcssa = $45;
     label = 19;
     break L22;
    } else label = 25;
   } else if ($50) label = 45; else label = 25; while (0);
   L31 : do if ((label | 0) == 25) {
    label = 0;
    switch (HEAP32[$49 >> 2] | 0) {
    case 16:
    case 46:
    case 48:
     {
      if (_prvTidynodeIsElement($45) | 0) _prvTidyReportError($doc, $element, $45, 208);
      _prvTidyFreeNode($doc, $45);
      $$0$be = $$093;
      $checkstack$0$be = $checkstack$095;
      break L31;
      break;
     }
    default:
     {}
    }
    if ($47) {
     $74 = HEAP32[$49 >> 2] | 0;
     switch ($74 | 0) {
     case 17:
      {
       HEAP32[$44 >> 2] = 5;
       label = 45;
       break L31;
       break;
      }
     case 80:
      {
       HEAP32[$44 >> 2] = 7;
       HEAP32[$45 + 60 >> 2] = 1;
       label = 45;
       break L31;
       break;
      }
     default:
      {
       $parent$02$i16 = HEAP32[$element >> 2] | 0;
       if ($parent$02$i16 | 0) {
        $parent$03$i17 = $parent$02$i16;
        do {
         $78 = HEAP32[$parent$03$i17 + 28 >> 2] | 0;
         if ($78 | 0) if ((HEAP32[$78 >> 2] | 0) == ($74 | 0)) {
          $$lcssa208 = $45;
          label = 39;
          break L22;
         }
         $parent$03$i17 = HEAP32[$parent$03$i17 >> 2] | 0;
        } while (($parent$03$i17 | 0) != 0);
       }
       if (!(HEAP32[$34 >> 2] | 0)) {
        label = 45;
        break L31;
       }
       if (_prvTidynodeHasCM($45, 128) | 0) {
        label = 44;
        break L22;
       }
       $87 = HEAP32[$48 >> 2] | 0;
       if (!$87) {
        label = 45;
        break L31;
       }
       if ((HEAP32[$87 >> 2] | 0) == 107) {
        label = 44;
        break L22;
       } else {
        label = 45;
        break L31;
       }
      }
     }
    } else label = 45;
   } while (0);
   L54 : do if ((label | 0) == 45) {
    label = 0;
    if (_prvTidynodeIsText($45) | 0) {
     if ($checkstack$095 | 0) if (!(HEAP32[(HEAP32[$2 >> 2] | 0) + 16 >> 2] & 131072)) if ((_prvTidyInlineDup($doc, $45) | 0) > 0) {
      $$0$be = $$093;
      $checkstack$0$be = 0;
      break;
     }
     HEAP32[$45 >> 2] = $element;
     $101 = HEAP32[$35 >> 2] | 0;
     HEAP32[$45 + 4 >> 2] = $101;
     if (!$101) HEAP32[$36 >> 2] = $45; else HEAP32[$101 + 8 >> 2] = $45;
     HEAP32[$35 >> 2] = $45;
     $106 = HEAP32[$2 >> 2] | 0;
     if (!$106) {
      $$0$be = 1;
      $checkstack$0$be = 0;
      break;
     }
     switch (HEAP32[$106 >> 2] | 0) {
     case 75:
     case 37:
     case 15:
     case 64:
     case 16:
      break;
     default:
      {
       $$0$be = 1;
       $checkstack$0$be = 0;
       break L54;
      }
     }
     _prvTidyConstrainVersion($doc, -293);
     $$0$be = 1;
     $checkstack$0$be = 0;
     break;
    }
    if (!(_InsertMisc($element, $45) | 0)) {
     $111 = HEAP32[$48 >> 2] | 0;
     if (!$111) {
      _prvTidyReportError($doc, $element, $45, 208);
      _prvTidyFreeNode($doc, $45);
      $$0$be = $$093;
      $checkstack$0$be = $checkstack$095;
      break;
     }
     switch (HEAP32[$111 >> 2] | 0) {
     case 81:
      {
       if (_prvTidynodeHasCM($element, 4096) | 0) if (_prvTidynodeIsElement($45) | 0) {
        HEAP32[$45 >> 2] = $element;
        $118 = HEAP32[$35 >> 2] | 0;
        HEAP32[$45 + 4 >> 2] = $118;
        if (!$118) HEAP32[$36 >> 2] = $45; else HEAP32[$118 + 8 >> 2] = $45;
        HEAP32[$35 >> 2] = $45;
        $$0$be = $$093;
        $checkstack$0$be = $checkstack$095;
        break L54;
       }
       _prvTidyReportError($doc, $element, $45, 208);
       _prvTidyFreeNode($doc, $45);
       $$0$be = $$093;
       $checkstack$0$be = $checkstack$095;
       break L54;
       break;
      }
     case 7:
      {
       $123 = HEAP32[$2 >> 2] | 0;
       if ($123 | 0) if ((HEAP32[$123 >> 2] | 0) == 64) if (_prvTidynodeIsElement($45) | 0) {
        HEAP32[$45 >> 2] = $element;
        $129 = HEAP32[$35 >> 2] | 0;
        HEAP32[$45 + 4 >> 2] = $129;
        if (!$129) HEAP32[$36 >> 2] = $45; else HEAP32[$129 + 8 >> 2] = $45;
        HEAP32[$35 >> 2] = $45;
        $$0$be = $$093;
        $checkstack$0$be = $checkstack$095;
        break L54;
       }
       _prvTidyReportError($doc, $element, $45, 208);
       _prvTidyFreeNode($doc, $45);
       $$0$be = $$093;
       $checkstack$0$be = $checkstack$095;
       break L54;
       break;
      }
     default:
      {
       L75 : do if (!(_prvTidynodeHasCM($45, 16) | 0)) {
        if (!(_prvTidynodeIsElement($45) | 0)) {
         $138 = HEAP32[$48 >> 2] | 0;
         if ($138 | 0) if ((HEAP32[$138 >> 2] | 0) == 37) HEAP32[$37 >> 2] = HEAP32[$37 >> 2] | 1;
         _prvTidyReportError($doc, $element, $45, 208);
         _prvTidyFreeNode($doc, $45);
         $$0$be = $$093;
         $checkstack$0$be = $checkstack$095;
         break L54;
        }
        $144 = HEAP32[$2 >> 2] | 0;
        L84 : do if (!$144) label = 97; else {
         switch (HEAP32[$144 >> 2] | 0) {
         case 61:
          {
           $147 = HEAP32[$48 >> 2] | 0;
           if (!$147) {
            label = 97;
            break L84;
           }
           switch (HEAP32[$147 >> 2] | 0) {
           case 79:
           case 78:
           case 39:
           case 38:
            break;
           default:
            {
             label = 97;
             break L84;
            }
           }
           _prvTidyReportError($doc, $element, $45, 208);
           _prvTidyFreeNode($doc, $45);
           $$0$be = $$093;
           $checkstack$0$be = $checkstack$095;
           break L54;
           break;
          }
         case 112:
         case 109:
          break;
         default:
          {
           label = 97;
           break L84;
          }
         }
         if (_prvTidynodeHasCM($45, 4) | 0) {
          _MoveToHead($doc, $element, $45);
          $$0$be = $$093;
          $checkstack$0$be = $checkstack$095;
          break L54;
         }
         do if (!(_prvTidynodeHasCM($45, 32) | 0)) {
          if (!(_prvTidynodeHasCM($45, 64) | 0)) {
           $node$0 = $45;
           break;
          }
          _prvTidyUngetToken($doc);
          $161 = _prvTidyInferredTag($doc, 31) | 0;
          HEAP32[$42 >> 2] = 1;
          $node$0 = $161;
         } else {
          _prvTidyUngetToken($doc);
          $154 = _prvTidyInferredTag($doc, 118) | 0;
          do if (HEAP32[$39 >> 2] | 0) if (!(HEAP32[$40 >> 2] | 0)) {
           _prvTidyAddStyleProperty($doc, $154, 307844);
           break;
          } else {
           _prvTidyAddStyleAsClass($doc, $154, 307844);
           break;
          } while (0);
          HEAP32[$42 >> 2] = 1;
          $node$0 = $154;
         } while (0);
         if (!(_prvTidynodeHasCM($node$0, 8) | 0)) {
          label = 96;
          break L22;
         } else $node$1 = $node$0;
        } while (0);
        do if ((label | 0) == 97) {
         label = 0;
         if (_prvTidynodeHasCM($45, 8) | 0) if (!(HEAP32[$42 >> 2] | 0)) {
          $node$157 = $45;
          label = 144;
          break L75;
         } else {
          $$lcssa211 = $45;
          label = 99;
          break L22;
         }
         $173 = HEAP32[$48 >> 2] | 0;
         if (HEAP32[$173 + 16 >> 2] & 4 | 0) {
          _MoveToHead($doc, $element, $45);
          $$0$be = $$093;
          $checkstack$0$be = $checkstack$095;
          break L54;
         }
         $178 = HEAP32[$2 >> 2] | 0;
         do if ($178 | 0) {
          if ((HEAP32[$178 >> 2] | 0) != 37) break;
          $182 = HEAP32[$element >> 2] | 0;
          if (!$182) break;
          $185 = HEAP32[$182 + 28 >> 2] | 0;
          if (!$185) break;
          if ((HEAP32[$185 >> 2] | 0) != 109) break;
          if ((HEAP32[$182 + 60 >> 2] | 0) == 0 | ($173 | 0) == 0) break;
          if ((HEAP32[$173 >> 2] | 0) == 109) {
           _prvTidyReportError($doc, $element, $45, 208);
           _prvTidyFreeNode($doc, $45);
           $$0$be = $$093;
           $checkstack$0$be = $checkstack$095;
           break L54;
          }
          if ((HEAP32[$173 >> 2] | 0) != 112) break;
          _prvTidyReportError($doc, $element, $45, 208);
          _prvTidyFreeNode($doc, $45);
          $197 = HEAP32[$element >> 2] | 0;
          $198 = HEAP32[$41 >> 2] | 0;
          $202 = $197 + 32 | 0;
          FUNCTION_TABLE_vii[HEAP32[(HEAP32[$198 >> 2] | 0) + 8 >> 2] & 15]($198, HEAP32[$202 >> 2] | 0);
          HEAP32[$202 >> 2] = _prvTidytmbstrdup(HEAP32[$41 >> 2] | 0, 308572) | 0;
          HEAP32[$197 + 28 >> 2] = _prvTidyLookupTagDef(112) | 0;
          $$0$be = $$093;
          $checkstack$0$be = $checkstack$095;
          break L54;
         } while (0);
         do if (!(_prvTidynodeHasCM($element, 32768) | 0)) {
          if (HEAP32[$38 >> 2] | 0) break;
          _prvTidyReportError($doc, $element, $45, 207);
         } while (0);
         _prvTidyUngetToken($doc);
         if (_prvTidynodeHasCM($45, 32) | 0) {
          $214 = HEAP32[$element >> 2] | 0;
          do if ($214 | 0) {
           $217 = HEAP32[$214 + 28 >> 2] | 0;
           if (!$217) break;
           if ((HEAP32[$217 + 20 >> 2] | 0) == 30) {
            label = 123;
            break L22;
           }
          } while (0);
          $222 = _prvTidyInferredTag($doc, 118) | 0;
          if (!(HEAP32[$39 >> 2] | 0)) {
           $node$1 = $222;
           break;
          }
          if (!(HEAP32[$40 >> 2] | 0)) {
           _prvTidyAddStyleProperty($doc, $222, 307844);
           $node$1 = $222;
           break;
          } else {
           _prvTidyAddStyleAsClass($doc, $222, 307844);
           $node$1 = $222;
           break;
          }
         }
         if (!(_prvTidynodeHasCM($45, 64) | 0)) {
          if (!(_prvTidynodeHasCM($45, 128) | 0)) if (!(_prvTidynodeHasCM($45, 512) | 0)) {
           label = 138;
           break L22;
          }
          if (HEAP32[$34 >> 2] | 0) {
           label = 195;
           break L22;
          }
          $node$1 = _prvTidyInferredTag($doc, 107) | 0;
          break;
         } else {
          $229 = HEAP32[$element >> 2] | 0;
          do if ($229 | 0) {
           $232 = HEAP32[$229 + 28 >> 2] | 0;
           if (!$232) break;
           if ((HEAP32[$232 >> 2] | 0) == 31) {
            label = 132;
            break L22;
           }
          } while (0);
          $node$1 = _prvTidyInferredTag($doc, 31) | 0;
          break;
         }
        } while (0);
        if (!$node$1) {
         $358 = 0;
         $node$158 = 0;
        } else {
         $node$157 = $node$1;
         label = 144;
        }
       } else {
        $node$157 = $45;
        label = 144;
       } while (0);
       L152 : do if ((label | 0) == 144) {
        label = 0;
        $256 = HEAP32[$node$157 + 28 >> 2] | 0;
        if (!$256) {
         $358 = 1;
         $node$158 = $node$157;
        } else if ((HEAP32[$256 >> 2] | 0) == 1) if (!(HEAP32[$node$157 + 60 >> 2] | 0)) {
         $263 = HEAP32[$2 >> 2] | 0;
         $264 = ($263 | 0) == 0;
         if ($264) label = 149; else if ((HEAP32[$263 >> 2] | 0) != 1) label = 149;
         L159 : do if ((label | 0) == 149) {
          label = 0;
          $parent$02$i28 = HEAP32[$element >> 2] | 0;
          if (!$parent$02$i28) {
           $358 = 1;
           $node$158 = $node$157;
           break L152;
          } else $parent$03$i29 = $parent$02$i28;
          while (1) {
           $269 = HEAP32[$parent$03$i29 + 28 >> 2] | 0;
           if ($269 | 0) if ((HEAP32[$269 >> 2] | 0) == 1) break L159;
           $parent$03$i29 = HEAP32[$parent$03$i29 >> 2] | 0;
           if (!$parent$03$i29) {
            $358 = 1;
            $node$158 = $node$157;
            break L152;
           }
          }
         } while (0);
         $274 = $node$157 + 44 | 0;
         if ((HEAP32[$274 >> 2] | 0) == 6) {
          $$093$lcssa226 = $$093;
          $$lcssa228 = $263;
          $$lcssa229 = $264;
          $node$157$lcssa = $node$157;
          label = 157;
          break L22;
         }
         if (HEAP32[$node$157 + 20 >> 2] | 0) {
          $$093$lcssa226 = $$093;
          $$lcssa228 = $263;
          $$lcssa229 = $264;
          $node$157$lcssa = $node$157;
          label = 157;
          break L22;
         }
         if (!(HEAP32[$43 >> 2] | 0)) {
          $$093$lcssa226 = $$093;
          $$lcssa228 = $263;
          $$lcssa229 = $264;
          $node$157$lcssa = $node$157;
          label = 157;
          break L22;
         }
         HEAP32[$274 >> 2] = 6;
         _prvTidyReportError($doc, $element, $node$157, 224);
         _prvTidyUngetToken($doc);
         $$0$be = $$093;
         $checkstack$0$be = $checkstack$095;
         break L54;
        } else {
         $358 = 1;
         $node$158 = $node$157;
        } else {
         $358 = 1;
         $node$158 = $node$157;
        }
       } while (0);
       if (!(_prvTidynodeIsElement($node$158) | 0)) {
        if ((HEAP32[$node$158 + 44 >> 2] | 0) == 6) _prvTidyPopInline($doc, $node$158);
        _prvTidyReportError($doc, $element, $node$158, 208);
        _prvTidyFreeNode($doc, $node$158);
        $$0$be = $$093;
        $checkstack$0$be = $checkstack$095;
        break L54;
       }
       $288 = $node$158 + 28 | 0;
       if (!(HEAP32[(HEAP32[$288 >> 2] | 0) + 16 >> 2] & 16)) {
        $$1 = 0;
        $checkstack$3 = 1;
       } else if (!$checkstack$095) {
        $$1 = 1;
        $checkstack$3 = 0;
       } else if (!(HEAP32[$node$158 + 60 >> 2] | 0)) if (!(HEAP32[(HEAP32[$2 >> 2] | 0) + 16 >> 2] & 131072)) if ((_prvTidyInlineDup($doc, $node$158) | 0) > 0) {
        $$0$be = $$093;
        $checkstack$0$be = 0;
        break L54;
       } else {
        $$1 = 1;
        $checkstack$3 = 0;
       } else {
        $$1 = 1;
        $checkstack$3 = 0;
       } else {
        $$1 = 1;
        $checkstack$3 = $checkstack$095;
       }
       if ($358) {
        $305 = HEAP32[$288 >> 2] | 0;
        if ($305 | 0) if ((HEAP32[$305 >> 2] | 0) == 17) _TrimSpaces($doc, $element);
       }
       HEAP32[$node$158 >> 2] = $element;
       $309 = HEAP32[$35 >> 2] | 0;
       HEAP32[$node$158 + 4 >> 2] = $309;
       if (!$309) HEAP32[$36 >> 2] = $node$158; else HEAP32[$309 + 8 >> 2] = $node$158;
       HEAP32[$35 >> 2] = $node$158;
       if (HEAP32[$node$158 + 60 >> 2] | 0) _prvTidyReportError($doc, $element, $node$158, 215);
       $317 = HEAP32[$0 >> 2] | 0;
       $318 = HEAP32[$288 >> 2] | 0;
       if (!$318) {
        $$0$be = $$1;
        $checkstack$0$be = $checkstack$3;
        break L54;
       }
       $321 = HEAP32[$318 + 16 >> 2] | 0;
       do if (!($321 & 1)) {
        if ($321 & 16 | 0) break;
        HEAP32[$317 + 16 >> 2] = 0;
       } else {
        HEAP32[$317 + 8 >> 2] = 0;
        if (!(HEAP32[$318 + 20 >> 2] | 0)) {
         $$0$be = $$1;
         $checkstack$0$be = $checkstack$3;
         break L54;
        }
       } while (0);
       $332 = HEAP32[$318 + 20 >> 2] | 0;
       if (!$332) {
        $$0$be = $$1;
        $checkstack$0$be = $checkstack$3;
        break L54;
       }
       if ((HEAP32[$node$158 + 44 >> 2] | 0) == 7) {
        $$0$be = $$1;
        $checkstack$0$be = $checkstack$3;
        break L54;
       }
       HEAP32[$317 + 72 >> 2] = $node$158;
       FUNCTION_TABLE_viii[$332 & 63]($doc, $node$158, 0);
       $$0$be = $$1;
       $checkstack$0$be = $checkstack$3;
       break L54;
      }
     }
    } else {
     $$0$be = $$093;
     $checkstack$0$be = $checkstack$095;
    }
   } while (0);
   $45 = _prvTidyGetToken($doc, $$0$be) | 0;
   if (!$45) {
    $346 = 0;
    break L20;
   } else {
    $$093 = $$0$be;
    $checkstack$095 = $checkstack$0$be;
   }
  }
  switch (label | 0) {
  case 19:
   {
    _prvTidyFreeNode($doc, $$lcssa);
    if (HEAP32[(HEAP32[$2 >> 2] | 0) + 16 >> 2] & 2048 | 0) {
     $60 = $1 + 112 | 0;
     $62 = $1 + 116 | 0;
     if ((HEAP32[$60 >> 2] | 0) >>> 0 > (HEAP32[$62 >> 2] | 0) >>> 0) do _prvTidyPopInline($doc, 0); while ((HEAP32[$60 >> 2] | 0) >>> 0 > (HEAP32[$62 >> 2] | 0) >>> 0);
     HEAP32[$62 >> 2] = $istackbase$0;
    }
    HEAP32[$element + 56 >> 2] = 1;
    _TrimSpaces($doc, $element);
    return;
   }
  case 39:
   {
    _prvTidyUngetToken($doc);
    $346 = $$lcssa208;
    break L20;
    break;
   }
  case 44:
   {
    _prvTidyUngetToken($doc);
    _TrimSpaces($doc, $element);
    return;
   }
  case 96:
   {
    _prvTidyUngetToken($doc);
    _TrimSpaces($doc, $element);
    return;
   }
  case 99:
   {
    if (!(_prvTidynodeHasCM($element, 32768) | 0)) _prvTidyReportError($doc, $element, $$lcssa211, 207);
    _prvTidyUngetToken($doc);
    if (_prvTidynodeHasCM($element, 2048) | 0) HEAP32[$1 + 116 >> 2] = $istackbase$0;
    _TrimSpaces($doc, $element);
    return;
   }
  case 123:
   {
    _TrimSpaces($doc, $element);
    return;
   }
  case 132:
   {
    _TrimSpaces($doc, $element);
    return;
   }
  case 138:
   {
    if (!(_prvTidynodeHasCM($element, 2048) | 0)) {
     _TrimSpaces($doc, $element);
     return;
    }
    $246 = $1 + 112 | 0;
    $248 = $1 + 116 | 0;
    if ((HEAP32[$246 >> 2] | 0) >>> 0 > (HEAP32[$248 >> 2] | 0) >>> 0) do _prvTidyPopInline($doc, 0); while ((HEAP32[$246 >> 2] | 0) >>> 0 > (HEAP32[$248 >> 2] | 0) >>> 0);
    HEAP32[$248 >> 2] = $istackbase$0;
    _TrimSpaces($doc, $element);
    return;
   }
  case 157:
   {
    if (!$$lcssa229) if ((HEAP32[$$lcssa228 >> 2] | 0) == 1) _prvTidyUngetToken($doc);
    _prvTidyReportError($doc, $element, $node$157$lcssa, 207);
    if ($$093$lcssa226 & 2 | 0) return;
    _TrimSpaces($doc, $element);
    return;
   }
  case 195:
   return;
  }
 } while (0);
 $343 = HEAP32[(HEAP32[$2 >> 2] | 0) + 16 >> 2] | 0;
 if (!($343 & 32768)) {
  _prvTidyReportError($doc, $element, $346, 206);
  $348 = HEAP32[(HEAP32[$2 >> 2] | 0) + 16 >> 2] | 0;
 } else $348 = $343;
 if ($348 & 2048 | 0) {
  $350 = $1 + 112 | 0;
  $352 = $1 + 116 | 0;
  if ((HEAP32[$350 >> 2] | 0) >>> 0 > (HEAP32[$352 >> 2] | 0) >>> 0) do _prvTidyPopInline($doc, 0); while ((HEAP32[$350 >> 2] | 0) >>> 0 > (HEAP32[$352 >> 2] | 0) >>> 0);
  HEAP32[$352 >> 2] = $istackbase$0;
 }
 _TrimSpaces($doc, $element);
 return;
}

function _ParseValue($doc, $name, $foldCase, $isempty, $pdelim) {
 $doc = $doc | 0;
 $name = $name | 0;
 $foldCase = $foldCase | 0;
 $isempty = $isempty | 0;
 $pdelim = $pdelim | 0;
 var $$0 = 0, $$0$i = 0, $$lcssa284 = 0, $$lcssa308 = 0, $$lcssa309 = 0, $$pre$phiZ2D = 0, $$pre162 = 0, $0 = 0, $1 = 0, $101 = 0, $109 = 0, $122 = 0, $125 = 0, $130 = 0, $14 = 0, $147 = 0, $16 = 0, $167 = 0, $168 = 0, $169 = 0, $170 = 0, $179 = 0, $182 = 0, $184 = 0, $187 = 0, $190 = 0, $195 = 0, $201 = 0, $206 = 0, $207 = 0, $218 = 0, $219 = 0, $22 = 0, $23 = 0, $24 = 0, $26 = 0, $28 = 0, $30 = 0, $32 = 0, $37 = 0, $4 = 0, $46 = 0, $5 = 0, $51 = 0, $58 = 0, $67 = 0, $7 = 0, $76 = 0, $85 = 0, $86 = 0, $87 = 0, $89 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $97 = 0, $c$0$be = 0, $c$0116 = 0, $c$454164 = 0, $c$455 = 0, $c$5 = 0, $delim$0 = 0, $delim$0$ph$lcssa$i = 0, $delim$0$ph30$i = 0, $delim$0$ph30$us$i = 0, $isrule$0$ph$i = 0, $len$0$lcssa = 0, $len$0110 = 0, $len$1104 = 0, $len$2 = 0, $quotewarning$0$be = 0, $quotewarning$0$lcssa = 0, $quotewarning$0117 = 0, $quotewarning$0117$lcssa286 = 0, $quotewarning$0117$lcssa287 = 0, $quotewarning$0117$lcssa288 = 0, $quotewarning$0117$lcssa289 = 0, $quotewarning$2 = 0, $quotewarning$24750167 = 0, $quotewarning$24750168 = 0, $quotewarning$24751 = 0, $quotewarning$3 = 0, $seen_gt$0$be = 0, $seen_gt$0$lcssa = 0, $seen_gt$0115 = 0, $seen_gt$0115$lcssa291 = 0, $seen_gt$0115$lcssa292 = 0, $seen_gt$0115$lcssa293 = 0, $seen_gt$0115$lcssa294 = 0, $seen_gt$1 = 0, $seen_gt$14552165 = 0, $seen_gt$14552166 = 0, $seen_gt$14553 = 0, $seen_gt$2 = 0, $start$0103 = 0, $start$1 = 0, $value$0 = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 HEAP32[$pdelim >> 2] = 34;
 $4 = (HEAP32[$doc + 324 >> 2] | 0) == 0;
 $5 = $doc + 6776 | 0;
 while (1) {
  $7 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
  if (($7 | 0) == -1) {
   label = 3;
   break;
  }
  if ($7 >>> 0 >= 128) {
   $$lcssa309 = $7;
   label = 6;
   break;
  }
  if (!(HEAP32[316488 + ($7 << 2) >> 2] & 8)) {
   $$lcssa309 = $7;
   label = 6;
   break;
  }
 }
 L5 : do if ((label | 0) == 3) {
  _prvTidyUngetChar(-1, HEAP32[$5 >> 2] | 0);
  $14 = -1;
 } else if ((label | 0) == 6) {
  switch ($$lcssa309 | 0) {
  case 34:
  case 39:
  case 61:
   break;
  default:
   {
    $14 = $$lcssa309;
    break L5;
   }
  }
  while (1) {
   $16 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
   if (($16 | 0) == -1) {
    label = 9;
    break;
   }
   if ($16 >>> 0 >= 128) {
    $$lcssa308 = $16;
    label = 12;
    break;
   }
   if (!(HEAP32[316488 + ($16 << 2) >> 2] & 8)) {
    $$lcssa308 = $16;
    label = 12;
    break;
   }
  }
  L12 : do if ((label | 0) == 9) {
   _prvTidyUngetChar(-1, HEAP32[$5 >> 2] | 0);
   $85 = -1;
   label = 46;
  } else if ((label | 0) == 12) {
   switch ($$lcssa308 | 0) {
   case 34:
   case 39:
    {
     $delim$0 = $$lcssa308;
     break L12;
     break;
    }
   case 60:
    break;
   default:
    {
     $85 = $$lcssa308;
     label = 46;
     break L12;
    }
   }
   $22 = $1 + 92 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   _prvTidyAddCharToLexer($1, 60);
   $24 = HEAP32[$0 >> 2] | 0;
   $26 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
   _prvTidyAddCharToLexer($24, $26);
   switch ($26 | 0) {
   case 37:
   case 63:
   case 64:
    {
     $isrule$0$ph$i = 1;
     break;
    }
   default:
    $isrule$0$ph$i = 0;
   }
   $28 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
   L19 : do if (($28 | 0) == -1) $$0$i = 34; else {
    $30 = ($isrule$0$ph$i | 0) != 0;
    L21 : do if ($30) {
     $218 = $28;
     $delim$0$ph30$i = 34;
     while (1) {
      $51 = $218;
      L24 : while (1) {
       if (($51 | 0) == 62) {
        $delim$0$ph$lcssa$i = $delim$0$ph30$i;
        label = 31;
        break L21;
       }
       _prvTidyAddCharToLexer($24, $51);
       L27 : do switch ($51 | 0) {
       case 34:
        {
         break L24;
         break;
        }
       case 39:
        {
         while (1) {
          $67 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
          switch ($67 | 0) {
          case -1:
           {
            label = 41;
            break L21;
            break;
           }
          case 62:
           {
            label = 42;
            break L21;
            break;
           }
          default:
           {}
          }
          _prvTidyAddCharToLexer($24, $67);
          if (($67 | 0) == 39) break L27;
         }
         break;
        }
       default:
        {}
       } while (0);
       $51 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
       if (($51 | 0) == -1) {
        $$0$i = $delim$0$ph30$i;
        break L19;
       }
      }
      do {
       $58 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
       switch ($58 | 0) {
       case -1:
        {
         label = 37;
         break L21;
         break;
        }
       case 62:
        {
         label = 38;
         break L21;
         break;
        }
       default:
        {}
       }
       _prvTidyAddCharToLexer($24, $58);
      } while (($58 | 0) != 34);
      $218 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
      if (($218 | 0) == -1) {
       $$0$i = 39;
       break L19;
      } else $delim$0$ph30$i = 39;
     }
    } else {
     $219 = $28;
     $delim$0$ph30$us$i = 34;
     while (1) {
      $37 = $219;
      L38 : while (1) {
       if (($37 | 0) == 62) {
        $delim$0$ph$lcssa$i = $delim$0$ph30$us$i;
        label = 31;
        break L21;
       }
       if ($37 >>> 0 < 128) if (HEAP32[316488 + ($37 << 2) >> 2] & 8 | 0) {
        $$0$i = $delim$0$ph30$us$i;
        break L19;
       }
       _prvTidyAddCharToLexer($24, $37);
       L44 : do switch ($37 | 0) {
       case 34:
        {
         break L38;
         break;
        }
       case 39:
        {
         while (1) {
          $46 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
          switch ($46 | 0) {
          case -1:
           {
            label = 41;
            break L21;
            break;
           }
          case 62:
           {
            label = 42;
            break L21;
            break;
           }
          default:
           {}
          }
          _prvTidyAddCharToLexer($24, $46);
          if (($46 | 0) == 39) break L44;
         }
         break;
        }
       default:
        {}
       } while (0);
       $37 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
       if (($37 | 0) == -1) {
        $$0$i = $delim$0$ph30$us$i;
        break L19;
       }
      }
      do {
       $32 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
       switch ($32 | 0) {
       case -1:
        {
         label = 37;
         break L21;
         break;
        }
       case 62:
        {
         label = 38;
         break L21;
         break;
        }
       default:
        {}
       }
       _prvTidyAddCharToLexer($24, $32);
      } while (($32 | 0) != 34);
      $219 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
      if (($219 | 0) == -1) {
       $$0$i = 39;
       break L19;
      } else $delim$0$ph30$us$i = 39;
     }
    } while (0);
    if ((label | 0) == 31) if ($30) {
     _prvTidyAddCharToLexer($24, 62);
     $$0$i = $delim$0$ph$lcssa$i;
     break;
    } else {
     _prvTidyUngetChar(62, HEAP32[$5 >> 2] | 0);
     $$0$i = $delim$0$ph$lcssa$i;
     break;
    } else if ((label | 0) == 37) {
     _prvTidyReportAttrError($doc, HEAP32[$24 + 60 >> 2] | 0, 0, 274);
     _prvTidyUngetChar(-1, HEAP32[$5 >> 2] | 0);
     $$0$i = 0;
     break;
    } else if ((label | 0) == 38) {
     _prvTidyUngetChar(62, HEAP32[$5 >> 2] | 0);
     _prvTidyReportAttrError($doc, HEAP32[$24 + 60 >> 2] | 0, 0, 252);
     $$0$i = 0;
     break;
    } else if ((label | 0) == 41) {
     _prvTidyReportAttrError($doc, HEAP32[$24 + 60 >> 2] | 0, 0, 274);
     _prvTidyUngetChar(-1, HEAP32[$5 >> 2] | 0);
     $$0$i = 0;
     break;
    } else if ((label | 0) == 42) {
     _prvTidyUngetChar(62, HEAP32[$5 >> 2] | 0);
     _prvTidyReportAttrError($doc, HEAP32[$24 + 60 >> 2] | 0, 0, 252);
     $$0$i = 0;
     break;
    }
   } while (0);
   HEAP32[$pdelim >> 2] = $$0$i;
   $76 = (HEAP32[$22 >> 2] | 0) - $23 | 0;
   HEAP32[$22 >> 2] = $23;
   if (($76 | 0) <= 0) {
    $$0 = 0;
    return $$0 | 0;
   }
   $$0 = _prvTidytmbstrndup(HEAP32[$doc + 6856 >> 2] | 0, (HEAP32[$1 + 84 >> 2] | 0) + $23 | 0, $76) | 0;
   return $$0 | 0;
  } while (0);
  if ((label | 0) == 46) {
   _prvTidyUngetChar($85, HEAP32[$5 >> 2] | 0);
   $delim$0 = 0;
  }
  $86 = $1 + 92 | 0;
  $87 = HEAP32[$86 >> 2] | 0;
  $89 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
  L70 : do if (($89 | 0) == -1) {
   $$pre$phiZ2D = $1 + 60 | 0;
   $quotewarning$0$lcssa = 0;
   $seen_gt$0$lcssa = 0;
   label = 50;
  } else {
   $91 = ($delim$0 | 0) == 0;
   $92 = $1 + 60 | 0;
   $93 = $1 + 84 | 0;
   $94 = ($foldCase | 0) == 0;
   $97 = $89;
   $c$0116 = 0;
   $quotewarning$0117 = 0;
   $seen_gt$0115 = 0;
   L73 : while (1) {
    L75 : do if ($91) {
     switch ($97 | 0) {
     case 62:
      {
       $quotewarning$0117$lcssa286 = $quotewarning$0117;
       $seen_gt$0115$lcssa291 = $seen_gt$0115;
       label = 53;
       break L73;
       break;
      }
     case 60:
      {
       $quotewarning$0117$lcssa287 = $quotewarning$0117;
       $seen_gt$0115$lcssa292 = $seen_gt$0115;
       label = 57;
       break L73;
       break;
      }
     case 34:
     case 39:
      {
       _prvTidyReportAttrError($doc, HEAP32[$92 >> 2] | 0, 0, 258);
       $101 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
       if (($101 | 0) == 62) {
        $$lcssa284 = $97;
        $quotewarning$0117$lcssa289 = $quotewarning$0117;
        $seen_gt$0115$lcssa294 = $seen_gt$0115;
        label = 56;
        break L73;
       }
       _prvTidyUngetChar($101, HEAP32[$5 >> 2] | 0);
       $quotewarning$2 = $quotewarning$0117;
       $seen_gt$1 = $seen_gt$0115;
       label = 64;
       break L75;
       break;
      }
     case 47:
      break;
     default:
      {
       $quotewarning$2 = $quotewarning$0117;
       $seen_gt$1 = $seen_gt$0115;
       label = 64;
       break L75;
      }
     }
     $109 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
     if (($109 | 0) == 62) if (!(_prvTidyIsUrl($doc, $name) | 0)) {
      $quotewarning$0117$lcssa288 = $quotewarning$0117;
      $seen_gt$0115$lcssa293 = $seen_gt$0115;
      label = 60;
      break L73;
     }
     _prvTidyUngetChar($109, HEAP32[$5 >> 2] | 0);
     $c$455 = 47;
     $quotewarning$24751 = $quotewarning$0117;
     $seen_gt$14553 = $seen_gt$0115;
     label = 70;
    } else {
     if (($97 | 0) == ($delim$0 | 0)) {
      $quotewarning$3 = $quotewarning$0117;
      $seen_gt$2 = $seen_gt$0115;
      break L70;
     }
     $quotewarning$2 = ((($97 | 0) == 10 | ($97 | 2 | 0) == 62) & 1) + $quotewarning$0117 | 0;
     $seen_gt$1 = ($97 | 0) == 62 ? 1 : $seen_gt$0115;
     label = 64;
    } while (0);
    L86 : do if ((label | 0) == 64) {
     label = 0;
     switch ($97 | 0) {
     case 38:
      {
       _prvTidyAddCharToLexer($1, 38);
       _ParseEntity($doc, 0);
       $122 = HEAP32[$86 >> 2] | 0;
       $125 = (HEAP32[$93 >> 2] | 0) + ($122 + -1) | 0;
       if (($122 | 0) == 0 | $4 & (HEAP8[$125 >> 0] | 0) == 10 ^ 1) {
        $c$0$be = 38;
        $quotewarning$0$be = $quotewarning$2;
        $seen_gt$0$be = $seen_gt$1;
        break L86;
       }
       HEAP8[$125 >> 0] = 32;
       $c$0$be = 38;
       $quotewarning$0$be = $quotewarning$2;
       $seen_gt$0$be = $seen_gt$1;
       break L86;
       break;
      }
     case 92:
      {
       $130 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
       if (($130 | 0) == 10) {
        $c$455 = 10;
        $quotewarning$24751 = $quotewarning$2;
        $seen_gt$14553 = $seen_gt$1;
        label = 70;
        break L86;
       }
       _prvTidyUngetChar($130, HEAP32[$5 >> 2] | 0);
       $c$455 = 92;
       $quotewarning$24751 = $quotewarning$2;
       $seen_gt$14553 = $seen_gt$1;
       label = 70;
       break L86;
       break;
      }
     default:
      if ($97 >>> 0 < 128) {
       $c$455 = $97;
       $quotewarning$24751 = $quotewarning$2;
       $seen_gt$14553 = $seen_gt$1;
       label = 70;
       break L86;
      } else {
       $147 = 0;
       $c$454164 = $97;
       $quotewarning$24750168 = $quotewarning$2;
       $seen_gt$14552166 = $seen_gt$1;
       label = 80;
       break L86;
      }
     }
    } while (0);
    do if ((label | 0) == 70) {
     label = 0;
     if (!(HEAP32[316488 + ($c$455 << 2) >> 2] & 8)) {
      $147 = 1;
      $c$454164 = $c$455;
      $quotewarning$24750168 = $quotewarning$24751;
      $seen_gt$14552166 = $seen_gt$14553;
      label = 80;
     } else {
      if ($91) {
       $quotewarning$3 = $quotewarning$24751;
       $seen_gt$2 = $seen_gt$14553;
       break L70;
      }
      if ($4) {
       if (($c$455 | 0) == 10) if (_prvTidyIsUrl($doc, $name) | 0) {
        _prvTidyReportAttrError($doc, HEAP32[$92 >> 2] | 0, 0, 265);
        $c$0$be = 10;
        $quotewarning$0$be = $quotewarning$24751;
        $seen_gt$0$be = $seen_gt$14553;
        break;
       }
       if (($c$0116 | 0) == 32) if (!(_prvTidyIsUrl($doc, $name) | 0)) {
        $c$0$be = 32;
        $quotewarning$0$be = $quotewarning$24751;
        $seen_gt$0$be = $seen_gt$14553;
       } else {
        _prvTidyReportAttrError($doc, HEAP32[$92 >> 2] | 0, 0, 287);
        $c$0$be = 32;
        $quotewarning$0$be = $quotewarning$24751;
        $seen_gt$0$be = $seen_gt$14553;
       } else {
        $c$5 = 32;
        $quotewarning$24750167 = $quotewarning$24751;
        $seen_gt$14552165 = $seen_gt$14553;
        label = 83;
       }
      } else {
       $c$5 = $c$455;
       $quotewarning$24750167 = $quotewarning$24751;
       $seen_gt$14552165 = $seen_gt$14553;
       label = 83;
      }
     }
    } while (0);
    if ((label | 0) == 80) {
     label = 0;
     if ($94 | $147 ^ 1) {
      $c$5 = $c$454164;
      $quotewarning$24750167 = $quotewarning$24750168;
      $seen_gt$14552165 = $seen_gt$14552166;
      label = 83;
     } else if ($147 & (HEAP32[316488 + ($c$454164 << 2) >> 2] & 64 | 0) != 0) {
      $c$5 = HEAP32[316488 + ($c$454164 << 2) >> 2] & 64 | 0 ? $c$454164 + 32 | 0 : $c$454164;
      $quotewarning$24750167 = $quotewarning$24750168;
      $seen_gt$14552165 = $seen_gt$14552166;
      label = 83;
     } else {
      $c$5 = $c$454164;
      $quotewarning$24750167 = $quotewarning$24750168;
      $seen_gt$14552165 = $seen_gt$14552166;
      label = 83;
     }
    }
    if ((label | 0) == 83) {
     label = 0;
     _prvTidyAddCharToLexer($1, $c$5);
     $c$0$be = $c$5;
     $quotewarning$0$be = $quotewarning$24750167;
     $seen_gt$0$be = $seen_gt$14552165;
    }
    $97 = _prvTidyReadChar(HEAP32[$5 >> 2] | 0) | 0;
    if (($97 | 0) == -1) {
     $$pre$phiZ2D = $92;
     $quotewarning$0$lcssa = $quotewarning$0$be;
     $seen_gt$0$lcssa = $seen_gt$0$be;
     label = 50;
     break L70;
    } else {
     $c$0116 = $c$0$be;
     $quotewarning$0117 = $quotewarning$0$be;
     $seen_gt$0115 = $seen_gt$0$be;
    }
   }
   if ((label | 0) == 53) {
    _prvTidyUngetChar(62, HEAP32[$5 >> 2] | 0);
    $quotewarning$3 = $quotewarning$0117$lcssa286;
    $seen_gt$2 = $seen_gt$0115$lcssa291;
    break;
   } else if ((label | 0) == 56) {
    _prvTidyAddCharToLexer($1, $$lcssa284);
    _prvTidyUngetChar(62, HEAP32[$5 >> 2] | 0);
    $quotewarning$3 = $quotewarning$0117$lcssa289;
    $seen_gt$2 = $seen_gt$0115$lcssa294;
    break;
   } else if ((label | 0) == 57) {
    _prvTidyUngetChar(60, HEAP32[$5 >> 2] | 0);
    _prvTidyUngetChar(62, HEAP32[$5 >> 2] | 0);
    _prvTidyReportAttrError($doc, HEAP32[$92 >> 2] | 0, 0, 252);
    $quotewarning$3 = $quotewarning$0117$lcssa287;
    $seen_gt$2 = $seen_gt$0115$lcssa292;
    break;
   } else if ((label | 0) == 60) {
    HEAP32[$isempty >> 2] = 1;
    _prvTidyUngetChar(62, HEAP32[$5 >> 2] | 0);
    $quotewarning$3 = $quotewarning$0117$lcssa288;
    $seen_gt$2 = $seen_gt$0115$lcssa293;
    break;
   }
  } while (0);
  if ((label | 0) == 50) {
   _prvTidyReportAttrError($doc, HEAP32[$$pre$phiZ2D >> 2] | 0, 0, 274);
   _prvTidyUngetChar(-1, HEAP32[$5 >> 2] | 0);
   $quotewarning$3 = $quotewarning$0$lcssa;
   $seen_gt$2 = $seen_gt$0$lcssa;
  }
  do if ($4 & (($seen_gt$2 | 0) != 0 & $quotewarning$3 >>> 0 > 10)) if (!(_prvTidyIsScript($doc, $name) | 0)) {
   $$pre162 = $1 + 84 | 0;
   if (_prvTidyIsUrl($doc, $name) | 0) if (!(_prvTidytmbstrncmp((HEAP32[$$pre162 >> 2] | 0) + $87 | 0, 310471, 11) | 0)) break;
   if (_prvTidytmbstrncmp((HEAP32[$$pre162 >> 2] | 0) + $87 | 0, 310483, 5) | 0) _prvTidyReportFatal($doc, 0, 0, 216);
  } while (0);
  $167 = HEAP32[$86 >> 2] | 0;
  $168 = $167 - $87 | 0;
  HEAP32[$86 >> 2] = $87;
  $169 = ($168 | 0) > 0;
  $170 = ($delim$0 | 0) != 0;
  if ($170 | $169) {
   L130 : do if ($4 & $169) if (!(_prvTidytmbstrcasecmp($name, 310489) | 0)) {
    $len$2 = $168;
    $start$1 = $87;
   } else if (!(_prvTidytmbstrcasecmp($name, 310493) | 0)) {
    $len$2 = $168;
    $start$1 = $87;
   } else if (!(_prvTidytmbstrcasecmp($name, 310499) | 0)) {
    $len$2 = $168;
    $start$1 = $87;
   } else if (!(_prvTidytmbstrcasecmp($name, 310505) | 0)) {
    $len$2 = $168;
    $start$1 = $87;
   } else {
    $179 = $87 + -1 | 0;
    $182 = HEAP32[$1 + 84 >> 2] | 0;
    $184 = HEAP8[$182 + ($167 + -1) >> 0] | 0;
    L136 : do if ($184 << 24 >> 24 > -1) {
     $190 = $184;
     $len$0110 = $168;
     while (1) {
      if (!(($len$0110 | 0) > 0 ? (HEAP32[316488 + ($190 << 24 >> 24 << 2) >> 2] & 8 | 0) != 0 : 0)) {
       $len$0$lcssa = $len$0110;
       break L136;
      }
      $195 = $len$0110 + -1 | 0;
      $190 = HEAP8[$182 + ($179 + $195) >> 0] | 0;
      if ($190 << 24 >> 24 <= -1) {
       $len$0$lcssa = $195;
       break;
      } else $len$0110 = $195;
     }
    } else $len$0$lcssa = $168; while (0);
    $187 = HEAP8[$182 + $87 >> 0] | 0;
    if ($187 << 24 >> 24 > -1) {
     $201 = $187;
     $len$1104 = $len$0$lcssa;
     $start$0103 = $87;
     while (1) {
      if (!(HEAP32[316488 + ($201 << 24 >> 24 << 2) >> 2] & 8)) {
       $len$2 = $len$1104;
       $start$1 = $start$0103;
       break L130;
      }
      if (!(($start$0103 | 0) < ($len$1104 | 0) & ($len$1104 | 0) > 0)) {
       $len$2 = $len$1104;
       $start$1 = $start$0103;
       break L130;
      }
      $206 = $start$0103 + 1 | 0;
      $207 = $len$1104 + -1 | 0;
      $201 = HEAP8[$182 + $206 >> 0] | 0;
      if ($201 << 24 >> 24 <= -1) {
       $len$2 = $207;
       $start$1 = $206;
       break;
      } else {
       $len$1104 = $207;
       $start$0103 = $206;
      }
     }
    } else {
     $len$2 = $len$0$lcssa;
     $start$1 = $87;
    }
   } else {
    $len$2 = $168;
    $start$1 = $87;
   } while (0);
   $value$0 = _prvTidytmbstrndup(HEAP32[$doc + 6856 >> 2] | 0, (HEAP32[$1 + 84 >> 2] | 0) + $start$1 | 0, $len$2) | 0;
  } else $value$0 = 0;
  HEAP32[$pdelim >> 2] = $170 ? $delim$0 : 34;
  $$0 = $value$0;
  return $$0 | 0;
 } while (0);
 _prvTidyUngetChar($14, HEAP32[$5 >> 2] | 0);
 $$0 = 0;
 return $$0 | 0;
}

function _printOption($tdoc, $topt, $d) {
 $tdoc = $tdoc | 0;
 $topt = $topt | 0;
 $d = $d | 0;
 var $$0$i$i = 0, $$0$i16$i = 0, $$0$i33$i = 0, $$lcssa = 0, $$lcssa$i$i = 0, $$lcssa$i26$i = 0, $$lcssa$i9$i = 0, $$lcssa13 = 0, $10 = 0, $101 = 0, $106 = 0, $109 = 0, $112 = 0, $115 = 0, $118 = 0, $121 = 0, $124 = 0, $127 = 0, $130 = 0, $133 = 0, $136 = 0, $139 = 0, $142 = 0, $145 = 0, $148 = 0, $15 = 0, $151 = 0, $154 = 0, $157 = 0, $160 = 0, $163 = 0, $166 = 0, $169 = 0, $172 = 0, $175 = 0, $2 = 0, $20 = 0, $203 = 0, $205 = 0, $208 = 0, $211 = 0, $214 = 0, $217 = 0, $22 = 0, $220 = 0, $230 = 0, $232 = 0, $24 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $38 = 0, $39 = 0, $40 = 0, $47 = 0, $52 = 0, $64 = 0, $69 = 0, $81 = 0, $98 = 0, $endptr$i$i = 0, $first$04$i$i = 0, $j$0$lcssa$i2137$i = 0, $j$08$i$lcssa$i = 0, $j$08$i19$i = 0, $j$08$i2$lcssa$i = 0, $j$1$lcssa$i$i = 0, $j$1$lcssa$i10$i = 0, $j$1$lcssa$i27$i = 0, $j$13$i24$i = 0, $l$0$i$i = 0, $l$0$i14$i = 0, $l$0$i31$i = 0, $len$0$lcssa$i$i = 0, $len$03$i$i = 0, $n$0$i$i = 0, $n$0$i15$i = 0, $n$0$i32$i = 0, $pc1$0$i = 0, $pc2$0$i = 0, $pc3$0$i = 0, $pos$i$i = 0, $pval$0 = 0, $val$0 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $pos$i$i = sp + 12 | 0;
 if (_tidyOptIsReadOnly($topt) | 0) {
  STACKTOP = sp;
  return;
 }
 $2 = HEAP32[$d >> 2] | 0;
 if (!(HEAP8[$2 >> 0] | 0)) if (!(HEAP8[HEAP32[$d + 8 >> 2] >> 0] | 0)) {
  STACKTOP = sp;
  return;
 }
 $10 = HEAP32[$d + 12 >> 2] | 0;
 if (!(HEAP32[$d + 100 >> 2] | 0)) {
  $232 = $2;
  $pval$0 = 222806;
  $val$0 = 0;
 } else if (!$10) {
  $15 = _tidyOptGetPickList($topt) | 0;
  HEAP32[$pos$i$i >> 2] = $15;
  if (!$15) $len$0$lcssa$i$i = 1; else {
   $first$04$i$i = 0;
   $len$03$i$i = 0;
   while (1) {
    $20 = (_strlen(_tidyOptGetNextPick($topt, $pos$i$i) | 0) | 0) + ($first$04$i$i ? $len$03$i$i + 2 | 0 : $len$03$i$i) | 0;
    if (!(HEAP32[$pos$i$i >> 2] | 0)) {
     $$lcssa13 = $20;
     break;
    } else {
     $first$04$i$i = 1;
     $len$03$i$i = $20;
    }
   }
   $len$0$lcssa$i$i = $$lcssa13 + 1 | 0;
  }
  $22 = _malloc($len$0$lcssa$i$i) | 0;
  if (!$22) _outOfMemory();
  HEAP8[$22 >> 0] = 0;
  $24 = _tidyOptGetPickList($topt) | 0;
  HEAP32[$pos$i$i >> 2] = $24;
  if ($24 | 0) {
   _strcat($22, _tidyOptGetNextPick($topt, $pos$i$i) | 0) | 0;
   if (HEAP32[$pos$i$i >> 2] | 0) do {
    $endptr$i$i = $22 + (_strlen($22) | 0) | 0;
    HEAP8[$endptr$i$i >> 0] = HEAP8[225098] | 0;
    HEAP8[$endptr$i$i + 1 >> 0] = HEAP8[225099] | 0;
    HEAP8[$endptr$i$i + 2 >> 0] = HEAP8[225100] | 0;
    _strcat($22, _tidyOptGetNextPick($topt, $pos$i$i) | 0) | 0;
   } while ((HEAP32[$pos$i$i >> 2] | 0) != 0);
  }
  $232 = HEAP32[$d >> 2] | 0;
  $pval$0 = $22;
  $val$0 = $22;
 } else {
  $232 = $2;
  $pval$0 = $10;
  $val$0 = 0;
 }
 $31 = HEAP32[$d + 8 >> 2] | 0;
 $32 = _malloc(28) | 0;
 $33 = _malloc(10) | 0;
 $34 = _malloc(41) | 0;
 if (!$32) _outOfMemory();
 if (!$33) _outOfMemory();
 if (!$34) _outOfMemory();
 $38 = $34 + 40 | 0;
 $39 = $33 + 9 | 0;
 $40 = $32 + 27 | 0;
 $pc1$0$i = $232;
 $pc2$0$i = $31;
 $pc3$0$i = $pval$0;
 while (1) {
  do if (!$pc1$0$i) {
   HEAP8[$32 >> 0] = 0;
   $$0$i$i = 0;
  } else {
   if ((_strlen($pc1$0$i) | 0) >>> 0 <= 27) {
    _strcpy($32, $pc1$0$i) | 0;
    HEAP8[$40 >> 0] = 0;
    $$0$i$i = 0;
    break;
   }
   do if ((HEAP8[$pc1$0$i >> 0] | 0) == 10) {
    $j$08$i$lcssa$i = 0;
    label = 31;
   } else {
    $47 = HEAP8[$pc1$0$i + 1 >> 0] | 0;
    if ($47 << 24 >> 24 == 10) {
     $j$08$i$lcssa$i = 1;
     label = 31;
    } else {
     $106 = HEAP8[$pc1$0$i + 2 >> 0] | 0;
     if ($106 << 24 >> 24 == 10) {
      $j$08$i$lcssa$i = 2;
      label = 31;
     } else {
      $109 = HEAP8[$pc1$0$i + 3 >> 0] | 0;
      if ($109 << 24 >> 24 == 10) {
       $j$08$i$lcssa$i = 3;
       label = 31;
      } else {
       $112 = HEAP8[$pc1$0$i + 4 >> 0] | 0;
       if ($112 << 24 >> 24 == 10) {
        $j$08$i$lcssa$i = 4;
        label = 31;
       } else {
        $115 = HEAP8[$pc1$0$i + 5 >> 0] | 0;
        if ($115 << 24 >> 24 == 10) {
         $j$08$i$lcssa$i = 5;
         label = 31;
        } else {
         $118 = HEAP8[$pc1$0$i + 6 >> 0] | 0;
         if ($118 << 24 >> 24 == 10) {
          $j$08$i$lcssa$i = 6;
          label = 31;
         } else {
          $121 = HEAP8[$pc1$0$i + 7 >> 0] | 0;
          if ($121 << 24 >> 24 == 10) {
           $j$08$i$lcssa$i = 7;
           label = 31;
          } else {
           $124 = HEAP8[$pc1$0$i + 8 >> 0] | 0;
           if ($124 << 24 >> 24 == 10) {
            $j$08$i$lcssa$i = 8;
            label = 31;
           } else {
            $127 = HEAP8[$pc1$0$i + 9 >> 0] | 0;
            if ($127 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 9;
             label = 31;
             break;
            }
            $130 = HEAP8[$pc1$0$i + 10 >> 0] | 0;
            if ($130 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 10;
             label = 31;
             break;
            }
            $133 = HEAP8[$pc1$0$i + 11 >> 0] | 0;
            if ($133 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 11;
             label = 31;
             break;
            }
            $136 = HEAP8[$pc1$0$i + 12 >> 0] | 0;
            if ($136 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 12;
             label = 31;
             break;
            }
            $139 = HEAP8[$pc1$0$i + 13 >> 0] | 0;
            if ($139 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 13;
             label = 31;
             break;
            }
            $142 = HEAP8[$pc1$0$i + 14 >> 0] | 0;
            if ($142 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 14;
             label = 31;
             break;
            }
            $145 = HEAP8[$pc1$0$i + 15 >> 0] | 0;
            if ($145 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 15;
             label = 31;
             break;
            }
            $148 = HEAP8[$pc1$0$i + 16 >> 0] | 0;
            if ($148 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 16;
             label = 31;
             break;
            }
            $151 = HEAP8[$pc1$0$i + 17 >> 0] | 0;
            if ($151 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 17;
             label = 31;
             break;
            }
            $154 = HEAP8[$pc1$0$i + 18 >> 0] | 0;
            if ($154 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 18;
             label = 31;
             break;
            }
            $157 = HEAP8[$pc1$0$i + 19 >> 0] | 0;
            if ($157 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 19;
             label = 31;
             break;
            }
            $160 = HEAP8[$pc1$0$i + 20 >> 0] | 0;
            if ($160 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 20;
             label = 31;
             break;
            }
            $163 = HEAP8[$pc1$0$i + 21 >> 0] | 0;
            if ($163 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 21;
             label = 31;
             break;
            }
            $166 = HEAP8[$pc1$0$i + 22 >> 0] | 0;
            if ($166 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 22;
             label = 31;
             break;
            }
            $169 = HEAP8[$pc1$0$i + 23 >> 0] | 0;
            if ($169 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 23;
             label = 31;
             break;
            }
            $172 = HEAP8[$pc1$0$i + 24 >> 0] | 0;
            if ($172 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 24;
             label = 31;
             break;
            }
            $175 = HEAP8[$pc1$0$i + 25 >> 0] | 0;
            if ($175 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 25;
             label = 31;
             break;
            }
            $52 = HEAP8[$pc1$0$i + 26 >> 0] | 0;
            if ($52 << 24 >> 24 == 10) {
             $j$08$i$lcssa$i = 26;
             label = 31;
             break;
            }
            do if ((HEAP8[$pc1$0$i + 27 >> 0] | 0) == 32) {
             $$lcssa$i$i = 0;
             $j$1$lcssa$i$i = 27;
            } else {
             if ($52 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 26;
              break;
             }
             if ($175 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 25;
              break;
             }
             if ($172 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 24;
              break;
             }
             if ($169 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 23;
              break;
             }
             if ($166 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 22;
              break;
             }
             if ($163 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 21;
              break;
             }
             if ($160 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 20;
              break;
             }
             if ($157 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 19;
              break;
             }
             if ($154 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 18;
              break;
             }
             if ($151 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 17;
              break;
             }
             if ($148 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 16;
              break;
             }
             if ($145 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 15;
              break;
             }
             if ($142 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 14;
              break;
             }
             if ($139 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 13;
              break;
             }
             if ($136 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 12;
              break;
             }
             if ($133 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 11;
              break;
             }
             if ($130 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 10;
              break;
             }
             if ($127 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 9;
              break;
             }
             if ($124 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 8;
              break;
             }
             if ($121 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 7;
              break;
             }
             if ($118 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 6;
              break;
             }
             if ($115 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 5;
              break;
             }
             if ($112 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 4;
              break;
             }
             if ($109 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 3;
              break;
             }
             if ($106 << 24 >> 24 == 32) {
              $$lcssa$i$i = 0;
              $j$1$lcssa$i$i = 2;
              break;
             }
             $203 = $47 << 24 >> 24 == 32;
             $$lcssa$i$i = $203 ^ 1;
             $j$1$lcssa$i$i = $203 & 1;
            } while (0);
            $l$0$i$i = $$lcssa$i$i ? 27 : $j$1$lcssa$i$i;
            $n$0$i$i = $$lcssa$i$i ? 27 : $j$1$lcssa$i$i + 1 | 0;
           }
          }
         }
        }
       }
      }
     }
    }
   } while (0);
   if ((label | 0) == 31) {
    label = 0;
    $l$0$i$i = $j$08$i$lcssa$i;
    $n$0$i$i = $j$08$i$lcssa$i + 1 | 0;
   }
   _strncpy($32, $pc1$0$i, $l$0$i$i) | 0;
   HEAP8[$32 + $l$0$i$i >> 0] = 0;
   $$0$i$i = $pc1$0$i + $n$0$i$i | 0;
  } while (0);
  do if (!$pc2$0$i) {
   HEAP8[$33 >> 0] = 0;
   $$0$i16$i = 0;
  } else {
   if ((_strlen($pc2$0$i) | 0) >>> 0 <= 9) {
    _strcpy($33, $pc2$0$i) | 0;
    HEAP8[$39 >> 0] = 0;
    $$0$i16$i = 0;
    break;
   }
   do if ((HEAP8[$pc2$0$i >> 0] | 0) == 10) {
    $j$08$i2$lcssa$i = 0;
    label = 42;
   } else {
    $64 = HEAP8[$pc2$0$i + 1 >> 0] | 0;
    if ($64 << 24 >> 24 == 10) {
     $j$08$i2$lcssa$i = 1;
     label = 42;
    } else {
     $205 = HEAP8[$pc2$0$i + 2 >> 0] | 0;
     if ($205 << 24 >> 24 == 10) {
      $j$08$i2$lcssa$i = 2;
      label = 42;
     } else {
      $208 = HEAP8[$pc2$0$i + 3 >> 0] | 0;
      if ($208 << 24 >> 24 == 10) {
       $j$08$i2$lcssa$i = 3;
       label = 42;
      } else {
       $211 = HEAP8[$pc2$0$i + 4 >> 0] | 0;
       if ($211 << 24 >> 24 == 10) {
        $j$08$i2$lcssa$i = 4;
        label = 42;
       } else {
        $214 = HEAP8[$pc2$0$i + 5 >> 0] | 0;
        if ($214 << 24 >> 24 == 10) {
         $j$08$i2$lcssa$i = 5;
         label = 42;
        } else {
         $217 = HEAP8[$pc2$0$i + 6 >> 0] | 0;
         if ($217 << 24 >> 24 == 10) {
          $j$08$i2$lcssa$i = 6;
          label = 42;
         } else {
          $220 = HEAP8[$pc2$0$i + 7 >> 0] | 0;
          if ($220 << 24 >> 24 == 10) {
           $j$08$i2$lcssa$i = 7;
           label = 42;
          } else {
           $69 = HEAP8[$pc2$0$i + 8 >> 0] | 0;
           if ($69 << 24 >> 24 == 10) {
            $j$08$i2$lcssa$i = 8;
            label = 42;
            break;
           }
           do if ((HEAP8[$pc2$0$i + 9 >> 0] | 0) == 32) {
            $$lcssa$i9$i = 0;
            $j$1$lcssa$i10$i = 9;
           } else {
            if ($69 << 24 >> 24 == 32) {
             $$lcssa$i9$i = 0;
             $j$1$lcssa$i10$i = 8;
             break;
            }
            if ($220 << 24 >> 24 == 32) {
             $$lcssa$i9$i = 0;
             $j$1$lcssa$i10$i = 7;
             break;
            }
            if ($217 << 24 >> 24 == 32) {
             $$lcssa$i9$i = 0;
             $j$1$lcssa$i10$i = 6;
             break;
            }
            if ($214 << 24 >> 24 == 32) {
             $$lcssa$i9$i = 0;
             $j$1$lcssa$i10$i = 5;
             break;
            }
            if ($211 << 24 >> 24 == 32) {
             $$lcssa$i9$i = 0;
             $j$1$lcssa$i10$i = 4;
             break;
            }
            if ($208 << 24 >> 24 == 32) {
             $$lcssa$i9$i = 0;
             $j$1$lcssa$i10$i = 3;
             break;
            }
            if ($205 << 24 >> 24 == 32) {
             $$lcssa$i9$i = 0;
             $j$1$lcssa$i10$i = 2;
             break;
            }
            $230 = $64 << 24 >> 24 == 32;
            $$lcssa$i9$i = $230 ^ 1;
            $j$1$lcssa$i10$i = $230 & 1;
           } while (0);
           $l$0$i14$i = $$lcssa$i9$i ? 9 : $j$1$lcssa$i10$i;
           $n$0$i15$i = $$lcssa$i9$i ? 9 : $j$1$lcssa$i10$i + 1 | 0;
          }
         }
        }
       }
      }
     }
    }
   } while (0);
   if ((label | 0) == 42) {
    label = 0;
    $l$0$i14$i = $j$08$i2$lcssa$i;
    $n$0$i15$i = $j$08$i2$lcssa$i + 1 | 0;
   }
   _strncpy($33, $pc2$0$i, $l$0$i14$i) | 0;
   HEAP8[$33 + $l$0$i14$i >> 0] = 0;
   $$0$i16$i = $pc2$0$i + $n$0$i15$i | 0;
  } while (0);
  do if (!$pc3$0$i) {
   HEAP8[$34 >> 0] = 0;
   $$0$i33$i = 0;
  } else {
   if ((_strlen($pc3$0$i) | 0) >>> 0 > 40) $j$08$i19$i = 0; else {
    _strcpy($34, $pc3$0$i) | 0;
    HEAP8[$38 >> 0] = 0;
    $$0$i33$i = 0;
    break;
   }
   while (1) {
    if ((HEAP8[$pc3$0$i + $j$08$i19$i >> 0] | 0) == 10) {
     $j$0$lcssa$i2137$i = $j$08$i19$i;
     label = 54;
     break;
    }
    $81 = $j$08$i19$i + 1 | 0;
    if ($81 >>> 0 < 40) $j$08$i19$i = $81; else {
     $$lcssa = $81;
     label = 50;
     break;
    }
   }
   if ((label | 0) == 50) {
    label = 0;
    if (($$lcssa | 0) == 40) {
     $j$13$i24$i = 40;
     while (1) {
      if ((HEAP8[$pc3$0$i + $j$13$i24$i >> 0] | 0) == 32) {
       $$lcssa$i26$i = 0;
       $j$1$lcssa$i27$i = $j$13$i24$i;
       break;
      }
      $j$13$i24$i = $j$13$i24$i + -1 | 0;
      if (!$j$13$i24$i) {
       $$lcssa$i26$i = 1;
       $j$1$lcssa$i27$i = 0;
       break;
      }
     }
     $l$0$i31$i = $$lcssa$i26$i ? 40 : $j$1$lcssa$i27$i;
     $n$0$i32$i = $$lcssa$i26$i ? 40 : $j$1$lcssa$i27$i + 1 | 0;
    } else {
     $j$0$lcssa$i2137$i = $$lcssa;
     label = 54;
    }
   }
   if ((label | 0) == 54) {
    label = 0;
    $l$0$i31$i = $j$0$lcssa$i2137$i;
    $n$0$i32$i = $j$0$lcssa$i2137$i + 1 | 0;
   }
   _strncpy($34, $pc3$0$i, $l$0$i31$i) | 0;
   HEAP8[$34 + $l$0$i31$i >> 0] = 0;
   $$0$i33$i = $pc3$0$i + $n$0$i32$i | 0;
  } while (0);
  $98 = HEAP8[$33 >> 0] | 0 ? $33 : 317568;
  $101 = HEAP8[$34 >> 0] | 0 ? $34 : 317568;
  HEAP32[$vararg_buffer >> 2] = HEAP8[$32 >> 0] | 0 ? $32 : 317568;
  HEAP32[$vararg_buffer + 4 >> 2] = $98;
  HEAP32[$vararg_buffer + 8 >> 2] = $101;
  _printf(222779, $vararg_buffer) | 0;
  if (($$0$i$i | 0) != 0 | ($$0$i16$i | 0) != 0 | ($$0$i33$i | 0) != 0) {
   $pc1$0$i = $$0$i$i;
   $pc2$0$i = $$0$i16$i;
   $pc3$0$i = $$0$i33$i;
  } else break;
 }
 _free($32);
 _free($33);
 _free($34);
 if (!$val$0) {
  STACKTOP = sp;
  return;
 }
 _free($val$0);
 STACKTOP = sp;
 return;
}

function _strstr($h, $n) {
 $h = $h | 0;
 $n = $n | 0;
 var $$0 = 0, $$0$lcssa$i = 0, $$0$lcssa$i12 = 0, $$0$lcssa$i4 = 0, $$01$i = 0, $$02$i = 0, $$02$i8 = 0, $$03$i = 0, $$3$i = 0, $$lcssa$i = 0, $$lcssa$i11 = 0, $$lcssa291 = 0, $$lcssa294 = 0, $$lcssa297 = 0, $$lcssa311 = 0, $$lcssa314 = 0, $$lcssa317 = 0, $$lcssa332 = 0, $$pr$i = 0, $0 = 0, $111 = 0, $115 = 0, $118 = 0, $12 = 0, $125 = 0, $132 = 0, $134 = 0, $135 = 0, $142 = 0, $151 = 0, $153 = 0, $154 = 0, $161 = 0, $165 = 0, $169 = 0, $17 = 0, $171 = 0, $175 = 0, $179 = 0, $180 = 0, $181 = 0, $183 = 0, $186 = 0, $193 = 0, $204 = 0, $205 = 0, $212 = 0, $214 = 0, $23 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $26 = 0, $27 = 0, $3 = 0, $31 = 0, $35 = 0, $36 = 0, $39 = 0, $48 = 0, $57 = 0, $59 = 0, $6 = 0, $60 = 0, $69 = 0, $70 = 0, $8 = 0, $84 = 0, $9 = 0, $95 = 0, $98 = 0, $99 = 0, $byteset$i = 0, $hw$0$in2$i = 0, $hw$03$i = 0, $hw$03$i7 = 0, $ip$0$ph$lcssa$i = 0, $ip$0$ph$lcssa145$i = 0, $ip$0$ph78$i = 0, $ip$1$ip$0$i = 0, $ip$1$ph$lcssa$i = 0, $ip$1$ph57$i = 0, $jp$0$ph15$ph72$i = 0, $jp$0$ph1567$i = 0, $jp$0$ph1567$i$lcssa = 0, $jp$0$ph1567$i$lcssa$lcssa = 0, $jp$0$ph79$i = 0, $jp$1$ph11$ph51$i = 0, $jp$1$ph1146$i = 0, $jp$1$ph1146$i$lcssa = 0, $jp$1$ph1146$i$lcssa$lcssa = 0, $jp$1$ph58$i = 0, $k$061$i = 0, $k$141$i = 0, $k$340$i = 0, $k$340$i$lcssa = 0, $k$4$i = 0, $l$082$i = 0, $l$082$i$lcssa331 = 0, $mem$0$i = 0, $mem0$0$i = 0, $p$0$ph$ph$lcssa34$i = 0, $p$0$ph$ph$lcssa34146$i = 0, $p$0$ph$ph73$i = 0, $p$1$p$0$i = 0, $p$1$ph$ph$lcssa25$i = 0, $p$1$ph$ph52$i = 0, $p$3$i = 0, $shift$i = 0, $z$0$i = 0, $z$3$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1056 | 0;
 $byteset$i = sp + 1024 | 0;
 $shift$i = sp;
 $0 = HEAP8[$n >> 0] | 0;
 do if (!($0 << 24 >> 24)) $$0 = $h; else {
  $3 = _strchr($h, $0 << 24 >> 24) | 0;
  if (!$3) $$0 = 0; else {
   $6 = HEAP8[$n + 1 >> 0] | 0;
   if (!($6 << 24 >> 24)) $$0 = $3; else {
    $8 = $3 + 1 | 0;
    $9 = HEAP8[$8 >> 0] | 0;
    if (!($9 << 24 >> 24)) $$0 = 0; else {
     $12 = HEAP8[$n + 2 >> 0] | 0;
     if (!($12 << 24 >> 24)) {
      $17 = $6 & 255 | ($0 & 255) << 8;
      $$01$i = $8;
      $233 = $9;
      $hw$0$in2$i = HEAPU8[$3 >> 0] << 8 | $9 & 255;
      while (1) {
       $23 = $hw$0$in2$i & 65535;
       if (($23 | 0) == ($17 | 0)) {
        $$0$lcssa$i = $$01$i;
        $31 = $233;
        break;
       }
       $26 = $$01$i + 1 | 0;
       $27 = HEAP8[$26 >> 0] | 0;
       if (!($27 << 24 >> 24)) {
        $$0$lcssa$i = $26;
        $31 = 0;
        break;
       } else {
        $$01$i = $26;
        $233 = $27;
        $hw$0$in2$i = $27 & 255 | $23 << 8;
       }
      }
      $$0 = $31 << 24 >> 24 ? $$0$lcssa$i + -1 | 0 : 0;
      break;
     }
     $35 = $3 + 2 | 0;
     $36 = HEAP8[$35 >> 0] | 0;
     if (!($36 << 24 >> 24)) $$0 = 0; else {
      $39 = HEAP8[$n + 3 >> 0] | 0;
      if (!($39 << 24 >> 24)) {
       $48 = ($6 & 255) << 16 | ($0 & 255) << 24 | ($12 & 255) << 8;
       $57 = ($36 & 255) << 8 | ($9 & 255) << 16 | HEAPU8[$3 >> 0] << 24;
       if (($57 | 0) == ($48 | 0)) {
        $$0$lcssa$i4 = $35;
        $$lcssa$i = $36;
       } else {
        $$02$i = $35;
        $hw$03$i = $57;
        while (1) {
         $59 = $$02$i + 1 | 0;
         $60 = HEAP8[$59 >> 0] | 0;
         $hw$03$i = ($60 & 255 | $hw$03$i) << 8;
         if ($60 << 24 >> 24 == 0 | ($hw$03$i | 0) == ($48 | 0)) {
          $$0$lcssa$i4 = $59;
          $$lcssa$i = $60;
          break;
         } else $$02$i = $59;
        }
       }
       $$0 = $$lcssa$i << 24 >> 24 ? $$0$lcssa$i4 + -2 | 0 : 0;
       break;
      }
      $69 = $3 + 3 | 0;
      $70 = HEAP8[$69 >> 0] | 0;
      if (!($70 << 24 >> 24)) $$0 = 0; else {
       if (!(HEAP8[$n + 4 >> 0] | 0)) {
        $84 = ($6 & 255) << 16 | ($0 & 255) << 24 | ($12 & 255) << 8 | $39 & 255;
        $95 = ($36 & 255) << 8 | ($9 & 255) << 16 | $70 & 255 | HEAPU8[$3 >> 0] << 24;
        if (($95 | 0) == ($84 | 0)) {
         $$0$lcssa$i12 = $69;
         $$lcssa$i11 = $70;
        } else {
         $$02$i8 = $69;
         $hw$03$i7 = $95;
         while (1) {
          $98 = $$02$i8 + 1 | 0;
          $99 = HEAP8[$98 >> 0] | 0;
          $hw$03$i7 = $99 & 255 | $hw$03$i7 << 8;
          if ($99 << 24 >> 24 == 0 | ($hw$03$i7 | 0) == ($84 | 0)) {
           $$0$lcssa$i12 = $98;
           $$lcssa$i11 = $99;
           break;
          } else $$02$i8 = $98;
         }
        }
        $$0 = $$lcssa$i11 << 24 >> 24 ? $$0$lcssa$i12 + -3 | 0 : 0;
        break;
       };
       HEAP32[$byteset$i >> 2] = 0;
       HEAP32[$byteset$i + 4 >> 2] = 0;
       HEAP32[$byteset$i + 8 >> 2] = 0;
       HEAP32[$byteset$i + 12 >> 2] = 0;
       HEAP32[$byteset$i + 16 >> 2] = 0;
       HEAP32[$byteset$i + 20 >> 2] = 0;
       HEAP32[$byteset$i + 24 >> 2] = 0;
       HEAP32[$byteset$i + 28 >> 2] = 0;
       $111 = $0;
       $l$082$i = 0;
       while (1) {
        if (!(HEAP8[$3 + $l$082$i >> 0] | 0)) {
         $$3$i = 0;
         break;
        }
        $115 = $byteset$i + ((($111 & 255) >>> 5 & 255) << 2) | 0;
        HEAP32[$115 >> 2] = HEAP32[$115 >> 2] | 1 << ($111 & 31);
        $118 = $l$082$i + 1 | 0;
        HEAP32[$shift$i + (($111 & 255) << 2) >> 2] = $118;
        $111 = HEAP8[$n + $118 >> 0] | 0;
        if (!($111 << 24 >> 24)) {
         $$lcssa332 = $118;
         $l$082$i$lcssa331 = $l$082$i;
         label = 23;
         break;
        } else $l$082$i = $118;
       }
       L32 : do if ((label | 0) == 23) {
        L34 : do if ($$lcssa332 >>> 0 > 1) {
         $234 = 1;
         $ip$0$ph78$i = -1;
         $jp$0$ph79$i = 0;
         L35 : while (1) {
          $235 = $234;
          $jp$0$ph15$ph72$i = $jp$0$ph79$i;
          $p$0$ph$ph73$i = 1;
          while (1) {
           $236 = $235;
           $jp$0$ph1567$i = $jp$0$ph15$ph72$i;
           L39 : while (1) {
            $134 = $236;
            $k$061$i = 1;
            while (1) {
             $132 = HEAP8[$n + ($k$061$i + $ip$0$ph78$i) >> 0] | 0;
             $135 = HEAP8[$n + $134 >> 0] | 0;
             if ($132 << 24 >> 24 != $135 << 24 >> 24) {
              $$lcssa311 = $134;
              $$lcssa314 = $132;
              $$lcssa317 = $135;
              $jp$0$ph1567$i$lcssa = $jp$0$ph1567$i;
              break L39;
             }
             if (($k$061$i | 0) == ($p$0$ph$ph73$i | 0)) break;
             $k$061$i = $k$061$i + 1 | 0;
             $134 = $k$061$i + $jp$0$ph1567$i | 0;
             if ($134 >>> 0 >= $$lcssa332 >>> 0) {
              $ip$0$ph$lcssa$i = $ip$0$ph78$i;
              $p$0$ph$ph$lcssa34$i = $p$0$ph$ph73$i;
              break L35;
             }
            }
            $jp$0$ph1567$i = $jp$0$ph1567$i + $p$0$ph$ph73$i | 0;
            $236 = $jp$0$ph1567$i + 1 | 0;
            if ($236 >>> 0 >= $$lcssa332 >>> 0) {
             $ip$0$ph$lcssa$i = $ip$0$ph78$i;
             $p$0$ph$ph$lcssa34$i = $p$0$ph$ph73$i;
             break L35;
            }
           }
           $142 = $$lcssa311 - $ip$0$ph78$i | 0;
           if (($$lcssa314 & 255) <= ($$lcssa317 & 255)) {
            $jp$0$ph1567$i$lcssa$lcssa = $jp$0$ph1567$i$lcssa;
            break;
           }
           $125 = $$lcssa311 + 1 | 0;
           if ($125 >>> 0 < $$lcssa332 >>> 0) {
            $235 = $125;
            $jp$0$ph15$ph72$i = $$lcssa311;
            $p$0$ph$ph73$i = $142;
           } else {
            $ip$0$ph$lcssa$i = $ip$0$ph78$i;
            $p$0$ph$ph$lcssa34$i = $142;
            break L35;
           }
          }
          $234 = $jp$0$ph1567$i$lcssa$lcssa + 2 | 0;
          if ($234 >>> 0 >= $$lcssa332 >>> 0) {
           $ip$0$ph$lcssa$i = $jp$0$ph1567$i$lcssa$lcssa;
           $p$0$ph$ph$lcssa34$i = 1;
           break;
          } else {
           $ip$0$ph78$i = $jp$0$ph1567$i$lcssa$lcssa;
           $jp$0$ph79$i = $jp$0$ph1567$i$lcssa$lcssa + 1 | 0;
          }
         }
         $237 = 1;
         $ip$1$ph57$i = -1;
         $jp$1$ph58$i = 0;
         while (1) {
          $239 = $237;
          $jp$1$ph11$ph51$i = $jp$1$ph58$i;
          $p$1$ph$ph52$i = 1;
          while (1) {
           $238 = $239;
           $jp$1$ph1146$i = $jp$1$ph11$ph51$i;
           L54 : while (1) {
            $153 = $238;
            $k$141$i = 1;
            while (1) {
             $151 = HEAP8[$n + ($k$141$i + $ip$1$ph57$i) >> 0] | 0;
             $154 = HEAP8[$n + $153 >> 0] | 0;
             if ($151 << 24 >> 24 != $154 << 24 >> 24) {
              $$lcssa291 = $153;
              $$lcssa294 = $151;
              $$lcssa297 = $154;
              $jp$1$ph1146$i$lcssa = $jp$1$ph1146$i;
              break L54;
             }
             if (($k$141$i | 0) == ($p$1$ph$ph52$i | 0)) break;
             $k$141$i = $k$141$i + 1 | 0;
             $153 = $k$141$i + $jp$1$ph1146$i | 0;
             if ($153 >>> 0 >= $$lcssa332 >>> 0) {
              $ip$0$ph$lcssa145$i = $ip$0$ph$lcssa$i;
              $ip$1$ph$lcssa$i = $ip$1$ph57$i;
              $p$0$ph$ph$lcssa34146$i = $p$0$ph$ph$lcssa34$i;
              $p$1$ph$ph$lcssa25$i = $p$1$ph$ph52$i;
              break L34;
             }
            }
            $jp$1$ph1146$i = $jp$1$ph1146$i + $p$1$ph$ph52$i | 0;
            $238 = $jp$1$ph1146$i + 1 | 0;
            if ($238 >>> 0 >= $$lcssa332 >>> 0) {
             $ip$0$ph$lcssa145$i = $ip$0$ph$lcssa$i;
             $ip$1$ph$lcssa$i = $ip$1$ph57$i;
             $p$0$ph$ph$lcssa34146$i = $p$0$ph$ph$lcssa34$i;
             $p$1$ph$ph$lcssa25$i = $p$1$ph$ph52$i;
             break L34;
            }
           }
           $161 = $$lcssa291 - $ip$1$ph57$i | 0;
           if (($$lcssa294 & 255) >= ($$lcssa297 & 255)) {
            $jp$1$ph1146$i$lcssa$lcssa = $jp$1$ph1146$i$lcssa;
            break;
           }
           $165 = $$lcssa291 + 1 | 0;
           if ($165 >>> 0 < $$lcssa332 >>> 0) {
            $239 = $165;
            $jp$1$ph11$ph51$i = $$lcssa291;
            $p$1$ph$ph52$i = $161;
           } else {
            $ip$0$ph$lcssa145$i = $ip$0$ph$lcssa$i;
            $ip$1$ph$lcssa$i = $ip$1$ph57$i;
            $p$0$ph$ph$lcssa34146$i = $p$0$ph$ph$lcssa34$i;
            $p$1$ph$ph$lcssa25$i = $161;
            break L34;
           }
          }
          $237 = $jp$1$ph1146$i$lcssa$lcssa + 2 | 0;
          if ($237 >>> 0 >= $$lcssa332 >>> 0) {
           $ip$0$ph$lcssa145$i = $ip$0$ph$lcssa$i;
           $ip$1$ph$lcssa$i = $jp$1$ph1146$i$lcssa$lcssa;
           $p$0$ph$ph$lcssa34146$i = $p$0$ph$ph$lcssa34$i;
           $p$1$ph$ph$lcssa25$i = 1;
           break;
          } else {
           $ip$1$ph57$i = $jp$1$ph1146$i$lcssa$lcssa;
           $jp$1$ph58$i = $jp$1$ph1146$i$lcssa$lcssa + 1 | 0;
          }
         }
        } else {
         $ip$0$ph$lcssa145$i = -1;
         $ip$1$ph$lcssa$i = -1;
         $p$0$ph$ph$lcssa34146$i = 1;
         $p$1$ph$ph$lcssa25$i = 1;
        } while (0);
        $169 = ($ip$1$ph$lcssa$i + 1 | 0) >>> 0 > ($ip$0$ph$lcssa145$i + 1 | 0) >>> 0;
        $p$1$p$0$i = $169 ? $p$1$ph$ph$lcssa25$i : $p$0$ph$ph$lcssa34146$i;
        $ip$1$ip$0$i = $169 ? $ip$1$ph$lcssa$i : $ip$0$ph$lcssa145$i;
        $171 = $ip$1$ip$0$i + 1 | 0;
        if (!(_memcmp($n, $n + $p$1$p$0$i | 0, $171) | 0)) {
         $mem0$0$i = $$lcssa332 - $p$1$p$0$i | 0;
         $p$3$i = $p$1$p$0$i;
        } else {
         $175 = $$lcssa332 - $ip$1$ip$0$i + -1 | 0;
         $mem0$0$i = 0;
         $p$3$i = ($ip$1$ip$0$i >>> 0 > $175 >>> 0 ? $ip$1$ip$0$i : $175) + 1 | 0;
        }
        $179 = $$lcssa332 | 63;
        $180 = ($mem0$0$i | 0) != 0;
        $181 = $$lcssa332 - $p$3$i | 0;
        $$03$i = $3;
        $mem$0$i = 0;
        $z$0$i = $3;
        L69 : while (1) {
         $183 = $$03$i;
         do if (($z$0$i - $183 | 0) >>> 0 < $$lcssa332 >>> 0) {
          $186 = _memchr($z$0$i, 0, $179) | 0;
          if (!$186) {
           $z$3$i = $z$0$i + $179 | 0;
           break;
          } else if (($186 - $183 | 0) >>> 0 < $$lcssa332 >>> 0) {
           $$3$i = 0;
           break L32;
          } else {
           $z$3$i = $186;
           break;
          }
         } else $z$3$i = $z$0$i; while (0);
         $193 = HEAP8[$$03$i + $l$082$i$lcssa331 >> 0] | 0;
         if (!(1 << ($193 & 31) & HEAP32[$byteset$i + ((($193 & 255) >>> 5 & 255) << 2) >> 2])) {
          $$03$i = $$03$i + $$lcssa332 | 0;
          $mem$0$i = 0;
          $z$0$i = $z$3$i;
          continue;
         }
         $204 = HEAP32[$shift$i + (($193 & 255) << 2) >> 2] | 0;
         $205 = $$lcssa332 - $204 | 0;
         if (($$lcssa332 | 0) != ($204 | 0)) {
          $$03$i = $$03$i + ($180 & ($mem$0$i | 0) != 0 & $205 >>> 0 < $p$3$i >>> 0 ? $181 : $205) | 0;
          $mem$0$i = 0;
          $z$0$i = $z$3$i;
          continue;
         }
         $212 = $171 >>> 0 > $mem$0$i >>> 0 ? $171 : $mem$0$i;
         $214 = HEAP8[$n + $212 >> 0] | 0;
         L83 : do if (!($214 << 24 >> 24)) $k$4$i = $171; else {
          $$pr$i = $214;
          $k$340$i = $212;
          while (1) {
           if ($$pr$i << 24 >> 24 != (HEAP8[$$03$i + $k$340$i >> 0] | 0)) {
            $k$340$i$lcssa = $k$340$i;
            break;
           }
           $k$340$i = $k$340$i + 1 | 0;
           $$pr$i = HEAP8[$n + $k$340$i >> 0] | 0;
           if (!($$pr$i << 24 >> 24)) {
            $k$4$i = $171;
            break L83;
           }
          }
          $$03$i = $$03$i + ($k$340$i$lcssa - $ip$1$ip$0$i) | 0;
          $mem$0$i = 0;
          $z$0$i = $z$3$i;
          continue L69;
         } while (0);
         do {
          if ($k$4$i >>> 0 <= $mem$0$i >>> 0) {
           $$3$i = $$03$i;
           break L32;
          }
          $k$4$i = $k$4$i + -1 | 0;
         } while ((HEAP8[$n + $k$4$i >> 0] | 0) == (HEAP8[$$03$i + $k$4$i >> 0] | 0));
         $$03$i = $$03$i + $p$3$i | 0;
         $mem$0$i = $mem0$0$i;
         $z$0$i = $z$3$i;
        }
       } while (0);
       $$0 = $$3$i;
      }
     }
    }
   }
  }
 } while (0);
 STACKTOP = sp;
 return $$0 | 0;
}

function _prvTidyParseBody($doc, $body, $mode) {
 $doc = $doc | 0;
 $body = $body | 0;
 $mode = $mode | 0;
 var $$0$be = 0, $$0$i = 0, $$0$i$lcssa = 0, $$012 = 0, $$1 = 0, $$pr7 = 0, $$pr8 = 0, $0 = 0, $1 = 0, $10 = 0, $104 = 0, $11 = 0, $111 = 0, $116 = 0, $118 = 0, $12 = 0, $120 = 0, $121 = 0, $124 = 0, $127 = 0, $129 = 0, $13 = 0, $137 = 0, $138 = 0, $14 = 0, $142 = 0, $144 = 0, $15 = 0, $152 = 0, $158 = 0, $16 = 0, $165 = 0, $17 = 0, $174 = 0, $177 = 0, $18 = 0, $182 = 0, $19 = 0, $190 = 0, $192 = 0, $20 = 0, $204 = 0, $21 = 0, $217 = 0, $22 = 0, $222 = 0, $224 = 0, $227 = 0, $238 = 0, $3 = 0, $41 = 0, $45 = 0, $48 = 0, $5 = 0, $57 = 0, $6 = 0, $62 = 0, $65 = 0, $7 = 0, $71 = 0, $74 = 0, $8 = 0, $83 = 0, $9 = 0, $99 = 0, $checkstack$0$be = 0, $checkstack$014 = 0, $checkstack$3 = 0, $iswhitenode$0 = 0, $node$0 = 0, $node$1 = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 _prvTidyBumpObject($doc, HEAP32[$body >> 2] | 0);
 $3 = _prvTidyGetToken($doc, 0) | 0;
 if (!$3) return;
 $5 = $body + 28 | 0;
 $6 = $1 + 76 | 0;
 $7 = $body + 56 | 0;
 $8 = $1 + 20 | 0;
 $9 = $doc + 428 | 0;
 $10 = $doc + 200 | 0;
 $11 = $body + 60 | 0;
 $12 = $body + 20 | 0;
 $13 = $doc + 6848 | 0;
 $14 = $doc + 12 | 0;
 $15 = $body + 16 | 0;
 $16 = $body + 12 | 0;
 $17 = $1 + 84 | 0;
 $18 = $1 + 80 | 0;
 $$012 = 0;
 $20 = $3;
 $checkstack$014 = 1;
 L4 : while (1) {
  $19 = $20 + 28 | 0;
  $21 = HEAP32[$19 >> 2] | 0;
  $22 = HEAP32[$5 >> 2] | 0;
  if (($21 | 0) == ($22 | 0)) if ((HEAP32[$20 + 44 >> 2] | 0) == 5) {
   _prvTidyReportError($doc, $body, $20, 208);
   _prvTidyFreeNode($doc, $20);
   $$0$be = $$012;
   $checkstack$0$be = $checkstack$014;
  } else label = 7; else label = 7;
  L9 : do if ((label | 0) == 7) {
   label = 0;
   if ($21 | 0) if ((HEAP32[$21 >> 2] | 0) == 48) {
    if (!(_prvTidynodeIsElement($20) | 0)) if (!(HEAP32[$18 >> 2] | 0)) HEAP32[$18 >> 2] = 1; else label = 11; else label = 11;
    if ((label | 0) == 11) {
     label = 0;
     _prvTidyReportError($doc, $body, $20, 208);
    }
    _prvTidyFreeNode($doc, $20);
    $$0$be = $$012;
    $checkstack$0$be = $checkstack$014;
    break;
   }
   if (!(HEAP32[$6 >> 2] | 0)) {
    $$pr7 = $21;
    $41 = $22;
   } else if (((HEAP32[$20 + 44 >> 2] | 0) + -5 | 0) >>> 0 < 3) {
    _prvTidyReportError($doc, $body, $20, 227);
    $$pr7 = HEAP32[$19 >> 2] | 0;
    $41 = HEAP32[$5 >> 2] | 0;
   } else {
    $$pr7 = $21;
    $41 = $22;
   }
   if (($$pr7 | 0) == ($41 | 0)) if ((HEAP32[$20 + 44 >> 2] | 0) == 6) {
    HEAP32[$7 >> 2] = 1;
    _TrimSpaces($doc, $body);
    _prvTidyFreeNode($doc, $20);
    HEAP32[$6 >> 2] = 1;
    $45 = HEAP32[$body >> 2] | 0;
    if (!$45) {
     $$0$be = 0;
     $checkstack$0$be = $checkstack$014;
     break;
    }
    $48 = HEAP32[$45 + 28 >> 2] | 0;
    if (!$48) {
     $$0$be = 0;
     $checkstack$0$be = $checkstack$014;
     break;
    }
    if ((HEAP32[$48 >> 2] | 0) == 72) {
     label = 136;
     break L4;
    } else {
     $$0$be = 0;
     $checkstack$0$be = $checkstack$014;
     break;
    }
   }
   if ($$pr7 | 0) {
    L33 : do if ((HEAP32[$$pr7 >> 2] | 0) == 72) {
     switch (HEAP32[$20 + 44 >> 2] | 0) {
     case 5:
      break;
     case 6:
      {
       $62 = HEAP32[$body >> 2] | 0;
       if (!$62) break L33;
       $65 = HEAP32[$62 + 28 >> 2] | 0;
       if (!$65) break L33;
       if ((HEAP32[$65 >> 2] | 0) == 72) {
        label = 32;
        break L4;
       } else break L33;
       break;
      }
     default:
      break L33;
     }
     HEAP32[$20 >> 2] = $body;
     $57 = HEAP32[$15 >> 2] | 0;
     HEAP32[$20 + 4 >> 2] = $57;
     if (!$57) HEAP32[$16 >> 2] = $20; else HEAP32[$57 + 8 >> 2] = $20;
     HEAP32[$15 >> 2] = $20;
     _prvTidyParseBlock($doc, $20, $$012);
     $$0$be = $$012;
     $checkstack$0$be = $checkstack$014;
     break L9;
    } while (0);
    if ((HEAP32[$$pr7 >> 2] & -2 | 0) == 38) {
     $71 = HEAP32[$body >> 2] | 0;
     if ($71 | 0) {
      $74 = HEAP32[$71 + 28 >> 2] | 0;
      if ($74 | 0) if ((HEAP32[$74 >> 2] | 0) == 72) {
       label = 37;
       break L4;
      }
     }
    }
   }
   if (!(_prvTidynodeIsText($20) | 0)) $iswhitenode$0 = 0; else {
    $83 = HEAP32[$20 + 36 >> 2] | 0;
    if ((HEAP32[$20 + 40 >> 2] | 0) >>> 0 > ($83 + 1 | 0) >>> 0) $iswhitenode$0 = 0; else $iswhitenode$0 = (HEAP8[(HEAP32[$17 >> 2] | 0) + $83 >> 0] | 0) == 32 & 1;
   }
   if (!(_InsertMisc($body, $20) | 0)) {
    if (_prvTidynodeIsText($20) | 0) {
     if (($$012 | 0) == 0 & ($iswhitenode$0 | 0) != 0) {
      _prvTidyFreeNode($doc, $20);
      $$0$be = 0;
      $checkstack$0$be = $checkstack$014;
      break;
     }
     _prvTidyConstrainVersion($doc, -294);
     if ($checkstack$014 | 0) if ((_prvTidyInlineDup($doc, $20) | 0) > 0) {
      $$0$be = $$012;
      $checkstack$0$be = 0;
      break;
     }
     HEAP32[$20 >> 2] = $body;
     $99 = HEAP32[$15 >> 2] | 0;
     HEAP32[$20 + 4 >> 2] = $99;
     if (!$99) HEAP32[$16 >> 2] = $20; else HEAP32[$99 + 8 >> 2] = $20;
     HEAP32[$15 >> 2] = $20;
     $$0$be = 1;
     $checkstack$0$be = 0;
     break;
    }
    $104 = $20 + 44 | 0;
    if ((HEAP32[$104 >> 2] | 0) == 1) {
     if (_prvTidyFindDocType($doc) | 0) {
      _prvTidyReportError($doc, $body, $20, 208);
      _prvTidyFreeNode($doc, $20);
      $$0$be = $$012;
      $checkstack$0$be = $checkstack$014;
      break;
     }
     _prvTidyReportError($doc, $body, $20, 234);
     $$0$i = $body;
     while (1) {
      if ($$0$i | 0) {
       $111 = HEAP32[$$0$i + 28 >> 2] | 0;
       if ($111 | 0) if ((HEAP32[$111 >> 2] | 0) == 48) {
        $$0$i$lcssa = $$0$i;
        break;
       }
      }
      $$0$i = HEAP32[$$0$i >> 2] | 0;
     }
     $116 = HEAP32[$$0$i$lcssa >> 2] | 0;
     HEAP32[$20 >> 2] = $116;
     HEAP32[$20 + 8 >> 2] = $$0$i$lcssa;
     $118 = $$0$i$lcssa + 4 | 0;
     $120 = $20 + 4 | 0;
     HEAP32[$120 >> 2] = HEAP32[$118 >> 2];
     HEAP32[$118 >> 2] = $20;
     $121 = HEAP32[$120 >> 2] | 0;
     if ($121 | 0) HEAP32[$121 + 8 >> 2] = $20;
     $124 = $116 + 12 | 0;
     if ((HEAP32[$124 >> 2] | 0) != ($$0$i$lcssa | 0)) {
      $$0$be = $$012;
      $checkstack$0$be = $checkstack$014;
      break;
     }
     HEAP32[$124 >> 2] = $20;
     $$0$be = $$012;
     $checkstack$0$be = $checkstack$014;
     break;
    }
    $127 = HEAP32[$19 >> 2] | 0;
    if ($127 | 0) {
     $129 = HEAP32[$127 >> 2] | 0;
     if (($129 | 0) != 81) {
      HEAP32[$8 >> 2] = 0;
      if (($129 | 0) == 53) {
       $137 = $127;
       label = 70;
      } else if (!(_prvTidynodeHasCM($20, 8) | 0)) if (!(_prvTidynodeHasCM($20, 16) | 0)) {
       $137 = HEAP32[$19 >> 2] | 0;
       label = 70;
      } else $node$1 = $20; else $node$1 = $20;
      L91 : do if ((label | 0) == 70) {
       label = 0;
       $138 = HEAP32[$137 + 16 >> 2] | 0;
       if (!($138 & 4)) {
        _prvTidyReportError($doc, $body, $20, 211);
        $$pr8 = HEAP32[$19 >> 2] | 0;
        $142 = HEAP32[$$pr8 + 16 >> 2] | 0;
        $144 = $$pr8;
       } else {
        $142 = $138;
        $144 = $137;
       }
       if ($142 & 2 | 0) {
        do if ($144 | 0) {
         if ((HEAP32[$144 >> 2] | 0) != 16) break;
         if (!(HEAP32[$11 >> 2] | 0)) break;
         if (HEAP32[$12 >> 2] | 0) break;
         $152 = $20 + 20 | 0;
         HEAP32[$12 >> 2] = HEAP32[$152 >> 2];
         HEAP32[$152 >> 2] = 0;
        } while (0);
        _prvTidyFreeNode($doc, $20);
        $$0$be = $$012;
        $checkstack$0$be = $checkstack$014;
        break L9;
       }
       if ($142 & 4 | 0) {
        _MoveToHead($doc, $body, $20);
        $$0$be = $$012;
        $checkstack$0$be = $checkstack$014;
        break L9;
       }
       if ($142 & 32 | 0) {
        _prvTidyUngetToken($doc);
        $158 = _prvTidyInferredTag($doc, 118) | 0;
        do if (HEAP32[$9 >> 2] | 0) if (!(HEAP32[$10 >> 2] | 0)) {
         _prvTidyAddStyleProperty($doc, $158, 307844);
         break;
        } else {
         _prvTidyAddStyleAsClass($doc, $158, 307844);
         break;
        } while (0);
        HEAP32[$8 >> 2] = 1;
        $node$1 = $158;
        break;
       }
       if ($142 & 64 | 0) {
        _prvTidyUngetToken($doc);
        $165 = _prvTidyInferredTag($doc, 31) | 0;
        HEAP32[$8 >> 2] = 1;
        $node$1 = $165;
        break;
       }
       if ($142 & 896 | 0) {
        if ((HEAP32[$104 >> 2] | 0) == 6) $node$0 = $20; else {
         _prvTidyUngetToken($doc);
         $node$0 = _prvTidyInferredTag($doc, 107) | 0;
        }
        HEAP32[$8 >> 2] = 1;
        $node$1 = $node$0;
        break;
       }
       do if ($144 | 0) {
        if ((HEAP32[$144 >> 2] | 0) != 53) break;
        _prvTidyUngetToken($doc);
        $174 = _prvTidyInferredTag($doc, 37) | 0;
        HEAP32[$8 >> 2] = 1;
        $node$1 = $174;
        break L91;
       } while (0);
       if (!(_prvTidynodeHasCM($20, 1536) | 0)) {
        label = 97;
        break L4;
       }
       _prvTidyFreeNode($doc, $20);
       $$0$be = $$012;
       $checkstack$0$be = $checkstack$014;
       break L9;
      } while (0);
      $177 = $node$1 + 44 | 0;
      L132 : do if ((HEAP32[$177 >> 2] | 0) == 6) {
       L134 : do if ($node$1 | 0) {
        $182 = HEAP32[$node$1 + 28 >> 2] | 0;
        if (!$182) break;
        switch (HEAP32[$182 >> 2] | 0) {
        case 17:
         {
          HEAP32[$177 >> 2] = 5;
          break L132;
          break;
         }
        case 80:
         {
          HEAP32[$177 >> 2] = 7;
          HEAP32[$node$1 + 60 >> 2] = 1;
          break L132;
          break;
         }
        default:
         break L134;
        }
       } while (0);
       if (_prvTidynodeHasCM($node$1, 16) | 0) _prvTidyPopInline($doc, $node$1);
      } while (0);
      if (!(_prvTidynodeIsElement($node$1) | 0)) {
       _prvTidyReportError($doc, $body, $node$1, 208);
       _prvTidyFreeNode($doc, $node$1);
       $$0$be = $$012;
       $checkstack$0$be = $checkstack$014;
       break;
      }
      $190 = ($node$1 | 0) != 0;
      do if ($190) {
       $192 = HEAP32[$node$1 + 28 >> 2] | 0;
       if (!$192) break;
       if ((HEAP32[$192 >> 2] | 0) != 137) break;
       if (!(_prvTidyFindNodeWithId(HEAP32[$14 >> 2] | 0, 137) | 0)) break;
       HEAP32[$13 >> 2] = HEAP32[$13 >> 2] | 2;
       _prvTidyReportError($doc, $body, $node$1, 208);
       _prvTidyFreeNode($doc, $node$1);
       $$0$be = $$012;
       $checkstack$0$be = $checkstack$014;
       break L9;
      } while (0);
      do if (!(_prvTidynodeHasCM($node$1, 16) | 0)) {
       $$1 = 0;
       $checkstack$3 = 1;
      } else {
       do if ($190) {
        $204 = HEAP32[$node$1 + 28 >> 2] | 0;
        if (!$204) {
         label = 118;
         break;
        }
        if ((HEAP32[$204 >> 2] | 0) != 52) {
         label = 118;
         break;
        }
        _prvTidyConstrainVersion($doc, -293);
       } else label = 118; while (0);
       if ((label | 0) == 118) {
        label = 0;
        _prvTidyConstrainVersion($doc, -294);
       }
       if (!$checkstack$014) {
        $$1 = 1;
        $checkstack$3 = 0;
        break;
       }
       if (HEAP32[$node$1 + 60 >> 2] | 0) {
        $$1 = 1;
        $checkstack$3 = $checkstack$014;
        break;
       }
       if ((_prvTidyInlineDup($doc, $node$1) | 0) > 0) {
        $$0$be = $$012;
        $checkstack$0$be = 0;
        break L9;
       } else {
        $$1 = 1;
        $checkstack$3 = 0;
       }
      } while (0);
      if (HEAP32[$node$1 + 60 >> 2] | 0) _prvTidyReportError($doc, $body, $node$1, 215);
      HEAP32[$node$1 >> 2] = $body;
      $217 = HEAP32[$15 >> 2] | 0;
      HEAP32[$node$1 + 4 >> 2] = $217;
      if (!$217) HEAP32[$16 >> 2] = $node$1; else HEAP32[$217 + 8 >> 2] = $node$1;
      HEAP32[$15 >> 2] = $node$1;
      $222 = HEAP32[$0 >> 2] | 0;
      $224 = HEAP32[$node$1 + 28 >> 2] | 0;
      if (!$224) {
       $$0$be = $$1;
       $checkstack$0$be = $checkstack$3;
       break;
      }
      $227 = HEAP32[$224 + 16 >> 2] | 0;
      do if (!($227 & 1)) {
       if ($227 & 16 | 0) break;
       HEAP32[$222 + 16 >> 2] = 0;
      } else {
       HEAP32[$222 + 8 >> 2] = 0;
       if (!(HEAP32[$224 + 20 >> 2] | 0)) {
        $$0$be = $$1;
        $checkstack$0$be = $checkstack$3;
        break L9;
       }
      } while (0);
      $238 = HEAP32[$224 + 20 >> 2] | 0;
      if (!$238) {
       $$0$be = $$1;
       $checkstack$0$be = $checkstack$3;
       break;
      }
      if ((HEAP32[$177 >> 2] | 0) == 7) {
       $$0$be = $$1;
       $checkstack$0$be = $checkstack$3;
       break;
      }
      HEAP32[$222 + 72 >> 2] = $node$1;
      FUNCTION_TABLE_viii[$238 & 63]($doc, $node$1, $$1);
      $$0$be = $$1;
      $checkstack$0$be = $checkstack$3;
      break;
     }
    }
    _prvTidyReportError($doc, $body, $20, 208);
    _prvTidyFreeNode($doc, $20);
    $$0$be = $$012;
    $checkstack$0$be = $checkstack$014;
   } else {
    $$0$be = $$012;
    $checkstack$0$be = $checkstack$014;
   }
  } while (0);
  $20 = _prvTidyGetToken($doc, $$0$be) | 0;
  if (!$20) {
   label = 136;
   break;
  } else {
   $$012 = $$0$be;
   $checkstack$014 = $checkstack$0$be;
  }
 }
 if ((label | 0) == 32) {
  _TrimSpaces($doc, $body);
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 37) {
  _TrimSpaces($doc, $body);
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 97) {
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 136) return;
}

function _prvTidyParseHTML($doc, $html, $mode) {
 $doc = $doc | 0;
 $html = $html | 0;
 $mode = $mode | 0;
 var $$lcssa = 0, $$lcssa68 = 0, $$pre = 0, $0 = 0, $100 = 0, $104 = 0, $109 = 0, $110 = 0, $113 = 0, $124 = 0, $132 = 0, $144 = 0, $145 = 0, $152 = 0, $154 = 0, $155 = 0, $166 = 0, $174 = 0, $175 = 0, $185 = 0, $186 = 0, $187 = 0, $193 = 0, $196 = 0, $198 = 0, $2 = 0, $201 = 0, $212 = 0, $218 = 0, $222 = 0, $227 = 0, $229 = 0, $23 = 0, $232 = 0, $24 = 0, $243 = 0, $30 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $37 = 0, $38 = 0, $44 = 0, $45 = 0, $5 = 0, $57 = 0, $6 = 0, $67 = 0, $68 = 0, $69 = 0, $75 = 0, $78 = 0, $80 = 0, $83 = 0, $94 = 0, $frameset$0$be = 0, $frameset$0$be$lcssa = 0, $frameset$030 = 0, $frameset$1 = 0, $node$0 = 0, $node$127 = 0, $node$129 = 0, $node$2 = 0, $noframes$0$be = 0, $noframes$031 = 0, $noframes$1 = 0, $noframes$228 = 0, $noframes$3 = 0, $noframes$443 = 0, $noframes$5 = 0, label = 0;
 _prvTidySetOptionBool($doc, 24, 0) | 0;
 $0 = _prvTidyGetToken($doc, 0) | 0;
 L1 : do if (!$0) label = 3; else {
  $2 = $html + 28 | 0;
  $5 = $0;
  while (1) {
   $6 = HEAP32[$5 + 28 >> 2] | 0;
   if ($6 | 0) if ((HEAP32[$6 >> 2] | 0) == 46) {
    $node$0 = $5;
    break L1;
   }
   do if (($6 | 0) == (HEAP32[$2 >> 2] | 0)) {
    if ((HEAP32[$5 + 44 >> 2] | 0) == 6) {
     _prvTidyReportError($doc, $html, $5, 208);
     _prvTidyFreeNode($doc, $5);
     break;
    }
    if ((HEAP32[$5 + 44 >> 2] | 0) == 5) {
     _prvTidyReportError($doc, $html, $5, 208);
     _prvTidyFreeNode($doc, $5);
    } else label = 12;
   } else label = 12; while (0);
   if ((label | 0) == 12) {
    label = 0;
    if (!(_InsertMisc($html, $5) | 0)) break;
   }
   $5 = _prvTidyGetToken($doc, 0) | 0;
   if (!$5) {
    label = 3;
    break L1;
   }
  }
  _prvTidyUngetToken($doc);
  $node$0 = _prvTidyInferredTag($doc, 46) | 0;
 } while (0);
 if ((label | 0) == 3) $node$0 = _prvTidyInferredTag($doc, 46) | 0;
 HEAP32[$node$0 >> 2] = $html;
 $23 = $html + 16 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 HEAP32[$node$0 + 4 >> 2] = $24;
 if (!$24) HEAP32[$html + 12 >> 2] = $node$0; else HEAP32[$24 + 8 >> 2] = $node$0;
 HEAP32[$23 >> 2] = $node$0;
 _prvTidyParseHead($doc, $node$0, 0);
 $30 = _prvTidyGetToken($doc, 0) | 0;
 do if ($30 | 0) {
  $32 = $html + 28 | 0;
  $33 = $doc + 68 | 0;
  $34 = $doc + 408 | 0;
  $35 = $html + 12 | 0;
  $45 = $30;
  $frameset$030 = 0;
  $noframes$031 = 0;
  L27 : while (1) {
   $44 = $45 + 28 | 0;
   L29 : do if ((HEAP32[$44 >> 2] | 0) == (HEAP32[$32 >> 2] | 0)) {
    if (($frameset$030 | 0) == 0 ? (HEAP32[$45 + 44 >> 2] | 0) != 5 : 0) _prvTidyReportError($doc, $html, $45, 208);
    _prvTidyFreeNode($doc, $45);
    $frameset$0$be = $frameset$030;
    $noframes$0$be = $noframes$031;
   } else if (!(_InsertMisc($html, $45) | 0)) {
    $57 = HEAP32[$44 >> 2] | 0;
    L36 : do if ($57 | 0) switch (HEAP32[$57 >> 2] | 0) {
    case 16:
     {
      if ((HEAP32[$45 + 44 >> 2] | 0) != 5) {
       _prvTidyReportError($doc, $html, $45, 208);
       _prvTidyFreeNode($doc, $45);
       $frameset$0$be = $frameset$030;
       $noframes$0$be = $noframes$031;
       break L29;
      }
      if (!(($frameset$030 | 0) != 0 & (HEAP32[$34 >> 2] | 0) == 0)) {
       $$lcssa68 = $45;
       label = 50;
       break L27;
      }
      _prvTidyUngetToken($doc);
      if (!$noframes$031) {
       $67 = _prvTidyInferredTag($doc, 72) | 0;
       HEAP32[$67 >> 2] = $frameset$030;
       $68 = $frameset$030 + 16 | 0;
       $69 = HEAP32[$68 >> 2] | 0;
       HEAP32[$67 + 4 >> 2] = $69;
       if (!$69) HEAP32[$frameset$030 + 12 >> 2] = $67; else HEAP32[$69 + 8 >> 2] = $67;
       HEAP32[$68 >> 2] = $67;
       _prvTidyReportError($doc, $html, $67, 215);
       $noframes$1 = $67;
      } else {
       $75 = $noframes$031 + 44 | 0;
       if ((HEAP32[$75 >> 2] | 0) == 7) {
        HEAP32[$75 >> 2] = 5;
        $noframes$1 = $noframes$031;
       } else $noframes$1 = $noframes$031;
      }
      $78 = HEAP32[$33 >> 2] | 0;
      $80 = HEAP32[$noframes$1 + 28 >> 2] | 0;
      if (!$80) {
       $frameset$0$be = $frameset$030;
       $noframes$0$be = $noframes$1;
       break L29;
      }
      $83 = HEAP32[$80 + 16 >> 2] | 0;
      if (!($83 & 1)) {
       if (!($83 & 16)) HEAP32[$78 + 16 >> 2] = 0;
      } else {
       HEAP32[$78 + 8 >> 2] = 0;
       if (!(HEAP32[$80 + 20 >> 2] | 0)) {
        $frameset$0$be = $frameset$030;
        $noframes$0$be = $noframes$1;
        break L29;
       }
      }
      $94 = HEAP32[$80 + 20 >> 2] | 0;
      if (!$94) {
       $frameset$0$be = $frameset$030;
       $noframes$0$be = $noframes$1;
       break L29;
      }
      if ((HEAP32[$noframes$1 + 44 >> 2] | 0) == 7) {
       $frameset$0$be = $frameset$030;
       $noframes$0$be = $noframes$1;
       break L29;
      }
      HEAP32[$78 + 72 >> 2] = $noframes$1;
      FUNCTION_TABLE_viii[$94 & 63]($doc, $noframes$1, $mode);
      $frameset$0$be = $frameset$030;
      $noframes$0$be = $noframes$1;
      break L29;
      break;
     }
    case 39:
     {
      $100 = $45 + 44 | 0;
      if ((HEAP32[$100 >> 2] | 0) != 5) {
       _prvTidyReportError($doc, $html, $45, 208);
       _prvTidyFreeNode($doc, $45);
       $frameset$0$be = $frameset$030;
       $noframes$0$be = $noframes$031;
       break L29;
      }
      if (!$frameset$030) $frameset$1 = $45; else {
       _prvTidyReportFatal($doc, $html, $45, 218);
       $frameset$1 = $frameset$030;
      }
      HEAP32[$45 >> 2] = $html;
      $104 = HEAP32[$23 >> 2] | 0;
      HEAP32[$45 + 4 >> 2] = $104;
      if (!$104) HEAP32[$35 >> 2] = $45; else HEAP32[$104 + 8 >> 2] = $45;
      HEAP32[$23 >> 2] = $45;
      $109 = HEAP32[$33 >> 2] | 0;
      $110 = HEAP32[$44 >> 2] | 0;
      do if ($110 | 0) {
       $113 = HEAP32[$110 + 16 >> 2] | 0;
       if (!($113 & 1)) {
        if (!($113 & 16)) HEAP32[$109 + 16 >> 2] = 0;
       } else {
        HEAP32[$109 + 8 >> 2] = 0;
        if (!(HEAP32[$110 + 20 >> 2] | 0)) break;
       }
       $124 = HEAP32[$110 + 20 >> 2] | 0;
       if ($124 | 0) if ((HEAP32[$100 >> 2] | 0) != 7) {
        HEAP32[$109 + 72 >> 2] = $45;
        FUNCTION_TABLE_viii[$124 & 63]($doc, $45, $mode);
       }
      } while (0);
      $node$127 = HEAP32[$frameset$1 + 12 >> 2] | 0;
      if (!$node$127) {
       $frameset$0$be = $frameset$1;
       $noframes$0$be = $noframes$031;
       break L29;
      } else {
       $node$129 = $node$127;
       $noframes$228 = $noframes$031;
      }
      while (1) {
       $132 = HEAP32[$node$129 + 28 >> 2] | 0;
       if (!$132) $noframes$3 = $noframes$228; else $noframes$3 = (HEAP32[$132 >> 2] | 0) == 72 ? $node$129 : $noframes$228;
       $node$129 = HEAP32[$node$129 + 8 >> 2] | 0;
       if (!$node$129) {
        $frameset$0$be = $frameset$1;
        $noframes$0$be = $noframes$3;
        break L29;
       } else $noframes$228 = $noframes$3;
      }
      break;
     }
    case 72:
     {
      if ((HEAP32[$45 + 44 >> 2] | 0) != 5) {
       _prvTidyReportError($doc, $html, $45, 208);
       _prvTidyFreeNode($doc, $45);
       $frameset$0$be = $frameset$030;
       $noframes$0$be = $noframes$031;
       break L29;
      }
      if (!$frameset$030) {
       $$lcssa = $45;
       label = 73;
       break L27;
      }
      if (!$noframes$031) {
       HEAP32[$45 >> 2] = $frameset$030;
       $144 = $frameset$030 + 16 | 0;
       $145 = HEAP32[$144 >> 2] | 0;
       HEAP32[$45 + 4 >> 2] = $145;
       if (!$145) HEAP32[$frameset$030 + 12 >> 2] = $45; else HEAP32[$145 + 8 >> 2] = $45;
       HEAP32[$144 >> 2] = $45;
       $154 = $57;
       $noframes$443 = $45;
      } else {
       _prvTidyFreeNode($doc, $45);
       $$pre = HEAP32[$noframes$031 + 28 >> 2] | 0;
       if (!$$pre) {
        $frameset$0$be = $frameset$030;
        $noframes$0$be = $noframes$031;
        break L29;
       } else {
        $154 = $$pre;
        $noframes$443 = $noframes$031;
       }
      }
      $152 = HEAP32[$33 >> 2] | 0;
      $155 = HEAP32[$154 + 16 >> 2] | 0;
      if (!($155 & 1)) {
       if (!($155 & 16)) HEAP32[$152 + 16 >> 2] = 0;
      } else {
       HEAP32[$152 + 8 >> 2] = 0;
       if (!(HEAP32[$154 + 20 >> 2] | 0)) {
        $frameset$0$be = $frameset$030;
        $noframes$0$be = $noframes$443;
        break L29;
       }
      }
      $166 = HEAP32[$154 + 20 >> 2] | 0;
      if (!$166) {
       $frameset$0$be = $frameset$030;
       $noframes$0$be = $noframes$443;
       break L29;
      }
      if ((HEAP32[$noframes$443 + 44 >> 2] | 0) == 7) {
       $frameset$0$be = $frameset$030;
       $noframes$0$be = $noframes$443;
       break L29;
      }
      HEAP32[$152 + 72 >> 2] = $noframes$443;
      FUNCTION_TABLE_viii[$166 & 63]($doc, $noframes$443, $mode);
      $frameset$0$be = $frameset$030;
      $noframes$0$be = $noframes$443;
      break L29;
      break;
     }
    default:
     break L36;
    } while (0);
    if (!(_prvTidynodeIsElement($45) | 0)) {
     _prvTidyUngetToken($doc);
     if (!$frameset$030) {
      label = 113;
      break L27;
     }
    } else {
     $174 = HEAP32[$44 >> 2] | 0;
     $175 = ($174 | 0) == 0;
     if (!$175) if (HEAP32[$174 + 16 >> 2] & 4 | 0) {
      _MoveToHead($doc, $html, $45);
      $frameset$0$be = $frameset$030;
      $noframes$0$be = $noframes$031;
      break;
     }
     if (!$frameset$030) {
      label = 92;
      break L27;
     }
     if (!$175) if ((HEAP32[$174 >> 2] | 0) == 38) {
      _prvTidyReportError($doc, $html, $45, 208);
      _prvTidyFreeNode($doc, $45);
      $frameset$0$be = $frameset$030;
      $noframes$0$be = $noframes$031;
      break;
     }
     _prvTidyUngetToken($doc);
    }
    if (!$noframes$031) {
     $185 = _prvTidyInferredTag($doc, 72) | 0;
     HEAP32[$185 >> 2] = $frameset$030;
     $186 = $frameset$030 + 16 | 0;
     $187 = HEAP32[$186 >> 2] | 0;
     HEAP32[$185 + 4 >> 2] = $187;
     if (!$187) HEAP32[$frameset$030 + 12 >> 2] = $185; else HEAP32[$187 + 8 >> 2] = $185;
     HEAP32[$186 >> 2] = $185;
     $noframes$5 = $185;
    } else {
     _prvTidyReportError($doc, $html, $45, 226);
     $193 = $noframes$031 + 44 | 0;
     if ((HEAP32[$193 >> 2] | 0) == 7) {
      HEAP32[$193 >> 2] = 5;
      $noframes$5 = $noframes$031;
     } else $noframes$5 = $noframes$031;
    }
    _prvTidyConstrainVersion($doc, 1168);
    $196 = HEAP32[$33 >> 2] | 0;
    $198 = HEAP32[$noframes$5 + 28 >> 2] | 0;
    if (!$198) {
     $frameset$0$be = $frameset$030;
     $noframes$0$be = $noframes$5;
    } else {
     $201 = HEAP32[$198 + 16 >> 2] | 0;
     if (!($201 & 1)) {
      if (!($201 & 16)) HEAP32[$196 + 16 >> 2] = 0;
     } else {
      HEAP32[$196 + 8 >> 2] = 0;
      if (!(HEAP32[$198 + 20 >> 2] | 0)) {
       $frameset$0$be = $frameset$030;
       $noframes$0$be = $noframes$5;
       break;
      }
     }
     $212 = HEAP32[$198 + 20 >> 2] | 0;
     if (!$212) {
      $frameset$0$be = $frameset$030;
      $noframes$0$be = $noframes$5;
     } else if ((HEAP32[$noframes$5 + 44 >> 2] | 0) == 7) {
      $frameset$0$be = $frameset$030;
      $noframes$0$be = $noframes$5;
     } else {
      HEAP32[$196 + 72 >> 2] = $noframes$5;
      FUNCTION_TABLE_viii[$212 & 63]($doc, $noframes$5, $mode);
      $frameset$0$be = $frameset$030;
      $noframes$0$be = $noframes$5;
     }
    }
   } else {
    $frameset$0$be = $frameset$030;
    $noframes$0$be = $noframes$031;
   } while (0);
   $45 = _prvTidyGetToken($doc, 0) | 0;
   if (!$45) {
    $frameset$0$be$lcssa = $frameset$0$be;
    label = 19;
    break;
   } else {
    $frameset$030 = $frameset$0$be;
    $noframes$031 = $noframes$0$be;
   }
  }
  if ((label | 0) == 19) {
   if (!$frameset$0$be$lcssa) break;
   return;
  } else if ((label | 0) == 50) {
   _prvTidyConstrainVersion($doc, -1169);
   $node$2 = $$lcssa68;
  } else if ((label | 0) == 73) {
   _prvTidyReportError($doc, $html, $$lcssa, 208);
   _prvTidyFreeNode($doc, $$lcssa);
   $node$2 = _prvTidyInferredTag($doc, 16) | 0;
  } else if ((label | 0) == 92) {
   _prvTidyUngetToken($doc);
   label = 113;
  }
  if ((label | 0) == 113) {
   $218 = _prvTidyInferredTag($doc, 16) | 0;
   if ((HEAP32[$doc + 328 >> 2] | 0) != 1) _prvTidyReportError($doc, $html, $218, 215);
   _prvTidyConstrainVersion($doc, -1169);
   $node$2 = $218;
  }
  HEAP32[$node$2 >> 2] = $html;
  $222 = HEAP32[$23 >> 2] | 0;
  HEAP32[$node$2 + 4 >> 2] = $222;
  if (!$222) HEAP32[$35 >> 2] = $node$2; else HEAP32[$222 + 8 >> 2] = $node$2;
  HEAP32[$23 >> 2] = $node$2;
  $227 = HEAP32[$33 >> 2] | 0;
  $229 = HEAP32[$node$2 + 28 >> 2] | 0;
  if (!$229) return;
  $232 = HEAP32[$229 + 16 >> 2] | 0;
  if (!($232 & 1)) {
   if (!($232 & 16)) HEAP32[$227 + 16 >> 2] = 0;
  } else {
   HEAP32[$227 + 8 >> 2] = 0;
   if (!(HEAP32[$229 + 20 >> 2] | 0)) return;
  }
  $243 = HEAP32[$229 + 20 >> 2] | 0;
  if (!$243) return;
  if ((HEAP32[$node$2 + 44 >> 2] | 0) == 7) return;
  HEAP32[$227 + 72 >> 2] = $node$2;
  FUNCTION_TABLE_viii[$243 & 63]($doc, $node$2, $mode);
  return;
 } while (0);
 $37 = _prvTidyInferredTag($doc, 16) | 0;
 HEAP32[$37 >> 2] = $html;
 $38 = HEAP32[$23 >> 2] | 0;
 HEAP32[$37 + 4 >> 2] = $38;
 if (!$38) HEAP32[$html + 12 >> 2] = $37; else HEAP32[$38 + 8 >> 2] = $37;
 HEAP32[$23 >> 2] = $37;
 _prvTidyParseBody($doc, $37, 0);
 return;
}

function _free($mem) {
 $mem = $mem | 0;
 var $$lcssa = 0, $$pre$phi41Z2D = 0, $$pre$phi43Z2D = 0, $$pre$phiZ2D = 0, $1 = 0, $104 = 0, $105 = 0, $113 = 0, $114 = 0, $12 = 0, $122 = 0, $130 = 0, $135 = 0, $136 = 0, $139 = 0, $141 = 0, $143 = 0, $15 = 0, $158 = 0, $16 = 0, $163 = 0, $165 = 0, $168 = 0, $171 = 0, $174 = 0, $177 = 0, $178 = 0, $179 = 0, $181 = 0, $183 = 0, $184 = 0, $186 = 0, $187 = 0, $193 = 0, $194 = 0, $2 = 0, $20 = 0, $203 = 0, $208 = 0, $211 = 0, $212 = 0, $218 = 0, $23 = 0, $233 = 0, $236 = 0, $237 = 0, $238 = 0, $242 = 0, $243 = 0, $249 = 0, $25 = 0, $254 = 0, $255 = 0, $258 = 0, $260 = 0, $263 = 0, $268 = 0, $27 = 0, $274 = 0, $278 = 0, $279 = 0, $297 = 0, $299 = 0, $306 = 0, $307 = 0, $308 = 0, $316 = 0, $40 = 0, $45 = 0, $47 = 0, $5 = 0, $50 = 0, $52 = 0, $55 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $62 = 0, $64 = 0, $65 = 0, $67 = 0, $68 = 0, $73 = 0, $74 = 0, $8 = 0, $83 = 0, $88 = 0, $9 = 0, $91 = 0, $92 = 0, $98 = 0, $F18$0 = 0, $I20$0 = 0, $K21$0 = 0, $R$1 = 0, $R$1$lcssa = 0, $R$3 = 0, $R8$1 = 0, $R8$1$lcssa = 0, $R8$3 = 0, $RP$1 = 0, $RP$1$lcssa = 0, $RP10$1 = 0, $RP10$1$lcssa = 0, $T$0 = 0, $T$0$lcssa = 0, $T$0$lcssa48 = 0, $p$1 = 0, $psize$1 = 0, $psize$2 = 0, $sp$0$i = 0, $sp$0$in$i = 0, label = 0;
 if (!$mem) return;
 $1 = $mem + -8 | 0;
 $2 = HEAP32[79272] | 0;
 if ($1 >>> 0 < $2 >>> 0) _abort();
 $5 = HEAP32[$mem + -4 >> 2] | 0;
 $6 = $5 & 3;
 if (($6 | 0) == 1) _abort();
 $8 = $5 & -8;
 $9 = $1 + $8 | 0;
 do if (!($5 & 1)) {
  $12 = HEAP32[$1 >> 2] | 0;
  if (!$6) return;
  $15 = $1 + (0 - $12) | 0;
  $16 = $12 + $8 | 0;
  if ($15 >>> 0 < $2 >>> 0) _abort();
  if (($15 | 0) == (HEAP32[79273] | 0)) {
   $104 = $9 + 4 | 0;
   $105 = HEAP32[$104 >> 2] | 0;
   if (($105 & 3 | 0) != 3) {
    $p$1 = $15;
    $psize$1 = $16;
    break;
   }
   HEAP32[79270] = $16;
   HEAP32[$104 >> 2] = $105 & -2;
   HEAP32[$15 + 4 >> 2] = $16 | 1;
   HEAP32[$15 + $16 >> 2] = $16;
   return;
  }
  $20 = $12 >>> 3;
  if ($12 >>> 0 < 256) {
   $23 = HEAP32[$15 + 8 >> 2] | 0;
   $25 = HEAP32[$15 + 12 >> 2] | 0;
   $27 = 317112 + ($20 << 1 << 2) | 0;
   if (($23 | 0) != ($27 | 0)) {
    if ($23 >>> 0 < $2 >>> 0) _abort();
    if ((HEAP32[$23 + 12 >> 2] | 0) != ($15 | 0)) _abort();
   }
   if (($25 | 0) == ($23 | 0)) {
    HEAP32[79268] = HEAP32[79268] & ~(1 << $20);
    $p$1 = $15;
    $psize$1 = $16;
    break;
   }
   if (($25 | 0) == ($27 | 0)) $$pre$phi43Z2D = $25 + 8 | 0; else {
    if ($25 >>> 0 < $2 >>> 0) _abort();
    $40 = $25 + 8 | 0;
    if ((HEAP32[$40 >> 2] | 0) == ($15 | 0)) $$pre$phi43Z2D = $40; else _abort();
   }
   HEAP32[$23 + 12 >> 2] = $25;
   HEAP32[$$pre$phi43Z2D >> 2] = $23;
   $p$1 = $15;
   $psize$1 = $16;
   break;
  }
  $45 = HEAP32[$15 + 24 >> 2] | 0;
  $47 = HEAP32[$15 + 12 >> 2] | 0;
  do if (($47 | 0) == ($15 | 0)) {
   $58 = $15 + 16 | 0;
   $59 = $58 + 4 | 0;
   $60 = HEAP32[$59 >> 2] | 0;
   if (!$60) {
    $62 = HEAP32[$58 >> 2] | 0;
    if (!$62) {
     $R$3 = 0;
     break;
    } else {
     $R$1 = $62;
     $RP$1 = $58;
    }
   } else {
    $R$1 = $60;
    $RP$1 = $59;
   }
   while (1) {
    $64 = $R$1 + 20 | 0;
    $65 = HEAP32[$64 >> 2] | 0;
    if ($65 | 0) {
     $R$1 = $65;
     $RP$1 = $64;
     continue;
    }
    $67 = $R$1 + 16 | 0;
    $68 = HEAP32[$67 >> 2] | 0;
    if (!$68) {
     $R$1$lcssa = $R$1;
     $RP$1$lcssa = $RP$1;
     break;
    } else {
     $R$1 = $68;
     $RP$1 = $67;
    }
   }
   if ($RP$1$lcssa >>> 0 < $2 >>> 0) _abort(); else {
    HEAP32[$RP$1$lcssa >> 2] = 0;
    $R$3 = $R$1$lcssa;
    break;
   }
  } else {
   $50 = HEAP32[$15 + 8 >> 2] | 0;
   if ($50 >>> 0 < $2 >>> 0) _abort();
   $52 = $50 + 12 | 0;
   if ((HEAP32[$52 >> 2] | 0) != ($15 | 0)) _abort();
   $55 = $47 + 8 | 0;
   if ((HEAP32[$55 >> 2] | 0) == ($15 | 0)) {
    HEAP32[$52 >> 2] = $47;
    HEAP32[$55 >> 2] = $50;
    $R$3 = $47;
    break;
   } else _abort();
  } while (0);
  if (!$45) {
   $p$1 = $15;
   $psize$1 = $16;
  } else {
   $73 = HEAP32[$15 + 28 >> 2] | 0;
   $74 = 317376 + ($73 << 2) | 0;
   if (($15 | 0) == (HEAP32[$74 >> 2] | 0)) {
    HEAP32[$74 >> 2] = $R$3;
    if (!$R$3) {
     HEAP32[79269] = HEAP32[79269] & ~(1 << $73);
     $p$1 = $15;
     $psize$1 = $16;
     break;
    }
   } else {
    if ($45 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
    $83 = $45 + 16 | 0;
    if ((HEAP32[$83 >> 2] | 0) == ($15 | 0)) HEAP32[$83 >> 2] = $R$3; else HEAP32[$45 + 20 >> 2] = $R$3;
    if (!$R$3) {
     $p$1 = $15;
     $psize$1 = $16;
     break;
    }
   }
   $88 = HEAP32[79272] | 0;
   if ($R$3 >>> 0 < $88 >>> 0) _abort();
   HEAP32[$R$3 + 24 >> 2] = $45;
   $91 = $15 + 16 | 0;
   $92 = HEAP32[$91 >> 2] | 0;
   do if ($92 | 0) if ($92 >>> 0 < $88 >>> 0) _abort(); else {
    HEAP32[$R$3 + 16 >> 2] = $92;
    HEAP32[$92 + 24 >> 2] = $R$3;
    break;
   } while (0);
   $98 = HEAP32[$91 + 4 >> 2] | 0;
   if (!$98) {
    $p$1 = $15;
    $psize$1 = $16;
   } else if ($98 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
    HEAP32[$R$3 + 20 >> 2] = $98;
    HEAP32[$98 + 24 >> 2] = $R$3;
    $p$1 = $15;
    $psize$1 = $16;
    break;
   }
  }
 } else {
  $p$1 = $1;
  $psize$1 = $8;
 } while (0);
 if ($p$1 >>> 0 >= $9 >>> 0) _abort();
 $113 = $9 + 4 | 0;
 $114 = HEAP32[$113 >> 2] | 0;
 if (!($114 & 1)) _abort();
 if (!($114 & 2)) {
  if (($9 | 0) == (HEAP32[79274] | 0)) {
   $122 = (HEAP32[79271] | 0) + $psize$1 | 0;
   HEAP32[79271] = $122;
   HEAP32[79274] = $p$1;
   HEAP32[$p$1 + 4 >> 2] = $122 | 1;
   if (($p$1 | 0) != (HEAP32[79273] | 0)) return;
   HEAP32[79273] = 0;
   HEAP32[79270] = 0;
   return;
  }
  if (($9 | 0) == (HEAP32[79273] | 0)) {
   $130 = (HEAP32[79270] | 0) + $psize$1 | 0;
   HEAP32[79270] = $130;
   HEAP32[79273] = $p$1;
   HEAP32[$p$1 + 4 >> 2] = $130 | 1;
   HEAP32[$p$1 + $130 >> 2] = $130;
   return;
  }
  $135 = ($114 & -8) + $psize$1 | 0;
  $136 = $114 >>> 3;
  do if ($114 >>> 0 < 256) {
   $139 = HEAP32[$9 + 8 >> 2] | 0;
   $141 = HEAP32[$9 + 12 >> 2] | 0;
   $143 = 317112 + ($136 << 1 << 2) | 0;
   if (($139 | 0) != ($143 | 0)) {
    if ($139 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
    if ((HEAP32[$139 + 12 >> 2] | 0) != ($9 | 0)) _abort();
   }
   if (($141 | 0) == ($139 | 0)) {
    HEAP32[79268] = HEAP32[79268] & ~(1 << $136);
    break;
   }
   if (($141 | 0) == ($143 | 0)) $$pre$phi41Z2D = $141 + 8 | 0; else {
    if ($141 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
    $158 = $141 + 8 | 0;
    if ((HEAP32[$158 >> 2] | 0) == ($9 | 0)) $$pre$phi41Z2D = $158; else _abort();
   }
   HEAP32[$139 + 12 >> 2] = $141;
   HEAP32[$$pre$phi41Z2D >> 2] = $139;
  } else {
   $163 = HEAP32[$9 + 24 >> 2] | 0;
   $165 = HEAP32[$9 + 12 >> 2] | 0;
   do if (($165 | 0) == ($9 | 0)) {
    $177 = $9 + 16 | 0;
    $178 = $177 + 4 | 0;
    $179 = HEAP32[$178 >> 2] | 0;
    if (!$179) {
     $181 = HEAP32[$177 >> 2] | 0;
     if (!$181) {
      $R8$3 = 0;
      break;
     } else {
      $R8$1 = $181;
      $RP10$1 = $177;
     }
    } else {
     $R8$1 = $179;
     $RP10$1 = $178;
    }
    while (1) {
     $183 = $R8$1 + 20 | 0;
     $184 = HEAP32[$183 >> 2] | 0;
     if ($184 | 0) {
      $R8$1 = $184;
      $RP10$1 = $183;
      continue;
     }
     $186 = $R8$1 + 16 | 0;
     $187 = HEAP32[$186 >> 2] | 0;
     if (!$187) {
      $R8$1$lcssa = $R8$1;
      $RP10$1$lcssa = $RP10$1;
      break;
     } else {
      $R8$1 = $187;
      $RP10$1 = $186;
     }
    }
    if ($RP10$1$lcssa >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
     HEAP32[$RP10$1$lcssa >> 2] = 0;
     $R8$3 = $R8$1$lcssa;
     break;
    }
   } else {
    $168 = HEAP32[$9 + 8 >> 2] | 0;
    if ($168 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
    $171 = $168 + 12 | 0;
    if ((HEAP32[$171 >> 2] | 0) != ($9 | 0)) _abort();
    $174 = $165 + 8 | 0;
    if ((HEAP32[$174 >> 2] | 0) == ($9 | 0)) {
     HEAP32[$171 >> 2] = $165;
     HEAP32[$174 >> 2] = $168;
     $R8$3 = $165;
     break;
    } else _abort();
   } while (0);
   if ($163 | 0) {
    $193 = HEAP32[$9 + 28 >> 2] | 0;
    $194 = 317376 + ($193 << 2) | 0;
    if (($9 | 0) == (HEAP32[$194 >> 2] | 0)) {
     HEAP32[$194 >> 2] = $R8$3;
     if (!$R8$3) {
      HEAP32[79269] = HEAP32[79269] & ~(1 << $193);
      break;
     }
    } else {
     if ($163 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
     $203 = $163 + 16 | 0;
     if ((HEAP32[$203 >> 2] | 0) == ($9 | 0)) HEAP32[$203 >> 2] = $R8$3; else HEAP32[$163 + 20 >> 2] = $R8$3;
     if (!$R8$3) break;
    }
    $208 = HEAP32[79272] | 0;
    if ($R8$3 >>> 0 < $208 >>> 0) _abort();
    HEAP32[$R8$3 + 24 >> 2] = $163;
    $211 = $9 + 16 | 0;
    $212 = HEAP32[$211 >> 2] | 0;
    do if ($212 | 0) if ($212 >>> 0 < $208 >>> 0) _abort(); else {
     HEAP32[$R8$3 + 16 >> 2] = $212;
     HEAP32[$212 + 24 >> 2] = $R8$3;
     break;
    } while (0);
    $218 = HEAP32[$211 + 4 >> 2] | 0;
    if ($218 | 0) if ($218 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
     HEAP32[$R8$3 + 20 >> 2] = $218;
     HEAP32[$218 + 24 >> 2] = $R8$3;
     break;
    }
   }
  } while (0);
  HEAP32[$p$1 + 4 >> 2] = $135 | 1;
  HEAP32[$p$1 + $135 >> 2] = $135;
  if (($p$1 | 0) == (HEAP32[79273] | 0)) {
   HEAP32[79270] = $135;
   return;
  } else $psize$2 = $135;
 } else {
  HEAP32[$113 >> 2] = $114 & -2;
  HEAP32[$p$1 + 4 >> 2] = $psize$1 | 1;
  HEAP32[$p$1 + $psize$1 >> 2] = $psize$1;
  $psize$2 = $psize$1;
 }
 $233 = $psize$2 >>> 3;
 if ($psize$2 >>> 0 < 256) {
  $236 = 317112 + ($233 << 1 << 2) | 0;
  $237 = HEAP32[79268] | 0;
  $238 = 1 << $233;
  if (!($237 & $238)) {
   HEAP32[79268] = $237 | $238;
   $$pre$phiZ2D = $236 + 8 | 0;
   $F18$0 = $236;
  } else {
   $242 = $236 + 8 | 0;
   $243 = HEAP32[$242 >> 2] | 0;
   if ($243 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
    $$pre$phiZ2D = $242;
    $F18$0 = $243;
   }
  }
  HEAP32[$$pre$phiZ2D >> 2] = $p$1;
  HEAP32[$F18$0 + 12 >> 2] = $p$1;
  HEAP32[$p$1 + 8 >> 2] = $F18$0;
  HEAP32[$p$1 + 12 >> 2] = $236;
  return;
 }
 $249 = $psize$2 >>> 8;
 if (!$249) $I20$0 = 0; else if ($psize$2 >>> 0 > 16777215) $I20$0 = 31; else {
  $254 = ($249 + 1048320 | 0) >>> 16 & 8;
  $255 = $249 << $254;
  $258 = ($255 + 520192 | 0) >>> 16 & 4;
  $260 = $255 << $258;
  $263 = ($260 + 245760 | 0) >>> 16 & 2;
  $268 = 14 - ($258 | $254 | $263) + ($260 << $263 >>> 15) | 0;
  $I20$0 = $psize$2 >>> ($268 + 7 | 0) & 1 | $268 << 1;
 }
 $274 = 317376 + ($I20$0 << 2) | 0;
 HEAP32[$p$1 + 28 >> 2] = $I20$0;
 HEAP32[$p$1 + 20 >> 2] = 0;
 HEAP32[$p$1 + 16 >> 2] = 0;
 $278 = HEAP32[79269] | 0;
 $279 = 1 << $I20$0;
 do if (!($278 & $279)) {
  HEAP32[79269] = $278 | $279;
  HEAP32[$274 >> 2] = $p$1;
  HEAP32[$p$1 + 24 >> 2] = $274;
  HEAP32[$p$1 + 12 >> 2] = $p$1;
  HEAP32[$p$1 + 8 >> 2] = $p$1;
 } else {
  $K21$0 = $psize$2 << (($I20$0 | 0) == 31 ? 0 : 25 - ($I20$0 >>> 1) | 0);
  $T$0 = HEAP32[$274 >> 2] | 0;
  while (1) {
   if ((HEAP32[$T$0 + 4 >> 2] & -8 | 0) == ($psize$2 | 0)) {
    $T$0$lcssa = $T$0;
    label = 130;
    break;
   }
   $297 = $T$0 + 16 + ($K21$0 >>> 31 << 2) | 0;
   $299 = HEAP32[$297 >> 2] | 0;
   if (!$299) {
    $$lcssa = $297;
    $T$0$lcssa48 = $T$0;
    label = 127;
    break;
   } else {
    $K21$0 = $K21$0 << 1;
    $T$0 = $299;
   }
  }
  if ((label | 0) == 127) if ($$lcssa >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
   HEAP32[$$lcssa >> 2] = $p$1;
   HEAP32[$p$1 + 24 >> 2] = $T$0$lcssa48;
   HEAP32[$p$1 + 12 >> 2] = $p$1;
   HEAP32[$p$1 + 8 >> 2] = $p$1;
   break;
  } else if ((label | 0) == 130) {
   $306 = $T$0$lcssa + 8 | 0;
   $307 = HEAP32[$306 >> 2] | 0;
   $308 = HEAP32[79272] | 0;
   if ($307 >>> 0 >= $308 >>> 0 & $T$0$lcssa >>> 0 >= $308 >>> 0) {
    HEAP32[$307 + 12 >> 2] = $p$1;
    HEAP32[$306 >> 2] = $p$1;
    HEAP32[$p$1 + 8 >> 2] = $307;
    HEAP32[$p$1 + 12 >> 2] = $T$0$lcssa;
    HEAP32[$p$1 + 24 >> 2] = 0;
    break;
   } else _abort();
  }
 } while (0);
 $316 = (HEAP32[79276] | 0) + -1 | 0;
 HEAP32[79276] = $316;
 if (!$316) $sp$0$in$i = 317528; else return;
 while (1) {
  $sp$0$i = HEAP32[$sp$0$in$i >> 2] | 0;
  if (!$sp$0$i) break; else $sp$0$in$i = $sp$0$i + 8 | 0;
 }
 HEAP32[79276] = -1;
 return;
}

function _prvTidyCleanWord2000($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0$be = 0, $$049 = 0, $$140 = 0, $$2 = 0, $$2$idx$val = 0, $$6 = 0, $$634 = 0, $$pr = 0, $$pr$pre = 0, $$pr1862 = 0, $$pr26 = 0, $$pr60 = 0, $$pre = 0, $$pre$phiZ2D = 0, $1 = 0, $109 = 0, $110 = 0, $112 = 0, $113 = 0, $114 = 0, $117 = 0, $119 = 0, $121 = 0, $124 = 0, $125 = 0, $135 = 0, $138 = 0, $139 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $158 = 0, $162 = 0, $165 = 0, $168 = 0, $174 = 0, $175 = 0, $178 = 0, $182 = 0, $186 = 0, $190 = 0, $197 = 0, $26 = 0, $28 = 0, $29 = 0, $3 = 0, $36 = 0, $39 = 0, $4 = 0, $41 = 0, $45 = 0, $47 = 0, $48 = 0, $5 = 0, $57 = 0, $58 = 0, $6 = 0, $74 = 0, $92 = 0, $96 = 0, $99 = 0, $attval$038 = 0, $c$i = 0, $list$0$be = 0, $list$044 = 0, $list$1 = 0, $list$2 = 0, $list$4 = 0, $list$433 = 0, $listType$0 = 0, $node$01$i = 0, $node$02$i = 0, label = 0, sp = 0, $attval$038$looptemp = 0, $$140$looptemp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c$i = sp;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 if (!$node) {
  STACKTOP = sp;
  return;
 }
 $3 = $1 + 84 | 0;
 $4 = $doc + 196 | 0;
 $$049 = $node;
 $list$044 = 0;
 L4 : while (1) {
  $5 = $$049 + 28 | 0;
  $6 = HEAP32[$5 >> 2] | 0;
  L6 : do if (!$6) $$2 = $$049; else {
   if ((HEAP32[$6 >> 2] | 0) == 48) {
    if (!(_prvTidyGetAttrByName($$049, 311458) | 0)) if (!(HEAP32[$4 >> 2] | 0)) {
     label = 101;
     break L4;
    }
    $15 = HEAP32[$$049 + 20 >> 2] | 0;
    if ($15 | 0) {
     $attval$038 = $15;
     do {
      $attval$038$looptemp = $attval$038;
      $attval$038 = HEAP32[$attval$038 >> 2] | 0;
      if (_strcmp(HEAP32[$attval$038$looptemp + 20 >> 2] | 0, 311466) | 0) _prvTidyReportAttrError($doc, $$049, $attval$038$looptemp, 253);
     } while (($attval$038 | 0) != 0);
    }
    _prvTidyFreeAttrs($doc, $$049);
    $$pr$pre = HEAP32[$5 >> 2] | 0;
    if (!$$pr$pre) {
     $$2 = $$049;
     break;
    } else $$pr60 = $$pr$pre;
   } else $$pr60 = $6;
   if ((HEAP32[$$pr60 >> 2] | 0) == 80) {
    $26 = _prvTidyAttrGetById($$049, 143) | 0;
    if (!$26) $$2 = $$049; else {
     $28 = $26 + 24 | 0;
     $29 = HEAP32[$28 >> 2] | 0;
     if (!$29) $$2 = $$049; else if (!(_prvTidytmbsubstr($29, 311472) | 0)) $$2 = $$049; else if (!(_prvTidytmbsubstr(HEAP32[$28 >> 2] | 0, 311486) | 0)) $$2 = $$049; else {
      _prvTidyCoerceNode($doc, $$049, 84, 0, 1);
      _PurgeWord2000Attributes($doc, $$049);
      $36 = HEAP32[$$049 + 12 >> 2] | 0;
      if ($36 | 0) _prvTidyCleanWord2000($doc, $36);
      $39 = HEAP32[$$049 + 8 >> 2] | 0;
      if (!$39) {
       label = 101;
       break L4;
      } else $$140 = $39;
      while (1) {
       $41 = HEAP32[$$140 + 28 >> 2] | 0;
       if (!$41) {
        $$2 = $$140;
        break L6;
       }
       if ((HEAP32[$41 >> 2] | 0) != 80) {
        $$2 = $$140;
        break L6;
       }
       $45 = _prvTidyAttrGetById($$140, 143) | 0;
       if (!$45) {
        $$2 = $$140;
        break L6;
       }
       $47 = $45 + 24 | 0;
       $48 = HEAP32[$47 >> 2] | 0;
       if (!$48) {
        $$2 = $$140;
        break L6;
       }
       if (!(_prvTidytmbsubstr($48, 311472) | 0)) {
        $$2 = $$140;
        break L6;
       }
       if (!(_prvTidytmbsubstr(HEAP32[$47 >> 2] | 0, 311486) | 0)) {
        $$2 = $$140;
        break L6;
       }
       $$140$looptemp = $$140;
       $$140 = HEAP32[$$140 + 8 >> 2] | 0;
       _prvTidyRemoveNode($$140$looptemp) | 0;
       _prvTidyInsertNodeAtEnd($$049, _prvTidyNewLineNode($1) | 0);
       _prvTidyInsertNodeAtEnd($$049, $$140$looptemp);
       _StripSpan($doc, $$140$looptemp) | 0;
       if (!$$140) {
        label = 101;
        break L4;
       }
      }
     }
    }
   } else $$2 = $$049;
  } while (0);
  $57 = $$2 + 28 | 0;
  $58 = HEAP32[$57 >> 2] | 0;
  L38 : do if (!$58) label = 37; else if (!(HEAP32[$58 + 16 >> 2] & 8)) label = 37; else {
   $$2$idx$val = HEAP32[$$2 + 12 >> 2] | 0;
   if (!$$2$idx$val) {
    $$pr1862 = $58;
    label = 39;
   } else if (!(HEAP32[$$2$idx$val + 8 >> 2] | 0)) if ((HEAP32[$$2$idx$val + 44 >> 2] | 0) == 4) {
    $74 = HEAP32[$$2$idx$val + 36 >> 2] | 0;
    switch ((HEAP32[$$2$idx$val + 40 >> 2] | 0) - $74 | 0) {
    case 1:
     {
      if ((HEAP8[(HEAP32[$3 >> 2] | 0) + $74 >> 0] | 0) != 32) {
       label = 38;
       break L38;
      }
      break;
     }
    case 2:
     {
      HEAP32[$c$i >> 2] = 0;
      _prvTidyGetUTF8((HEAP32[$3 >> 2] | 0) + $74 | 0, $c$i) | 0;
      if ((HEAP32[$c$i >> 2] | 0) != 160) {
       label = 38;
       break L38;
      }
      break;
     }
    default:
     {
      label = 38;
      break L38;
     }
    }
    $$0$be = _StripSpan($doc, $$2) | 0;
    $list$0$be = $list$044;
   } else {
    $$pr1862 = $58;
    label = 39;
   } else {
    $$pr1862 = $58;
    label = 39;
   }
  } while (0);
  if ((label | 0) == 37) {
   label = 0;
   if (!$$2) label = 40; else label = 38;
  }
  if ((label | 0) == 38) {
   label = 0;
   $$pre = HEAP32[$57 >> 2] | 0;
   if (!$$pre) label = 40; else {
    $$pr1862 = $$pre;
    label = 39;
   }
  }
  if ((label | 0) == 39) {
   label = 0;
   switch (HEAP32[$$pr1862 >> 2] | 0) {
   case 68:
   case 103:
    {
     label = 41;
     break;
    }
   default:
    label = 40;
   }
  }
  L54 : do if ((label | 0) == 40) {
   label = 0;
   if ((HEAP32[$$2 + 44 >> 2] | 0) == 2) label = 41; else {
    $92 = HEAP32[$57 >> 2] | 0;
    if ($92 | 0) {
     switch (HEAP32[$92 >> 2] | 0) {
     case 36:
     case 100:
      {
       $$0$be = _StripSpan($doc, $$2) | 0;
       $list$0$be = $list$044;
       break L54;
       break;
      }
     case 62:
      {
       label = 45;
       break;
      }
     default:
      {}
     }
     if ((label | 0) == 45) {
      label = 0;
      $96 = _prvTidyAttrGetById($$2, 122) | 0;
      if ($96 | 0) {
       $99 = HEAP32[$96 + 24 >> 2] | 0;
       if ($99 | 0) if (!(_prvTidytmbstrcasecmp($99, 311515) | 0)) {
        $$0$be = _prvTidyDiscardElement($doc, $$2) | 0;
        $list$0$be = $list$044;
        break;
       }
      }
     }
     $$pr = HEAP32[$57 >> 2] | 0;
     if ($$pr | 0) if (!(_prvTidytmbstrcmp(HEAP32[$$pr + 4 >> 2] | 0, 311525) | 0)) {
      _prvTidyReportError($doc, 0, $$2, 221);
      $109 = $$2 + 12 | 0;
      $110 = HEAP32[$109 >> 2] | 0;
      $112 = $110;
      if (!$110) {
       $$0$be = _prvTidyDiscardElement($doc, $$2) | 0;
       $list$0$be = $list$044;
       break;
      }
      $113 = HEAP32[$$2 >> 2] | 0;
      $114 = $$2 + 8 | 0;
      $117 = HEAP32[$$2 + 16 >> 2] | 0;
      HEAP32[$117 + 8 >> 2] = HEAP32[$114 >> 2];
      $119 = HEAP32[$114 >> 2] | 0;
      $121 = $117;
      if (!$119) HEAP32[$113 + 16 >> 2] = $121; else HEAP32[$119 + 4 >> 2] = $121;
      $124 = $$2 + 4 | 0;
      $125 = HEAP32[$124 >> 2] | 0;
      if (!$125) HEAP32[$113 + 12 >> 2] = $112; else {
       HEAP32[$110 + 4 >> 2] = $125;
       HEAP32[(HEAP32[$124 >> 2] | 0) + 8 >> 2] = $112;
      }
      $node$01$i = HEAP32[$109 >> 2] | 0;
      if ($node$01$i | 0) {
       $node$02$i = $node$01$i;
       do {
        HEAP32[$node$02$i >> 2] = $113;
        $node$02$i = HEAP32[$node$02$i + 8 >> 2] | 0;
       } while (($node$02$i | 0) != 0);
      }
      HEAP32[$109 >> 2] = 0;
      HEAP32[$114 >> 2] = 0;
      _prvTidyFreeNode($doc, $$2);
      $$0$be = $node$01$i;
      $list$0$be = $list$044;
      break;
     }
    }
    $135 = $$2 + 12 | 0;
    $138 = HEAP32[$57 >> 2] | 0;
    $139 = ($138 | 0) == 0;
    if (!(HEAP32[$135 >> 2] | 0)) if ($139) {
     $$634 = $$2;
     $list$433 = 0;
    } else if ((HEAP32[$138 >> 2] | 0) == 80) {
     $$0$be = _prvTidyTrimEmptyElement($doc, $$2) | 0;
     $list$0$be = $list$044;
     break;
    } else label = 67; else if ($139) {
     $$634 = $$2;
     $list$433 = 0;
    } else label = 67;
    if ((label | 0) == 67) {
     label = 0;
     if ((HEAP32[$138 >> 2] | 0) == 80) {
      $145 = _prvTidyAttrGetById($$2, 26) | 0;
      $146 = _prvTidyAttrGetById($$2, 143) | 0;
      $147 = ($145 | 0) != 0;
      if ($147) {
       $148 = $145 + 24 | 0;
       $149 = HEAP32[$148 >> 2] | 0;
       if (!$149) label = 73; else if (!(_prvTidytmbstrcasecmp($149, 311529) | 0)) {
        $$pre$phiZ2D = $148;
        label = 78;
       } else {
        $$pr26 = HEAP32[$148 >> 2] | 0;
        if (!$$pr26) label = 73; else if (!(_prvTidytmbstrcasecmp($$pr26, 311543) | 0)) label = 76; else label = 73;
       }
      } else label = 73;
      do if ((label | 0) == 73) {
       label = 0;
       if ($146 | 0) {
        $158 = HEAP32[$146 + 24 >> 2] | 0;
        if ($158 | 0) if (_prvTidytmbsubstr($158, 311557) | 0) {
         label = 76;
         break;
        }
       }
       if ($147) {
        $178 = HEAP32[$145 + 24 >> 2] | 0;
        if (!$178) {
         $$6 = $$2;
         $list$4 = 0;
        } else if (!(_prvTidytmbstrcasecmp($178, 311503) | 0)) {
         $182 = _prvTidyNewLineNode($1) | 0;
         _prvTidyNormalizeSpaces($1, HEAP32[$135 >> 2] | 0);
         if (!$list$044) label = 93; else {
          $186 = HEAP32[$list$044 + 28 >> 2] | 0;
          if (!$186) label = 93; else if ((HEAP32[$186 >> 2] | 0) == 84) $list$2 = $list$044; else label = 93;
         }
         if ((label | 0) == 93) {
          label = 0;
          $190 = _prvTidyInferredTag($doc, 84) | 0;
          _prvTidyInsertNodeBeforeElement($$2, $190);
          $list$2 = $190;
         }
         _prvTidyRemoveNode($$2) | 0;
         _prvTidyInsertNodeAtEnd($list$2, $$2);
         _StripSpan($doc, $$2) | 0;
         _prvTidyInsertNodeAtEnd($list$2, $182);
         $$6 = HEAP32[$list$2 + 8 >> 2] | 0;
         $list$4 = $list$2;
        } else {
         $$6 = $$2;
         $list$4 = 0;
        }
       } else {
        $$6 = $$2;
        $list$4 = 0;
       }
      } while (0);
      if ((label | 0) == 76) {
       label = 0;
       if ($147) {
        $$pre$phiZ2D = $145 + 24 | 0;
        label = 78;
       } else {
        $listType$0 = 118;
        label = 80;
       }
      }
      if ((label | 0) == 78) {
       label = 0;
       $162 = HEAP32[$$pre$phiZ2D >> 2] | 0;
       if (!$162) {
        $listType$0 = 118;
        label = 80;
       } else {
        $165 = (_prvTidytmbstrcasecmp($162, 311543) | 0) == 0;
        $listType$0 = $165 ? 77 : 118;
        label = 80;
       }
      }
      if ((label | 0) == 80) {
       label = 0;
       _prvTidyCoerceNode($doc, $$2, 61, 0, 1);
       if (!$list$044) label = 83; else {
        $168 = HEAP32[$list$044 + 28 >> 2] | 0;
        if (!$168) label = 83; else if ((HEAP32[$168 >> 2] | 0) == ($listType$0 | 0)) $list$1 = $list$044; else label = 83;
       }
       if ((label | 0) == 83) {
        label = 0;
        $174 = _prvTidyInferredTag($doc, HEAP32[(_prvTidyLookupTagDef($listType$0) | 0) >> 2] | 0) | 0;
        _prvTidyInsertNodeBeforeElement($$2, $174);
        $list$1 = $174;
       }
       _PurgeWord2000Attributes($doc, $$2);
       $175 = HEAP32[$135 >> 2] | 0;
       if ($175 | 0) _prvTidyCleanWord2000($doc, $175);
       _prvTidyRemoveNode($$2) | 0;
       _prvTidyInsertNodeAtEnd($list$1, $$2);
       $$6 = $list$1;
       $list$4 = $list$1;
      }
      if (!$$6) {
       label = 101;
       break L4;
      } else {
       $$634 = $$6;
       $list$433 = $list$4;
      }
     } else {
      $$634 = $$2;
      $list$433 = 0;
     }
    }
    if (_prvTidynodeIsElement($$634) | 0) _PurgeWord2000Attributes($doc, $$634);
    $197 = HEAP32[$$634 + 12 >> 2] | 0;
    if ($197 | 0) _prvTidyCleanWord2000($doc, $197);
    $$0$be = HEAP32[$$634 + 8 >> 2] | 0;
    $list$0$be = $list$433;
   }
  } while (0);
  if ((label | 0) == 41) {
   label = 0;
   $$0$be = _prvTidyDiscardElement($doc, $$2) | 0;
   $list$0$be = $list$044;
  }
  if (!$$0$be) {
   label = 101;
   break;
  } else {
   $$049 = $$0$be;
   $list$044 = $list$0$be;
  }
 }
 if ((label | 0) == 101) {
  STACKTOP = sp;
  return;
 }
}

function _prvTidyParseConfigFileEnc($doc, $file, $charenc) {
 $doc = $doc | 0;
 $file = $file | 0;
 $charenc = $charenc | 0;
 var $$0 = 0, $$0$i = 0, $$0$i$i = 0, $$0$i$i23 = 0, $$0$i$i26 = 0, $$0$i$i26$lcssa = 0, $$0$i$i31 = 0, $$0$i$i37 = 0, $$0$i$i42 = 0, $$0$i$i47$us = 0, $$0$i$i47$us89 = 0, $$0$i$i52 = 0, $$0$i$i55 = 0, $$0$i28 = 0, $$0$i4$i = 0, $$0$i6$i = 0, $$phi$trans$insert$i = 0, $0 = 0, $1 = 0, $10 = 0, $107 = 0, $112 = 0, $116 = 0, $124 = 0, $13 = 0, $136 = 0, $142 = 0, $15 = 0, $154 = 0, $18 = 0, $19 = 0, $20 = 0, $23 = 0, $24 = 0, $27 = 0, $38 = 0, $40 = 0, $5 = 0, $63 = 0, $73 = 0, $76 = 0, $79 = 0, $8 = 0, $88 = 0, $9 = 0, $96 = 0, $buf = 0, $c$076 = 0, $c$077 = 0, $c2$0$ph = 0, $c2$0$ph59$be = 0, $c2$0$ph5975 = 0, $c2$065$us = 0, $c2$065$us86 = 0, $c2$1 = 0, $config$idx$val$i22 = 0, $config$idx$val$i25 = 0, $config$idx$val$i30 = 0, $config$idx$val$i36 = 0, $config$idx$val$i41 = 0, $config$idx$val$i46$us = 0, $config$idx$val$i46$us87 = 0, $config$idx$val$i51 = 0, $config$idx$val$i57 = 0, $config$idx2$val$i = 0, $config$idx3$val$i = 0, $delim$0$ph = 0, $filename$$i = 0, $i$0$ph$lcssa = 0, $i$0$ph73 = 0, $ix$064 = 0, $name = 0, $np$01$i = 0, $waswhite$0$ph74 = 0, dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 8256 | 0;
 $name = sp + 8192 | 0;
 $buf = sp;
 $0 = $doc + 6808 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$file) $$0$i = 0; else if ((HEAP8[$file >> 0] | 0) == 126) {
  $5 = $file + 1 | 0;
  if ((HEAP8[$5 >> 0] | 0) == 47) {
   $8 = _getenv(225637) | 0;
   $9 = ($8 | 0) == 0;
   $filename$$i = $9 ? $file : $5;
   if ($9) $$0$i = $file; else {
    $10 = _prvTidytmbstrlen($filename$$i) | 0;
    $13 = $10 + 1 + (_prvTidytmbstrlen($8) | 0) | 0;
    $15 = HEAP32[$doc + 6856 >> 2] | 0;
    $18 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$15 >> 2] >> 2] & 31]($15, $13) | 0;
    _prvTidytmbstrcpy($18, $8) | 0;
    _prvTidytmbstrcat($18, $filename$$i) | 0;
    $$0$i = $18;
   }
  } else $$0$i = $file;
 } else $$0$i = $file;
 $19 = _fopen($$0$i, 225642) | 0;
 $20 = _prvTidyGetCharEncodingFromOptName($charenc) | 0;
 if (($19 | 0) == 0 | ($20 | 0) < 0) {
  _prvTidyFileError($doc, $$0$i, 2);
  $$0 = -1;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $23 = _prvTidyFileInput($doc, $19, $20) | 0;
 $24 = $doc + 872 | 0;
 HEAP32[$24 >> 2] = $23;
 if (!$23) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($23) | 0;
 $27 = $doc + 868 | 0;
 HEAP32[$27 >> 2] = $$0$i$i;
 L14 : do if (_prvTidyIsWhite($$0$i$i) | 0) do {
  if (_prvTidyIsNewline(HEAP32[$27 >> 2] | 0) | 0) break L14;
  $config$idx$val$i22 = HEAP32[$24 >> 2] | 0;
  if (!$config$idx$val$i22) $$0$i$i23 = -1; else $$0$i$i23 = _prvTidyReadChar($config$idx$val$i22) | 0;
  HEAP32[$27 >> 2] = $$0$i$i23;
 } while ((_prvTidyIsWhite($$0$i$i23) | 0) != 0); while (0);
 $c$076 = HEAP32[$27 >> 2] | 0;
 L22 : do if (($c$076 | 0) != -1) {
  $38 = $doc + 6800 | 0;
  $c$077 = $c$076;
  while (1) {
   dest = $name;
   stop = dest + 64 | 0;
   do {
    HEAP8[dest >> 0] = 0;
    dest = dest + 1 | 0;
   } while ((dest | 0) < (stop | 0));
   L26 : do switch ($c$077 | 0) {
   case 35:
   case 47:
    break;
   default:
    {
     $40 = $c$077;
     $ix$064 = 0;
     L27 : while (1) {
      switch ($40 | 0) {
      case 10:
      case -1:
       {
        break L26;
        break;
       }
      case 58:
       {
        $np$01$i = 1892;
        break L27;
        break;
       }
      default:
       {}
      }
      HEAP8[$name + $ix$064 >> 0] = $40;
      $ix$064 = $ix$064 + 1 | 0;
      $config$idx$val$i25 = HEAP32[$24 >> 2] | 0;
      if (!$config$idx$val$i25) $$0$i$i26 = -1; else $$0$i$i26 = _prvTidyReadChar($config$idx$val$i25) | 0;
      HEAP32[$27 >> 2] = $$0$i$i26;
      if ($ix$064 >>> 0 >= 63) {
       $$0$i$i26$lcssa = $$0$i$i26;
       label = 23;
       break;
      } else $40 = $$0$i$i26;
     }
     if ((label | 0) == 23) {
      label = 0;
      if (($$0$i$i26$lcssa | 0) == 58) $np$01$i = 1892; else break L26;
     }
     while (1) {
      if (!(_prvTidytmbstrcasecmp($name, HEAP32[$np$01$i + 8 >> 2] | 0) | 0)) {
       $$0$i28 = $np$01$i;
       break;
      }
      $np$01$i = $np$01$i + 32 | 0;
      if ($np$01$i >>> 0 >= 5028 >>> 0) {
       $$0$i28 = 0;
       break;
      }
     }
     if ((HEAP32[$27 >> 2] | 0) == -1) $63 = -1; else {
      $config$idx$val$i30 = HEAP32[$24 >> 2] | 0;
      if (!$config$idx$val$i30) $$0$i$i31 = -1; else $$0$i$i31 = _prvTidyReadChar($config$idx$val$i30) | 0;
      HEAP32[$27 >> 2] = $$0$i$i31;
      $63 = $$0$i$i31;
     }
     if ($$0$i28 | 0) {
      FUNCTION_TABLE_iii[HEAP32[$$0$i28 + 20 >> 2] & 31]($doc, $$0$i28) | 0;
      break L26;
     }
     if (!(HEAP32[$38 >> 2] | 0)) {
      _prvTidyReportUnknownOption($doc, $name);
      break L26;
     }
     L51 : do if (_prvTidyIsWhite($63) | 0) do {
      if (_prvTidyIsNewline(HEAP32[$27 >> 2] | 0) | 0) break L51;
      $config$idx$val$i36 = HEAP32[$24 >> 2] | 0;
      if (!$config$idx$val$i36) $$0$i$i37 = -1; else $$0$i$i37 = _prvTidyReadChar($config$idx$val$i36) | 0;
      HEAP32[$27 >> 2] = $$0$i$i37;
     } while ((_prvTidyIsWhite($$0$i$i37) | 0) != 0); while (0);
     $73 = HEAP32[$27 >> 2] | 0;
     switch ($73 | 0) {
     case 34:
     case 39:
      {
       $config$idx$val$i41 = HEAP32[$24 >> 2] | 0;
       if (!$config$idx$val$i41) $$0$i$i42 = -1; else $$0$i$i42 = _prvTidyReadChar($config$idx$val$i41) | 0;
       HEAP32[$27 >> 2] = $$0$i$i42;
       $c2$0$ph = $$0$i$i42;
       $delim$0$ph = $73;
       break;
      }
     default:
      {
       $c2$0$ph = $73;
       $delim$0$ph = 0;
      }
     }
     $76 = ($delim$0$ph | 0) == 0;
     $c2$0$ph5975 = $c2$0$ph;
     $i$0$ph73 = 0;
     $waswhite$0$ph74 = 0;
     L65 : while (1) {
      L67 : do if ($76) {
       if ($waswhite$0$ph74) {
        switch ($c2$0$ph5975 | 0) {
        case 10:
        case 13:
        case -1:
         {
          $i$0$ph$lcssa = $i$0$ph73;
          break L65;
          break;
         }
        default:
         {}
        }
        $88 = (_prvTidyIsWhite($c2$0$ph5975) | 0) == 0;
        $c2$1 = $88 ? $c2$0$ph5975 : 32;
        break;
       } else $c2$065$us86 = $c2$0$ph5975;
       while (1) {
        switch ($c2$065$us86 | 0) {
        case 10:
        case 13:
        case -1:
         {
          $i$0$ph$lcssa = $i$0$ph73;
          break L65;
          break;
         }
        default:
         {}
        }
        if (!(_prvTidyIsWhite($c2$065$us86) | 0)) {
         $c2$1 = $c2$065$us86;
         break L67;
        }
        if ((HEAP32[$27 >> 2] | 0) == -1) {
         $c2$065$us86 = -1;
         continue;
        }
        $config$idx$val$i46$us87 = HEAP32[$24 >> 2] | 0;
        if (!$config$idx$val$i46$us87) $$0$i$i47$us89 = -1; else $$0$i$i47$us89 = _prvTidyReadChar($config$idx$val$i46$us87) | 0;
        HEAP32[$27 >> 2] = $$0$i$i47$us89;
        $c2$065$us86 = $$0$i$i47$us89;
       }
      } else {
       if ($waswhite$0$ph74) {
        switch ($c2$0$ph5975 | 0) {
        case 10:
        case 13:
        case -1:
         {
          $i$0$ph$lcssa = $i$0$ph73;
          break L65;
          break;
         }
        default:
         {}
        }
        if (($c2$0$ph5975 | 0) == ($delim$0$ph | 0)) {
         $i$0$ph$lcssa = $i$0$ph73;
         break L65;
        }
        $79 = (_prvTidyIsWhite($c2$0$ph5975) | 0) == 0;
        $c2$1 = $79 ? $c2$0$ph5975 : 32;
        break;
       } else $c2$065$us = $c2$0$ph5975;
       while (1) {
        switch ($c2$065$us | 0) {
        case 10:
        case 13:
        case -1:
         {
          $i$0$ph$lcssa = $i$0$ph73;
          break L65;
          break;
         }
        default:
         {}
        }
        if (($c2$065$us | 0) == ($delim$0$ph | 0)) {
         $i$0$ph$lcssa = $i$0$ph73;
         break L65;
        }
        if (!(_prvTidyIsWhite($c2$065$us) | 0)) {
         $c2$1 = $c2$065$us;
         break L67;
        }
        if ((HEAP32[$27 >> 2] | 0) == -1) {
         $c2$065$us = -1;
         continue;
        }
        $config$idx$val$i46$us = HEAP32[$24 >> 2] | 0;
        if (!$config$idx$val$i46$us) $$0$i$i47$us = -1; else $$0$i$i47$us = _prvTidyReadChar($config$idx$val$i46$us) | 0;
        HEAP32[$27 >> 2] = $$0$i$i47$us;
        $c2$065$us = $$0$i$i47$us;
       }
      } while (0);
      $96 = $i$0$ph73 + 1 | 0;
      HEAP8[$buf + $i$0$ph73 >> 0] = $c2$1;
      if ((HEAP32[$27 >> 2] | 0) == -1) $c2$0$ph59$be = -1; else {
       $config$idx$val$i51 = HEAP32[$24 >> 2] | 0;
       if (!$config$idx$val$i51) $$0$i$i52 = -1; else $$0$i$i52 = _prvTidyReadChar($config$idx$val$i51) | 0;
       HEAP32[$27 >> 2] = $$0$i$i52;
       $c2$0$ph59$be = $$0$i$i52;
      }
      if ($96 >>> 0 < 8190) {
       $c2$0$ph5975 = $c2$0$ph59$be;
       $i$0$ph73 = $96;
       $waswhite$0$ph74 = 1;
      } else {
       $i$0$ph$lcssa = $96;
       break;
      }
     }
     HEAP8[$buf + $i$0$ph$lcssa >> 0] = 0;
     if (!(FUNCTION_TABLE_iii[HEAP32[$38 >> 2] & 31]($name, $buf) | 0)) _prvTidyReportUnknownOption($doc, $name);
    }
   } while (0);
   do {
    $107 = HEAP32[$27 >> 2] | 0;
    L108 : while (1) {
     switch ($107 | 0) {
     case 13:
      {
       label = 79;
       break L108;
       break;
      }
     case -1:
     case 10:
      {
       $112 = $107;
       break L108;
       break;
      }
     default:
      {}
     }
     $config$idx3$val$i = HEAP32[$24 >> 2] | 0;
     if (!$config$idx3$val$i) $$0$i$i55 = -1; else $$0$i$i55 = _prvTidyReadChar($config$idx3$val$i) | 0;
     HEAP32[$27 >> 2] = $$0$i$i55;
     $107 = $$0$i$i55;
    }
    if ((label | 0) == 79) {
     label = 0;
     $config$idx2$val$i = HEAP32[$24 >> 2] | 0;
     if (!$config$idx2$val$i) $$0$i4$i = -1; else $$0$i4$i = _prvTidyReadChar($config$idx2$val$i) | 0;
     HEAP32[$27 >> 2] = $$0$i4$i;
     $112 = $$0$i4$i;
    }
    if (($112 | 0) == 10) {
     $config$idx$val$i57 = HEAP32[$24 >> 2] | 0;
     if (!$config$idx$val$i57) $$0$i6$i = -1; else $$0$i6$i = _prvTidyReadChar($config$idx$val$i57) | 0;
     HEAP32[$27 >> 2] = $$0$i6$i;
     $116 = $$0$i6$i;
    } else $116 = $112;
   } while ((_prvTidyIsWhite($116) | 0) != 0);
   $c$077 = HEAP32[$27 >> 2] | 0;
   if (($c$077 | 0) == -1) break L22;
  }
 } while (0);
 _prvTidyfreeFileSource((HEAP32[$24 >> 2] | 0) + 304 | 0, 1);
 _prvTidyfreeStreamIn(HEAP32[$24 >> 2] | 0);
 HEAP32[$24 >> 2] = 0;
 if (($$0$i | 0) != ($file | 0)) {
  $124 = HEAP32[$doc + 6856 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$124 >> 2] | 0) + 8 >> 2] & 15]($124, $$0$i);
 }
 if (HEAP32[$doc + 300 >> 2] | 0) HEAP32[$doc + 296 >> 2] = 1;
 if (!(HEAP32[$doc + 152 >> 2] | 0)) HEAP32[$doc + 76 >> 2] = 0;
 $136 = $doc + 80 | 0;
 if (!(HEAP32[$136 >> 2] | 0)) HEAP32[$136 >> 2] = 2147483647;
 if (HEAP32[$doc + 308 >> 2] | 0) {
  $142 = $doc + 864 | 0;
  HEAP32[$142 >> 2] = HEAP32[$142 >> 2] | 2;
  _prvTidyDefineTag($doc, 2, 311525);
 }
 $$phi$trans$insert$i = $doc + 176 | 0;
 if (!(HEAP32[$doc + 168 >> 2] | 0)) {
  if (HEAP32[$$phi$trans$insert$i >> 2] | 0) {
   HEAP32[$doc + 172 >> 2] = 1;
   HEAP32[$doc + 188 >> 2] = 0;
   HEAP32[$doc + 192 >> 2] = 0;
  }
 } else {
  HEAP32[$$phi$trans$insert$i >> 2] = 0;
  HEAP32[$doc + 172 >> 2] = 1;
  HEAP32[$doc + 288 >> 2] = 1;
 }
 $154 = HEAP32[$doc + 96 >> 2] | 0;
 switch ($154 | 0) {
 case 0:
 case 9:
 case 10:
 case 11:
 case 4:
 case 1:
  break;
 default:
  if (HEAP32[$doc + 172 >> 2] | 0) HEAP32[$doc + 184 >> 2] = 1;
 }
 if (HEAP32[$doc + 172 >> 2] | 0) {
  if (($154 + -9 | 0) >>> 0 < 3) HEAP32[$doc + 380 >> 2] = 1;
  HEAP32[$doc + 252 >> 2] = 1;
  HEAP32[$doc + 164 >> 2] = 0;
 }
 $$0 = (HEAP32[$0 >> 2] | 0) >>> 0 > $1 >>> 0 & 1;
 STACKTOP = sp;
 return $$0 | 0;
}

function ___intscan($f, $base, $pok, $0, $1) {
 $f = $f | 0;
 $base = $base | 0;
 $pok = $pok | 0;
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$1 = 0, $$115 = 0, $$116 = 0, $$base14 = 0, $$lcssa = 0, $$lcssa108 = 0, $$lcssa109 = 0, $$lcssa110 = 0, $$lcssa111 = 0, $$lcssa112 = 0, $$lcssa113 = 0, $100 = 0, $101 = 0, $108 = 0, $120 = 0, $121 = 0, $128 = 0, $13 = 0, $130 = 0, $131 = 0, $134 = 0, $135 = 0, $136 = 0, $144 = 0, $149 = 0, $150 = 0, $152 = 0, $154 = 0, $156 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $166 = 0, $167 = 0, $168 = 0, $17 = 0, $18 = 0, $185 = 0, $186 = 0, $187 = 0, $195 = 0, $201 = 0, $203 = 0, $204 = 0, $205 = 0, $207 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $222 = 0, $223 = 0, $224 = 0, $239 = 0, $25 = 0, $259 = 0, $261 = 0, $272 = 0, $281 = 0, $284 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $3 = 0, $37 = 0, $39 = 0, $4 = 0, $47 = 0, $51 = 0, $6 = 0, $67 = 0, $70 = 0, $71 = 0, $72 = 0, $83 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $91 = 0, $93 = 0, $99 = 0, $c$0 = 0, $c$1 = 0, $c$117 = 0, $c$2$be = 0, $c$2$be$lcssa = 0, $c$2$lcssa = 0, $c$3$be = 0, $c$3$lcssa = 0, $c$359 = 0, $c$4$be = 0, $c$4$be$lcssa = 0, $c$4$lcssa = 0, $c$5$be = 0, $c$6$be = 0, $c$6$be$lcssa = 0, $c$6$lcssa = 0, $c$7$be = 0, $c$742 = 0, $c$8 = 0, $c$9$be = 0, $neg$0 = 0, $neg$1 = 0, $x$070 = 0, $x$136 = 0, $x$254 = 0, label = 0;
 L1 : do if ($base >>> 0 > 36) {
  HEAP32[(___errno_location() | 0) >> 2] = 22;
  $286 = 0;
  $287 = 0;
 } else {
  $3 = $f + 4 | 0;
  $4 = $f + 100 | 0;
  do {
   $6 = HEAP32[$3 >> 2] | 0;
   if ($6 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
    HEAP32[$3 >> 2] = $6 + 1;
    $13 = HEAPU8[$6 >> 0] | 0;
   } else $13 = ___shgetc($f) | 0;
  } while ((_isspace($13) | 0) != 0);
  $$lcssa113 = $13;
  L11 : do switch ($$lcssa113 | 0) {
  case 43:
  case 45:
   {
    $17 = (($$lcssa113 | 0) == 45) << 31 >> 31;
    $18 = HEAP32[$3 >> 2] | 0;
    if ($18 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
     HEAP32[$3 >> 2] = $18 + 1;
     $c$0 = HEAPU8[$18 >> 0] | 0;
     $neg$0 = $17;
     break L11;
    } else {
     $c$0 = ___shgetc($f) | 0;
     $neg$0 = $17;
     break L11;
    }
    break;
   }
  default:
   {
    $c$0 = $$lcssa113;
    $neg$0 = 0;
   }
  } while (0);
  $25 = ($base | 0) == 0;
  do if (($base | 16 | 0) == 16 & ($c$0 | 0) == 48) {
   $29 = HEAP32[$3 >> 2] | 0;
   if ($29 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
    HEAP32[$3 >> 2] = $29 + 1;
    $37 = HEAPU8[$29 >> 0] | 0;
   } else $37 = ___shgetc($f) | 0;
   if (($37 | 32 | 0) != 120) if ($25) {
    $$116 = 8;
    $c$117 = $37;
    label = 46;
    break;
   } else {
    $$1 = $base;
    $c$1 = $37;
    label = 32;
    break;
   }
   $39 = HEAP32[$3 >> 2] | 0;
   if ($39 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
    HEAP32[$3 >> 2] = $39 + 1;
    $47 = HEAPU8[$39 >> 0] | 0;
   } else $47 = ___shgetc($f) | 0;
   if ((HEAPU8[316178 + $47 >> 0] | 0) > 15) {
    $51 = (HEAP32[$4 >> 2] | 0) == 0;
    if (!$51) HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + -1;
    if (!$pok) {
     ___shlim($f, 0);
     $286 = 0;
     $287 = 0;
     break L1;
    }
    if ($51) {
     $286 = 0;
     $287 = 0;
     break L1;
    }
    HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + -1;
    $286 = 0;
    $287 = 0;
    break L1;
   } else {
    $$116 = 16;
    $c$117 = $47;
    label = 46;
   }
  } else {
   $$base14 = $25 ? 10 : $base;
   if ((HEAPU8[316178 + $c$0 >> 0] | 0) >>> 0 < $$base14 >>> 0) {
    $$1 = $$base14;
    $c$1 = $c$0;
    label = 32;
   } else {
    if (HEAP32[$4 >> 2] | 0) HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + -1;
    ___shlim($f, 0);
    HEAP32[(___errno_location() | 0) >> 2] = 22;
    $286 = 0;
    $287 = 0;
    break L1;
   }
  } while (0);
  if ((label | 0) == 32) if (($$1 | 0) == 10) {
   $67 = $c$1 + -48 | 0;
   if ($67 >>> 0 < 10) {
    $71 = $67;
    $x$070 = 0;
    while (1) {
     $70 = ($x$070 * 10 | 0) + $71 | 0;
     $72 = HEAP32[$3 >> 2] | 0;
     if ($72 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
      HEAP32[$3 >> 2] = $72 + 1;
      $c$2$be = HEAPU8[$72 >> 0] | 0;
     } else $c$2$be = ___shgetc($f) | 0;
     $71 = $c$2$be + -48 | 0;
     if (!($71 >>> 0 < 10 & $70 >>> 0 < 429496729)) {
      $$lcssa112 = $70;
      $c$2$be$lcssa = $c$2$be;
      break;
     } else $x$070 = $70;
    }
    $288 = $$lcssa112;
    $289 = 0;
    $c$2$lcssa = $c$2$be$lcssa;
   } else {
    $288 = 0;
    $289 = 0;
    $c$2$lcssa = $c$1;
   }
   $83 = $c$2$lcssa + -48 | 0;
   if ($83 >>> 0 < 10) {
    $85 = $288;
    $86 = $289;
    $89 = $83;
    $c$359 = $c$2$lcssa;
    while (1) {
     $87 = ___muldi3($85 | 0, $86 | 0, 10, 0) | 0;
     $88 = tempRet0;
     $91 = (($89 | 0) < 0) << 31 >> 31;
     $93 = ~$91;
     if ($88 >>> 0 > $93 >>> 0 | ($88 | 0) == ($93 | 0) & $87 >>> 0 > ~$89 >>> 0) {
      $$lcssa = $89;
      $290 = $85;
      $291 = $86;
      $c$3$lcssa = $c$359;
      break;
     }
     $99 = _i64Add($87 | 0, $88 | 0, $89 | 0, $91 | 0) | 0;
     $100 = tempRet0;
     $101 = HEAP32[$3 >> 2] | 0;
     if ($101 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
      HEAP32[$3 >> 2] = $101 + 1;
      $c$3$be = HEAPU8[$101 >> 0] | 0;
     } else $c$3$be = ___shgetc($f) | 0;
     $108 = $c$3$be + -48 | 0;
     if ($108 >>> 0 < 10 & ($100 >>> 0 < 429496729 | ($100 | 0) == 429496729 & $99 >>> 0 < 2576980378)) {
      $85 = $99;
      $86 = $100;
      $89 = $108;
      $c$359 = $c$3$be;
     } else {
      $$lcssa = $108;
      $290 = $99;
      $291 = $100;
      $c$3$lcssa = $c$3$be;
      break;
     }
    }
    if ($$lcssa >>> 0 > 9) {
     $259 = $291;
     $261 = $290;
     $neg$1 = $neg$0;
    } else {
     $$115 = 10;
     $292 = $290;
     $293 = $291;
     $c$8 = $c$3$lcssa;
     label = 72;
    }
   } else {
    $259 = $289;
    $261 = $288;
    $neg$1 = $neg$0;
   }
  } else {
   $$116 = $$1;
   $c$117 = $c$1;
   label = 46;
  }
  L63 : do if ((label | 0) == 46) {
   if (!($$116 + -1 & $$116)) {
    $128 = HEAP8[316434 + (($$116 * 23 | 0) >>> 5 & 7) >> 0] | 0;
    $130 = HEAP8[316178 + $c$117 >> 0] | 0;
    $131 = $130 & 255;
    if ($131 >>> 0 < $$116 >>> 0) {
     $135 = $131;
     $x$136 = 0;
     while (1) {
      $134 = $135 | $x$136 << $128;
      $136 = HEAP32[$3 >> 2] | 0;
      if ($136 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
       HEAP32[$3 >> 2] = $136 + 1;
       $c$4$be = HEAPU8[$136 >> 0] | 0;
      } else $c$4$be = ___shgetc($f) | 0;
      $144 = HEAP8[316178 + $c$4$be >> 0] | 0;
      $135 = $144 & 255;
      if (!($134 >>> 0 < 134217728 & $135 >>> 0 < $$116 >>> 0)) {
       $$lcssa108 = $134;
       $$lcssa109 = $144;
       $c$4$be$lcssa = $c$4$be;
       break;
      } else $x$136 = $134;
     }
     $152 = $$lcssa109;
     $154 = 0;
     $156 = $$lcssa108;
     $c$4$lcssa = $c$4$be$lcssa;
    } else {
     $152 = $130;
     $154 = 0;
     $156 = 0;
     $c$4$lcssa = $c$117;
    }
    $149 = _bitshift64Lshr(-1, -1, $128 | 0) | 0;
    $150 = tempRet0;
    if (($152 & 255) >>> 0 >= $$116 >>> 0 | ($154 >>> 0 > $150 >>> 0 | ($154 | 0) == ($150 | 0) & $156 >>> 0 > $149 >>> 0)) {
     $$115 = $$116;
     $292 = $156;
     $293 = $154;
     $c$8 = $c$4$lcssa;
     label = 72;
     break;
    } else {
     $161 = $156;
     $162 = $154;
     $166 = $152;
    }
    while (1) {
     $163 = _bitshift64Shl($161 | 0, $162 | 0, $128 | 0) | 0;
     $164 = tempRet0;
     $167 = $166 & 255 | $163;
     $168 = HEAP32[$3 >> 2] | 0;
     if ($168 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
      HEAP32[$3 >> 2] = $168 + 1;
      $c$5$be = HEAPU8[$168 >> 0] | 0;
     } else $c$5$be = ___shgetc($f) | 0;
     $166 = HEAP8[316178 + $c$5$be >> 0] | 0;
     if (($166 & 255) >>> 0 >= $$116 >>> 0 | ($164 >>> 0 > $150 >>> 0 | ($164 | 0) == ($150 | 0) & $167 >>> 0 > $149 >>> 0)) {
      $$115 = $$116;
      $292 = $167;
      $293 = $164;
      $c$8 = $c$5$be;
      label = 72;
      break L63;
     } else {
      $161 = $167;
      $162 = $164;
     }
    }
   }
   $120 = HEAP8[316178 + $c$117 >> 0] | 0;
   $121 = $120 & 255;
   if ($121 >>> 0 < $$116 >>> 0) {
    $186 = $121;
    $x$254 = 0;
    while (1) {
     $185 = $186 + (Math_imul($x$254, $$116) | 0) | 0;
     $187 = HEAP32[$3 >> 2] | 0;
     if ($187 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
      HEAP32[$3 >> 2] = $187 + 1;
      $c$6$be = HEAPU8[$187 >> 0] | 0;
     } else $c$6$be = ___shgetc($f) | 0;
     $195 = HEAP8[316178 + $c$6$be >> 0] | 0;
     $186 = $195 & 255;
     if (!($185 >>> 0 < 119304647 & $186 >>> 0 < $$116 >>> 0)) {
      $$lcssa110 = $185;
      $$lcssa111 = $195;
      $c$6$be$lcssa = $c$6$be;
      break;
     } else $x$254 = $185;
    }
    $201 = $$lcssa111;
    $294 = $$lcssa110;
    $295 = 0;
    $c$6$lcssa = $c$6$be$lcssa;
   } else {
    $201 = $120;
    $294 = 0;
    $295 = 0;
    $c$6$lcssa = $c$117;
   }
   if (($201 & 255) >>> 0 < $$116 >>> 0) {
    $203 = ___udivdi3(-1, -1, $$116 | 0, 0) | 0;
    $204 = tempRet0;
    $205 = $295;
    $207 = $294;
    $215 = $201;
    $c$742 = $c$6$lcssa;
    while (1) {
     if ($205 >>> 0 > $204 >>> 0 | ($205 | 0) == ($204 | 0) & $207 >>> 0 > $203 >>> 0) {
      $$115 = $$116;
      $292 = $207;
      $293 = $205;
      $c$8 = $c$742;
      label = 72;
      break L63;
     }
     $212 = ___muldi3($207 | 0, $205 | 0, $$116 | 0, 0) | 0;
     $213 = tempRet0;
     $214 = $215 & 255;
     if ($213 >>> 0 > 4294967295 | ($213 | 0) == -1 & $212 >>> 0 > ~$214 >>> 0) {
      $$115 = $$116;
      $292 = $207;
      $293 = $205;
      $c$8 = $c$742;
      label = 72;
      break L63;
     }
     $222 = _i64Add($214 | 0, 0, $212 | 0, $213 | 0) | 0;
     $223 = tempRet0;
     $224 = HEAP32[$3 >> 2] | 0;
     if ($224 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
      HEAP32[$3 >> 2] = $224 + 1;
      $c$7$be = HEAPU8[$224 >> 0] | 0;
     } else $c$7$be = ___shgetc($f) | 0;
     $215 = HEAP8[316178 + $c$7$be >> 0] | 0;
     if (($215 & 255) >>> 0 >= $$116 >>> 0) {
      $$115 = $$116;
      $292 = $222;
      $293 = $223;
      $c$8 = $c$7$be;
      label = 72;
      break;
     } else {
      $205 = $223;
      $207 = $222;
      $c$742 = $c$7$be;
     }
    }
   } else {
    $$115 = $$116;
    $292 = $294;
    $293 = $295;
    $c$8 = $c$6$lcssa;
    label = 72;
   }
  } while (0);
  if ((label | 0) == 72) if ((HEAPU8[316178 + $c$8 >> 0] | 0) >>> 0 < $$115 >>> 0) {
   do {
    $239 = HEAP32[$3 >> 2] | 0;
    if ($239 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
     HEAP32[$3 >> 2] = $239 + 1;
     $c$9$be = HEAPU8[$239 >> 0] | 0;
    } else $c$9$be = ___shgetc($f) | 0;
   } while ((HEAPU8[316178 + $c$9$be >> 0] | 0) >>> 0 < $$115 >>> 0);
   HEAP32[(___errno_location() | 0) >> 2] = 34;
   $259 = $1;
   $261 = $0;
   $neg$1 = ($0 & 1 | 0) == 0 & 0 == 0 ? $neg$0 : 0;
  } else {
   $259 = $293;
   $261 = $292;
   $neg$1 = $neg$0;
  }
  if (HEAP32[$4 >> 2] | 0) HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + -1;
  if (!($259 >>> 0 < $1 >>> 0 | ($259 | 0) == ($1 | 0) & $261 >>> 0 < $0 >>> 0)) {
   if (!(($0 & 1 | 0) != 0 | 0 != 0 | ($neg$1 | 0) != 0)) {
    HEAP32[(___errno_location() | 0) >> 2] = 34;
    $272 = _i64Add($0 | 0, $1 | 0, -1, -1) | 0;
    $286 = tempRet0;
    $287 = $272;
    break;
   }
   if ($259 >>> 0 > $1 >>> 0 | ($259 | 0) == ($1 | 0) & $261 >>> 0 > $0 >>> 0) {
    HEAP32[(___errno_location() | 0) >> 2] = 34;
    $286 = $1;
    $287 = $0;
    break;
   }
  }
  $281 = (($neg$1 | 0) < 0) << 31 >> 31;
  $284 = _i64Subtract($261 ^ $neg$1 | 0, $259 ^ $281 | 0, $neg$1 | 0, $281 | 0) | 0;
  $286 = tempRet0;
  $287 = $284;
 } while (0);
 tempRet0 = $286;
 return $287 | 0;
}

function _dispose_chunk($p, $psize) {
 $p = $p | 0;
 $psize = $psize | 0;
 var $$1 = 0, $$14 = 0, $$2 = 0, $$lcssa = 0, $$pre$phi22Z2D = 0, $$pre$phi24Z2D = 0, $$pre$phiZ2D = 0, $0 = 0, $10 = 0, $100 = 0, $107 = 0, $109 = 0, $11 = 0, $110 = 0, $116 = 0, $124 = 0, $129 = 0, $130 = 0, $133 = 0, $135 = 0, $137 = 0, $15 = 0, $150 = 0, $155 = 0, $157 = 0, $160 = 0, $162 = 0, $165 = 0, $168 = 0, $169 = 0, $170 = 0, $172 = 0, $174 = 0, $175 = 0, $177 = 0, $178 = 0, $18 = 0, $183 = 0, $184 = 0, $193 = 0, $198 = 0, $2 = 0, $20 = 0, $201 = 0, $202 = 0, $208 = 0, $22 = 0, $223 = 0, $226 = 0, $227 = 0, $228 = 0, $232 = 0, $233 = 0, $239 = 0, $244 = 0, $245 = 0, $248 = 0, $250 = 0, $253 = 0, $258 = 0, $264 = 0, $268 = 0, $269 = 0, $287 = 0, $289 = 0, $296 = 0, $297 = 0, $298 = 0, $35 = 0, $40 = 0, $42 = 0, $45 = 0, $47 = 0, $5 = 0, $50 = 0, $53 = 0, $54 = 0, $55 = 0, $57 = 0, $59 = 0, $60 = 0, $62 = 0, $63 = 0, $68 = 0, $69 = 0, $78 = 0, $83 = 0, $86 = 0, $87 = 0, $9 = 0, $93 = 0, $99 = 0, $F17$0 = 0, $I20$0 = 0, $K21$0 = 0, $R$1 = 0, $R$1$lcssa = 0, $R$3 = 0, $R7$1 = 0, $R7$1$lcssa = 0, $R7$3 = 0, $RP$1 = 0, $RP$1$lcssa = 0, $RP9$1 = 0, $RP9$1$lcssa = 0, $T$0 = 0, $T$0$lcssa = 0, $T$0$lcssa30 = 0, label = 0;
 $0 = $p + $psize | 0;
 $2 = HEAP32[$p + 4 >> 2] | 0;
 do if (!($2 & 1)) {
  $5 = HEAP32[$p >> 2] | 0;
  if (!($2 & 3)) return;
  $9 = $p + (0 - $5) | 0;
  $10 = $5 + $psize | 0;
  $11 = HEAP32[79272] | 0;
  if ($9 >>> 0 < $11 >>> 0) _abort();
  if (($9 | 0) == (HEAP32[79273] | 0)) {
   $99 = $0 + 4 | 0;
   $100 = HEAP32[$99 >> 2] | 0;
   if (($100 & 3 | 0) != 3) {
    $$1 = $9;
    $$14 = $10;
    break;
   }
   HEAP32[79270] = $10;
   HEAP32[$99 >> 2] = $100 & -2;
   HEAP32[$9 + 4 >> 2] = $10 | 1;
   HEAP32[$9 + $10 >> 2] = $10;
   return;
  }
  $15 = $5 >>> 3;
  if ($5 >>> 0 < 256) {
   $18 = HEAP32[$9 + 8 >> 2] | 0;
   $20 = HEAP32[$9 + 12 >> 2] | 0;
   $22 = 317112 + ($15 << 1 << 2) | 0;
   if (($18 | 0) != ($22 | 0)) {
    if ($18 >>> 0 < $11 >>> 0) _abort();
    if ((HEAP32[$18 + 12 >> 2] | 0) != ($9 | 0)) _abort();
   }
   if (($20 | 0) == ($18 | 0)) {
    HEAP32[79268] = HEAP32[79268] & ~(1 << $15);
    $$1 = $9;
    $$14 = $10;
    break;
   }
   if (($20 | 0) == ($22 | 0)) $$pre$phi24Z2D = $20 + 8 | 0; else {
    if ($20 >>> 0 < $11 >>> 0) _abort();
    $35 = $20 + 8 | 0;
    if ((HEAP32[$35 >> 2] | 0) == ($9 | 0)) $$pre$phi24Z2D = $35; else _abort();
   }
   HEAP32[$18 + 12 >> 2] = $20;
   HEAP32[$$pre$phi24Z2D >> 2] = $18;
   $$1 = $9;
   $$14 = $10;
   break;
  }
  $40 = HEAP32[$9 + 24 >> 2] | 0;
  $42 = HEAP32[$9 + 12 >> 2] | 0;
  do if (($42 | 0) == ($9 | 0)) {
   $53 = $9 + 16 | 0;
   $54 = $53 + 4 | 0;
   $55 = HEAP32[$54 >> 2] | 0;
   if (!$55) {
    $57 = HEAP32[$53 >> 2] | 0;
    if (!$57) {
     $R$3 = 0;
     break;
    } else {
     $R$1 = $57;
     $RP$1 = $53;
    }
   } else {
    $R$1 = $55;
    $RP$1 = $54;
   }
   while (1) {
    $59 = $R$1 + 20 | 0;
    $60 = HEAP32[$59 >> 2] | 0;
    if ($60 | 0) {
     $R$1 = $60;
     $RP$1 = $59;
     continue;
    }
    $62 = $R$1 + 16 | 0;
    $63 = HEAP32[$62 >> 2] | 0;
    if (!$63) {
     $R$1$lcssa = $R$1;
     $RP$1$lcssa = $RP$1;
     break;
    } else {
     $R$1 = $63;
     $RP$1 = $62;
    }
   }
   if ($RP$1$lcssa >>> 0 < $11 >>> 0) _abort(); else {
    HEAP32[$RP$1$lcssa >> 2] = 0;
    $R$3 = $R$1$lcssa;
    break;
   }
  } else {
   $45 = HEAP32[$9 + 8 >> 2] | 0;
   if ($45 >>> 0 < $11 >>> 0) _abort();
   $47 = $45 + 12 | 0;
   if ((HEAP32[$47 >> 2] | 0) != ($9 | 0)) _abort();
   $50 = $42 + 8 | 0;
   if ((HEAP32[$50 >> 2] | 0) == ($9 | 0)) {
    HEAP32[$47 >> 2] = $42;
    HEAP32[$50 >> 2] = $45;
    $R$3 = $42;
    break;
   } else _abort();
  } while (0);
  if (!$40) {
   $$1 = $9;
   $$14 = $10;
  } else {
   $68 = HEAP32[$9 + 28 >> 2] | 0;
   $69 = 317376 + ($68 << 2) | 0;
   if (($9 | 0) == (HEAP32[$69 >> 2] | 0)) {
    HEAP32[$69 >> 2] = $R$3;
    if (!$R$3) {
     HEAP32[79269] = HEAP32[79269] & ~(1 << $68);
     $$1 = $9;
     $$14 = $10;
     break;
    }
   } else {
    if ($40 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
    $78 = $40 + 16 | 0;
    if ((HEAP32[$78 >> 2] | 0) == ($9 | 0)) HEAP32[$78 >> 2] = $R$3; else HEAP32[$40 + 20 >> 2] = $R$3;
    if (!$R$3) {
     $$1 = $9;
     $$14 = $10;
     break;
    }
   }
   $83 = HEAP32[79272] | 0;
   if ($R$3 >>> 0 < $83 >>> 0) _abort();
   HEAP32[$R$3 + 24 >> 2] = $40;
   $86 = $9 + 16 | 0;
   $87 = HEAP32[$86 >> 2] | 0;
   do if ($87 | 0) if ($87 >>> 0 < $83 >>> 0) _abort(); else {
    HEAP32[$R$3 + 16 >> 2] = $87;
    HEAP32[$87 + 24 >> 2] = $R$3;
    break;
   } while (0);
   $93 = HEAP32[$86 + 4 >> 2] | 0;
   if (!$93) {
    $$1 = $9;
    $$14 = $10;
   } else if ($93 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
    HEAP32[$R$3 + 20 >> 2] = $93;
    HEAP32[$93 + 24 >> 2] = $R$3;
    $$1 = $9;
    $$14 = $10;
    break;
   }
  }
 } else {
  $$1 = $p;
  $$14 = $psize;
 } while (0);
 $107 = HEAP32[79272] | 0;
 if ($0 >>> 0 < $107 >>> 0) _abort();
 $109 = $0 + 4 | 0;
 $110 = HEAP32[$109 >> 2] | 0;
 if (!($110 & 2)) {
  if (($0 | 0) == (HEAP32[79274] | 0)) {
   $116 = (HEAP32[79271] | 0) + $$14 | 0;
   HEAP32[79271] = $116;
   HEAP32[79274] = $$1;
   HEAP32[$$1 + 4 >> 2] = $116 | 1;
   if (($$1 | 0) != (HEAP32[79273] | 0)) return;
   HEAP32[79273] = 0;
   HEAP32[79270] = 0;
   return;
  }
  if (($0 | 0) == (HEAP32[79273] | 0)) {
   $124 = (HEAP32[79270] | 0) + $$14 | 0;
   HEAP32[79270] = $124;
   HEAP32[79273] = $$1;
   HEAP32[$$1 + 4 >> 2] = $124 | 1;
   HEAP32[$$1 + $124 >> 2] = $124;
   return;
  }
  $129 = ($110 & -8) + $$14 | 0;
  $130 = $110 >>> 3;
  do if ($110 >>> 0 < 256) {
   $133 = HEAP32[$0 + 8 >> 2] | 0;
   $135 = HEAP32[$0 + 12 >> 2] | 0;
   $137 = 317112 + ($130 << 1 << 2) | 0;
   if (($133 | 0) != ($137 | 0)) {
    if ($133 >>> 0 < $107 >>> 0) _abort();
    if ((HEAP32[$133 + 12 >> 2] | 0) != ($0 | 0)) _abort();
   }
   if (($135 | 0) == ($133 | 0)) {
    HEAP32[79268] = HEAP32[79268] & ~(1 << $130);
    break;
   }
   if (($135 | 0) == ($137 | 0)) $$pre$phi22Z2D = $135 + 8 | 0; else {
    if ($135 >>> 0 < $107 >>> 0) _abort();
    $150 = $135 + 8 | 0;
    if ((HEAP32[$150 >> 2] | 0) == ($0 | 0)) $$pre$phi22Z2D = $150; else _abort();
   }
   HEAP32[$133 + 12 >> 2] = $135;
   HEAP32[$$pre$phi22Z2D >> 2] = $133;
  } else {
   $155 = HEAP32[$0 + 24 >> 2] | 0;
   $157 = HEAP32[$0 + 12 >> 2] | 0;
   do if (($157 | 0) == ($0 | 0)) {
    $168 = $0 + 16 | 0;
    $169 = $168 + 4 | 0;
    $170 = HEAP32[$169 >> 2] | 0;
    if (!$170) {
     $172 = HEAP32[$168 >> 2] | 0;
     if (!$172) {
      $R7$3 = 0;
      break;
     } else {
      $R7$1 = $172;
      $RP9$1 = $168;
     }
    } else {
     $R7$1 = $170;
     $RP9$1 = $169;
    }
    while (1) {
     $174 = $R7$1 + 20 | 0;
     $175 = HEAP32[$174 >> 2] | 0;
     if ($175 | 0) {
      $R7$1 = $175;
      $RP9$1 = $174;
      continue;
     }
     $177 = $R7$1 + 16 | 0;
     $178 = HEAP32[$177 >> 2] | 0;
     if (!$178) {
      $R7$1$lcssa = $R7$1;
      $RP9$1$lcssa = $RP9$1;
      break;
     } else {
      $R7$1 = $178;
      $RP9$1 = $177;
     }
    }
    if ($RP9$1$lcssa >>> 0 < $107 >>> 0) _abort(); else {
     HEAP32[$RP9$1$lcssa >> 2] = 0;
     $R7$3 = $R7$1$lcssa;
     break;
    }
   } else {
    $160 = HEAP32[$0 + 8 >> 2] | 0;
    if ($160 >>> 0 < $107 >>> 0) _abort();
    $162 = $160 + 12 | 0;
    if ((HEAP32[$162 >> 2] | 0) != ($0 | 0)) _abort();
    $165 = $157 + 8 | 0;
    if ((HEAP32[$165 >> 2] | 0) == ($0 | 0)) {
     HEAP32[$162 >> 2] = $157;
     HEAP32[$165 >> 2] = $160;
     $R7$3 = $157;
     break;
    } else _abort();
   } while (0);
   if ($155 | 0) {
    $183 = HEAP32[$0 + 28 >> 2] | 0;
    $184 = 317376 + ($183 << 2) | 0;
    if (($0 | 0) == (HEAP32[$184 >> 2] | 0)) {
     HEAP32[$184 >> 2] = $R7$3;
     if (!$R7$3) {
      HEAP32[79269] = HEAP32[79269] & ~(1 << $183);
      break;
     }
    } else {
     if ($155 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
     $193 = $155 + 16 | 0;
     if ((HEAP32[$193 >> 2] | 0) == ($0 | 0)) HEAP32[$193 >> 2] = $R7$3; else HEAP32[$155 + 20 >> 2] = $R7$3;
     if (!$R7$3) break;
    }
    $198 = HEAP32[79272] | 0;
    if ($R7$3 >>> 0 < $198 >>> 0) _abort();
    HEAP32[$R7$3 + 24 >> 2] = $155;
    $201 = $0 + 16 | 0;
    $202 = HEAP32[$201 >> 2] | 0;
    do if ($202 | 0) if ($202 >>> 0 < $198 >>> 0) _abort(); else {
     HEAP32[$R7$3 + 16 >> 2] = $202;
     HEAP32[$202 + 24 >> 2] = $R7$3;
     break;
    } while (0);
    $208 = HEAP32[$201 + 4 >> 2] | 0;
    if ($208 | 0) if ($208 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
     HEAP32[$R7$3 + 20 >> 2] = $208;
     HEAP32[$208 + 24 >> 2] = $R7$3;
     break;
    }
   }
  } while (0);
  HEAP32[$$1 + 4 >> 2] = $129 | 1;
  HEAP32[$$1 + $129 >> 2] = $129;
  if (($$1 | 0) == (HEAP32[79273] | 0)) {
   HEAP32[79270] = $129;
   return;
  } else $$2 = $129;
 } else {
  HEAP32[$109 >> 2] = $110 & -2;
  HEAP32[$$1 + 4 >> 2] = $$14 | 1;
  HEAP32[$$1 + $$14 >> 2] = $$14;
  $$2 = $$14;
 }
 $223 = $$2 >>> 3;
 if ($$2 >>> 0 < 256) {
  $226 = 317112 + ($223 << 1 << 2) | 0;
  $227 = HEAP32[79268] | 0;
  $228 = 1 << $223;
  if (!($227 & $228)) {
   HEAP32[79268] = $227 | $228;
   $$pre$phiZ2D = $226 + 8 | 0;
   $F17$0 = $226;
  } else {
   $232 = $226 + 8 | 0;
   $233 = HEAP32[$232 >> 2] | 0;
   if ($233 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
    $$pre$phiZ2D = $232;
    $F17$0 = $233;
   }
  }
  HEAP32[$$pre$phiZ2D >> 2] = $$1;
  HEAP32[$F17$0 + 12 >> 2] = $$1;
  HEAP32[$$1 + 8 >> 2] = $F17$0;
  HEAP32[$$1 + 12 >> 2] = $226;
  return;
 }
 $239 = $$2 >>> 8;
 if (!$239) $I20$0 = 0; else if ($$2 >>> 0 > 16777215) $I20$0 = 31; else {
  $244 = ($239 + 1048320 | 0) >>> 16 & 8;
  $245 = $239 << $244;
  $248 = ($245 + 520192 | 0) >>> 16 & 4;
  $250 = $245 << $248;
  $253 = ($250 + 245760 | 0) >>> 16 & 2;
  $258 = 14 - ($248 | $244 | $253) + ($250 << $253 >>> 15) | 0;
  $I20$0 = $$2 >>> ($258 + 7 | 0) & 1 | $258 << 1;
 }
 $264 = 317376 + ($I20$0 << 2) | 0;
 HEAP32[$$1 + 28 >> 2] = $I20$0;
 HEAP32[$$1 + 20 >> 2] = 0;
 HEAP32[$$1 + 16 >> 2] = 0;
 $268 = HEAP32[79269] | 0;
 $269 = 1 << $I20$0;
 if (!($268 & $269)) {
  HEAP32[79269] = $268 | $269;
  HEAP32[$264 >> 2] = $$1;
  HEAP32[$$1 + 24 >> 2] = $264;
  HEAP32[$$1 + 12 >> 2] = $$1;
  HEAP32[$$1 + 8 >> 2] = $$1;
  return;
 }
 $K21$0 = $$2 << (($I20$0 | 0) == 31 ? 0 : 25 - ($I20$0 >>> 1) | 0);
 $T$0 = HEAP32[$264 >> 2] | 0;
 while (1) {
  if ((HEAP32[$T$0 + 4 >> 2] & -8 | 0) == ($$2 | 0)) {
   $T$0$lcssa = $T$0;
   label = 127;
   break;
  }
  $287 = $T$0 + 16 + ($K21$0 >>> 31 << 2) | 0;
  $289 = HEAP32[$287 >> 2] | 0;
  if (!$289) {
   $$lcssa = $287;
   $T$0$lcssa30 = $T$0;
   label = 124;
   break;
  } else {
   $K21$0 = $K21$0 << 1;
   $T$0 = $289;
  }
 }
 if ((label | 0) == 124) {
  if ($$lcssa >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
  HEAP32[$$lcssa >> 2] = $$1;
  HEAP32[$$1 + 24 >> 2] = $T$0$lcssa30;
  HEAP32[$$1 + 12 >> 2] = $$1;
  HEAP32[$$1 + 8 >> 2] = $$1;
  return;
 } else if ((label | 0) == 127) {
  $296 = $T$0$lcssa + 8 | 0;
  $297 = HEAP32[$296 >> 2] | 0;
  $298 = HEAP32[79272] | 0;
  if (!($297 >>> 0 >= $298 >>> 0 & $T$0$lcssa >>> 0 >= $298 >>> 0)) _abort();
  HEAP32[$297 + 12 >> 2] = $$1;
  HEAP32[$296 >> 2] = $$1;
  HEAP32[$$1 + 8 >> 2] = $297;
  HEAP32[$$1 + 12 >> 2] = $T$0$lcssa;
  HEAP32[$$1 + 24 >> 2] = 0;
  return;
 }
}

function _PPrintAttribute($doc, $indent, $node, $attr) {
 $doc = $doc | 0;
 $indent = $indent | 0;
 $node = $node | 0;
 $attr = $attr | 0;
 var $$ = 0, $$0 = 0, $$0$i = 0, $$idx$i = 0, $$idx$val$i = 0, $$idx$val$i18 = 0, $$pre = 0, $$pre$i$i11 = 0, $$pre$phi$i$iZ2D = 0, $0 = 0, $10 = 0, $104 = 0, $108 = 0, $111 = 0, $113 = 0, $12 = 0, $121 = 0, $123 = 0, $125 = 0, $126 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $137 = 0, $143 = 0, $145 = 0, $151 = 0, $153 = 0, $157 = 0, $158 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $170 = 0, $176 = 0, $178 = 0, $18 = 0, $184 = 0, $186 = 0, $193 = 0, $199 = 0, $2 = 0, $201 = 0, $202 = 0, $203 = 0, $207 = 0, $212 = 0, $219 = 0, $25 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $37 = 0, $4 = 0, $46 = 0, $49 = 0, $54 = 0, $57 = 0, $6 = 0, $62 = 0, $65 = 0, $72 = 0, $74 = 0, $8 = 0, $82 = 0, $87 = 0, $91 = 0, $97 = 0, $98 = 0, $99 = 0, $buflen$0$i$i$i = 0, $buflen$0$i$i$i$lcssa = 0, $buflen$0$i$i$i14 = 0, $buflen$0$i$i$i14$lcssa = 0, $buflen$0$i$i$i14$us = 0, $buflen$0$i$i$i14$us$lcssa = 0, $c = 0, $name$023 = 0, $name$023$us = 0, $name$1 = 0, $name$1$us = 0, $wrappable$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 $0 = $doc + 6724 | 0;
 $2 = HEAP32[$doc + 172 >> 2] | 0;
 $4 = HEAP32[$doc + 176 >> 2] | 0;
 $6 = HEAP32[$doc + 256 >> 2] | 0;
 $8 = HEAP32[$doc + 192 >> 2] | 0;
 $10 = HEAP32[$doc + 284 >> 2] | 0;
 $12 = HEAP32[$doc + 76 >> 2] | 0;
 $13 = $node + 32 | 0;
 do if (!(HEAP32[$13 >> 2] | 0)) $$0$i = $12; else {
  if (_prvTidynodeHasCM($node, 16) | 0) {
   $18 = HEAP32[$node >> 2] | 0;
   if (_ShouldIndent(HEAP32[$doc + 152 >> 2] | 0, ($18 | 0) == 0 ? $node : $18) | 0) {
    $25 = _prvTidyFindContainer($node) | 0;
    if (!$25) {
     $$0$i = $12;
     break;
    }
    $$0$i = (_prvTidytmbstrlen(HEAP32[$25 + 32 >> 2] | 0) | 0) + 2 | 0;
    break;
   }
  }
  $$0$i = (_prvTidytmbstrlen(HEAP32[$13 >> 2] | 0) | 0) + 2 | 0;
 } while (0);
 $31 = (HEAP32[$node + 20 >> 2] | 0) == ($attr | 0);
 $32 = $attr + 20 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = ($10 | 0) != 0;
 $$ = $34 ? $$0$i : 0;
 if ($34) if ($31 | (_prvTidynodeIsElement($node) | 0) == 0) $$0 = $indent; else {
  $37 = $$ + $indent | 0;
  if (HEAP32[$doc + 6736 >> 2] | 0) {
   _PFlushLineImpl($doc);
   if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
    _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
    $46 = $doc + 6744 | 0;
    HEAP32[$46 >> 2] = (HEAP32[$46 >> 2] | 0) + 1;
   }
  }
  $49 = $doc + 6752 | 0;
  if ((HEAP32[$49 >> 2] | 0) == ($37 | 0)) $$0 = $37; else {
   HEAP32[$49 >> 2] = $37;
   $$0 = $37;
  }
 } else $$0 = $indent;
 $$idx$i = $doc + 6752 | 0;
 $$idx$val$i = HEAP32[$$idx$i >> 2] | 0;
 $54 = $doc + 6736 | 0;
 $57 = $doc + 80 | 0;
 if (((($$idx$val$i | 0) < 0 ? 0 : $$idx$val$i) + (HEAP32[$54 >> 2] | 0) | 0) >>> 0 >= (HEAP32[$57 >> 2] | 0) >>> 0) {
  _WrapLine($doc);
  if ((HEAP32[$$idx$i >> 2] | 0) < 0) HEAP32[$$idx$i >> 2] = $$0;
 }
 $62 = ($2 | 0) == 0;
 L22 : do if (!($4 | $2)) {
  $65 = $attr + 4 | 0;
  if (!(HEAP32[$65 >> 2] | 0)) $wrappable$0 = 0; else {
   if (_prvTidyIsScript($doc, $33) | 0) {
    $wrappable$0 = HEAP32[$doc + 260 >> 2] | 0;
    break;
   }
   $72 = HEAP32[$65 >> 2] | 0;
   if (!$72) {
    if (!$6) {
     $wrappable$0 = 0;
     break;
    }
   } else {
    $74 = HEAP32[$72 >> 2] | 0;
    switch ($74 | 0) {
    case 10:
    case 154:
    case 36:
     {
      $wrappable$0 = 0;
      break L22;
      break;
     }
    default:
     {}
    }
    if (!(($6 | 0) != 0 & ($74 | 0) != 148)) {
     $wrappable$0 = 0;
     break;
    }
   }
   $wrappable$0 = 1;
  }
 } else $wrappable$0 = 0; while (0);
 $$pre = HEAP32[$54 >> 2] | 0;
 do if ($31) label = 37; else {
  if (($$pre + $$0 | 0) >>> 0 < (HEAP32[$57 >> 2] | 0) >>> 0) {
   if ((HEAP32[$$idx$i >> 2] | 0) < 0) HEAP32[$$idx$i >> 2] = $$0;
   HEAP32[$doc + 6740 >> 2] = $$pre;
   label = 37;
   break;
  }
  $82 = $doc + 6748 | 0;
  if (!(HEAP32[$82 >> 2] | 0)) {
   HEAP32[$doc + 6764 >> 2] = $$0;
   HEAP32[$82 >> 2] = 1;
  }
  $87 = $$0 + $$ | 0;
  if ($$pre | 0) _PFlushLineImpl($doc);
  _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
  $91 = $doc + 6744 | 0;
  HEAP32[$91 >> 2] = (HEAP32[$91 >> 2] | 0) + 1;
  if ((HEAP32[$$idx$i >> 2] | 0) != ($87 | 0)) HEAP32[$$idx$i >> 2] = $87;
 } while (0);
 if ((label | 0) == 37) if ($$pre | 0) {
  $97 = $$pre + 1 | 0;
  $98 = $doc + 6732 | 0;
  $99 = HEAP32[$98 >> 2] | 0;
  if ($97 >>> 0 < $99 >>> 0) $$pre$phi$i$iZ2D = $doc + 6728 | 0; else {
   $buflen$0$i$i$i = ($99 | 0) == 0 ? 256 : $99;
   while (1) if ($buflen$0$i$i$i >>> 0 > $97 >>> 0) {
    $buflen$0$i$i$i$lcssa = $buflen$0$i$i$i;
    break;
   } else $buflen$0$i$i$i = $buflen$0$i$i$i << 1;
   $104 = HEAP32[$0 >> 2] | 0;
   $108 = $doc + 6728 | 0;
   $111 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$104 >> 2] | 0) + 4 >> 2] & 15]($104, HEAP32[$108 >> 2] | 0, $buflen$0$i$i$i$lcssa << 2) | 0;
   if (!$111) $$pre$phi$i$iZ2D = $108; else {
    $113 = HEAP32[$98 >> 2] | 0;
    _memset($111 + ($113 << 2) | 0, 0, $buflen$0$i$i$i$lcssa - $113 << 2 | 0) | 0;
    HEAP32[$98 >> 2] = $buflen$0$i$i$i$lcssa;
    HEAP32[$108 >> 2] = $111;
    $$pre$phi$i$iZ2D = $108;
   }
  }
  HEAP32[(HEAP32[$$pre$phi$i$iZ2D >> 2] | 0) + ($$pre << 2) >> 2] = 32;
  HEAP32[$54 >> 2] = (HEAP32[$54 >> 2] | 0) + 1;
 }
 $121 = HEAP8[$33 >> 0] | 0;
 L61 : do if (!($121 << 24 >> 24)) $193 = HEAP32[$54 >> 2] | 0; else {
  $123 = $doc + 6732 | 0;
  $$pre$i$i11 = $doc + 6728 | 0;
  if (!$8) {
   $126 = $121;
   $name$023$us = $33;
   while (1) {
    $125 = $126 & 255;
    HEAP32[$c >> 2] = $125;
    if ($126 << 24 >> 24 < 0) {
     $129 = $name$023$us + (_prvTidyGetUTF8($name$023$us, $c) | 0) | 0;
     $151 = HEAP32[$c >> 2] | 0;
     $name$1$us = $129;
    } else {
     $151 = $125;
     $name$1$us = $name$023$us;
    }
    $130 = HEAP32[$54 >> 2] | 0;
    $131 = $130 + 1 | 0;
    $132 = HEAP32[$123 >> 2] | 0;
    if ($131 >>> 0 >= $132 >>> 0) {
     $buflen$0$i$i$i14$us = ($132 | 0) == 0 ? 256 : $132;
     while (1) if ($buflen$0$i$i$i14$us >>> 0 > $131 >>> 0) {
      $buflen$0$i$i$i14$us$lcssa = $buflen$0$i$i$i14$us;
      break;
     } else $buflen$0$i$i$i14$us = $buflen$0$i$i$i14$us << 1;
     $137 = HEAP32[$0 >> 2] | 0;
     $143 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$137 >> 2] | 0) + 4 >> 2] & 15]($137, HEAP32[$$pre$i$i11 >> 2] | 0, $buflen$0$i$i$i14$us$lcssa << 2) | 0;
     if ($143 | 0) {
      $145 = HEAP32[$123 >> 2] | 0;
      _memset($143 + ($145 << 2) | 0, 0, $buflen$0$i$i$i14$us$lcssa - $145 << 2 | 0) | 0;
      HEAP32[$123 >> 2] = $buflen$0$i$i$i14$us$lcssa;
      HEAP32[$$pre$i$i11 >> 2] = $143;
     }
    }
    HEAP32[(HEAP32[$$pre$i$i11 >> 2] | 0) + ($130 << 2) >> 2] = $151;
    $153 = (HEAP32[$54 >> 2] | 0) + 1 | 0;
    HEAP32[$54 >> 2] = $153;
    $name$023$us = $name$1$us + 1 | 0;
    $126 = HEAP8[$name$023$us >> 0] | 0;
    if (!($126 << 24 >> 24)) {
     $193 = $153;
     break L61;
    }
   }
  } else {
   $158 = $121;
   $name$023 = $33;
  }
  do {
   $157 = $158 & 255;
   HEAP32[$c >> 2] = $157;
   if ($158 << 24 >> 24 < 0) {
    $161 = $name$023 + (_prvTidyGetUTF8($name$023, $c) | 0) | 0;
    $184 = HEAP32[$c >> 2] | 0;
    $name$1 = $161;
   } else {
    $162 = _prvTidyToUpper($157) | 0;
    HEAP32[$c >> 2] = $162;
    $184 = $162;
    $name$1 = $name$023;
   }
   $163 = HEAP32[$54 >> 2] | 0;
   $164 = $163 + 1 | 0;
   $165 = HEAP32[$123 >> 2] | 0;
   if ($164 >>> 0 >= $165 >>> 0) {
    $buflen$0$i$i$i14 = ($165 | 0) == 0 ? 256 : $165;
    while (1) if ($buflen$0$i$i$i14 >>> 0 > $164 >>> 0) {
     $buflen$0$i$i$i14$lcssa = $buflen$0$i$i$i14;
     break;
    } else $buflen$0$i$i$i14 = $buflen$0$i$i$i14 << 1;
    $170 = HEAP32[$0 >> 2] | 0;
    $176 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$170 >> 2] | 0) + 4 >> 2] & 15]($170, HEAP32[$$pre$i$i11 >> 2] | 0, $buflen$0$i$i$i14$lcssa << 2) | 0;
    if ($176 | 0) {
     $178 = HEAP32[$123 >> 2] | 0;
     _memset($176 + ($178 << 2) | 0, 0, $buflen$0$i$i$i14$lcssa - $178 << 2 | 0) | 0;
     HEAP32[$123 >> 2] = $buflen$0$i$i$i14$lcssa;
     HEAP32[$$pre$i$i11 >> 2] = $176;
    }
   }
   HEAP32[(HEAP32[$$pre$i$i11 >> 2] | 0) + ($163 << 2) >> 2] = $184;
   $186 = (HEAP32[$54 >> 2] | 0) + 1 | 0;
   HEAP32[$54 >> 2] = $186;
   $name$023 = $name$1 + 1 | 0;
   $158 = HEAP8[$name$023 >> 0] | 0;
  } while ($158 << 24 >> 24 != 0);
  $193 = $186;
 } while (0);
 $$idx$val$i18 = HEAP32[$$idx$i >> 2] | 0;
 if (((($$idx$val$i18 | 0) < 0 ? 0 : $$idx$val$i18) + $193 | 0) >>> 0 >= (HEAP32[$57 >> 2] | 0) >>> 0) {
  _WrapLine($doc);
  if ((HEAP32[$$idx$i >> 2] | 0) < 0) HEAP32[$$idx$i >> 2] = $$0;
 }
 $199 = HEAP32[$attr + 24 >> 2] | 0;
 if ($199 | 0) {
  _PPrintAttrValue($doc, $$0, $199, HEAP32[$attr + 16 >> 2] | 0, $wrappable$0, 0);
  STACKTOP = sp;
  return;
 }
 $201 = _prvTidyIsBoolAttribute($attr) | 0;
 $202 = _prvTidyattrIsEvent($attr) | 0;
 $203 = ($201 | 0) == 0;
 if (!$62) {
  if ($203) $207 = 317568; else $207 = HEAP32[$32 >> 2] | 0;
  _PPrintAttrValue($doc, $$0, $207, HEAP32[$attr + 16 >> 2] | 0, 0, $202);
  STACKTOP = sp;
  return;
 }
 if ($203) if (!(_prvTidyIsNewNode($node) | 0)) {
  _PPrintAttrValue($doc, $$0, 317568, HEAP32[$attr + 16 >> 2] | 0, 1, $202);
  STACKTOP = sp;
  return;
 }
 $212 = HEAP32[$54 >> 2] | 0;
 if (($212 + $$0 | 0) >>> 0 < (HEAP32[$57 >> 2] | 0) >>> 0) {
  if ((HEAP32[$$idx$i >> 2] | 0) < 0) HEAP32[$$idx$i >> 2] = $$0;
  HEAP32[$doc + 6740 >> 2] = $212;
  STACKTOP = sp;
  return;
 } else {
  $219 = $doc + 6748 | 0;
  if (HEAP32[$219 >> 2] | 0) {
   STACKTOP = sp;
   return;
  }
  HEAP32[$doc + 6764 >> 2] = $$0;
  HEAP32[$219 >> 2] = 1;
  STACKTOP = sp;
  return;
 }
}

function _prvTidyParseDocument($doc) {
 $doc = $doc | 0;
 var $$lcssa10 = 0, $$lcssa12 = 0, $$lcssa94 = 0, $0 = 0, $103 = 0, $107 = 0, $108 = 0, $109 = 0, $118 = 0, $121 = 0, $123 = 0, $126 = 0, $130 = 0, $132 = 0, $147 = 0, $148 = 0, $150 = 0, $152 = 0, $153 = 0, $156 = 0, $159 = 0, $160 = 0, $167 = 0, $169 = 0, $170 = 0, $175 = 0, $177 = 0, $179 = 0, $181 = 0, $184 = 0, $188 = 0, $199 = 0, $2 = 0, $24 = 0, $25 = 0, $3 = 0, $43 = 0, $48 = 0, $5 = 0, $50 = 0, $51 = 0, $55 = 0, $58 = 0, $6 = 0, $63 = 0, $67 = 0, $69 = 0, $71 = 0, $79 = 0, $83 = 0, $93 = 0, $94 = 0, $95 = 0, $doctype$0$ph16 = 0, $html$0 = 0, $node$0$be$i = 0, $node$08$i = 0, $node$1$lcssa$i = 0, $node$15$i = 0, label = 0, $node$15$i$looptemp = 0;
 $0 = _prvTidyGetToken($doc, 0) | 0;
 L1 : do if ($0 | 0) {
  $2 = $doc + 12 | 0;
  $3 = $doc + 16 | 0;
  $199 = $0;
  $doctype$0$ph16 = 0;
  L3 : while (1) {
   if (!$doctype$0$ph16) $6 = $199; else {
    $25 = $199;
    label = 15;
    break;
   }
   L5 : while (1) {
    $5 = $6 + 44 | 0;
    do if ((HEAP32[$5 >> 2] | 0) == 13) {
     if (_prvTidyFindXmlDecl($doc) | 0) if (HEAP32[$2 >> 2] | 0) {
      _prvTidyReportError($doc, $doc, $6, 208);
      _prvTidyFreeNode($doc, $6);
      break;
     }
     if ((HEAP32[$6 + 48 >> 2] | 0) == 1) if ((HEAP32[$6 + 52 >> 2] | 0) == 1) {
      label = 11;
      break;
     }
     _prvTidyReportError($doc, $doc, $6, 245);
     label = 11;
    } else label = 11; while (0);
    if ((label | 0) == 11) {
     label = 0;
     if (!(_InsertMisc($doc, $6) | 0)) {
      switch (HEAP32[$5 >> 2] | 0) {
      case 5:
       {
        $$lcssa10 = $6;
        $$lcssa12 = $5;
        label = 31;
        break L3;
        break;
       }
      case 1:
       {
        $$lcssa94 = $6;
        break L5;
        break;
       }
      case 6:
       break;
      default:
       {
        label = 41;
        break L3;
       }
      }
      _prvTidyReportError($doc, $doc, $6, 208);
      _prvTidyFreeNode($doc, $6);
     }
    }
    $6 = _prvTidyGetToken($doc, 0) | 0;
    if (!$6) break L1;
   }
   HEAP32[$$lcssa94 >> 2] = $doc;
   $43 = HEAP32[$3 >> 2] | 0;
   HEAP32[$$lcssa94 + 4 >> 2] = $43;
   if (!$43) HEAP32[$2 >> 2] = $$lcssa94; else HEAP32[$43 + 8 >> 2] = $$lcssa94;
   HEAP32[$3 >> 2] = $$lcssa94;
   $48 = _prvTidyGetToken($doc, 0) | 0;
   if (!$48) break L1; else {
    $199 = $48;
    $doctype$0$ph16 = $$lcssa94;
   }
  }
  L26 : do if ((label | 0) == 15) while (1) {
   label = 0;
   $24 = $25 + 44 | 0;
   do if ((HEAP32[$24 >> 2] | 0) == 13) {
    if (_prvTidyFindXmlDecl($doc) | 0) if (HEAP32[$2 >> 2] | 0) {
     _prvTidyReportError($doc, $doc, $25, 208);
     _prvTidyFreeNode($doc, $25);
     break;
    }
    if ((HEAP32[$25 + 48 >> 2] | 0) == 1) if ((HEAP32[$25 + 52 >> 2] | 0) == 1) {
     label = 23;
     break;
    }
    _prvTidyReportError($doc, $doc, $25, 245);
    label = 23;
   } else label = 23; while (0);
   L38 : do if ((label | 0) == 23) {
    label = 0;
    if (!(_InsertMisc($doc, $25) | 0)) switch (HEAP32[$24 >> 2] | 0) {
    case 5:
     {
      $$lcssa10 = $25;
      $$lcssa12 = $24;
      label = 31;
      break L26;
      break;
     }
    case 1:
     {
      _prvTidyReportError($doc, $doc, $25, 208);
      _prvTidyFreeNode($doc, $25);
      break L38;
      break;
     }
    case 6:
     {
      _prvTidyReportError($doc, $doc, $25, 208);
      _prvTidyFreeNode($doc, $25);
      break L38;
      break;
     }
    default:
     {
      label = 41;
      break L26;
     }
    }
   } while (0);
   $25 = _prvTidyGetToken($doc, 0) | 0;
   if (!$25) break L1; else label = 15;
  } while (0);
  if ((label | 0) == 31) {
   $50 = $$lcssa10 + 28 | 0;
   $51 = HEAP32[$50 >> 2] | 0;
   if ($51 | 0) if ((HEAP32[$51 >> 2] | 0) == 48) {
    $55 = _prvTidyAttrGetById($$lcssa10, 163) | 0;
    if ($55 | 0) {
     $58 = HEAP32[$55 + 24 >> 2] | 0;
     if ($58 | 0) if (!(_prvTidytmbstrcasecmp($58, 311626) | 0)) {
      $63 = HEAP32[$doc + 180 >> 2] | 0;
      HEAP32[(HEAP32[$doc + 68 >> 2] | 0) + 28 >> 2] = 1;
      $67 = ($63 | 0) != 0;
      $69 = $67 & 1 ^ 1;
      _prvTidySetOptionBool($doc, 26, $69) | 0;
      _prvTidySetOptionBool($doc, 25, $69) | 0;
      if (!$67) {
       _prvTidySetOptionBool($doc, 29, 0) | 0;
       _prvTidySetOptionBool($doc, 30, 0) | 0;
      }
     }
    }
   }
   if ((HEAP32[$$lcssa12 >> 2] | 0) == 5) {
    $71 = HEAP32[$50 >> 2] | 0;
    if (!$71) label = 41; else if ((HEAP32[$71 >> 2] | 0) == 48) $html$0 = $$lcssa10; else label = 41;
   } else label = 41;
  }
  if ((label | 0) == 41) {
   _prvTidyUngetToken($doc);
   $html$0 = _prvTidyInferredTag($doc, 48) | 0;
  }
  L60 : do if (!(_prvTidyFindDocType($doc) | 0)) {
   $79 = HEAP32[$doc + 104 >> 2] | 0;
   if (($79 | 0) != 1) {
    if ((HEAP32[$doc + 328 >> 2] | 0) != 1) _prvTidyReportError($doc, 0, 0, 244);
    switch ($79 | 0) {
    case 0:
    case 2:
     {
      break L60;
      break;
     }
    default:
     {}
    }
   }
   _prvTidyAdjustTags($doc);
  } while (0);
  HEAP32[$html$0 >> 2] = $doc;
  $83 = HEAP32[$3 >> 2] | 0;
  HEAP32[$html$0 + 4 >> 2] = $83;
  if (!$83) HEAP32[$2 >> 2] = $html$0; else HEAP32[$83 + 8 >> 2] = $html$0;
  HEAP32[$3 >> 2] = $html$0;
  _prvTidyParseHTML($doc, $html$0, 0);
 } while (0);
 if (HEAP32[$doc + 408 >> 2] | 0) _prvTidyAccessibilityChecks($doc);
 if (!(_prvTidyFindHTML($doc) | 0)) {
  $93 = _prvTidyInferredTag($doc, 48) | 0;
  HEAP32[$93 >> 2] = $doc;
  $94 = $doc + 16 | 0;
  $95 = HEAP32[$94 >> 2] | 0;
  HEAP32[$93 + 4 >> 2] = $95;
  if (!$95) HEAP32[$doc + 12 >> 2] = $93; else HEAP32[$95 + 8 >> 2] = $93;
  HEAP32[$94 >> 2] = $93;
  _prvTidyParseHTML($doc, $93, 0);
 }
 if (!(_prvTidyFindTITLE($doc) | 0)) {
  $103 = _prvTidyFindHEAD($doc) | 0;
  if ((HEAP32[$doc + 328 >> 2] | 0) != 1) _prvTidyReportError($doc, $103, 0, 217);
  $107 = _prvTidyInferredTag($doc, 114) | 0;
  HEAP32[$107 >> 2] = $103;
  $108 = $103 + 16 | 0;
  $109 = HEAP32[$108 >> 2] | 0;
  HEAP32[$107 + 4 >> 2] = $109;
  if (!$109) HEAP32[$103 + 12 >> 2] = $107; else HEAP32[$109 + 8 >> 2] = $107;
  HEAP32[$108 >> 2] = $107;
 }
 _AttributeChecks($doc, $doc);
 _ReplaceObsoleteElements($doc, $doc);
 _prvTidyDropEmptyElements($doc, $doc) | 0;
 _CleanSpaces($doc, $doc);
 if (HEAP32[$doc + 296 >> 2] | 0) {
  $118 = _prvTidyFindBody($doc) | 0;
  if ($118 | 0) {
   $121 = HEAP32[$118 + 12 >> 2] | 0;
   if ($121 | 0) {
    $123 = $doc + 68 | 0;
    $node$08$i = $121;
    while (1) {
     if (!(_prvTidynodeIsText($node$08$i) | 0)) label = 75; else {
      $126 = HEAP32[$123 >> 2] | 0;
      if (!(_prvTidynodeIsText($node$08$i) | 0)) label = 78; else {
       $130 = HEAP32[$node$08$i + 40 >> 2] | 0;
       $132 = HEAP32[$node$08$i + 36 >> 2] | 0;
       if (($130 | 0) == ($132 | 0)) label = 75; else if (($130 | 0) == ($132 + 1 | 0)) if ((HEAP8[(HEAP32[$126 + 84 >> 2] | 0) + $132 >> 0] | 0) == 32) label = 75; else label = 78; else label = 78;
      }
     }
     do if ((label | 0) == 75) {
      label = 0;
      if (_prvTidynodeIsElement($node$08$i) | 0) if (_prvTidynodeHasCM($node$08$i, 16) | 0) if (!(_prvTidynodeHasCM($node$08$i, 8) | 0)) {
       label = 78;
       break;
      }
      $node$0$be$i = HEAP32[$node$08$i + 8 >> 2] | 0;
     } while (0);
     if ((label | 0) == 78) {
      label = 0;
      $147 = _prvTidyInferredTag($doc, 80) | 0;
      $148 = HEAP32[$node$08$i >> 2] | 0;
      HEAP32[$147 >> 2] = $148;
      HEAP32[$147 + 8 >> 2] = $node$08$i;
      $150 = $node$08$i + 4 | 0;
      $152 = $147 + 4 | 0;
      HEAP32[$152 >> 2] = HEAP32[$150 >> 2];
      HEAP32[$150 >> 2] = $147;
      $153 = HEAP32[$152 >> 2] | 0;
      if ($153 | 0) HEAP32[$153 + 8 >> 2] = $147;
      $156 = $148 + 12 | 0;
      if ((HEAP32[$156 >> 2] | 0) == ($node$08$i | 0)) HEAP32[$156 >> 2] = $147;
      $159 = $147 + 16 | 0;
      $160 = $147 + 12 | 0;
      $node$15$i = $node$08$i;
      while (1) {
       if (_prvTidynodeIsElement($node$15$i) | 0) {
        if (!(_prvTidynodeHasCM($node$15$i, 16) | 0)) {
         $node$1$lcssa$i = $node$15$i;
         break;
        }
        if (_prvTidynodeHasCM($node$15$i, 8) | 0) {
         $node$1$lcssa$i = $node$15$i;
         break;
        }
       }
       $167 = $node$15$i + 8 | 0;
       $node$15$i$looptemp = $node$15$i;
       $node$15$i = HEAP32[$167 >> 2] | 0;
       $169 = $node$15$i$looptemp + 4 | 0;
       $170 = HEAP32[$169 >> 2] | 0;
       if (!$170) $175 = $node$15$i; else {
        HEAP32[$170 + 8 >> 2] = $node$15$i;
        $175 = HEAP32[$167 >> 2] | 0;
       }
       $177 = $175;
       if ($175 | 0) HEAP32[$175 + 4 >> 2] = $170;
       $179 = HEAP32[$node$15$i$looptemp >> 2] | 0;
       do if ($179 | 0) {
        $181 = $179 + 12 | 0;
        if ((HEAP32[$181 >> 2] | 0) == ($node$15$i$looptemp | 0)) HEAP32[$181 >> 2] = $177;
        $184 = $179 + 16 | 0;
        if ((HEAP32[$184 >> 2] | 0) != ($node$15$i$looptemp | 0)) break;
        HEAP32[$184 >> 2] = HEAP32[$169 >> 2];
       } while (0);
       HEAP32[$167 >> 2] = 0;
       HEAP32[$node$15$i$looptemp >> 2] = $147;
       $188 = HEAP32[$159 >> 2] | 0;
       HEAP32[$169 >> 2] = $188;
       if (!$188) HEAP32[$160 >> 2] = $node$15$i$looptemp; else HEAP32[$188 + 8 >> 2] = $node$15$i$looptemp;
       HEAP32[$159 >> 2] = $node$15$i$looptemp;
       if (!$node$15$i) {
        $node$1$lcssa$i = 0;
        break;
       }
      }
      _TrimSpaces($doc, $147);
      $node$0$be$i = $node$1$lcssa$i;
     }
     if (!$node$0$be$i) break; else $node$08$i = $node$0$be$i;
    }
   }
  }
 }
 if (!(HEAP32[$doc + 300 >> 2] | 0)) return;
 _EncloseBlockText($doc, $doc);
 return;
}

function _prvTidyParseRow($doc, $row, $mode) {
 $doc = $doc | 0;
 $row = $row | 0;
 $mode = $mode | 0;
 var $$pr34 = 0, $0 = 0, $1 = 0, $10 = 0, $101 = 0, $103 = 0, $104 = 0, $107 = 0, $11 = 0, $111 = 0, $113 = 0, $115 = 0, $116 = 0, $119 = 0, $12 = 0, $122 = 0, $123 = 0, $125 = 0, $126 = 0, $129 = 0, $13 = 0, $14 = 0, $140 = 0, $144 = 0, $149 = 0, $15 = 0, $151 = 0, $154 = 0, $159 = 0, $16 = 0, $160 = 0, $162 = 0, $17 = 0, $173 = 0, $18 = 0, $2 = 0, $22 = 0, $24 = 0, $28 = 0, $29 = 0, $36 = 0, $37 = 0, $43 = 0, $44 = 0, $45 = 0, $51 = 0, $56 = 0, $57 = 0, $62 = 0, $63 = 0, $64 = 0, $66 = 0, $70 = 0, $75 = 0, $8 = 0, $85 = 0, $95 = 0, $99 = 0, $node$010 = 0, $node$011 = 0, $parent$02$i = 0, $parent$03$i = 0, $table$03$i = 0, $table$04$i = 0, $table$04$i$lcssa = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $row + 28 | 0;
 if (HEAP32[(HEAP32[$2 >> 2] | 0) + 16 >> 2] & 1 | 0) return;
 $8 = _prvTidyGetToken($doc, 0) | 0;
 if (!$8) return;
 $10 = $doc + 6848 | 0;
 $11 = $1 + 24 | 0;
 $12 = $1 + 20 | 0;
 $13 = $row + 16 | 0;
 $14 = $row + 12 | 0;
 $15 = $1 + 112 | 0;
 $16 = $1 + 116 | 0;
 $18 = $8;
 L7 : while (1) {
  $17 = $18 + 28 | 0;
  $22 = $18 + 44 | 0;
  $24 = (HEAP32[$22 >> 2] | 0) == 6;
  if ((HEAP32[$17 >> 2] | 0) == (HEAP32[$2 >> 2] | 0)) {
   label = 5;
   break;
  }
  L10 : do if ($24) {
   $43 = (_prvTidynodeHasCM($18, 130) | 0) == 0;
   $44 = HEAP32[$17 >> 2] | 0;
   $45 = ($44 | 0) == 0;
   if ($43) if ($45) label = 29; else if ((HEAP32[$44 >> 2] | 0) == 107) label = 21; else {
    $$pr34 = $44;
    label = 28;
   } else if ($45) {
    $56 = 0;
    $57 = 0;
    label = 22;
   } else label = 21;
   if ((label | 0) == 21) {
    label = 0;
    $56 = HEAP32[$44 >> 2] | 0;
    $57 = $44;
    label = 22;
   }
   if ((label | 0) == 22) {
    label = 0;
    $parent$02$i = HEAP32[$row >> 2] | 0;
    if ($parent$02$i | 0) {
     $parent$03$i = $parent$02$i;
     do {
      $51 = HEAP32[$parent$03$i + 28 >> 2] | 0;
      if ($51 | 0) if ((HEAP32[$51 >> 2] | 0) == ($56 | 0)) {
       label = 26;
       break L7;
      }
      $parent$03$i = HEAP32[$parent$03$i >> 2] | 0;
     } while (($parent$03$i | 0) != 0);
    }
    if (!$57) label = 29; else {
     $$pr34 = $57;
     label = 28;
    }
   }
   if ((label | 0) == 28) {
    label = 0;
    if ((HEAP32[$$pr34 >> 2] | 0) == 37) {
     $66 = $$pr34;
     label = 31;
    } else label = 29;
   }
   do if ((label | 0) == 29) {
    label = 0;
    $62 = (_prvTidynodeHasCM($18, 24) | 0) == 0;
    $63 = HEAP32[$17 >> 2] | 0;
    $64 = ($63 | 0) == 0;
    if (!$62) if ($64) break; else {
     $66 = $63;
     label = 31;
     break;
    }
    if ($64) {
     label = 38;
     break L10;
    }
    switch (HEAP32[$63 >> 2] | 0) {
    case 112:
    case 109:
     break;
    default:
     {
      label = 38;
      break L10;
     }
    }
    _prvTidyReportError($doc, $row, $18, 208);
    _prvTidyFreeNode($doc, $18);
    break L10;
   } while (0);
   if ((label | 0) == 31) {
    label = 0;
    if ((HEAP32[$66 >> 2] | 0) == 37) HEAP32[$10 >> 2] = HEAP32[$10 >> 2] | 1;
   }
   _prvTidyReportError($doc, $row, $18, 208);
   _prvTidyFreeNode($doc, $18);
  } else label = 38; while (0);
  L40 : do if ((label | 0) == 38) {
   label = 0;
   if (!(_InsertMisc($row, $18) | 0)) {
    $75 = HEAP32[$17 >> 2] | 0;
    if (!$75) {
     if ((HEAP32[$22 >> 2] | 0) != 4) {
      _prvTidyReportError($doc, $row, $18, 208);
      _prvTidyFreeNode($doc, $18);
      break;
     }
    } else if ((HEAP32[$75 >> 2] | 0) == 107) {
     _prvTidyReportError($doc, $row, $18, 208);
     _prvTidyFreeNode($doc, $18);
     break;
    }
    if (_prvTidynodeHasCM($18, 256) | 0) {
     label = 45;
     break L7;
    }
    if ((HEAP32[$22 >> 2] | 0) == 6) {
     _prvTidyReportError($doc, $row, $18, 208);
     _prvTidyFreeNode($doc, $18);
     break;
    }
    $85 = HEAP32[$17 >> 2] | 0;
    if (!$85) label = 50; else if ((HEAP32[$85 >> 2] | 0) == 37) {
     _prvTidyUngetToken($doc);
     $149 = _prvTidyInferredTag($doc, 109) | 0;
     _prvTidyReportError($doc, $row, $149, 212);
     if (!$149) $node$011 = 0; else {
      $151 = HEAP32[$149 + 28 >> 2] | 0;
      $node$010 = $149;
      label = 77;
     }
    } else label = 50;
    do if ((label | 0) == 50) {
     label = 0;
     if (!(_prvTidynodeIsText($18) | 0)) if (!(_prvTidynodeHasCM($18, 24) | 0)) {
      $144 = HEAP32[$17 >> 2] | 0;
      if (!(HEAP32[$144 + 16 >> 2] & 4)) {
       $151 = $144;
       $node$010 = $18;
       label = 77;
       break;
      }
      _prvTidyReportError($doc, $row, $18, 211);
      _MoveToHead($doc, $row, $18);
      break L40;
     }
     $table$03$i = HEAP32[$row >> 2] | 0;
     L64 : do if (!$table$03$i) label = 60; else {
      $table$04$i = $table$03$i;
      while (1) {
       $95 = HEAP32[$table$04$i + 28 >> 2] | 0;
       if ($95 | 0) if ((HEAP32[$95 >> 2] | 0) == 107) {
        $table$04$i$lcssa = $table$04$i;
        break;
       }
       $table$04$i = HEAP32[$table$04$i >> 2] | 0;
       if (!$table$04$i) {
        label = 60;
        break L64;
       }
      }
      $99 = HEAP32[$table$04$i$lcssa >> 2] | 0;
      HEAP32[$18 >> 2] = $99;
      HEAP32[$18 + 8 >> 2] = $table$04$i$lcssa;
      $101 = $table$04$i$lcssa + 4 | 0;
      $103 = $18 + 4 | 0;
      HEAP32[$103 >> 2] = HEAP32[$101 >> 2];
      HEAP32[$101 >> 2] = $18;
      $104 = HEAP32[$103 >> 2] | 0;
      if ($104 | 0) HEAP32[$104 + 8 >> 2] = $18;
      $107 = $99 + 12 | 0;
      if ((HEAP32[$107 >> 2] | 0) == ($table$04$i$lcssa | 0)) HEAP32[$107 >> 2] = $18;
     } while (0);
     if ((label | 0) == 60) {
      label = 0;
      $111 = HEAP32[$table$03$i >> 2] | 0;
      HEAP32[$18 >> 2] = $111;
      HEAP32[$18 + 8 >> 2] = $table$03$i;
      $113 = $table$03$i + 4 | 0;
      $115 = $18 + 4 | 0;
      HEAP32[$115 >> 2] = HEAP32[$113 >> 2];
      HEAP32[$113 >> 2] = $18;
      $116 = HEAP32[$115 >> 2] | 0;
      if ($116 | 0) HEAP32[$116 + 8 >> 2] = $18;
      $119 = $111 + 12 | 0;
      if ((HEAP32[$119 >> 2] | 0) == ($table$03$i | 0)) HEAP32[$119 >> 2] = $18;
     }
     _prvTidyReportError($doc, $row, $18, 211);
     HEAP32[$11 >> 2] = 1;
     $122 = HEAP32[$12 >> 2] | 0;
     HEAP32[$12 >> 2] = 0;
     $123 = HEAP32[$22 >> 2] | 0;
     do if (($123 | 0) != 4) {
      $125 = HEAP32[$0 >> 2] | 0;
      $126 = HEAP32[$17 >> 2] | 0;
      if ($126 | 0) {
       $129 = HEAP32[$126 + 16 >> 2] | 0;
       if (!($129 & 1)) {
        if (!($129 & 16)) HEAP32[$125 + 16 >> 2] = 0;
       } else {
        HEAP32[$125 + 8 >> 2] = 0;
        if (!(HEAP32[$126 + 20 >> 2] | 0)) break;
       }
       $140 = HEAP32[$126 + 20 >> 2] | 0;
       if (!(($140 | 0) == 0 | ($123 | 0) == 7)) {
        HEAP32[$125 + 72 >> 2] = $18;
        FUNCTION_TABLE_viii[$140 & 63]($doc, $18, 0);
       }
      }
     } while (0);
     HEAP32[$11 >> 2] = 0;
     HEAP32[$12 >> 2] = $122;
     break L40;
    } while (0);
    L92 : do if ((label | 0) == 77) {
     label = 0;
     if (!$151) $node$011 = $node$010; else {
      switch (HEAP32[$151 >> 2] | 0) {
      case 112:
      case 109:
       break;
      default:
       {
        $node$011 = $node$010;
        break L92;
       }
      }
      HEAP32[$node$010 >> 2] = $row;
      $154 = HEAP32[$13 >> 2] | 0;
      HEAP32[$node$010 + 4 >> 2] = $154;
      if (!$154) HEAP32[$14 >> 2] = $node$010; else HEAP32[$154 + 8 >> 2] = $node$010;
      HEAP32[$13 >> 2] = $node$010;
      $159 = HEAP32[$12 >> 2] | 0;
      HEAP32[$12 >> 2] = 0;
      $160 = HEAP32[$0 >> 2] | 0;
      $162 = HEAP32[$151 + 16 >> 2] | 0;
      if (!($162 & 1)) if (!($162 & 16)) {
       HEAP32[$160 + 16 >> 2] = 0;
       label = 87;
      } else label = 87; else {
       HEAP32[$160 + 8 >> 2] = 0;
       if (HEAP32[$151 + 20 >> 2] | 0) label = 87;
      }
      if ((label | 0) == 87) {
       label = 0;
       $173 = HEAP32[$151 + 20 >> 2] | 0;
       if ($173 | 0) if ((HEAP32[$node$010 + 44 >> 2] | 0) != 7) {
        HEAP32[$160 + 72 >> 2] = $node$010;
        FUNCTION_TABLE_viii[$173 & 63]($doc, $node$010, 0);
       }
      }
      HEAP32[$12 >> 2] = $159;
      if ((HEAP32[$15 >> 2] | 0) >>> 0 <= (HEAP32[$16 >> 2] | 0) >>> 0) break L40;
      while (1) {
       _prvTidyPopInline($doc, 0);
       if ((HEAP32[$15 >> 2] | 0) >>> 0 <= (HEAP32[$16 >> 2] | 0) >>> 0) break L40;
      }
     }
    } while (0);
    _prvTidyReportError($doc, $row, $node$011, 211);
    _prvTidyFreeNode($doc, $node$011);
   }
  } while (0);
  $70 = _prvTidyGetToken($doc, 0) | 0;
  if (!$70) {
   label = 92;
   break;
  } else $18 = $70;
 }
 if ((label | 0) == 5) if ($24) {
  _prvTidyFreeNode($doc, $18);
  HEAP32[$row + 56 >> 2] = 1;
  if (HEAP32[$14 >> 2] | 0) return;
  $28 = _prvTidyInferredTag($doc, 109) | 0;
  HEAP32[$28 >> 2] = $row;
  $29 = HEAP32[$13 >> 2] | 0;
  HEAP32[$28 + 4 >> 2] = $29;
  if (!$29) HEAP32[$14 >> 2] = $28; else HEAP32[$29 + 8 >> 2] = $28;
  HEAP32[$13 >> 2] = $28;
  _prvTidyReportError($doc, $row, $28, 212);
  return;
 } else {
  _prvTidyUngetToken($doc);
  if (HEAP32[$14 >> 2] | 0) return;
  $36 = _prvTidyInferredTag($doc, 109) | 0;
  HEAP32[$36 >> 2] = $row;
  $37 = HEAP32[$13 >> 2] | 0;
  HEAP32[$36 + 4 >> 2] = $37;
  if (!$37) HEAP32[$14 >> 2] = $36; else HEAP32[$37 + 8 >> 2] = $36;
  HEAP32[$13 >> 2] = $36;
  _prvTidyReportError($doc, $row, $36, 212);
  return;
 } else if ((label | 0) == 26) {
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 45) {
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 92) return;
}

function _prvTidyParsePre($doc, $pre, $mode) {
 $doc = $doc | 0;
 $pre = $pre | 0;
 $mode = $mode | 0;
 var $$0$be = 0, $$0$lcssa = 0, $$019 = 0, $$019$lcssa = 0, $$019$lcssa57 = 0, $$019$lcssa58 = 0, $$lcssa = 0, $$lcssa55 = 0, $$lcssa60 = 0, $$pre$phi$i6Z2D = 0, $$pre$phi$iZ2D = 0, $10 = 0, $108 = 0, $11 = 0, $113 = 0, $114 = 0, $116 = 0, $119 = 0, $120 = 0, $125 = 0, $131 = 0, $133 = 0, $134 = 0, $140 = 0, $147 = 0, $15 = 0, $151 = 0, $157 = 0, $158 = 0, $166 = 0, $170 = 0, $171 = 0, $177 = 0, $178 = 0, $18 = 0, $181 = 0, $192 = 0, $23 = 0, $28 = 0, $39 = 0, $40 = 0, $48 = 0, $49 = 0, $55 = 0, $6 = 0, $68 = 0, $74 = 0, $8 = 0, $82 = 0, $84 = 0, $87 = 0, $88 = 0, $9 = 0, $93 = 0, $94 = 0, $97 = 0, $parent$02$i = 0, $parent$03$i = 0, label = 0;
 if (HEAP32[(HEAP32[$pre + 28 >> 2] | 0) + 16 >> 2] & 1 | 0) return;
 _prvTidyInlineDup($doc, 0) | 0;
 $6 = _prvTidyGetToken($doc, 2) | 0;
 L4 : do if (!$6) $$0$lcssa = $pre; else {
  $8 = $doc + 68 | 0;
  $9 = $doc + 6856 | 0;
  $$019 = $pre;
  $11 = $6;
  L6 : while (1) {
   $10 = $11 + 44 | 0;
   L8 : do if ((HEAP32[$10 >> 2] | 0) == 6) {
    $15 = HEAP32[$11 + 28 >> 2] | 0;
    $18 = ($15 | 0) == (HEAP32[$$019 + 28 >> 2] | 0);
    L10 : do if (!$18) {
     if (!$15) $28 = 0; else $28 = HEAP32[$15 >> 2] | 0;
     $parent$02$i = HEAP32[$$019 >> 2] | 0;
     if (!$parent$02$i) {
      label = 21;
      break L8;
     } else $parent$03$i = $parent$02$i;
     while (1) {
      $23 = HEAP32[$parent$03$i + 28 >> 2] | 0;
      if ($23 | 0) if ((HEAP32[$23 >> 2] | 0) == ($28 | 0)) break L10;
      $parent$03$i = HEAP32[$parent$03$i >> 2] | 0;
      if (!$parent$03$i) {
       label = 21;
       break L8;
      }
     }
    } while (0);
    if (!$15) {
     $$019$lcssa58 = $$019;
     $$lcssa55 = $11;
     $$lcssa60 = $18;
     label = 17;
     break L6;
    }
    if ((HEAP32[$15 >> 2] | 0) != 16) if ((HEAP32[$15 >> 2] | 0) != 48) {
     $$019$lcssa58 = $$019;
     $$lcssa55 = $11;
     $$lcssa60 = $18;
     label = 17;
     break L6;
    }
    _prvTidyReportError($doc, $$019, $11, 208);
    _prvTidyFreeNode($doc, $11);
    $$0$be = $$019;
   } else label = 21; while (0);
   L25 : do if ((label | 0) == 21) {
    label = 0;
    if (_prvTidynodeIsText($11) | 0) {
     HEAP32[$11 >> 2] = $$019;
     $39 = $$019 + 16 | 0;
     $40 = HEAP32[$39 >> 2] | 0;
     HEAP32[$11 + 4 >> 2] = $40;
     if (!$40) HEAP32[$$019 + 12 >> 2] = $11; else HEAP32[$40 + 8 >> 2] = $11;
     HEAP32[$39 >> 2] = $11;
     $$0$be = $$019;
     break;
    }
    if (!(_InsertMisc($$019, $11) | 0)) {
     $48 = $11 + 28 | 0;
     $49 = HEAP32[$48 >> 2] | 0;
     if (!$49) {
      _prvTidyReportError($doc, $$019, $11, 208);
      _prvTidyFreeNode($doc, $11);
      $$0$be = $$019;
      break;
     }
     do if ((HEAP32[$49 >> 2] | 0) != 80) if (!(_prvTidynodeIsText($11) | 0)) {
      $55 = HEAP32[$48 >> 2] | 0;
      if ($55 | 0) if ((HEAP32[$55 >> 2] | 0) != 81) if (_prvTidynodeHasCM($11, 1048592) | 0) break;
      if ((HEAP32[$10 >> 2] | 0) == 6) {
       if (HEAP32[(HEAP32[$8 >> 2] | 0) + 24 >> 2] | 0) {
        if (_prvTidynodeHasCM($11, 128) | 0) {
         $$019$lcssa57 = $$019;
         label = 39;
         break L6;
        }
        $68 = HEAP32[$48 >> 2] | 0;
        if ($68 | 0) if ((HEAP32[$68 >> 2] | 0) == 107) {
         $$019$lcssa57 = $$019;
         label = 39;
         break L6;
        }
       }
       _prvTidyReportError($doc, $$019, $11, 208);
       _prvTidyFreeNode($doc, $11);
       $$0$be = $$019;
       break L25;
      }
      if (_prvTidynodeHasCM($11, 640) | 0) {
       $$019$lcssa = $$019;
       $$lcssa = $11;
       label = 44;
       break L6;
      }
      $74 = HEAP32[$48 >> 2] | 0;
      if ($74 | 0) if ((HEAP32[$74 >> 2] | 0) == 107) {
       $$019$lcssa = $$019;
       $$lcssa = $11;
       label = 44;
       break L6;
      }
      $82 = HEAP32[$$019 >> 2] | 0;
      HEAP32[$11 >> 2] = $82;
      if (!$82) label = 50; else {
       $84 = $82 + 16 | 0;
       if ((HEAP32[$84 >> 2] | 0) == ($$019 | 0)) {
        HEAP32[$84 >> 2] = $11;
        $$pre$phi$iZ2D = $$019 + 8 | 0;
       } else label = 50;
      }
      if ((label | 0) == 50) {
       label = 0;
       $87 = $$019 + 8 | 0;
       $88 = HEAP32[$87 >> 2] | 0;
       HEAP32[$11 + 8 >> 2] = $88;
       if (!$88) $$pre$phi$iZ2D = $87; else {
        HEAP32[$88 + 4 >> 2] = $11;
        $$pre$phi$iZ2D = $87;
       }
      }
      HEAP32[$$pre$phi$iZ2D >> 2] = $11;
      HEAP32[$11 + 4 >> 2] = $$019;
      _prvTidyReportError($doc, $$019, $11, 207);
      $93 = HEAP32[$8 >> 2] | 0;
      $94 = HEAP32[$48 >> 2] | 0;
      L64 : do if ($94 | 0) {
       $97 = HEAP32[$94 + 16 >> 2] | 0;
       do if (!($97 & 1)) {
        if ($97 & 16 | 0) break;
        HEAP32[$93 + 16 >> 2] = 0;
       } else {
        HEAP32[$93 + 8 >> 2] = 0;
        if (!(HEAP32[$94 + 20 >> 2] | 0)) break L64;
       } while (0);
       $108 = HEAP32[$94 + 20 >> 2] | 0;
       if (!$108) break;
       if ((HEAP32[$10 >> 2] | 0) == 7) break;
       HEAP32[$93 + 72 >> 2] = $11;
       FUNCTION_TABLE_viii[$108 & 63]($doc, $11, 0);
      } while (0);
      $113 = _prvTidyInferredTag($doc, 84) | 0;
      _prvTidyReportError($doc, $$019, $113, 215);
      $114 = HEAP32[$11 >> 2] | 0;
      HEAP32[$113 >> 2] = $114;
      do if (!$114) label = 63; else {
       $116 = $114 + 16 | 0;
       if ((HEAP32[$116 >> 2] | 0) != ($11 | 0)) {
        label = 63;
        break;
       }
       HEAP32[$116 >> 2] = $113;
       $$pre$phi$i6Z2D = $11 + 8 | 0;
      } while (0);
      do if ((label | 0) == 63) {
       label = 0;
       $119 = $11 + 8 | 0;
       $120 = HEAP32[$119 >> 2] | 0;
       HEAP32[$113 + 8 >> 2] = $120;
       if (!$120) {
        $$pre$phi$i6Z2D = $119;
        break;
       }
       HEAP32[$120 + 4 >> 2] = $113;
       $$pre$phi$i6Z2D = $119;
      } while (0);
      HEAP32[$$pre$phi$i6Z2D >> 2] = $113;
      HEAP32[$113 + 4 >> 2] = $11;
      $$0$be = $113;
      break L25;
     } while (0);
     $125 = HEAP32[$48 >> 2] | 0;
     if ($125 | 0) if ((HEAP32[$125 >> 2] | 0) == 80) {
      if ((HEAP32[$10 >> 2] | 0) != 5) {
       _prvTidyReportError($doc, $$019, $11, 208);
       _prvTidyFreeNode($doc, $11);
       $$0$be = $$019;
       break;
      }
      _prvTidyReportError($doc, $$019, $11, 214);
      _TrimSpaces($doc, $$019);
      $131 = _prvTidyLookupTagDef(17) | 0;
      $133 = _prvTidyInferredTag($doc, HEAP32[$131 >> 2] | 0) | 0;
      _prvTidyReportNotice($doc, $11, $133, 283);
      $134 = HEAP32[$9 >> 2] | 0;
      FUNCTION_TABLE_vii[HEAP32[(HEAP32[$134 >> 2] | 0) + 8 >> 2] & 15]($134, HEAP32[$133 + 32 >> 2] | 0);
      $140 = HEAP32[$9 >> 2] | 0;
      FUNCTION_TABLE_vii[HEAP32[(HEAP32[$140 >> 2] | 0) + 8 >> 2] & 15]($140, $133);
      HEAP32[$11 + 24 >> 2] = HEAP32[$48 >> 2];
      HEAP32[$48 >> 2] = $131;
      HEAP32[$10 >> 2] = 5;
      HEAP32[$11 + 60 >> 2] = 1;
      $147 = HEAP32[$9 >> 2] | 0;
      $151 = $11 + 32 | 0;
      FUNCTION_TABLE_vii[HEAP32[(HEAP32[$147 >> 2] | 0) + 8 >> 2] & 15]($147, HEAP32[$151 >> 2] | 0);
      HEAP32[$151 >> 2] = _prvTidytmbstrdup(HEAP32[$9 >> 2] | 0, HEAP32[$131 + 4 >> 2] | 0) | 0;
      _prvTidyFreeAttrs($doc, $11);
      HEAP32[$11 >> 2] = $$019;
      $157 = $$019 + 16 | 0;
      $158 = HEAP32[$157 >> 2] | 0;
      HEAP32[$11 + 4 >> 2] = $158;
      if (!$158) HEAP32[$$019 + 12 >> 2] = $11; else HEAP32[$158 + 8 >> 2] = $11;
      HEAP32[$157 >> 2] = $11;
      $$0$be = $$019;
      break;
     }
     if (!(_prvTidynodeIsElement($11) | 0)) {
      _prvTidyReportError($doc, $$019, $11, 208);
      _prvTidyFreeNode($doc, $11);
      $$0$be = $$019;
      break;
     }
     $166 = HEAP32[$48 >> 2] | 0;
     if ($166 | 0) if ((HEAP32[$166 >> 2] | 0) == 17) _TrimSpaces($doc, $$019);
     HEAP32[$11 >> 2] = $$019;
     $170 = $$019 + 16 | 0;
     $171 = HEAP32[$170 >> 2] | 0;
     HEAP32[$11 + 4 >> 2] = $171;
     if (!$171) HEAP32[$$019 + 12 >> 2] = $11; else HEAP32[$171 + 8 >> 2] = $11;
     HEAP32[$170 >> 2] = $11;
     $177 = HEAP32[$8 >> 2] | 0;
     $178 = HEAP32[$48 >> 2] | 0;
     if (!$178) $$0$be = $$019; else {
      $181 = HEAP32[$178 + 16 >> 2] | 0;
      if (!($181 & 1)) {
       if (!($181 & 16)) HEAP32[$177 + 16 >> 2] = 0;
      } else {
       HEAP32[$177 + 8 >> 2] = 0;
       if (!(HEAP32[$178 + 20 >> 2] | 0)) {
        $$0$be = $$019;
        break;
       }
      }
      $192 = HEAP32[$178 + 20 >> 2] | 0;
      if (!$192) $$0$be = $$019; else if ((HEAP32[$10 >> 2] | 0) == 7) $$0$be = $$019; else {
       HEAP32[$177 + 72 >> 2] = $11;
       FUNCTION_TABLE_viii[$192 & 63]($doc, $11, 2);
       $$0$be = $$019;
      }
     }
    } else $$0$be = $$019;
   } while (0);
   $11 = _prvTidyGetToken($doc, 2) | 0;
   if (!$11) {
    $$0$lcssa = $$0$be;
    break L4;
   } else $$019 = $$0$be;
  }
  if ((label | 0) == 17) {
   if ($$lcssa60) _prvTidyFreeNode($doc, $$lcssa55); else {
    _prvTidyReportError($doc, $$019$lcssa58, $$lcssa55, 207);
    _prvTidyUngetToken($doc);
   }
   HEAP32[$$019$lcssa58 + 56 >> 2] = 1;
   _TrimSpaces($doc, $$019$lcssa58);
   return;
  } else if ((label | 0) == 39) {
   _prvTidyUngetToken($doc);
   _TrimSpaces($doc, $$019$lcssa57);
   return;
  } else if ((label | 0) == 44) {
   if (!(HEAP32[(HEAP32[$8 >> 2] | 0) + 24 >> 2] | 0)) _prvTidyReportError($doc, $$019$lcssa, $$lcssa, 207);
   _prvTidyUngetToken($doc);
   return;
  }
 } while (0);
 _prvTidyReportError($doc, $$0$lcssa, 0, 206);
 return;
}

function _prvTidyIsXMLLetter($c) {
 $c = $c | 0;
 var $13 = 0, $136 = 0, $137 = 0, $21 = 0, $46 = 0, $5 = 0, $switch$tableidx = 0, $switch$tableidx774 = 0, $switch$tableidx785 = 0, $switch$tableidx800 = 0, $switch$tableidx809 = 0, $switch$tableidx823 = 0;
 $5 = $c & -8;
 $13 = $c & -2;
 if (($c + -592 | 0) >>> 0 < 89 | (($c + -506 | 0) >>> 0 < 30 | (($13 | 0) == 500 | (($c + -461 | 0) >>> 0 < 36 | (($c + -384 | 0) >>> 0 < 68 | (($c + -330 | 0) >>> 0 < 53 | (($c + -321 | 0) >>> 0 < 8 | (($c + -308 | 0) >>> 0 < 11 | (($c + -256 | 0) >>> 0 < 50 | (($5 | 0) == 248 | (($c + -216 | 0) >>> 0 < 31 | (($c + -192 | 0) >>> 0 < 23 | (($c & -33) + -65 | 0) >>> 0 < 26)))))))))))) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 switch ($c | 0) {
 case 904:
 case 905:
 case 906:
 case 908:
 case 699:
 case 700:
 case 701:
 case 702:
 case 703:
 case 704:
 case 705:
 case 902:
  {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 default:
  {}
 }
 if (($c + -910 | 0) >>> 0 < 20 | ($c + -931 | 0) >>> 0 < 44) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 $21 = $c | 2;
 if (($13 | 0) == 1272 | (($c + -1262 | 0) >>> 0 < 8 | (($c + -1232 | 0) >>> 0 < 28 | (($c + -1227 | 0) >>> 0 < 2 | (($c + -1223 | 0) >>> 0 < 2 | (($c + -1168 | 0) >>> 0 < 53 | (($c + -1118 | 0) >>> 0 < 36 | (($c + -1105 | 0) >>> 0 < 12 | (($c + -1038 | 0) >>> 0 < 66 | (($c + -1025 | 0) >>> 0 < 12 | (($c + -994 | 0) >>> 0 < 18 | (($c | 0) == 992 | (($21 | 0) == 990 | (($c | 0) == 986 | ($c + -976 | 0) >>> 0 < 7)))))))))))))) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 if (($c + -1728 | 0) >>> 0 < 15 | (($c + -1722 | 0) >>> 0 < 5 | (($c + -1649 | 0) >>> 0 < 71 | (($c + -1601 | 0) >>> 0 < 10 | (($c + -1569 | 0) >>> 0 < 26 | (($c + -1520 | 0) >>> 0 < 3 | (($c + -1488 | 0) >>> 0 < 27 | (($c + -1377 | 0) >>> 0 < 38 | (($c | 0) == 1369 | ($c + -1329 | 0) >>> 0 < 38))))))))) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 $46 = $c & -4;
 if (($46 | 0) == 1744) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 switch ($c | 0) {
 case 1749:
 case 1765:
 case 1766:
  {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 default:
  {}
 }
 if (($c + -2451 | 0) >>> 0 < 22 | (($c + -2447 | 0) >>> 0 < 2 | (($c + -2437 | 0) >>> 0 < 8 | (($c + -2392 | 0) >>> 0 < 10 | (($c | 0) == 2365 | ($c + -2309 | 0) >>> 0 < 53))))) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 $switch$tableidx = $c + -2474 | 0;
 if ($switch$tableidx >>> 0 < 9) {
  if (($c + -2579 | 0) >>> 0 < 22 | (383 >>> ($switch$tableidx & 65535) & 1) != 0) {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 } else if (($c + -2579 | 0) >>> 0 < 22) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 switch ($c | 0) {
 case 2649:
 case 2650:
 case 2651:
 case 2652:
 case 2654:
 case 2486:
 case 2487:
 case 2488:
 case 2489:
 case 2524:
 case 2525:
 case 2527:
 case 2528:
 case 2529:
 case 2544:
 case 2545:
 case 2565:
 case 2566:
 case 2567:
 case 2568:
 case 2569:
 case 2570:
 case 2575:
 case 2576:
 case 2602:
 case 2603:
 case 2604:
 case 2605:
 case 2606:
 case 2607:
 case 2608:
 case 2610:
 case 2611:
 case 2613:
 case 2614:
 case 2616:
 case 2617:
  {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 default:
  {}
 }
 if (($c + -2674 | 0) >>> 0 < 3) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 $switch$tableidx774 = $c + -2693 | 0;
 if ($switch$tableidx774 >>> 0 < 9) {
  if (($c + -2707 | 0) >>> 0 < 22 | (383 >>> ($switch$tableidx774 & 65535) & 1) != 0) {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 } else if (($c + -2707 | 0) >>> 0 < 22) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 switch ($c | 0) {
 case 2741:
 case 2742:
 case 2743:
 case 2744:
 case 2745:
 case 2749:
 case 2784:
 case 2703:
 case 2704:
 case 2705:
 case 2730:
 case 2731:
 case 2732:
 case 2733:
 case 2734:
 case 2735:
 case 2736:
 case 2738:
 case 2739:
  {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 default:
  {}
 }
 if (($c + -2835 | 0) >>> 0 < 22) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 switch ($c | 0) {
 case 2969:
 case 2970:
 case 2972:
 case 2908:
 case 2909:
 case 2911:
 case 2912:
 case 2913:
 case 2949:
 case 2950:
 case 2951:
 case 2952:
 case 2953:
 case 2954:
 case 2958:
 case 2959:
 case 2960:
 case 2962:
 case 2963:
 case 2964:
 case 2965:
 case 2870:
 case 2871:
 case 2872:
 case 2873:
 case 2877:
 case 2821:
 case 2822:
 case 2823:
 case 2824:
 case 2825:
 case 2826:
 case 2827:
 case 2828:
 case 2831:
 case 2832:
 case 2858:
 case 2859:
 case 2860:
 case 2861:
 case 2862:
 case 2863:
 case 2864:
 case 2866:
 case 2867:
  {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 default:
  {}
 }
 if (($c + -3242 | 0) >>> 0 < 10 | (($c + -3218 | 0) >>> 0 < 23 | (($c + -3214 | 0) >>> 0 < 3 | (($c + -3205 | 0) >>> 0 < 8 | (($13 | 0) == 3168 | (($c + -3125 | 0) >>> 0 < 5 | (($c + -3114 | 0) >>> 0 < 10 | (($c + -3090 | 0) >>> 0 < 23 | (($c + -3086 | 0) >>> 0 < 3 | (($c + -3077 | 0) >>> 0 < 8 | (($c + -2999 | 0) >>> 0 < 3 | (($c + -2990 | 0) >>> 0 < 8 | (($c + -2984 | 0) >>> 0 < 3 | (($13 | 0) == 2974 | ($c + -2979 | 0) >>> 0 < 2)))))))))))))) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 switch ($c | 0) {
 case 3253:
 case 3254:
 case 3255:
 case 3256:
 case 3257:
 case 3294:
  {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 default:
  {}
 }
 if (($c + -3585 | 0) >>> 0 < 46 | (($13 | 0) == 3424 | (($c + -3370 | 0) >>> 0 < 16 | (($c + -3346 | 0) >>> 0 < 23 | (($c + -3342 | 0) >>> 0 < 3 | (($13 | 0) == 3296 | ($c + -3333 | 0) >>> 0 < 8)))))) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 switch ($c | 0) {
 case 3719:
 case 3720:
 case 3722:
 case 3725:
 case 3713:
 case 3714:
 case 3716:
 case 3632:
 case 3634:
 case 3635:
 case 3648:
 case 3649:
 case 3650:
 case 3651:
 case 3652:
 case 3653:
  {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 default:
  {}
 }
 if (($46 | 0) == 3732 | ($c + -3737 | 0) >>> 0 < 7 | ($21 | 0) == 3751) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 $switch$tableidx823 = $c + -3745 | 0;
 if ($switch$tableidx823 >>> 0 < 11) if (1543 >>> ($switch$tableidx823 & 65535) & 1) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 $switch$tableidx800 = $c + -3757 | 0;
 if ($switch$tableidx800 >>> 0 < 17) if (65643 >>> $switch$tableidx800 & 1 | 0) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 if (($c + -4304 | 0) >>> 0 < 39 | (($c + -4256 | 0) >>> 0 < 38 | (($c + -3913 | 0) >>> 0 < 33 | (($c + -3776 | 0) >>> 0 < 5 | ($5 | 0) == 3904)))) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 $switch$tableidx809 = $c + -4352 | 0;
 if ($switch$tableidx809 >>> 0 < 10) {
  if (($c + -4363 | 0) >>> 0 < 2 | (749 >>> ($switch$tableidx809 & 65535) & 1) != 0) {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 } else if (($c + -4363 | 0) >>> 0 < 2) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 if (($c | 0) == 4432 | (($21 | 0) == 4430 | (($c | 0) == 4416 | (($21 | 0) == 4414 | ($c + -4366 | 0) >>> 0 < 5)))) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 switch ($c | 0) {
 case 4436:
 case 4437:
 case 4441:
  {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 default:
  {}
 }
 if (($21 | 0) == 4455) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 switch ($c | 0) {
 case 4466:
 case 4467:
 case 4469:
 case 4510:
 case 4520:
 case 4523:
 case 4447:
 case 4448:
 case 4449:
 case 4451:
 case 4457:
 case 4461:
 case 4462:
  {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 default:
  {}
 }
 if (($13 | 0) == 4526) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 switch ($c | 0) {
 case 4540:
 case 4541:
 case 4542:
 case 4543:
 case 4544:
 case 4545:
 case 4546:
 case 4587:
 case 4592:
 case 4601:
 case 4535:
 case 4536:
 case 4538:
  {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 default:
  {}
 }
 if (($c + -8008 | 0) >>> 0 < 6 | (($c + -7968 | 0) >>> 0 < 38 | (($c + -7960 | 0) >>> 0 < 6 | (($c + -7936 | 0) >>> 0 < 22 | (($c + -7680 | 0) >>> 0 < 156 | ($c + -7840 | 0) >>> 0 < 90))))) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 if (($c + -8064 | 0) >>> 0 < 53 | (($c + -8031 | 0) >>> 0 < 31 | (($c | 0) == 8029 | (($21 | 0) == 8027 | ($5 | 0) == 8016)))) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 $switch$tableidx785 = $c + -8118 | 0;
 do if ($switch$tableidx785 >>> 0 < 9) {
  if (!(383 >>> ($switch$tableidx785 & 65535) & 1)) break; else $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 } while (0);
 if (($c + -8178 | 0) >>> 0 < 3 | (($c + -8160 | 0) >>> 0 < 13 | (($c + -8150 | 0) >>> 0 < 6 | (($46 | 0) == 8144 | (($c + -8130 | 0) >>> 0 < 3 | ($c + -8134 | 0) >>> 0 < 7))))) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 switch ($c | 0) {
 case 8490:
 case 8491:
 case 8494:
 case 8182:
 case 8183:
 case 8184:
 case 8185:
 case 8186:
 case 8187:
 case 8188:
 case 8486:
  {
   $137 = 1;
   $136 = $137 & 1;
   return $136 | 0;
  }
 default:
  {}
 }
 if (($c + -44032 | 0) >>> 0 < 11172 | (($c + -12549 | 0) >>> 0 < 40 | (($c + -12449 | 0) >>> 0 < 90 | (($c + -8576 | 0) >>> 0 < 3 | ($c + -12353 | 0) >>> 0 < 84)))) {
  $137 = 1;
  $136 = $137 & 1;
  return $136 | 0;
 }
 $137 = ($c + -12321 | 0) >>> 0 < 9 | (($c | 0) == 12295 | ($c + -19968 | 0) >>> 0 < 20902);
 $136 = $137 & 1;
 return $136 | 0;
}

function _NeedReparseTagDecls($current, $new, $changedUserTags) {
 $current = $current | 0;
 $new = $new | 0;
 $changedUserTags = $changedUserTags | 0;
 var $$lcssa = 0, $$lcssa179 = 0, $$lcssa180 = 0, $$lcssa181 = 0, $$lcssa182 = 0, $$lcssa183 = 0, $$lcssa184 = 0, $$lcssa185 = 0, $0 = 0, $1 = 0, $11 = 0, $12 = 0, $2 = 0, $24 = 0, $25 = 0, $3 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $50 = 0, $51 = 0, $6 = 0, $7 = 0, $ixVal$025$ph = 0, $ixVal$025114 = 0, $ixVal$025114$lcssa151 = 0, $ixVal$025114$lcssa152 = 0, $ixVal$025114$lcssa153 = 0, $ixVal$025114$lcssa154 = 0, $ixVal$025114$lcssa155 = 0, $ixVal$025114$lcssa156 = 0, $ixVal$025114$lcssa157 = 0, $ixVal$025114$lcssa158 = 0, $ixVal$025114160 = 0, $ixVal$025114161 = 0, $ixVal$025114162 = 0, $ixVal$025114163 = 0, $ixVal$025114164 = 0, $option$026$ph = 0, $option$026113 = 0, $option$026113$lcssa165 = 0, $option$026113$lcssa166 = 0, $option$026113$lcssa167 = 0, $option$026113$lcssa168 = 0, $option$026113$lcssa169 = 0, $option$026113$lcssa170 = 0, $option$026113$lcssa171 = 0, $option$026113$lcssa172 = 0, $option$026113174 = 0, $option$026113175 = 0, $option$026113176 = 0, $option$026113177 = 0, $option$026113178 = 0, $ret$024$ph = 0, $ret$1 = 0, $ret$1$lcssa = 0, label = 0;
 HEAP32[$changedUserTags >> 2] = 0;
 $0 = $current + 320 | 0;
 $1 = $new + 320 | 0;
 $2 = $current + 324 | 0;
 $3 = $new + 324 | 0;
 $4 = $current + 328 | 0;
 $5 = $new + 328 | 0;
 $6 = $current + 332 | 0;
 $7 = $new + 332 | 0;
 $ixVal$025$ph = 0;
 $option$026$ph = 1892;
 $ret$024$ph = 0;
 L1 : while (1) {
  if (($ixVal$025$ph | 0) == (HEAP32[$option$026$ph >> 2] | 0)) {
   $ixVal$025114 = $ixVal$025$ph;
   $option$026113 = $option$026$ph;
  } else {
   label = 3;
   break;
  }
  L3 : while (1) {
   switch ($ixVal$025114 | 0) {
   case 80:
    {
     if (HEAP32[$option$026113 + 12 >> 2] | 0) {
      $ixVal$025114$lcssa157 = $ixVal$025114;
      $option$026113$lcssa171 = $option$026113;
      label = 9;
      break L3;
     }
     $11 = HEAP32[$0 >> 2] | 0;
     $12 = HEAP32[$1 >> 2] | 0;
     if (($11 | 0) != ($12 | 0)) {
      $$lcssa184 = $11;
      $$lcssa185 = $12;
      $ixVal$025114$lcssa158 = $ixVal$025114;
      $option$026113$lcssa172 = $option$026113;
      label = 7;
      break L3;
     }
     break;
    }
   case 81:
    {
     if (HEAP32[$option$026113 + 12 >> 2] | 0) {
      $ixVal$025114$lcssa155 = $ixVal$025114;
      $option$026113$lcssa169 = $option$026113;
      label = 15;
      break L3;
     }
     $24 = HEAP32[$2 >> 2] | 0;
     $25 = HEAP32[$3 >> 2] | 0;
     if (($24 | 0) != ($25 | 0)) {
      $$lcssa182 = $24;
      $$lcssa183 = $25;
      $ixVal$025114$lcssa156 = $ixVal$025114;
      $option$026113$lcssa170 = $option$026113;
      label = 13;
      break L3;
     }
     break;
    }
   case 82:
    {
     if (HEAP32[$option$026113 + 12 >> 2] | 0) {
      $ixVal$025114$lcssa153 = $ixVal$025114;
      $option$026113$lcssa167 = $option$026113;
      label = 21;
      break L3;
     }
     $37 = HEAP32[$4 >> 2] | 0;
     $38 = HEAP32[$5 >> 2] | 0;
     if (($37 | 0) != ($38 | 0)) {
      $$lcssa180 = $37;
      $$lcssa181 = $38;
      $ixVal$025114$lcssa154 = $ixVal$025114;
      $option$026113$lcssa168 = $option$026113;
      label = 19;
      break L3;
     }
     break;
    }
   case 83:
    {
     if (HEAP32[$option$026113 + 12 >> 2] | 0) {
      $ixVal$025114$lcssa151 = $ixVal$025114;
      $option$026113$lcssa165 = $option$026113;
      label = 27;
      break L3;
     }
     $50 = HEAP32[$6 >> 2] | 0;
     $51 = HEAP32[$7 >> 2] | 0;
     if (($50 | 0) != ($51 | 0)) {
      $$lcssa = $50;
      $$lcssa179 = $51;
      $ixVal$025114$lcssa152 = $ixVal$025114;
      $option$026113$lcssa166 = $option$026113;
      label = 25;
      break L3;
     }
     break;
    }
   default:
    {
     $ixVal$025114161 = $ixVal$025114;
     $option$026113175 = $option$026113;
     $ret$1 = $ret$024$ph;
     break L3;
    }
   }
   $option$026113 = $option$026113 + 32 | 0;
   $ixVal$025114 = $ixVal$025114 + 1 | 0;
   if (($ixVal$025114 | 0) != (HEAP32[$option$026113 >> 2] | 0)) {
    label = 3;
    break L1;
   }
  }
  if ((label | 0) == 7) {
   label = 0;
   if (($$lcssa184 | 0) == 0 | ($$lcssa185 | 0) == 0) {
    $ixVal$025114164 = $ixVal$025114$lcssa158;
    $option$026113178 = $option$026113$lcssa172;
    label = 10;
   } else if (!(_prvTidytmbstrcmp($$lcssa184, $$lcssa185) | 0)) {
    $ixVal$025114161 = $ixVal$025114$lcssa158;
    $option$026113175 = $option$026113$lcssa172;
    $ret$1 = $ret$024$ph;
   } else {
    $ixVal$025114164 = $ixVal$025114$lcssa158;
    $option$026113178 = $option$026113$lcssa172;
    label = 10;
   }
  } else if ((label | 0) == 9) {
   label = 0;
   if ((HEAP32[$0 >> 2] | 0) == (HEAP32[$1 >> 2] | 0)) {
    $ixVal$025114161 = $ixVal$025114$lcssa157;
    $option$026113175 = $option$026113$lcssa171;
    $ret$1 = $ret$024$ph;
   } else {
    $ixVal$025114164 = $ixVal$025114$lcssa157;
    $option$026113178 = $option$026113$lcssa171;
    label = 10;
   }
  } else if ((label | 0) == 13) {
   label = 0;
   if (($$lcssa182 | 0) == 0 | ($$lcssa183 | 0) == 0) {
    $ixVal$025114163 = $ixVal$025114$lcssa156;
    $option$026113177 = $option$026113$lcssa170;
    label = 16;
   } else if (!(_prvTidytmbstrcmp($$lcssa182, $$lcssa183) | 0)) {
    $ixVal$025114161 = $ixVal$025114$lcssa156;
    $option$026113175 = $option$026113$lcssa170;
    $ret$1 = $ret$024$ph;
   } else {
    $ixVal$025114163 = $ixVal$025114$lcssa156;
    $option$026113177 = $option$026113$lcssa170;
    label = 16;
   }
  } else if ((label | 0) == 15) {
   label = 0;
   if ((HEAP32[$2 >> 2] | 0) == (HEAP32[$3 >> 2] | 0)) {
    $ixVal$025114161 = $ixVal$025114$lcssa155;
    $option$026113175 = $option$026113$lcssa169;
    $ret$1 = $ret$024$ph;
   } else {
    $ixVal$025114163 = $ixVal$025114$lcssa155;
    $option$026113177 = $option$026113$lcssa169;
    label = 16;
   }
  } else if ((label | 0) == 19) {
   label = 0;
   if (($$lcssa180 | 0) == 0 | ($$lcssa181 | 0) == 0) {
    $ixVal$025114162 = $ixVal$025114$lcssa154;
    $option$026113176 = $option$026113$lcssa168;
    label = 22;
   } else if (!(_prvTidytmbstrcmp($$lcssa180, $$lcssa181) | 0)) {
    $ixVal$025114161 = $ixVal$025114$lcssa154;
    $option$026113175 = $option$026113$lcssa168;
    $ret$1 = $ret$024$ph;
   } else {
    $ixVal$025114162 = $ixVal$025114$lcssa154;
    $option$026113176 = $option$026113$lcssa168;
    label = 22;
   }
  } else if ((label | 0) == 21) {
   label = 0;
   if ((HEAP32[$4 >> 2] | 0) == (HEAP32[$5 >> 2] | 0)) {
    $ixVal$025114161 = $ixVal$025114$lcssa153;
    $option$026113175 = $option$026113$lcssa167;
    $ret$1 = $ret$024$ph;
   } else {
    $ixVal$025114162 = $ixVal$025114$lcssa153;
    $option$026113176 = $option$026113$lcssa167;
    label = 22;
   }
  } else if ((label | 0) == 25) {
   label = 0;
   if (($$lcssa | 0) == 0 | ($$lcssa179 | 0) == 0) {
    $ixVal$025114160 = $ixVal$025114$lcssa152;
    $option$026113174 = $option$026113$lcssa166;
    label = 28;
   } else if (!(_prvTidytmbstrcmp($$lcssa, $$lcssa179) | 0)) {
    $ixVal$025114161 = $ixVal$025114$lcssa152;
    $option$026113175 = $option$026113$lcssa166;
    $ret$1 = $ret$024$ph;
   } else {
    $ixVal$025114160 = $ixVal$025114$lcssa152;
    $option$026113174 = $option$026113$lcssa166;
    label = 28;
   }
  } else if ((label | 0) == 27) {
   label = 0;
   if ((HEAP32[$6 >> 2] | 0) == (HEAP32[$7 >> 2] | 0)) {
    $ixVal$025114161 = $ixVal$025114$lcssa151;
    $option$026113175 = $option$026113$lcssa165;
    $ret$1 = $ret$024$ph;
   } else {
    $ixVal$025114160 = $ixVal$025114$lcssa151;
    $option$026113174 = $option$026113$lcssa165;
    label = 28;
   }
  }
  if ((label | 0) == 10) {
   label = 0;
   HEAP32[$changedUserTags >> 2] = HEAP32[$changedUserTags >> 2] | 2;
   $ixVal$025114161 = $ixVal$025114164;
   $option$026113175 = $option$026113178;
   $ret$1 = 1;
  } else if ((label | 0) == 16) {
   label = 0;
   HEAP32[$changedUserTags >> 2] = HEAP32[$changedUserTags >> 2] | 4;
   $ixVal$025114161 = $ixVal$025114163;
   $option$026113175 = $option$026113177;
   $ret$1 = 1;
  } else if ((label | 0) == 22) {
   label = 0;
   HEAP32[$changedUserTags >> 2] = HEAP32[$changedUserTags >> 2] | 1;
   $ixVal$025114161 = $ixVal$025114162;
   $option$026113175 = $option$026113176;
   $ret$1 = 1;
  } else if ((label | 0) == 28) {
   label = 0;
   HEAP32[$changedUserTags >> 2] = HEAP32[$changedUserTags >> 2] | 8;
   $ixVal$025114161 = $ixVal$025114160;
   $option$026113175 = $option$026113174;
   $ret$1 = 1;
  }
  $ixVal$025$ph = $ixVal$025114161 + 1 | 0;
  if ($ixVal$025$ph >>> 0 >= 98) {
   $ret$1$lcssa = $ret$1;
   label = 31;
   break;
  } else {
   $option$026$ph = $option$026113175 + 32 | 0;
   $ret$024$ph = $ret$1;
  }
 }
 if ((label | 0) == 3) ___assert_fail(225459, 223800, 482, 225588); else if ((label | 0) == 31) return $ret$1$lcssa | 0;
 return 0;
}

function ___udivmoddi4($a$0, $a$1, $b$0, $b$1, $rem) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 $rem = $rem | 0;
 var $n_sroa_0_0_extract_trunc = 0, $n_sroa_1_4_extract_shift$0 = 0, $n_sroa_1_4_extract_trunc = 0, $d_sroa_0_0_extract_trunc = 0, $d_sroa_1_4_extract_shift$0 = 0, $d_sroa_1_4_extract_trunc = 0, $4 = 0, $17 = 0, $37 = 0, $51 = 0, $57 = 0, $58 = 0, $66 = 0, $78 = 0, $88 = 0, $89 = 0, $91 = 0, $92 = 0, $95 = 0, $105 = 0, $119 = 0, $125 = 0, $126 = 0, $130 = 0, $q_sroa_1_1_ph = 0, $q_sroa_0_1_ph = 0, $r_sroa_1_1_ph = 0, $r_sroa_0_1_ph = 0, $sr_1_ph = 0, $d_sroa_0_0_insert_insert99$0 = 0, $d_sroa_0_0_insert_insert99$1 = 0, $137$0 = 0, $137$1 = 0, $carry_0203 = 0, $sr_1202 = 0, $r_sroa_0_1201 = 0, $r_sroa_1_1200 = 0, $q_sroa_0_1199 = 0, $q_sroa_1_1198 = 0, $r_sroa_0_0_insert_insert42$0 = 0, $r_sroa_0_0_insert_insert42$1 = 0, $150$1 = 0, $151$0 = 0, $carry_0_lcssa$0 = 0, $carry_0_lcssa$1 = 0, $r_sroa_0_1_lcssa = 0, $r_sroa_1_1_lcssa = 0, $q_sroa_0_1_lcssa = 0, $q_sroa_1_1_lcssa = 0, $q_sroa_0_0_insert_ext75$0 = 0, $q_sroa_0_0_insert_ext75$1 = 0, $_0$0 = 0, $_0$1 = 0, $q_sroa_1_1198$looptemp = 0;
 $n_sroa_0_0_extract_trunc = $a$0;
 $n_sroa_1_4_extract_shift$0 = $a$1;
 $n_sroa_1_4_extract_trunc = $n_sroa_1_4_extract_shift$0;
 $d_sroa_0_0_extract_trunc = $b$0;
 $d_sroa_1_4_extract_shift$0 = $b$1;
 $d_sroa_1_4_extract_trunc = $d_sroa_1_4_extract_shift$0;
 if (!$n_sroa_1_4_extract_trunc) {
  $4 = ($rem | 0) != 0;
  if (!$d_sroa_1_4_extract_trunc) {
   if ($4) {
    HEAP32[$rem >> 2] = ($n_sroa_0_0_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0);
    HEAP32[$rem + 4 >> 2] = 0;
   }
   $_0$1 = 0;
   $_0$0 = ($n_sroa_0_0_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  } else {
   if (!$4) {
    $_0$1 = 0;
    $_0$0 = 0;
    return (tempRet0 = $_0$1, $_0$0) | 0;
   }
   HEAP32[$rem >> 2] = $a$0 | 0;
   HEAP32[$rem + 4 >> 2] = $a$1 & 0;
   $_0$1 = 0;
   $_0$0 = 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
 }
 $17 = ($d_sroa_1_4_extract_trunc | 0) == 0;
 do if (!$d_sroa_0_0_extract_trunc) {
  if ($17) {
   if ($rem | 0) {
    HEAP32[$rem >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0);
    HEAP32[$rem + 4 >> 2] = 0;
   }
   $_0$1 = 0;
   $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
  if (!$n_sroa_0_0_extract_trunc) {
   if ($rem | 0) {
    HEAP32[$rem >> 2] = 0;
    HEAP32[$rem + 4 >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_1_4_extract_trunc >>> 0);
   }
   $_0$1 = 0;
   $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_1_4_extract_trunc >>> 0) >>> 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
  $37 = $d_sroa_1_4_extract_trunc - 1 | 0;
  if (!($37 & $d_sroa_1_4_extract_trunc)) {
   if ($rem | 0) {
    HEAP32[$rem >> 2] = $a$0 | 0;
    HEAP32[$rem + 4 >> 2] = $37 & $n_sroa_1_4_extract_trunc | $a$1 & 0;
   }
   $_0$1 = 0;
   $_0$0 = $n_sroa_1_4_extract_trunc >>> ((_llvm_cttz_i32($d_sroa_1_4_extract_trunc | 0) | 0) >>> 0);
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
  $51 = (Math_clz32($d_sroa_1_4_extract_trunc | 0) | 0) - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
  if ($51 >>> 0 <= 30) {
   $57 = $51 + 1 | 0;
   $58 = 31 - $51 | 0;
   $sr_1_ph = $57;
   $r_sroa_0_1_ph = $n_sroa_1_4_extract_trunc << $58 | $n_sroa_0_0_extract_trunc >>> ($57 >>> 0);
   $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($57 >>> 0);
   $q_sroa_0_1_ph = 0;
   $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $58;
   break;
  }
  if (!$rem) {
   $_0$1 = 0;
   $_0$0 = 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
  HEAP32[$rem >> 2] = $a$0 | 0;
  HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
  $_0$1 = 0;
  $_0$0 = 0;
  return (tempRet0 = $_0$1, $_0$0) | 0;
 } else {
  if (!$17) {
   $119 = (Math_clz32($d_sroa_1_4_extract_trunc | 0) | 0) - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
   if ($119 >>> 0 <= 31) {
    $125 = $119 + 1 | 0;
    $126 = 31 - $119 | 0;
    $130 = $119 - 31 >> 31;
    $sr_1_ph = $125;
    $r_sroa_0_1_ph = $n_sroa_0_0_extract_trunc >>> ($125 >>> 0) & $130 | $n_sroa_1_4_extract_trunc << $126;
    $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($125 >>> 0) & $130;
    $q_sroa_0_1_ph = 0;
    $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $126;
    break;
   }
   if (!$rem) {
    $_0$1 = 0;
    $_0$0 = 0;
    return (tempRet0 = $_0$1, $_0$0) | 0;
   }
   HEAP32[$rem >> 2] = $a$0 | 0;
   HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
   $_0$1 = 0;
   $_0$0 = 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
  $66 = $d_sroa_0_0_extract_trunc - 1 | 0;
  if ($66 & $d_sroa_0_0_extract_trunc | 0) {
   $88 = (Math_clz32($d_sroa_0_0_extract_trunc | 0) | 0) + 33 - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
   $89 = 64 - $88 | 0;
   $91 = 32 - $88 | 0;
   $92 = $91 >> 31;
   $95 = $88 - 32 | 0;
   $105 = $95 >> 31;
   $sr_1_ph = $88;
   $r_sroa_0_1_ph = $91 - 1 >> 31 & $n_sroa_1_4_extract_trunc >>> ($95 >>> 0) | ($n_sroa_1_4_extract_trunc << $91 | $n_sroa_0_0_extract_trunc >>> ($88 >>> 0)) & $105;
   $r_sroa_1_1_ph = $105 & $n_sroa_1_4_extract_trunc >>> ($88 >>> 0);
   $q_sroa_0_1_ph = $n_sroa_0_0_extract_trunc << $89 & $92;
   $q_sroa_1_1_ph = ($n_sroa_1_4_extract_trunc << $89 | $n_sroa_0_0_extract_trunc >>> ($95 >>> 0)) & $92 | $n_sroa_0_0_extract_trunc << $91 & $88 - 33 >> 31;
   break;
  }
  if ($rem | 0) {
   HEAP32[$rem >> 2] = $66 & $n_sroa_0_0_extract_trunc;
   HEAP32[$rem + 4 >> 2] = 0;
  }
  if (($d_sroa_0_0_extract_trunc | 0) == 1) {
   $_0$1 = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
   $_0$0 = $a$0 | 0 | 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  } else {
   $78 = _llvm_cttz_i32($d_sroa_0_0_extract_trunc | 0) | 0;
   $_0$1 = $n_sroa_1_4_extract_trunc >>> ($78 >>> 0) | 0;
   $_0$0 = $n_sroa_1_4_extract_trunc << 32 - $78 | $n_sroa_0_0_extract_trunc >>> ($78 >>> 0) | 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
 } while (0);
 if (!$sr_1_ph) {
  $q_sroa_1_1_lcssa = $q_sroa_1_1_ph;
  $q_sroa_0_1_lcssa = $q_sroa_0_1_ph;
  $r_sroa_1_1_lcssa = $r_sroa_1_1_ph;
  $r_sroa_0_1_lcssa = $r_sroa_0_1_ph;
  $carry_0_lcssa$1 = 0;
  $carry_0_lcssa$0 = 0;
 } else {
  $d_sroa_0_0_insert_insert99$0 = $b$0 | 0 | 0;
  $d_sroa_0_0_insert_insert99$1 = $d_sroa_1_4_extract_shift$0 | $b$1 & 0;
  $137$0 = _i64Add($d_sroa_0_0_insert_insert99$0 | 0, $d_sroa_0_0_insert_insert99$1 | 0, -1, -1) | 0;
  $137$1 = tempRet0;
  $q_sroa_1_1198 = $q_sroa_1_1_ph;
  $q_sroa_0_1199 = $q_sroa_0_1_ph;
  $r_sroa_1_1200 = $r_sroa_1_1_ph;
  $r_sroa_0_1201 = $r_sroa_0_1_ph;
  $sr_1202 = $sr_1_ph;
  $carry_0203 = 0;
  do {
   $q_sroa_1_1198$looptemp = $q_sroa_1_1198;
   $q_sroa_1_1198 = $q_sroa_0_1199 >>> 31 | $q_sroa_1_1198 << 1;
   $q_sroa_0_1199 = $carry_0203 | $q_sroa_0_1199 << 1;
   $r_sroa_0_0_insert_insert42$0 = $r_sroa_0_1201 << 1 | $q_sroa_1_1198$looptemp >>> 31 | 0;
   $r_sroa_0_0_insert_insert42$1 = $r_sroa_0_1201 >>> 31 | $r_sroa_1_1200 << 1 | 0;
   _i64Subtract($137$0 | 0, $137$1 | 0, $r_sroa_0_0_insert_insert42$0 | 0, $r_sroa_0_0_insert_insert42$1 | 0) | 0;
   $150$1 = tempRet0;
   $151$0 = $150$1 >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1;
   $carry_0203 = $151$0 & 1;
   $r_sroa_0_1201 = _i64Subtract($r_sroa_0_0_insert_insert42$0 | 0, $r_sroa_0_0_insert_insert42$1 | 0, $151$0 & $d_sroa_0_0_insert_insert99$0 | 0, ((($150$1 | 0) < 0 ? -1 : 0) >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1) & $d_sroa_0_0_insert_insert99$1 | 0) | 0;
   $r_sroa_1_1200 = tempRet0;
   $sr_1202 = $sr_1202 - 1 | 0;
  } while (($sr_1202 | 0) != 0);
  $q_sroa_1_1_lcssa = $q_sroa_1_1198;
  $q_sroa_0_1_lcssa = $q_sroa_0_1199;
  $r_sroa_1_1_lcssa = $r_sroa_1_1200;
  $r_sroa_0_1_lcssa = $r_sroa_0_1201;
  $carry_0_lcssa$1 = 0;
  $carry_0_lcssa$0 = $carry_0203;
 }
 $q_sroa_0_0_insert_ext75$0 = $q_sroa_0_1_lcssa;
 $q_sroa_0_0_insert_ext75$1 = 0;
 if ($rem | 0) {
  HEAP32[$rem >> 2] = $r_sroa_0_1_lcssa;
  HEAP32[$rem + 4 >> 2] = $r_sroa_1_1_lcssa;
 }
 $_0$1 = ($q_sroa_0_0_insert_ext75$0 | 0) >>> 31 | ($q_sroa_1_1_lcssa | $q_sroa_0_0_insert_ext75$1) << 1 | ($q_sroa_0_0_insert_ext75$1 << 1 | $q_sroa_0_0_insert_ext75$0 >>> 31) & 0 | $carry_0_lcssa$1;
 $_0$0 = ($q_sroa_0_0_insert_ext75$0 << 1 | 0 >>> 31) & -2 | $carry_0_lcssa$0;
 return (tempRet0 = $_0$1, $_0$0) | 0;
}

function _ParseEntity($doc, $mode) {
 $doc = $doc | 0;
 $mode = $mode | 0;
 var $$lcssa = 0, $$lcssa201 = 0, $$lcssa207 = 0, $$lcssa215 = 0, $$lcssa23$ph$us = 0, $$lcssa24 = 0, $$lcssa25 = 0, $$pre = 0, $1 = 0, $116 = 0, $119 = 0, $128 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $18 = 0, $20 = 0, $21 = 0, $29 = 0, $3 = 0, $30 = 0, $39 = 0, $4 = 0, $40 = 0, $47 = 0, $48 = 0, $5 = 0, $6 = 0, $61 = 0, $7 = 0, $8 = 0, $82 = 0, $83 = 0, $9 = 0, $91 = 0, $95 = 0, $98 = 0, $99 = 0, $ch = 0, $charRead$0 = 0, $charRead$0$ph = 0, $charRead$0$us = 0, $charRead$0$us$us = 0, $charRead$0$us31 = 0, $entState$0$ph = 0, $entver = 0, $preserveEntities$019778081 = 0, $preserveEntities$019778082 = 0, $semicolon$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ch = sp + 4 | 0;
 $entver = sp;
 $1 = HEAP32[$doc + 168 >> 2] | 0;
 $3 = HEAP32[$doc + 432 >> 2] | 0;
 HEAP32[$entver >> 2] = 0;
 $4 = $doc + 68 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 $6 = $5 + 92 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $7 + -1 | 0;
 $9 = $doc + 6776 | 0;
 $13 = (HEAP32[(HEAP32[$9 >> 2] | 0) + 288 >> 2] | 0) + -1 | 0;
 $14 = ($1 | 0) == 0;
 $15 = $doc + 376 | 0;
 $16 = $doc + 92 | 0;
 $charRead$0$ph = 0;
 $entState$0$ph = 0;
 L1 : while (1) {
  $18 = 64056 + ($entState$0$ph << 2) | 0;
  L3 : do if (($entState$0$ph | 0) == 1) {
   L5 : do if ($14) {
    $charRead$0$us$us = $charRead$0$ph;
    while (1) {
     $20 = _prvTidyReadChar(HEAP32[$9 >> 2] | 0) | 0;
     switch ($20 | 0) {
     case 59:
      {
       $82 = $20;
       $semicolon$0 = 1;
       break L1;
       break;
      }
     case -1:
      {
       $$lcssa215 = $20;
       label = 30;
       break L1;
       break;
      }
     default:
      {}
     }
     $21 = $charRead$0$us$us + 1 | 0;
     if (($charRead$0$us$us | 0) == 0 & ($20 | 0) == 35) {
      $$lcssa25 = $21;
      break L3;
     }
     if (($21 | 0) == 2) switch ($20 | 0) {
     case 88:
     case 120:
      {
       $$lcssa23$ph$us = $20;
       break L5;
       break;
      }
     default:
      {}
     }
     if (!(FUNCTION_TABLE_ii[HEAP32[$18 >> 2] & 31]($20) | 0)) {
      $$lcssa24 = $20;
      label = 29;
      break L1;
     }
     _prvTidyAddCharToLexer($5, $20);
     $charRead$0$us$us = $21;
    }
   } else {
    $charRead$0$us = $charRead$0$ph;
    while (1) {
     $29 = _prvTidyReadChar(HEAP32[$9 >> 2] | 0) | 0;
     switch ($29 | 0) {
     case -1:
      {
       $$lcssa207 = $29;
       label = 31;
       break L1;
       break;
      }
     case 59:
      {
       $82 = $29;
       $semicolon$0 = 1;
       break L1;
       break;
      }
     default:
      {}
     }
     $30 = $charRead$0$us + 1 | 0;
     if (($charRead$0$us | 0) == 0 & ($29 | 0) == 35) {
      $$lcssa25 = $30;
      break L3;
     }
     if (($30 | 0) == 2 & ($29 | 0) == 120) {
      $$lcssa23$ph$us = 120;
      break L5;
     }
     if (!(FUNCTION_TABLE_ii[HEAP32[$18 >> 2] & 31]($29) | 0)) {
      $$lcssa24 = $29;
      label = 29;
      break L1;
     }
     _prvTidyAddCharToLexer($5, $29);
     $charRead$0$us = $30;
    }
   } while (0);
   _prvTidyAddCharToLexer($5, $$lcssa23$ph$us);
   $charRead$0$ph = 2;
   $entState$0$ph = 2;
   continue L1;
  } else if ($14) {
   $charRead$0$us31 = $charRead$0$ph;
   while (1) {
    $39 = _prvTidyReadChar(HEAP32[$9 >> 2] | 0) | 0;
    switch ($39 | 0) {
    case 59:
     {
      $82 = $39;
      $semicolon$0 = 1;
      break L1;
      break;
     }
    case -1:
     {
      $$lcssa201 = $39;
      label = 32;
      break L1;
      break;
     }
    default:
     {}
    }
    $40 = $charRead$0$us31 + 1 | 0;
    if (($charRead$0$us31 | 0) == 0 & ($39 | 0) == 35) {
     $$lcssa25 = $40;
     break L3;
    }
    if (!(FUNCTION_TABLE_ii[HEAP32[$18 >> 2] & 31]($39) | 0)) {
     $$lcssa24 = $39;
     label = 29;
     break L1;
    }
    _prvTidyAddCharToLexer($5, $39);
    $charRead$0$us31 = $40;
   }
  } else {
   $charRead$0 = $charRead$0$ph;
   while (1) {
    $47 = _prvTidyReadChar(HEAP32[$9 >> 2] | 0) | 0;
    switch ($47 | 0) {
    case 59:
     {
      $82 = $47;
      $semicolon$0 = 1;
      break L1;
      break;
     }
    case -1:
     {
      $$lcssa = $47;
      label = 33;
      break L1;
      break;
     }
    default:
     {}
    }
    $48 = $charRead$0 + 1 | 0;
    if (($charRead$0 | 0) == 0 & ($47 | 0) == 35) {
     $$lcssa25 = $48;
     break L3;
    }
    if (!(FUNCTION_TABLE_ii[HEAP32[$18 >> 2] & 31]($47) | 0)) {
     $$lcssa24 = $47;
     label = 29;
     break L1;
    }
    _prvTidyAddCharToLexer($5, $47);
    $charRead$0 = $48;
   }
  } while (0);
  if (!(HEAP32[$15 >> 2] | 0)) {
   label = 24;
   break;
  }
  if ((HEAP32[$16 >> 2] & -2 | 0) == 12) {
   label = 24;
   break;
  }
  _prvTidyAddCharToLexer($5, 35);
  $charRead$0$ph = $$lcssa25;
  $entState$0$ph = 1;
 }
 if ((label | 0) == 24) {
  _prvTidyUngetChar(35, HEAP32[$9 >> 2] | 0);
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 29) {
  _prvTidyUngetChar($$lcssa24, HEAP32[$9 >> 2] | 0);
  $82 = $$lcssa24;
  $semicolon$0 = 0;
 } else if ((label | 0) == 30) {
  $82 = $$lcssa215;
  $semicolon$0 = 0;
 } else if ((label | 0) == 31) {
  $82 = $$lcssa207;
  $semicolon$0 = 0;
 } else if ((label | 0) == 32) {
  $82 = $$lcssa201;
  $semicolon$0 = 0;
 } else if ((label | 0) == 33) {
  $82 = $$lcssa;
  $semicolon$0 = 0;
 }
 $61 = $5 + 84 | 0;
 HEAP8[(HEAP32[$61 >> 2] | 0) + (HEAP32[$6 >> 2] | 0) >> 0] = 0;
 if (!(_prvTidytmbstrcmp((HEAP32[$61 >> 2] | 0) + $8 | 0, 310435) | 0)) if (!(HEAP32[$doc + 172 >> 2] | 0)) if (!(HEAP32[$5 + 28 >> 2] | 0)) if (!(HEAP32[$doc + 176 >> 2] | 0)) if ((_prvTidyHTMLVersion($doc) | 0) != 131072) _prvTidyReportEntityError($doc, 205, (HEAP32[$61 >> 2] | 0) + $8 | 0, 39);
 $83 = ($82 | 0) == 59;
 do if (($mode | 0) == 4 & $83) {
  HEAP32[$ch >> 2] = 255;
  HEAP32[$entver >> 2] = 393216;
  if (($82 | 0) == 59) label = 58; else {
   $preserveEntities$019778082 = 1;
   label = 56;
  }
 } else {
  if (_prvTidyEntityInfo((HEAP32[$61 >> 2] | 0) + $8 | 0, $1, $ch, $entver) | 0) {
   $$pre = HEAP32[$ch >> 2] | 0;
   if (($$pre & -32 | 0) != 128) {
    $91 = ($82 | 0) != 59;
    if (!($91 & $$pre >>> 0 > 255)) if ($91) {
     $preserveEntities$019778082 = $3;
     label = 56;
     break;
    } else {
     $preserveEntities$019778081 = $3;
     label = 57;
     break;
    }
   }
  }
  HEAP32[$5 >> 2] = HEAP32[(HEAP32[$9 >> 2] | 0) + 292 >> 2];
  HEAP32[$5 + 4 >> 2] = $13;
  if ((HEAP32[$6 >> 2] | 0) >>> 0 <= $7 >>> 0) {
   if ((_prvTidyHTMLVersion($doc) | 0) == 131072) {
    STACKTOP = sp;
    return;
   }
   _prvTidyReportEntityError($doc, 204, (HEAP32[$61 >> 2] | 0) + $8 | 0, HEAP32[$ch >> 2] | 0);
   STACKTOP = sp;
   return;
  }
  $95 = HEAP32[$ch >> 2] | 0;
  if (($95 & -32 | 0) != 128) {
   _prvTidyReportEntityError($doc, 203, (HEAP32[$61 >> 2] | 0) + $8 | 0, $95);
   if (!$semicolon$0) {
    STACKTOP = sp;
    return;
   }
   _prvTidyAddCharToLexer($5, 59);
   STACKTOP = sp;
   return;
  }
  $98 = _prvTidyDecodeWin1252($95) | 0;
  $99 = ($98 | 0) != 0;
  if (!$83) _prvTidyReportEntityError($doc, 202, (HEAP32[$61 >> 2] | 0) + $8 | 0, $82);
  _prvTidyReportEncodingError($doc, 297, HEAP32[$ch >> 2] | 0, $99 & 1 ^ 1);
  HEAP32[$6 >> 2] = $8;
  if (!$99) {
   STACKTOP = sp;
   return;
  }
  _prvTidyAddCharToLexer($5, $98);
  STACKTOP = sp;
  return;
 } while (0);
 if ((label | 0) == 56) {
  HEAP32[$5 >> 2] = HEAP32[(HEAP32[$9 >> 2] | 0) + 292 >> 2];
  HEAP32[$5 + 4 >> 2] = $13;
  _prvTidyReportEntityError($doc, 201, (HEAP32[$61 >> 2] | 0) + $8 | 0, $82);
  $preserveEntities$019778081 = $preserveEntities$019778082;
  label = 57;
 }
 if ((label | 0) == 57) if (!$preserveEntities$019778081) {
  HEAP32[$6 >> 2] = $8;
  $116 = HEAP32[$ch >> 2] | 0;
  if (($mode | 0) == 2 & ($116 | 0) == 160) {
   HEAP32[$ch >> 2] = 32;
   $119 = 32;
  } else $119 = $116;
  _prvTidyAddCharToLexer($5, $119);
  if ((HEAP32[$ch >> 2] | 0) == 38) if (!(HEAP32[$doc + 252 >> 2] | 0)) {
   _prvTidyAddCharToLexer($5, 97);
   _prvTidyAddCharToLexer($5, 109);
   _prvTidyAddCharToLexer($5, 112);
   _prvTidyAddCharToLexer($5, 59);
  }
 } else label = 58;
 if ((label | 0) == 58) _prvTidyAddCharToLexer($5, 59);
 $128 = (HEAP32[$4 >> 2] | 0) + 32 | 0;
 HEAP32[$128 >> 2] = HEAP32[$128 >> 2] & (HEAP32[$entver >> 2] | 57344);
 STACKTOP = sp;
 return;
}

function _prvTidyFixDocType($doc) {
 $doc = $doc | 0;
 var $$0 = 0, $$0$i = 0, $$0$i14 = 0, $$0$i7 = 0, $$0$i8 = 0, $0 = 0, $1 = 0, $125 = 0, $126 = 0, $127 = 0, $13 = 0, $16 = 0, $19 = 0, $2 = 0, $25 = 0, $33 = 0, $4 = 0, $42 = 0, $45 = 0, $46 = 0, $58 = 0, $59 = 0, $63 = 0, $67 = 0, $71 = 0, $74 = 0, $82 = 0, $85 = 0, $91 = 0, $doctype$0 = 0, $doctype$1 = 0, $guessed$0$ph = 0, $guessed$023 = 0, $hadSI$021 = 0, $i$02$lcssa$i = 0, $i$02$lcssa$i6 = 0, $node$0$lcssa$i1617 = 0, $node$0$lcssa$i161730 = 0, $node$0$lcssa$i1618 = 0, $node$01$i = 0, $node$01$i$lcssa = 0, $node$01$i10 = 0, $node$02$i$i = 0, $node$02$i$i$lcssa = 0, dest = 0, label = 0, stop = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = ($doc | 0) == 0;
 L1 : do if ($2) label = 5; else {
  $4 = HEAP32[$doc + 12 >> 2] | 0;
  if (!$4) label = 5; else {
   $node$01$i = $4;
   while (1) {
    if ((HEAP32[$node$01$i + 44 >> 2] | 0) == 1) {
     $node$01$i$lcssa = $node$01$i;
     break;
    }
    $node$01$i = HEAP32[$node$01$i + 8 >> 2] | 0;
    if (!$node$01$i) {
     label = 5;
     break L1;
    }
   }
   $16 = HEAP32[$doc + 104 >> 2] | 0;
   if (($16 | 0) == 2) {
    $19 = HEAP32[$1 + 36 >> 2] | 0;
    if (($19 | 0) == 393216) {
     HEAP32[$1 + 40 >> 2] = 131072;
     $$0 = 1;
     return $$0 | 0;
    } else {
     $126 = 1;
     $25 = $19;
     $node$0$lcssa$i1618 = $node$01$i$lcssa;
     label = 10;
    }
   } else {
    $125 = 1;
    $42 = $16;
    $node$0$lcssa$i1617 = $node$01$i$lcssa;
    label = 17;
   }
  }
 } while (0);
 if ((label | 0) == 5) {
  $13 = HEAP32[$doc + 104 >> 2] | 0;
  if (($13 | 0) == 2) {
   $126 = 0;
   $25 = HEAP32[$1 + 36 >> 2] | 0;
   $node$0$lcssa$i1618 = 0;
   label = 10;
  } else {
   $125 = 0;
   $42 = $13;
   $node$0$lcssa$i1617 = 0;
   label = 17;
  }
 }
 L13 : do if ((label | 0) == 10) if (!($25 & HEAP32[$1 + 32 >> 2])) {
  $127 = $126;
  $59 = 2;
  $node$0$lcssa$i161730 = $node$0$lcssa$i1618;
 } else {
  if ($25 & 270080 | 0) if (!(HEAP32[$1 + 28 >> 2] | 0)) {
   $127 = $126;
   $59 = 2;
   $node$0$lcssa$i161730 = $node$0$lcssa$i1618;
   break;
  }
  $33 = HEAP32[$doc + 12 >> 2] | 0;
  if (!$33) {
   $127 = $126;
   $59 = 2;
   $node$0$lcssa$i161730 = $node$0$lcssa$i1618;
  } else {
   $node$01$i10 = $33;
   while (1) {
    if ((HEAP32[$node$01$i10 + 44 >> 2] | 0) == 1) break;
    $node$01$i10 = HEAP32[$node$01$i10 + 8 >> 2] | 0;
    if (!$node$01$i10) {
     $127 = $126;
     $59 = 2;
     $node$0$lcssa$i161730 = $node$0$lcssa$i1618;
     break L13;
    }
   }
   HEAP32[$1 + 40 >> 2] = $25;
   $$0 = 1;
   return $$0 | 0;
  }
 } else if ((label | 0) == 17) if (($42 | 0) == 1) {
  if ($125) {
   _prvTidyDiscardElement($doc, $node$0$lcssa$i1617) | 0;
   $45 = HEAP32[$0 >> 2] | 0;
  } else $45 = $1;
  $46 = HEAP32[$45 + 36 >> 2] | 0;
  switch ($46 | 0) {
  case 4096:
  case 2048:
   {
    if (!(HEAP32[$45 + 32 >> 2] & $46)) label = 22; else $$0$i14 = $46;
    break;
   }
  default:
   label = 22;
  }
  if ((label | 0) == 22) $$0$i14 = _prvTidyHTMLVersion($doc) | 0;
  HEAP32[$1 + 40 >> 2] = $$0$i14;
  $$0 = 1;
  return $$0 | 0;
 } else {
  $127 = $125;
  $59 = $42;
  $node$0$lcssa$i161730 = $node$0$lcssa$i1617;
 } while (0);
 if (HEAP32[$doc + 172 >> 2] | 0) {
  $$0 = 1;
  return $$0 | 0;
 }
 if ($127) {
  $58 = (_prvTidyGetAttrByName($node$0$lcssa$i161730, 310777) | 0) != 0 & 1;
  if (($59 + -3 | 0) >>> 0 < 2) {
   _prvTidyDiscardElement($doc, $node$0$lcssa$i161730) | 0;
   $doctype$0 = 0;
   $hadSI$021 = $58;
  } else {
   $doctype$0 = $node$0$lcssa$i161730;
   $hadSI$021 = $58;
  }
 } else {
  $doctype$0 = $node$0$lcssa$i161730;
  $hadSI$021 = 0;
 }
 switch ($59 | 0) {
 case 0:
  {
   $guessed$0$ph = 131072;
   label = 32;
   break;
  }
 case 3:
  {
   $guessed$0$ph = 32;
   label = 32;
   break;
  }
 case 4:
  {
   $guessed$0$ph = 64;
   label = 32;
   break;
  }
 case 2:
  {
   $63 = _prvTidyHTMLVersion($doc) | 0;
   HEAP32[$1 + 40 >> 2] = $63;
   if (!$63) {
    $$0 = 0;
    return $$0 | 0;
   } else $guessed$023 = $63;
   break;
  }
 default:
  {
   HEAP32[$1 + 40 >> 2] = 0;
   $$0 = 0;
   return $$0 | 0;
  }
 }
 if ((label | 0) == 32) {
  HEAP32[$1 + 40 >> 2] = $guessed$0$ph;
  $guessed$023 = $guessed$0$ph;
 }
 if (!$doctype$0) {
  L55 : do if ($2) $$0$i8 = 0; else {
   $71 = HEAP32[$doc + 12 >> 2] | 0;
   if (!$71) $$0$i8 = 0; else {
    $node$02$i$i = $71;
    while (1) {
     $74 = HEAP32[$node$02$i$i + 28 >> 2] | 0;
     if ($74 | 0) if ((HEAP32[$74 >> 2] | 0) == 48) {
      $node$02$i$i$lcssa = $node$02$i$i;
      break;
     }
     $node$02$i$i = HEAP32[$node$02$i$i + 8 >> 2] | 0;
     if (!$node$02$i$i) {
      $$0$i8 = 0;
      break L55;
     }
    }
    $82 = HEAP32[$doc + 6856 >> 2] | 0;
    $85 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$82 >> 2] >> 2] & 31]($82, 68) | 0;
    dest = $85;
    stop = dest + 68 | 0;
    do {
     HEAP32[dest >> 2] = 0;
     dest = dest + 4 | 0;
    } while ((dest | 0) < (stop | 0));
    HEAP32[$85 + 44 >> 2] = 1;
    _prvTidyInsertNodeBeforeElement($node$02$i$i$lcssa, $85);
    $$0$i8 = $85;
   }
  } while (0);
  HEAP32[$$0$i8 + 32 >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, 310346) | 0;
  $doctype$1 = $$0$i8;
 } else {
  $67 = $doctype$0 + 32 | 0;
  HEAP32[$67 >> 2] = _prvTidytmbstrtolower(HEAP32[$67 >> 2] | 0) | 0;
  $doctype$1 = $doctype$0;
 }
 $91 = ($guessed$023 | 0) == 1;
 if ($91) {
  $i$02$lcssa$i6 = 0;
  label = 44;
 } else if (($guessed$023 | 0) == 2) {
  $i$02$lcssa$i6 = 3;
  label = 44;
 } else if (($guessed$023 | 0) == 4) {
  $i$02$lcssa$i6 = 6;
  label = 44;
 } else if (($guessed$023 | 0) == 8) {
  $i$02$lcssa$i6 = 7;
  label = 44;
 } else if (($guessed$023 | 0) == 16) {
  $i$02$lcssa$i6 = 8;
  label = 44;
 } else if (($guessed$023 | 0) == 32) {
  $i$02$lcssa$i6 = 9;
  label = 44;
 } else if (($guessed$023 | 0) == 64) {
  $i$02$lcssa$i6 = 10;
  label = 44;
 } else if (($guessed$023 | 0) == 128) {
  $i$02$lcssa$i6 = 11;
  label = 44;
 } else if (($guessed$023 | 0) == 256) {
  $i$02$lcssa$i6 = 12;
  label = 44;
 } else if (($guessed$023 | 0) == 512) {
  $i$02$lcssa$i6 = 13;
  label = 44;
 } else if (($guessed$023 | 0) == 1024) {
  $i$02$lcssa$i6 = 14;
  label = 44;
 } else if (($guessed$023 | 0) == 2048) {
  $i$02$lcssa$i6 = 15;
  label = 44;
 } else if (($guessed$023 | 0) == 4096) {
  $i$02$lcssa$i6 = 16;
  label = 44;
 } else if (($guessed$023 | 0) == 131072) {
  $i$02$lcssa$i6 = 17;
  label = 44;
 } else if (($guessed$023 | 0) == 262144) {
  $i$02$lcssa$i6 = 18;
  label = 44;
 } else $$0$i7 = 0;
 if ((label | 0) == 44) $$0$i7 = HEAP32[63656 + ($i$02$lcssa$i6 * 20 | 0) + 12 >> 2] | 0;
 _prvTidyRepairAttrValue($doc, $doctype$1, 310770, $$0$i7) | 0;
 if (!$hadSI$021) {
  $$0 = 1;
  return $$0 | 0;
 }
 do if ($91) {
  $i$02$lcssa$i = 0;
  label = 61;
 } else if (($guessed$023 | 0) == 2) {
  $i$02$lcssa$i = 3;
  label = 61;
 } else if (($guessed$023 | 0) == 4) {
  $i$02$lcssa$i = 6;
  label = 61;
 } else if (($guessed$023 | 0) == 8) {
  $i$02$lcssa$i = 7;
  label = 61;
 } else if (($guessed$023 | 0) == 16) {
  $i$02$lcssa$i = 8;
  label = 61;
 } else if (($guessed$023 | 0) == 32) {
  $i$02$lcssa$i = 9;
  label = 61;
 } else if (($guessed$023 | 0) == 64) {
  $i$02$lcssa$i = 10;
  label = 61;
 } else if (($guessed$023 | 0) == 128) {
  $i$02$lcssa$i = 11;
  label = 61;
 } else if (($guessed$023 | 0) == 256) {
  $i$02$lcssa$i = 12;
  label = 61;
 } else if (($guessed$023 | 0) == 512) {
  $i$02$lcssa$i = 13;
  label = 61;
 } else if (($guessed$023 | 0) == 1024) {
  $i$02$lcssa$i = 14;
  label = 61;
 } else if (($guessed$023 | 0) == 2048) {
  $i$02$lcssa$i = 15;
  label = 61;
 } else if (($guessed$023 | 0) == 4096) {
  $i$02$lcssa$i = 16;
  label = 61;
 } else {
  if (($guessed$023 | 0) == 131072) {
   $i$02$lcssa$i = 17;
   label = 61;
   break;
  }
  if (($guessed$023 | 0) == 262144) {
   $i$02$lcssa$i = 18;
   label = 61;
  } else $$0$i = 0;
 } while (0);
 if ((label | 0) == 61) $$0$i = HEAP32[63656 + ($i$02$lcssa$i * 20 | 0) + 16 >> 2] | 0;
 _prvTidyRepairAttrValue($doc, $doctype$1, 310777, $$0$i) | 0;
 $$0 = 1;
 return $$0 | 0;
}

function _ParseAttribute($doc, $isempty, $asp, $php) {
 $doc = $doc | 0;
 $isempty = $isempty | 0;
 $asp = $asp | 0;
 $php = $php | 0;
 var $$0 = 0, $$lcssa81 = 0, $0 = 0, $1 = 0, $10 = 0, $106 = 0, $107 = 0, $109 = 0, $114 = 0, $117 = 0, $127 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $15 = 0, $17 = 0, $19 = 0, $2 = 0, $21 = 0, $24 = 0, $3 = 0, $32 = 0, $33 = 0, $37 = 0, $40 = 0, $5 = 0, $54 = 0, $55 = 0, $56 = 0, $58 = 0, $60 = 0, $62 = 0, $65 = 0, $7 = 0, $73 = 0, $74 = 0, $78 = 0, $81 = 0, $95 = 0, $asp$0$i = 0, $c$047 = 0, $c$1$lcssa = 0, $c$136 = 0, $c$136$lcssa = 0, $c$136$lcssa74 = 0, $c$2 = 0, $doc$idx$val$i = 0, $doc$idx$val$i11 = 0, $lastc$037 = 0, $php$0$i = 0, dest = 0, label = 0, stop = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 HEAP32[$asp >> 2] = 0;
 HEAP32[$php >> 2] = 0;
 $2 = $doc + 6776 | 0;
 $3 = $1 + 60 | 0;
 L1 : while (1) {
  $5 = _prvTidyReadChar(HEAP32[$2 >> 2] | 0) | 0;
  switch ($5 | 0) {
  case 47:
   {
    label = 3;
    break L1;
    break;
   }
  case 60:
   {
    label = 6;
    break L1;
    break;
   }
  case -1:
   {
    label = 32;
    break L1;
    break;
   }
  case 62:
   {
    $$0 = 0;
    label = 52;
    break L1;
    break;
   }
  case 61:
   {
    _prvTidyReportAttrError($doc, HEAP32[$3 >> 2] | 0, 0, 268);
    continue L1;
    break;
   }
  case 34:
  case 39:
   {
    _prvTidyReportAttrError($doc, HEAP32[$3 >> 2] | 0, 0, 258);
    continue L1;
    break;
   }
  default:
   {
    if ($5 >>> 0 >= 128) {
     $$lcssa81 = $5;
     label = 35;
     break L1;
    }
    if (!(HEAP32[316488 + ($5 << 2) >> 2] & 8)) {
     $$lcssa81 = $5;
     label = 35;
     break L1;
    } else continue L1;
   }
  }
 }
 do if ((label | 0) == 3) {
  $7 = _prvTidyReadChar(HEAP32[$2 >> 2] | 0) | 0;
  if (($7 | 0) != 62) {
   _prvTidyUngetChar($7, HEAP32[$2 >> 2] | 0);
   $10 = $1 + 92 | 0;
   $114 = $10;
   $140 = HEAP32[$10 >> 2] | 0;
   $c$047 = 47;
   label = 36;
   break;
  }
  HEAP32[$isempty >> 2] = 1;
  $$0 = 0;
  return $$0 | 0;
 } else if ((label | 0) == 6) {
  $13 = _prvTidyReadChar(HEAP32[$2 >> 2] | 0) | 0;
  switch ($13 | 0) {
  case 37:
   {
    $14 = HEAP32[$0 >> 2] | 0;
    $15 = $14 + 92 | 0;
    $17 = $14 + 48 | 0;
    HEAP32[$17 >> 2] = HEAP32[$15 >> 2];
    $19 = _prvTidyReadChar(HEAP32[$2 >> 2] | 0) | 0;
    L19 : do if (($19 | 0) != -1) {
     $21 = $19;
     while (1) {
      _prvTidyAddCharToLexer($14, $21);
      if (($21 | 0) == 37) {
       $24 = _prvTidyReadChar(HEAP32[$2 >> 2] | 0) | 0;
       if (($24 | 0) == -1) break L19;
       _prvTidyAddCharToLexer($14, $24);
       if (($24 | 0) == 62) break;
      }
      $21 = _prvTidyReadChar(HEAP32[$2 >> 2] | 0) | 0;
      if (($21 | 0) == -1) break L19;
     }
     HEAP32[$15 >> 2] = (HEAP32[$15 >> 2] | 0) + -2;
    } while (0);
    $32 = HEAP32[$15 >> 2] | 0;
    $33 = $14 + 52 | 0;
    HEAP32[$33 >> 2] = $32;
    if ($32 >>> 0 > (HEAP32[$17 >> 2] | 0) >>> 0) {
     $doc$idx$val$i = HEAP32[$0 >> 2] | 0;
     $37 = HEAP32[$doc$idx$val$i + 124 >> 2] | 0;
     $40 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$37 >> 2] >> 2] & 31]($37, 68) | 0;
     dest = $40;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($doc$idx$val$i | 0) {
      HEAP32[$40 + 48 >> 2] = HEAP32[$doc$idx$val$i >> 2];
      HEAP32[$40 + 52 >> 2] = HEAP32[$doc$idx$val$i + 4 >> 2];
     }
     HEAP32[$40 + 44 >> 2] = 10;
     HEAP32[$40 + 36 >> 2] = HEAP32[$doc$idx$val$i + 48 >> 2];
     HEAP32[$40 + 40 >> 2] = HEAP32[$doc$idx$val$i + 52 >> 2];
     $54 = HEAP32[$33 >> 2] | 0;
     $asp$0$i = $40;
    } else {
     $54 = $32;
     $asp$0$i = 0;
    }
    HEAP32[$17 >> 2] = $54;
    HEAP32[$asp >> 2] = $asp$0$i;
    $$0 = 0;
    return $$0 | 0;
   }
  case 63:
   {
    $55 = HEAP32[$0 >> 2] | 0;
    $56 = $55 + 92 | 0;
    $58 = $55 + 48 | 0;
    HEAP32[$58 >> 2] = HEAP32[$56 >> 2];
    $60 = _prvTidyReadChar(HEAP32[$2 >> 2] | 0) | 0;
    L36 : do if (($60 | 0) != -1) {
     $62 = $60;
     while (1) {
      _prvTidyAddCharToLexer($55, $62);
      if (($62 | 0) == 63) {
       $65 = _prvTidyReadChar(HEAP32[$2 >> 2] | 0) | 0;
       if (($65 | 0) == -1) break L36;
       _prvTidyAddCharToLexer($55, $65);
       if (($65 | 0) == 62) break;
      }
      $62 = _prvTidyReadChar(HEAP32[$2 >> 2] | 0) | 0;
      if (($62 | 0) == -1) break L36;
     }
     HEAP32[$56 >> 2] = (HEAP32[$56 >> 2] | 0) + -2;
    } while (0);
    $73 = HEAP32[$56 >> 2] | 0;
    $74 = $55 + 52 | 0;
    HEAP32[$74 >> 2] = $73;
    if ($73 >>> 0 > (HEAP32[$58 >> 2] | 0) >>> 0) {
     $doc$idx$val$i11 = HEAP32[$0 >> 2] | 0;
     $78 = HEAP32[$doc$idx$val$i11 + 124 >> 2] | 0;
     $81 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$78 >> 2] >> 2] & 31]($78, 68) | 0;
     dest = $81;
     stop = dest + 68 | 0;
     do {
      HEAP32[dest >> 2] = 0;
      dest = dest + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     if ($doc$idx$val$i11 | 0) {
      HEAP32[$81 + 48 >> 2] = HEAP32[$doc$idx$val$i11 >> 2];
      HEAP32[$81 + 52 >> 2] = HEAP32[$doc$idx$val$i11 + 4 >> 2];
     }
     HEAP32[$81 + 44 >> 2] = 12;
     HEAP32[$81 + 36 >> 2] = HEAP32[$doc$idx$val$i11 + 48 >> 2];
     HEAP32[$81 + 40 >> 2] = HEAP32[$doc$idx$val$i11 + 52 >> 2];
     $95 = HEAP32[$74 >> 2] | 0;
     $php$0$i = $81;
    } else {
     $95 = $73;
     $php$0$i = 0;
    }
    HEAP32[$58 >> 2] = $95;
    HEAP32[$php >> 2] = $php$0$i;
    $$0 = 0;
    return $$0 | 0;
   }
  default:
   {
    _prvTidyUngetChar($13, HEAP32[$2 >> 2] | 0);
    _prvTidyUngetChar(60, HEAP32[$2 >> 2] | 0);
    _prvTidyReportAttrError($doc, HEAP32[$3 >> 2] | 0, 0, 252);
    $$0 = 0;
    return $$0 | 0;
   }
  }
 } else if ((label | 0) == 32) {
  _prvTidyReportAttrError($doc, HEAP32[$3 >> 2] | 0, 0, 274);
  _prvTidyUngetChar(-1, HEAP32[$2 >> 2] | 0);
  $$0 = 0;
  return $$0 | 0;
 } else if ((label | 0) == 35) {
  $106 = $1 + 92 | 0;
  $107 = HEAP32[$106 >> 2] | 0;
  if (($$lcssa81 + -61 | 0) >>> 0 < 2) {
   $141 = $107;
   $142 = $106;
   $c$1$lcssa = $$lcssa81;
   label = 37;
  } else {
   $114 = $106;
   $140 = $107;
   $c$047 = $$lcssa81;
   label = 36;
  }
 } else if ((label | 0) == 52) return $$0 | 0; while (0);
 L56 : do if ((label | 0) == 36) {
  $109 = $doc + 168 | 0;
  $c$136 = $c$047;
  $lastc$037 = $c$047;
  L58 : while (1) {
   switch ($c$136 | 0) {
   case 60:
   case -1:
    {
     $c$136$lcssa = $c$136;
     label = 39;
     break L58;
     break;
    }
   default:
    {}
   }
   if (($lastc$037 | 0) == 45) switch ($c$136 | 0) {
   case 34:
   case 39:
    {
     $c$136$lcssa74 = $c$136;
     label = 42;
     break L58;
     break;
    }
   default:
    {}
   }
   $117 = $c$136 >>> 0 < 128;
   if ($117) if (HEAP32[316488 + ($c$136 << 2) >> 2] & 8 | 0) {
    $130 = $114;
    $132 = $140;
    break L56;
   }
   if ((HEAP32[$109 >> 2] | 0) != 0 | $117 ^ 1) $c$2 = $c$136; else if ($117 & (HEAP32[316488 + ($c$136 << 2) >> 2] & 64 | 0) != 0) $c$2 = HEAP32[316488 + ($c$136 << 2) >> 2] & 64 | 0 ? $c$136 + 32 | 0 : $c$136; else $c$2 = $c$136;
   _prvTidyAddCharToLexer($1, $c$2);
   $127 = _prvTidyReadChar(HEAP32[$2 >> 2] | 0) | 0;
   if (($127 + -61 | 0) >>> 0 < 2) {
    $141 = $140;
    $142 = $114;
    $c$1$lcssa = $127;
    label = 37;
    break L56;
   } else {
    $c$136 = $127;
    $lastc$037 = $c$2;
   }
  }
  if ((label | 0) == 39) {
   _prvTidyUngetChar($c$136$lcssa, HEAP32[$2 >> 2] | 0);
   $130 = $114;
   $132 = $140;
   break;
  } else if ((label | 0) == 42) {
   HEAP32[$114 >> 2] = (HEAP32[$114 >> 2] | 0) + -1;
   _prvTidyUngetChar($c$136$lcssa74, HEAP32[$2 >> 2] | 0);
   $130 = $114;
   $132 = $140;
   break;
  }
 } while (0);
 if ((label | 0) == 37) {
  _prvTidyUngetChar($c$1$lcssa, HEAP32[$2 >> 2] | 0);
  $130 = $142;
  $132 = $141;
 }
 $131 = (HEAP32[$130 >> 2] | 0) - $132 | 0;
 if (($131 | 0) > 0) $143 = _prvTidytmbstrndup(HEAP32[$doc + 6856 >> 2] | 0, (HEAP32[$1 + 84 >> 2] | 0) + $132 | 0, $131) | 0; else $143 = 0;
 HEAP32[$130 >> 2] = $132;
 $$0 = $143;
 return $$0 | 0;
}

function _prvTidyParseRowGroup($doc, $rowgroup, $mode) {
 $doc = $doc | 0;
 $rowgroup = $rowgroup | 0;
 $mode = $mode | 0;
 var $$lcssa = 0, $$pr7 = 0, $$pre$phi25Z2D = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $103 = 0, $105 = 0, $11 = 0, $112 = 0, $118 = 0, $119 = 0, $12 = 0, $127 = 0, $13 = 0, $132 = 0, $136 = 0, $137 = 0, $14 = 0, $142 = 0, $144 = 0, $147 = 0, $15 = 0, $158 = 0, $16 = 0, $2 = 0, $31 = 0, $33 = 0, $34 = 0, $40 = 0, $47 = 0, $51 = 0, $53 = 0, $55 = 0, $56 = 0, $59 = 0, $63 = 0, $65 = 0, $67 = 0, $68 = 0, $71 = 0, $74 = 0, $76 = 0, $77 = 0, $8 = 0, $80 = 0, $91 = 0, $node$0 = 0, $node$1 = 0, $rowgroup$pn = 0, $table$03$i = 0, $table$04$i = 0, $table$04$i$lcssa = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $rowgroup + 28 | 0;
 if (HEAP32[(HEAP32[$2 >> 2] | 0) + 16 >> 2] & 1 | 0) return;
 $8 = _prvTidyGetToken($doc, 0) | 0;
 if (!$8) return;
 $10 = $doc + 6848 | 0;
 $11 = $rowgroup + 16 | 0;
 $12 = $rowgroup + 12 | 0;
 $13 = $1 + 24 | 0;
 $15 = $8;
 L7 : while (1) {
  $14 = $15 + 28 | 0;
  $16 = HEAP32[$14 >> 2] | 0;
  if (($16 | 0) == (HEAP32[$2 >> 2] | 0)) {
   $$lcssa = $15;
   label = 5;
   break;
  }
  if ($16 | 0) if ((HEAP32[$16 >> 2] | 0) == 107) if ((HEAP32[$15 + 44 >> 2] | 0) == 6) {
   label = 11;
   break;
  }
  L14 : do if (!(_InsertMisc($rowgroup, $15) | 0)) {
   $31 = HEAP32[$14 >> 2] | 0;
   $33 = $15 + 44 | 0;
   $34 = HEAP32[$33 >> 2] | 0;
   L16 : do if (!$31) if (($34 | 0) == 4) label = 20; else {
    _prvTidyReportError($doc, $rowgroup, $15, 208);
    _prvTidyFreeNode($doc, $15);
    break L14;
   } else if (($34 | 0) == 6) $node$0 = $15; else {
    switch (HEAP32[$31 >> 2] | 0) {
    case 112:
    case 109:
     break;
    default:
     {
      label = 20;
      break L16;
     }
    }
    _prvTidyUngetToken($doc);
    $40 = _prvTidyInferredTag($doc, 115) | 0;
    _prvTidyReportError($doc, $rowgroup, $40, 212);
    $node$0 = $40;
   } while (0);
   do if ((label | 0) == 20) {
    label = 0;
    if (!(_prvTidynodeIsText($15) | 0)) if (!(_prvTidynodeHasCM($15, 24) | 0)) {
     if (!(HEAP32[(HEAP32[$14 >> 2] | 0) + 16 >> 2] & 4)) {
      $node$0 = $15;
      break;
     }
     _prvTidyReportError($doc, $rowgroup, $15, 211);
     _MoveToHead($doc, $rowgroup, $15);
     break L14;
    }
    $table$03$i = HEAP32[$rowgroup >> 2] | 0;
    L29 : do if (!$table$03$i) label = 30; else {
     $table$04$i = $table$03$i;
     while (1) {
      $47 = HEAP32[$table$04$i + 28 >> 2] | 0;
      if ($47 | 0) if ((HEAP32[$47 >> 2] | 0) == 107) {
       $table$04$i$lcssa = $table$04$i;
       break;
      }
      $table$04$i = HEAP32[$table$04$i >> 2] | 0;
      if (!$table$04$i) {
       label = 30;
       break L29;
      }
     }
     $51 = HEAP32[$table$04$i$lcssa >> 2] | 0;
     HEAP32[$15 >> 2] = $51;
     HEAP32[$15 + 8 >> 2] = $table$04$i$lcssa;
     $53 = $table$04$i$lcssa + 4 | 0;
     $55 = $15 + 4 | 0;
     HEAP32[$55 >> 2] = HEAP32[$53 >> 2];
     HEAP32[$53 >> 2] = $15;
     $56 = HEAP32[$55 >> 2] | 0;
     if ($56 | 0) HEAP32[$56 + 8 >> 2] = $15;
     $59 = $51 + 12 | 0;
     if ((HEAP32[$59 >> 2] | 0) == ($table$04$i$lcssa | 0)) HEAP32[$59 >> 2] = $15;
    } while (0);
    if ((label | 0) == 30) {
     label = 0;
     $63 = HEAP32[$table$03$i >> 2] | 0;
     HEAP32[$15 >> 2] = $63;
     HEAP32[$15 + 8 >> 2] = $table$03$i;
     $65 = $table$03$i + 4 | 0;
     $67 = $15 + 4 | 0;
     HEAP32[$67 >> 2] = HEAP32[$65 >> 2];
     HEAP32[$65 >> 2] = $15;
     $68 = HEAP32[$67 >> 2] | 0;
     if ($68 | 0) HEAP32[$68 + 8 >> 2] = $15;
     $71 = $63 + 12 | 0;
     if ((HEAP32[$71 >> 2] | 0) == ($table$03$i | 0)) HEAP32[$71 >> 2] = $15;
    }
    _prvTidyReportError($doc, $rowgroup, $15, 211);
    HEAP32[$13 >> 2] = 1;
    $74 = HEAP32[$33 >> 2] | 0;
    do if (($74 | 0) != 4) {
     $76 = HEAP32[$0 >> 2] | 0;
     $77 = HEAP32[$14 >> 2] | 0;
     if ($77 | 0) {
      $80 = HEAP32[$77 + 16 >> 2] | 0;
      if (!($80 & 1)) {
       if (!($80 & 16)) HEAP32[$76 + 16 >> 2] = 0;
      } else {
       HEAP32[$76 + 8 >> 2] = 0;
       if (!(HEAP32[$77 + 20 >> 2] | 0)) break;
      }
      $91 = HEAP32[$77 + 20 >> 2] | 0;
      if (!(($91 | 0) == 0 | ($74 | 0) == 7)) {
       HEAP32[$76 + 72 >> 2] = $15;
       FUNCTION_TABLE_viii[$91 & 63]($doc, $15, 0);
      }
     }
    } while (0);
    HEAP32[$13 >> 2] = 0;
    break L14;
   } while (0);
   $100 = $node$0 + 44 | 0;
   $101 = HEAP32[$100 >> 2] | 0;
   do if (($101 | 0) == 6) {
    $103 = ($node$0 | 0) != 0;
    if ($103) {
     $105 = HEAP32[$node$0 + 28 >> 2] | 0;
     if (!$105) label = 50; else if ((HEAP32[$105 >> 2] | 0) != 37) label = 50;
    } else label = 50;
    if ((label | 0) == 50) {
     label = 0;
     if (!(_prvTidynodeHasCM($node$0, 24) | 0)) {
      $118 = $node$0 + 28 | 0;
      L66 : do if ($103) {
       $119 = HEAP32[$118 >> 2] | 0;
       if (!$119) $rowgroup$pn = $rowgroup; else {
        switch (HEAP32[$119 >> 2] | 0) {
        case 112:
        case 109:
        case 115:
         break;
        default:
         {
          $rowgroup$pn = $rowgroup;
          break L66;
         }
        }
        _prvTidyReportError($doc, $rowgroup, $node$0, 208);
        _prvTidyFreeNode($doc, $node$0);
        break L14;
       }
      } else $rowgroup$pn = $rowgroup; while (0);
      while (1) {
       $rowgroup$pn = HEAP32[$rowgroup$pn >> 2] | 0;
       if (!$rowgroup$pn) break;
       if ((HEAP32[$118 >> 2] | 0) == (HEAP32[$rowgroup$pn + 28 >> 2] | 0)) {
        label = 62;
        break L7;
       }
      }
      $$pr7 = HEAP32[$100 >> 2] | 0;
      $$pre$phi25Z2D = $118;
      break;
     }
    }
    if ($103) {
     $112 = HEAP32[$node$0 + 28 >> 2] | 0;
     if ($112 | 0) if ((HEAP32[$112 >> 2] | 0) == 37) HEAP32[$10 >> 2] = HEAP32[$10 >> 2] | 1;
    }
    _prvTidyReportError($doc, $rowgroup, $node$0, 208);
    _prvTidyFreeNode($doc, $node$0);
    break L14;
   } else {
    $$pr7 = $101;
    $$pre$phi25Z2D = $node$0 + 28 | 0;
   } while (0);
   $127 = HEAP32[$$pre$phi25Z2D >> 2] | 0;
   $132 = ($$pr7 | 0) == 6;
   if (!(HEAP32[$127 + 16 >> 2] & 256)) {
    if (!$132) {
     if (!$127) label = 71; else if ((HEAP32[$127 >> 2] | 0) == 115) $node$1 = $node$0; else label = 71;
     if ((label | 0) == 71) {
      label = 0;
      $136 = _prvTidyInferredTag($doc, 115) | 0;
      _prvTidyReportError($doc, $rowgroup, $136, 212);
      _prvTidyUngetToken($doc);
      $node$1 = $136;
     }
     HEAP32[$node$1 >> 2] = $rowgroup;
     $137 = HEAP32[$11 >> 2] | 0;
     HEAP32[$node$1 + 4 >> 2] = $137;
     if (!$137) HEAP32[$12 >> 2] = $node$1; else HEAP32[$137 + 8 >> 2] = $node$1;
     HEAP32[$11 >> 2] = $node$1;
     $142 = HEAP32[$0 >> 2] | 0;
     $144 = HEAP32[$node$1 + 28 >> 2] | 0;
     if (!$144) break;
     $147 = HEAP32[$144 + 16 >> 2] | 0;
     if (!($147 & 1)) {
      if (!($147 & 16)) HEAP32[$142 + 16 >> 2] = 0;
     } else {
      HEAP32[$142 + 8 >> 2] = 0;
      if (!(HEAP32[$144 + 20 >> 2] | 0)) break;
     }
     $158 = HEAP32[$144 + 20 >> 2] | 0;
     if (!$158) break;
     if ((HEAP32[$node$1 + 44 >> 2] | 0) == 7) break;
     HEAP32[$142 + 72 >> 2] = $node$1;
     FUNCTION_TABLE_viii[$158 & 63]($doc, $node$1, 0);
     break;
    }
   } else if (!$132) {
    label = 66;
    break L7;
   }
   _prvTidyReportError($doc, $rowgroup, $node$0, 208);
   _prvTidyFreeNode($doc, $node$0);
  } while (0);
  $15 = _prvTidyGetToken($doc, 0) | 0;
  if (!$15) {
   label = 83;
   break;
  }
 }
 if ((label | 0) == 5) if ((HEAP32[$$lcssa + 44 >> 2] | 0) == 6) {
  HEAP32[$rowgroup + 56 >> 2] = 1;
  _prvTidyFreeNode($doc, $$lcssa);
  return;
 } else {
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 11) {
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 62) {
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 66) {
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 83) return;
}

function _prvTidyReadChar($in) {
 $in = $in | 0;
 var $$3 = 0, $$6 = 0, $$lcssa94 = 0, $$pre = 0, $0 = 0, $10 = 0, $100 = 0, $107 = 0, $111 = 0, $119 = 0, $123 = 0, $128 = 0, $14 = 0, $143 = 0, $144 = 0, $146 = 0, $158 = 0, $17 = 0, $18 = 0, $21 = 0, $22 = 0, $24 = 0, $3 = 0, $34 = 0, $35 = 0, $37 = 0, $4 = 0, $45 = 0, $46 = 0, $48 = 0, $56 = 0, $59 = 0, $60 = 0, $62 = 0, $63 = 0, $67 = 0, $7 = 0, $75 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $81 = 0, $82 = 0, $85 = 0, $88 = 0, $89 = 0, $90 = 0, $91 = 0, $93 = 0, $95 = 0, $97 = 0, $c$3 = 0, $c$3$ph = 0, $c$4 = 0, $c$5 = 0, $c$517 = 0, $c$517$ph = 0, $c1$0 = 0, label = 0;
 $0 = $in + 320 | 0;
 $3 = HEAP32[(HEAP32[$0 >> 2] | 0) + 84 >> 2] | 0;
 $4 = $in + 4 | 0;
 if (HEAP32[$4 >> 2] | 0) {
  $7 = $in + 16 | 0;
  $8 = HEAP32[$7 >> 2] | 0;
  if (!$8) ___assert_fail(225953, 225968, 511, 226059);
  $10 = $8 + -1 | 0;
  HEAP32[$7 >> 2] = $10;
  $14 = HEAP32[(HEAP32[$in + 12 >> 2] | 0) + ($10 << 2) >> 2] | 0;
  if (!$10) HEAP32[$4 >> 2] = 0;
  $17 = $in + 288 | 0;
  if (($14 | 0) == 10) {
   HEAP32[$17 >> 2] = 1;
   $18 = $in + 292 | 0;
   HEAP32[$18 >> 2] = (HEAP32[$18 >> 2] | 0) + 1;
   $21 = $in + 284 | 0;
   $22 = HEAP32[$21 >> 2] | 0;
   $24 = $22 + 1 & 63;
   HEAP16[$21 >> 1] = $24;
   if (($24 | 0) != ($22 >>> 16 | 0)) {
    $$3 = 10;
    return $$3 | 0;
   }
   HEAP16[$in + 286 >> 1] = $22 + 2 & 63;
   $$3 = 10;
   return $$3 | 0;
  } else {
   HEAP32[$17 >> 2] = (HEAP32[$17 >> 2] | 0) + 1;
   $34 = $in + 284 | 0;
   $35 = HEAP32[$34 >> 2] | 0;
   $37 = $35 + 1 & 63;
   HEAP16[$34 >> 1] = $37;
   if (($37 | 0) != ($35 >>> 16 | 0)) {
    $$3 = $14;
    return $$3 | 0;
   }
   HEAP16[$in + 286 >> 1] = $35 + 2 & 63;
   $$3 = $14;
   return $$3 | 0;
  }
 }
 $45 = $in + 284 | 0;
 $46 = HEAP32[$45 >> 2] | 0;
 $48 = $46 + 1 & 63;
 HEAP16[$45 >> 1] = $48;
 if (($48 | 0) == ($46 >>> 16 | 0)) HEAP16[$in + 286 >> 1] = $46 + 2 & 63;
 $56 = $in + 288 | 0;
 HEAP32[$in + 28 + ($48 << 2) >> 2] = HEAP32[$56 >> 2];
 $59 = $in + 24 | 0;
 $60 = HEAP32[$59 >> 2] | 0;
 if (($60 | 0) > 0) {
  HEAP32[$56 >> 2] = (HEAP32[$56 >> 2] | 0) + 1;
  HEAP32[$59 >> 2] = $60 + -1;
  $$3 = 32;
  return $$3 | 0;
 }
 $62 = $in + 296 | 0;
 $63 = $in + 292 | 0;
 L28 : while (1) {
  $67 = _ReadCharFromStream($in) | 0;
  switch ($67 | 0) {
  case -1:
   {
    label = 69;
    break L28;
    break;
   }
  case 10:
   {
    label = 17;
    break L28;
    break;
   }
  case 9:
   {
    label = 18;
    break L28;
    break;
   }
  case 13:
   {
    label = 21;
    break L28;
    break;
   }
  case 27:
   {
    $$3 = 27;
    label = 70;
    break L28;
    break;
   }
  default:
   {}
  }
  if ($67 >>> 0 < 32) continue;
  $111 = HEAP32[$62 >> 2] | 0;
  switch ($111 | 0) {
  case 12:
  case 13:
  case 4:
  case 5:
  case 0:
   {
    $$lcssa94 = $67;
    label = 33;
    break L28;
    break;
   }
  case 10:
  case 11:
  case 9:
   {
    do if (!(_prvTidyIsValidUTF16FromUCS4($67) | 0)) {
     _prvTidyReportEncodingError(HEAP32[$0 >> 2] | 0, 294, $67, 1);
     $c$3$ph = 0;
    } else if (!(_prvTidyIsLowSurrogate($67) | 0)) $c$3$ph = $67; else {
     $119 = _ReadCharFromStream($in) | 0;
     if (($119 | 0) == -1) {
      label = 69;
      break L28;
     }
     if (_prvTidyIsHighSurrogate($119) | 0) {
      $123 = _prvTidyCombineSurrogatePair($119, $67) | 0;
      if (!(($123 | 0) == 0 | (_prvTidyIsValidCombinedChar($123) | 0) == 0)) {
       $c$3$ph = $123;
       break;
      }
     }
     _prvTidyReportEncodingError(HEAP32[$0 >> 2] | 0, 294, 0, 1);
     $c$3$ph = 0;
    } while (0);
    $128 = HEAP32[$62 >> 2] | 0;
    $c$3 = $c$3$ph;
    break;
   }
  default:
   {
    $128 = $111;
    $c$3 = $67;
   }
  }
  switch ($128 | 0) {
  case 6:
   {
    if ($c$3 >>> 0 > 127) $c$4 = HEAP32[5284 + ($c$3 + -128 << 2) >> 2] | 0; else $c$4 = $c$3;
    break;
   }
  case 8:
   {
    if (($c$3 & -128 | 0) == 128) $c$4 = HEAP32[5796 + ($c$3 + -128 << 2) >> 2] | 0; else $c$4 = $c$3;
    break;
   }
  case 2:
   {
    if (($c$3 + -160 | 0) >>> 0 < 31) switch ($c$3 | 0) {
    case 164:
     {
      $c$517$ph = 8364;
      label = 63;
      break L28;
      break;
     }
    case 166:
     {
      label = 64;
      break L28;
      break;
     }
    case 168:
     {
      label = 65;
      break L28;
      break;
     }
    case 180:
     {
      label = 66;
      break L28;
      break;
     }
    case 184:
     {
      label = 67;
      break L28;
      break;
     }
    case 188:
     {
      $c$517 = 338;
      break L28;
      break;
     }
    case 189:
     {
      label = 49;
      break L28;
      break;
     }
    case 190:
     {
      label = 50;
      break L28;
      break;
     }
    default:
     $c$4 = $c$3;
    } else $c$4 = $c$3;
    break;
   }
  default:
   $c$4 = $c$3;
  }
  if (($c$4 & -32 | 0) == 128) {
   $143 = ($128 | 1 | 0) == 7;
   $144 = HEAP32[$0 >> 2] | 0;
   $146 = HEAP32[$144 + 68 >> 2] | 0;
   if ($146 | 0) {
    HEAP32[$146 >> 2] = HEAP32[$63 >> 2];
    HEAP32[$146 + 4 >> 2] = HEAP32[$56 >> 2];
   }
   if (($128 | 0) == 6) if ($c$4 >>> 0 > 127) $c1$0 = HEAP32[5284 + ($c$4 + -128 << 2) >> 2] | 0; else $c1$0 = $c$4; else $c1$0 = HEAP32[6308 + ($c$4 + -128 << 2) >> 2] | 0;
   $158 = ($c1$0 | 0) == 0;
   $$6 = $158 & 1;
   if ($143 & $158) {
    _prvTidyReportEncodingError($144, 291, $c$4, $$6);
    continue;
   }
   if ($143) $c$5 = $c1$0; else {
    _prvTidyReportEncodingError($144, 292, $c$4, $$6);
    $c$5 = $c1$0;
   }
  } else $c$5 = $c$4;
  if ($c$5 | 0) {
   $c$517$ph = $c$5;
   label = 63;
   break;
  }
 }
 switch (label | 0) {
 case 17:
  {
   HEAP32[$56 >> 2] = 1;
   HEAP32[$63 >> 2] = (HEAP32[$63 >> 2] | 0) + 1;
   $$3 = 10;
   return $$3 | 0;
  }
 case 18:
  {
   $$pre = HEAP32[$56 >> 2] | 0;
   if (!$3) $75 = 0; else $75 = $3 + -1 - ((($$pre + -1 | 0) >>> 0) % ($3 >>> 0) | 0) | 0;
   HEAP32[$59 >> 2] = $75;
   HEAP32[$56 >> 2] = $$pre + 1;
   $$3 = 32;
   return $$3 | 0;
  }
 case 21:
  {
   $77 = _ReadCharFromStream($in) | 0;
   L78 : do switch ($77 | 0) {
   case -1:
   case 10:
    break;
   default:
    {
     HEAP32[$4 >> 2] = 1;
     $78 = $in + 16 | 0;
     $79 = HEAP32[$78 >> 2] | 0;
     $81 = $in + 20 | 0;
     $82 = HEAP32[$81 >> 2] | 0;
     if (($79 + 1 | 0) >>> 0 < $82 >>> 0) {
      $95 = $79;
      $97 = HEAP32[$in + 12 >> 2] | 0;
     } else {
      $85 = HEAP32[$in + 8 >> 2] | 0;
      $88 = HEAP32[(HEAP32[$85 >> 2] | 0) + 4 >> 2] | 0;
      $89 = $in + 12 | 0;
      $90 = HEAP32[$89 >> 2] | 0;
      $91 = $82 + 1 | 0;
      HEAP32[$81 >> 2] = $91;
      $93 = FUNCTION_TABLE_iiii[$88 & 15]($85, $90, $91 << 2) | 0;
      HEAP32[$89 >> 2] = $93;
      $95 = HEAP32[$78 >> 2] | 0;
      $97 = $93;
     }
     HEAP32[$78 >> 2] = $95 + 1;
     HEAP32[$97 + ($95 << 2) >> 2] = $77;
     $100 = HEAP16[$45 >> 1] | 0;
     if ((HEAP16[$in + 286 >> 1] | 0) == $100 << 16 >> 16) {
      HEAP32[$56 >> 2] = 0;
      break L78;
     }
     HEAP32[$56 >> 2] = HEAP32[$in + 28 + (($100 & 65535) << 2) >> 2];
     if (!($100 << 16 >> 16)) {
      HEAP16[$45 >> 1] = 64;
      $107 = 64;
     } else $107 = $100;
     HEAP16[$45 >> 1] = $107 + -1 << 16 >> 16;
    }
   } while (0);
   HEAP32[$56 >> 2] = 1;
   HEAP32[$63 >> 2] = (HEAP32[$63 >> 2] | 0) + 1;
   $$3 = 10;
   return $$3 | 0;
  }
 case 33:
  {
   HEAP32[$56 >> 2] = (HEAP32[$56 >> 2] | 0) + 1;
   $$3 = $$lcssa94;
   return $$3 | 0;
  }
 case 49:
  {
   $c$517 = 339;
   break;
  }
 case 50:
  {
   $c$517 = 376;
   break;
  }
 case 63:
  {
   $c$517 = $c$517$ph;
   break;
  }
 case 64:
  {
   $c$517 = 352;
   break;
  }
 case 65:
  {
   $c$517 = 353;
   break;
  }
 case 66:
  {
   $c$517 = 381;
   break;
  }
 case 67:
  {
   $c$517 = 382;
   break;
  }
 case 69:
  {
   $$3 = -1;
   return $$3 | 0;
  }
 case 70:
  return $$3 | 0;
 }
 HEAP32[$56 >> 2] = (HEAP32[$56 >> 2] | 0) + 1;
 $$3 = $c$517;
 return $$3 | 0;
}

function _prvTidyRepairDuplicateAttributes($doc, $node, $isXml) {
 $doc = $doc | 0;
 $node = $node | 0;
 $isXml = $isXml | 0;
 var $1 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $108 = 0, $111 = 0, $15 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $27 = 0, $3 = 0, $31 = 0, $33 = 0, $35 = 0, $36 = 0, $37 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $44 = 0, $48 = 0, $5 = 0, $51 = 0, $59 = 0, $6 = 0, $61 = 0, $65 = 0, $68 = 0, $7 = 0, $70 = 0, $71 = 0, $73 = 0, $76 = 0, $79 = 0, $82 = 0, $83 = 0, $85 = 0, $88 = 0, $91 = 0, $92 = 0, $95 = 0, $98 = 0, $first$0$be = 0, $first$030 = 0, $first$1$ph$lcssa38 = 0, $first$1$ph25 = 0, $first$1$ph25$lcssa51 = 0, $firstRedefined$0$ph27 = 0, $firstRedefined$0$ph27$lcssa50 = 0, $or$cond = 0, $phitmp$i = 0, $second$0$be = 0, $second$0$ph26 = 0, $second$020 = 0, $second$020$lcssa = 0, label = 0;
 $1 = HEAP32[$node + 20 >> 2] | 0;
 if (!$1) return;
 $3 = ($isXml | 0) == 0;
 $4 = $doc + 360 | 0;
 $5 = $doc + 364 | 0;
 $6 = $doc + 6856 | 0;
 $7 = $doc + 112 | 0;
 $first$030 = $1;
 while (1) {
  L6 : do if (!(HEAP32[$first$030 + 8 >> 2] | 0)) if (!(HEAP32[$first$030 + 12 >> 2] | 0)) {
   $15 = HEAP32[$first$030 >> 2] | 0;
   if (!$15) $first$1$ph$lcssa38 = $first$030; else {
    $first$1$ph25 = $first$030;
    $firstRedefined$0$ph27 = 0;
    $second$0$ph26 = $15;
    L10 : while (1) {
     $17 = ($first$1$ph25 | 0) != 0;
     $18 = $first$1$ph25 + 4 | 0;
     $19 = $first$1$ph25 + 20 | 0;
     $or$cond = $3 & $17;
     $20 = $first$1$ph25 + 24 | 0;
     $second$020 = $second$0$ph26;
     L12 : while (1) {
      L14 : do if (!(HEAP32[$second$020 + 8 >> 2] | 0)) if (!(HEAP32[$second$020 + 12 >> 2] | 0)) {
       if ($17) {
        $27 = HEAP32[$18 >> 2] | 0;
        if (!$27) $33 = 0; else $33 = HEAP32[$27 >> 2] | 0;
       } else $33 = 0;
       $31 = HEAP32[$second$020 + 4 >> 2] | 0;
       if (!$31) {
        $39 = 0;
        $40 = ($33 | 0) != 0;
        label = 18;
       } else {
        $35 = HEAP32[$31 >> 2] | 0;
        $phitmp$i = ($35 | 0) != 0;
        $36 = ($33 | 0) != 0;
        if ($36 & $phitmp$i) {
         if (!$17) {
          label = 23;
          break;
         }
         $37 = HEAP32[$18 >> 2] | 0;
         if (!$37) {
          label = 23;
          break;
         }
         $48 = HEAP32[$37 >> 2] | 0;
         if (!(($48 | 0) == ($35 | 0) & ($48 | 0) != 0)) {
          label = 23;
          break;
         }
        } else {
         $39 = $phitmp$i;
         $40 = $36;
         label = 18;
        }
       }
       if ((label | 0) == 18) {
        label = 0;
        if ($40 | $39) {
         label = 23;
         break;
        }
        $41 = HEAP32[$19 >> 2] | 0;
        if (!$41) {
         label = 23;
         break;
        }
        $44 = HEAP32[$second$020 + 20 >> 2] | 0;
        if (!$44) {
         label = 23;
         break;
        }
        if (_prvTidytmbstrcmp($41, $44) | 0) {
         label = 23;
         break;
        }
       }
       L33 : do if ($or$cond) {
        $51 = HEAP32[$18 >> 2] | 0;
        if ($51 | 0) {
         switch (HEAP32[$51 >> 2] | 0) {
         case 26:
          {
           if (!(HEAP32[$4 >> 2] | 0)) break L33;
           if (!(HEAP32[$20 >> 2] | 0)) break L33;
           $59 = HEAP32[$second$020 + 24 >> 2] | 0;
           if (!$59) break L33;
           _prvTidyAppendToClassAttr($doc, $first$1$ph25, $59);
           $61 = HEAP32[$second$020 >> 2] | 0;
           _prvTidyReportAttrError($doc, $node, $second$020, 267);
           _prvTidyRemoveAttribute($doc, $node, $second$020);
           $second$0$be = $61;
           break L14;
           break;
          }
         case 143:
          break;
         default:
          break L33;
         }
         if (HEAP32[$5 >> 2] | 0) {
          $65 = HEAP32[$20 >> 2] | 0;
          if ($65 | 0) {
           $68 = HEAP32[$second$020 + 24 >> 2] | 0;
           if ($68 | 0) {
            $70 = _prvTidytmbstrlen($65) | 0;
            $71 = ($70 | 0) != 0;
            L45 : do if ($71) {
             $73 = HEAP32[$20 >> 2] | 0;
             switch (HEAP8[$73 + ($70 + -1) >> 0] | 0) {
             case 59:
              {
               $76 = HEAP32[$6 >> 2] | 0;
               $79 = HEAP32[(HEAP32[$76 >> 2] | 0) + 4 >> 2] | 0;
               $82 = $70 + 2 + (_prvTidytmbstrlen($68) | 0) | 0;
               $83 = FUNCTION_TABLE_iiii[$79 & 15]($76, $73, $82) | 0;
               HEAP32[$20 >> 2] = $83;
               _prvTidytmbstrcat($83, 307688) | 0;
               _prvTidytmbstrcat(HEAP32[$20 >> 2] | 0, $68) | 0;
               break L45;
               break;
              }
             case 125:
              {
               $85 = HEAP32[$6 >> 2] | 0;
               $88 = HEAP32[(HEAP32[$85 >> 2] | 0) + 4 >> 2] | 0;
               $91 = $70 + 6 + (_prvTidytmbstrlen($68) | 0) | 0;
               $92 = FUNCTION_TABLE_iiii[$88 & 15]($85, $73, $91) | 0;
               HEAP32[$20 >> 2] = $92;
               _prvTidytmbstrcat($92, 307721) | 0;
               _prvTidytmbstrcat(HEAP32[$20 >> 2] | 0, $68) | 0;
               _prvTidytmbstrcat(HEAP32[$20 >> 2] | 0, 307725) | 0;
               break L45;
               break;
              }
             default:
              {
               $102 = $73;
               label = 40;
               break L45;
              }
             }
            } else {
             $102 = HEAP32[$20 >> 2] | 0;
             label = 40;
            } while (0);
            if ((label | 0) == 40) {
             label = 0;
             $95 = HEAP32[$6 >> 2] | 0;
             $98 = HEAP32[(HEAP32[$95 >> 2] | 0) + 4 >> 2] | 0;
             $101 = $70 + 3 + (_prvTidytmbstrlen($68) | 0) | 0;
             $103 = FUNCTION_TABLE_iiii[$98 & 15]($95, $102, $101) | 0;
             HEAP32[$20 >> 2] = $103;
             if ($71) {
              _prvTidytmbstrcat($103, 307728) | 0;
              $104 = HEAP32[$20 >> 2] | 0;
             } else $104 = $103;
             _prvTidytmbstrcat($104, $68) | 0;
            }
            $105 = HEAP32[$second$020 >> 2] | 0;
            _prvTidyReportAttrError($doc, $node, $second$020, 267);
            _prvTidyRemoveAttribute($doc, $node, $second$020);
            $second$0$be = $105;
            break L14;
           }
          }
         }
        }
       } while (0);
       if ((HEAP32[$7 >> 2] | 0) == 1) {
        $second$020$lcssa = $second$020;
        break L12;
       }
       $111 = HEAP32[$second$020 >> 2] | 0;
       _prvTidyReportAttrError($doc, $node, $second$020, 255);
       _prvTidyRemoveAttribute($doc, $node, $second$020);
       $second$0$be = $111;
      } else label = 23; else label = 23; while (0);
      if ((label | 0) == 23) {
       label = 0;
       $second$0$be = HEAP32[$second$020 >> 2] | 0;
      }
      if (!$second$0$be) {
       $first$1$ph25$lcssa51 = $first$1$ph25;
       $firstRedefined$0$ph27$lcssa50 = $firstRedefined$0$ph27;
       break L10;
      } else $second$020 = $second$0$be;
     }
     $108 = HEAP32[$first$1$ph25 >> 2] | 0;
     _prvTidyReportAttrError($doc, $node, $first$1$ph25, 255);
     _prvTidyRemoveAttribute($doc, $node, $first$1$ph25);
     $second$0$ph26 = HEAP32[$second$020$lcssa >> 2] | 0;
     if (!$second$0$ph26) {
      $first$0$be = $108;
      break L6;
     } else {
      $first$1$ph25 = $108;
      $firstRedefined$0$ph27 = 1;
     }
    }
    if (!$firstRedefined$0$ph27$lcssa50) $first$1$ph$lcssa38 = $first$1$ph25$lcssa51; else {
     $first$0$be = $first$1$ph25$lcssa51;
     break;
    }
   }
   $first$0$be = HEAP32[$first$1$ph$lcssa38 >> 2] | 0;
  } else label = 5; else label = 5; while (0);
  if ((label | 0) == 5) {
   label = 0;
   $first$0$be = HEAP32[$first$030 >> 2] | 0;
  }
  if (!$first$0$be) break; else $first$030 = $first$0$be;
 }
 return;
}

function _CheckMetaData($doc, $node, $HasMetaData) {
 $doc = $doc | 0;
 $node = $node | 0;
 $HasMetaData = $HasMetaData | 0;
 var $$025 = 0, $$027 = 0, $$4 = 0, $$6 = 0, $$726 = 0, $$8 = 0, $$pr = 0, $10 = 0, $100 = 0, $104 = 0, $107 = 0, $11 = 0, $113 = 0, $15 = 0, $16 = 0, $18 = 0, $2 = 0, $24 = 0, $3 = 0, $31 = 0, $32 = 0, $34 = 0, $4 = 0, $48 = 0, $53 = 0, $56 = 0, $62 = 0, $66 = 0, $70 = 0, $71 = 0, $74 = 0, $75 = 0, $76 = 0, $87 = 0, $91 = 0, $ContainsAttr$0$lcssa = 0, $ContainsAttr$031 = 0, $ContainsAttr$1$ph = 0, $ContainsAttr$2 = 0, $HasContent$0$lcssa = 0, $HasContent$030 = 0, $HasContent$1 = 0, $HasHttpEquiv$0$lcssa = 0, $HasHttpEquiv$029 = 0, $HasHttpEquiv$1$ph = 0, $HasHttpEquiv$118 = 0, $av$028 = 0, $av$032 = 0, $cp$03$i = 0, $cp$03$i$i = 0, $cp$03$i$i11 = 0, $i$02$i = 0, $isWht$0$lcssa$i = 0, $isWht$02$i = 0, $x$01$i = 0, $x$1$i = 0, label = 0;
 if ((HEAP32[$doc + 6396 >> 2] | 1 | 0) != 3) {
  $$8 = $HasMetaData;
  return $$8 | 0;
 }
 $2 = ($node | 0) != 0;
 L4 : do if ($2) {
  $3 = $node + 28 | 0;
  $4 = HEAP32[$3 >> 2] | 0;
  do if ($4 | 0) if ((HEAP32[$4 >> 2] | 0) == 68) {
   $av$028 = HEAP32[$node + 20 >> 2] | 0;
   if (!$av$028) {
    $ContainsAttr$0$lcssa = 0;
    $HasContent$0$lcssa = 0;
    $HasHttpEquiv$0$lcssa = 0;
   } else {
    $ContainsAttr$031 = 0;
    $HasContent$030 = 0;
    $HasHttpEquiv$029 = 0;
    $av$032 = $av$028;
    while (1) {
     $10 = $av$032 + 4 | 0;
     $11 = HEAP32[$10 >> 2] | 0;
     L12 : do if (!$11) {
      $ContainsAttr$2 = $ContainsAttr$031;
      $HasContent$1 = $HasContent$030;
      $HasHttpEquiv$118 = $HasHttpEquiv$029;
     } else {
      L14 : do if ((HEAP32[$11 >> 2] | 0) == 62) {
       $15 = $av$032 + 24 | 0;
       $16 = HEAP32[$15 >> 2] | 0;
       if (!$16) {
        $ContainsAttr$1$ph = $ContainsAttr$031;
        $HasHttpEquiv$1$ph = $HasHttpEquiv$029;
       } else {
        $cp$03$i$i = $16;
        while (1) {
         $18 = HEAP8[$cp$03$i$i >> 0] | 0;
         if (!($18 << 24 >> 24)) {
          $ContainsAttr$1$ph = $ContainsAttr$031;
          $HasHttpEquiv$1$ph = $HasHttpEquiv$029;
          break L14;
         }
         if (!(_prvTidyIsWhite($18 << 24 >> 24) | 0)) break; else $cp$03$i$i = $cp$03$i$i + 1 | 0;
        }
        $24 = HEAP32[$15 >> 2] | 0;
        if (!$24) {
         $ContainsAttr$1$ph = 1;
         $HasHttpEquiv$1$ph = $HasHttpEquiv$029;
        } else if (!(_prvTidytmbstrcasecmp($24, 311824) | 0)) {
         _prvTidyReportAccessError($doc, $node, 385);
         $ContainsAttr$1$ph = 1;
         $HasHttpEquiv$1$ph = 1;
        } else {
         $ContainsAttr$1$ph = 1;
         $HasHttpEquiv$1$ph = $HasHttpEquiv$029;
        }
       }
      } else {
       $ContainsAttr$1$ph = $ContainsAttr$031;
       $HasHttpEquiv$1$ph = $HasHttpEquiv$029;
      } while (0);
      $$pr = HEAP32[$10 >> 2] | 0;
      if (!$$pr) {
       $ContainsAttr$2 = $ContainsAttr$1$ph;
       $HasContent$1 = $HasContent$030;
       $HasHttpEquiv$118 = $HasHttpEquiv$1$ph;
      } else if ((HEAP32[$$pr >> 2] | 0) == 36) {
       $31 = $av$032 + 24 | 0;
       $32 = HEAP32[$31 >> 2] | 0;
       if (!$32) {
        $ContainsAttr$2 = $ContainsAttr$1$ph;
        $HasContent$1 = $HasContent$030;
        $HasHttpEquiv$118 = $HasHttpEquiv$1$ph;
       } else {
        $cp$03$i$i11 = $32;
        while (1) {
         $34 = HEAP8[$cp$03$i$i11 >> 0] | 0;
         if (!($34 << 24 >> 24)) {
          $ContainsAttr$2 = $ContainsAttr$1$ph;
          $HasContent$1 = $HasContent$030;
          $HasHttpEquiv$118 = $HasHttpEquiv$1$ph;
          break L12;
         }
         if (!(_prvTidyIsWhite($34 << 24 >> 24) | 0)) break; else $cp$03$i$i11 = $cp$03$i$i11 + 1 | 0;
        }
        if (!(_prvTidytmbstrncmp(HEAP32[$31 >> 2] | 0, 311832, 5) | 0)) {
         _prvTidyReportAccessError($doc, $node, 386);
         $ContainsAttr$2 = 1;
         $HasContent$1 = 1;
         $HasHttpEquiv$118 = $HasHttpEquiv$1$ph;
        } else {
         $ContainsAttr$2 = 1;
         $HasContent$1 = $HasContent$030;
         $HasHttpEquiv$118 = $HasHttpEquiv$1$ph;
        }
       }
      } else {
       $ContainsAttr$2 = $ContainsAttr$1$ph;
       $HasContent$1 = $HasContent$030;
       $HasHttpEquiv$118 = $HasHttpEquiv$1$ph;
      }
     } while (0);
     $av$032 = HEAP32[$av$032 >> 2] | 0;
     if (!$av$032) {
      $ContainsAttr$0$lcssa = $ContainsAttr$2;
      $HasContent$0$lcssa = $HasContent$1;
      $HasHttpEquiv$0$lcssa = $HasHttpEquiv$118;
      break;
     } else {
      $ContainsAttr$031 = $ContainsAttr$2;
      $HasContent$030 = $HasContent$1;
      $HasHttpEquiv$029 = $HasHttpEquiv$118;
     }
    }
   }
   if (!($HasContent$0$lcssa | $HasHttpEquiv$0$lcssa)) if (!$ContainsAttr$0$lcssa) break; else {
    $$6 = 1;
    break L4;
   } else {
    _prvTidyReportAccessError($doc, $node, 429);
    $$6 = 1;
    break L4;
   }
  } while (0);
  if (!$HasMetaData) {
   $48 = HEAP32[$3 >> 2] | 0;
   if ($48 | 0) if ((HEAP32[$48 >> 2] | 0) == 4) {
    $53 = HEAP32[$node + 12 >> 2] | 0;
    if ($53 | 0) {
     $56 = HEAP32[$53 + 28 >> 2] | 0;
     if ($56 | 0) if ((HEAP32[$56 >> 2] | 0) == 1) {
      $$6 = 1;
      break;
     }
    }
   }
   if ($2) {
    $62 = HEAP32[$node + 28 >> 2] | 0;
    if (!$62) label = 35; else if ((HEAP32[$62 >> 2] | 0) == 114) {
     $$4 = 0;
     label = 44;
    } else label = 35;
   } else label = 35;
  } else $$6 = $HasMetaData;
 } else if (!$HasMetaData) label = 35; else $$6 = $HasMetaData; while (0);
 if ((label | 0) == 35) {
  $66 = $node + 12 | 0;
  if (!(_prvTidynodeIsText(HEAP32[$66 >> 2] | 0) | 0)) {
   $$4 = 0;
   label = 44;
  } else {
   $70 = HEAP32[$66 >> 2] | 0;
   $71 = $doc + 6532 | 0;
   L49 : do if (!$70) $x$1$i = 0; else {
    $74 = HEAP32[$70 + 36 >> 2] | 0;
    $75 = $doc + 68 | 0;
    $76 = $70 + 40 | 0;
    if ($74 >>> 0 < (HEAP32[$76 >> 2] | 0) >>> 0) {
     $i$02$i = $74;
     $x$01$i = 0;
     while (1) {
      HEAP8[$doc + 6532 + $x$01$i >> 0] = HEAP8[(HEAP32[(HEAP32[$75 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i >> 0] | 0;
      if ($x$01$i >>> 0 > 126) {
       $x$1$i = $x$01$i;
       break L49;
      }
      $i$02$i = $i$02$i + 1 | 0;
      $87 = $x$01$i + 1 | 0;
      if ($i$02$i >>> 0 >= (HEAP32[$76 >> 2] | 0) >>> 0) {
       $x$1$i = $87;
       break;
      } else $x$01$i = $87;
     }
    } else $x$1$i = 0;
   } while (0);
   HEAP8[$doc + 6532 + $x$1$i >> 0] = 0;
   $cp$03$i = $71;
   $isWht$02$i = 1;
   while (1) {
    $91 = HEAP8[$cp$03$i >> 0] | 0;
    if (!($91 << 24 >> 24)) {
     $isWht$0$lcssa$i = $isWht$02$i;
     break;
    }
    $isWht$02$i = _prvTidyIsWhite($91 << 24 >> 24) | 0;
    if (!$isWht$02$i) {
     $isWht$0$lcssa$i = 0;
     break;
    } else $cp$03$i = $cp$03$i + 1 | 0;
   }
   $$4 = ($isWht$0$lcssa$i | 0) == 0 & 1;
   label = 44;
  }
 }
 do if ((label | 0) == 44) if ($2 & ($$4 | 0) == 0) {
  $100 = HEAP32[$node + 28 >> 2] | 0;
  if (!$100) $$6 = 0; else if ((HEAP32[$100 >> 2] | 0) == 62) {
   $104 = _prvTidyAttrGetById($node, 122) | 0;
   if ($104 | 0) {
    $107 = HEAP32[$104 + 24 >> 2] | 0;
    if ($107 | 0) if (_prvTidytmbsubstr($107, 311719) | 0) {
     $$6 = 0;
     break;
    }
   }
   $$6 = 1;
  } else $$6 = 0;
 } else $$6 = $$4; while (0);
 $$025 = HEAP32[$node + 12 >> 2] | 0;
 if (!$$025) {
  $$8 = $$6;
  return $$8 | 0;
 } else {
  $$027 = $$025;
  $$726 = $$6;
 }
 while (1) {
  $113 = _CheckMetaData($doc, $$027, $$726) | 0;
  $$027 = HEAP32[$$027 + 8 >> 2] | 0;
  if (!$$027) {
   $$8 = $113;
   break;
  } else $$726 = $113;
 }
 return $$8 | 0;
}

function _prvTidyParseDefList($doc, $list, $mode) {
 $doc = $doc | 0;
 $list = $list | 0;
 $mode = $mode | 0;
 var $$01$be = 0, $$01$lcssa = 0, $$01$pn = 0, $$0121 = 0, $$0121$lcssa = 0, $$0121$lcssa71 = 0, $$0121$lcssa72 = 0, $$lcssa = 0, $$pre$phi$i6Z2D = 0, $$pre$phi$iZ2D = 0, $0 = 0, $1 = 0, $106 = 0, $11 = 0, $113 = 0, $114 = 0, $116 = 0, $117 = 0, $12 = 0, $123 = 0, $125 = 0, $128 = 0, $139 = 0, $14 = 0, $27 = 0, $28 = 0, $29 = 0, $34 = 0, $42 = 0, $50 = 0, $51 = 0, $53 = 0, $56 = 0, $57 = 0, $63 = 0, $65 = 0, $66 = 0, $69 = 0, $72 = 0, $74 = 0, $85 = 0, $9 = 0, $92 = 0, $93 = 0, $95 = 0, $98 = 0, $99 = 0, $node$0 = 0, $node$0$lcssa = 0, $node$0$lcssa75 = 0, $node$1 = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (HEAP32[(HEAP32[$list + 28 >> 2] | 0) + 16 >> 2] & 1 | 0) return;
 HEAP32[$1 + 100 >> 2] = 0;
 $9 = _prvTidyGetToken($doc, 0) | 0;
 L4 : do if (!$9) $$01$lcssa = $list; else {
  $11 = $doc + 6848 | 0;
  $12 = $1 + 20 | 0;
  $$0121 = $list;
  $14 = $9;
  L6 : while (1) {
   if ((HEAP32[$14 + 28 >> 2] | 0) == (HEAP32[$$0121 + 28 >> 2] | 0)) if ((HEAP32[$14 + 44 >> 2] | 0) == 6) {
    $$0121$lcssa = $$0121;
    $$lcssa = $14;
    label = 6;
    break;
   }
   L11 : do if (!(_InsertMisc($$0121, $14) | 0)) {
    if (!(_prvTidynodeIsText($14) | 0)) $node$0 = $14; else {
     _prvTidyUngetToken($doc);
     $27 = _prvTidyInferredTag($doc, 32) | 0;
     _prvTidyReportError($doc, $$0121, $27, 212);
     $node$0 = $27;
    }
    $28 = $node$0 + 28 | 0;
    $29 = HEAP32[$28 >> 2] | 0;
    if (!$29) {
     _prvTidyReportError($doc, $$0121, $node$0, 208);
     _prvTidyFreeNode($doc, $node$0);
     $$01$be = $$0121;
     break;
    }
    $34 = HEAP32[$node$0 + 44 >> 2] | 0;
    L19 : do if (($34 | 0) == 6) {
     if ((HEAP32[$29 >> 2] | 0) == 37) {
      HEAP32[$11 >> 2] = HEAP32[$11 >> 2] | 1;
      _prvTidyReportError($doc, $$0121, $node$0, 208);
      _prvTidyFreeNode($doc, $node$0);
      $$01$be = $$0121;
      break L11;
     } else $$01$pn = $$0121;
     while (1) {
      $$01$pn = HEAP32[$$01$pn >> 2] | 0;
      if (!$$01$pn) break L19;
      $42 = HEAP32[$$01$pn + 28 >> 2] | 0;
      if ($42 | 0) if ((HEAP32[$42 >> 2] | 0) == 16) break;
      if (($29 | 0) == ($42 | 0)) {
       $$0121$lcssa71 = $$0121;
       $node$0$lcssa = $node$0;
       label = 20;
       break L6;
      }
     }
     _prvTidyReportError($doc, $$0121, $node$0, 208);
     _prvTidyFreeNode($doc, $node$0);
     $$01$be = $$0121;
     break L11;
    } while (0);
    switch (HEAP32[$29 >> 2] | 0) {
    case 20:
     {
      $50 = (HEAP32[$$0121 + 12 >> 2] | 0) == 0;
      $51 = HEAP32[$$0121 >> 2] | 0;
      HEAP32[$node$0 >> 2] = $51;
      if ($50) {
       HEAP32[$node$0 + 8 >> 2] = $$0121;
       $63 = $$0121 + 4 | 0;
       $65 = $node$0 + 4 | 0;
       HEAP32[$65 >> 2] = HEAP32[$63 >> 2];
       HEAP32[$63 >> 2] = $node$0;
       $66 = HEAP32[$65 >> 2] | 0;
       if ($66 | 0) HEAP32[$66 + 8 >> 2] = $node$0;
       $69 = $51 + 12 | 0;
       if ((HEAP32[$69 >> 2] | 0) == ($$0121 | 0)) HEAP32[$69 >> 2] = $node$0;
      } else {
       if (!$51) label = 27; else {
        $53 = $51 + 16 | 0;
        if ((HEAP32[$53 >> 2] | 0) == ($$0121 | 0)) {
         HEAP32[$53 >> 2] = $node$0;
         $$pre$phi$iZ2D = $$0121 + 8 | 0;
        } else label = 27;
       }
       if ((label | 0) == 27) {
        label = 0;
        $56 = $$0121 + 8 | 0;
        $57 = HEAP32[$56 >> 2] | 0;
        HEAP32[$node$0 + 8 >> 2] = $57;
        if (!$57) $$pre$phi$iZ2D = $56; else {
         HEAP32[$57 + 4 >> 2] = $node$0;
         $$pre$phi$iZ2D = $56;
        }
       }
       HEAP32[$$pre$phi$iZ2D >> 2] = $node$0;
       HEAP32[$node$0 + 4 >> 2] = $$0121;
      }
      HEAP32[$12 >> 2] = 0;
      $72 = HEAP32[$0 >> 2] | 0;
      $74 = HEAP32[$29 + 16 >> 2] | 0;
      if (!($74 & 1)) if (!($74 & 16)) {
       HEAP32[$72 + 16 >> 2] = 0;
       label = 38;
      } else label = 38; else {
       HEAP32[$72 + 8 >> 2] = 0;
       if (HEAP32[$29 + 20 >> 2] | 0) label = 38;
      }
      if ((label | 0) == 38) {
       label = 0;
       $85 = HEAP32[$29 + 20 >> 2] | 0;
       if (!(($85 | 0) == 0 | ($34 | 0) == 7)) {
        HEAP32[$72 + 72 >> 2] = $node$0;
        FUNCTION_TABLE_viii[$85 & 63]($doc, $node$0, $mode);
       }
      }
      HEAP32[$12 >> 2] = 1;
      if ((HEAP32[$51 + 16 >> 2] | 0) != ($node$0 | 0)) {
       $$01$be = $$0121;
       break L11;
      }
      $92 = _prvTidyInferredTag($doc, 31) | 0;
      $93 = HEAP32[$node$0 >> 2] | 0;
      HEAP32[$92 >> 2] = $93;
      if (!$93) label = 44; else {
       $95 = $93 + 16 | 0;
       if ((HEAP32[$95 >> 2] | 0) == ($node$0 | 0)) {
        HEAP32[$95 >> 2] = $92;
        $$pre$phi$i6Z2D = $node$0 + 8 | 0;
       } else label = 44;
      }
      if ((label | 0) == 44) {
       label = 0;
       $98 = $node$0 + 8 | 0;
       $99 = HEAP32[$98 >> 2] | 0;
       HEAP32[$92 + 8 >> 2] = $99;
       if (!$99) $$pre$phi$i6Z2D = $98; else {
        HEAP32[$99 + 4 >> 2] = $92;
        $$pre$phi$i6Z2D = $98;
       }
      }
      HEAP32[$$pre$phi$i6Z2D >> 2] = $92;
      HEAP32[$92 + 4 >> 2] = $node$0;
      $$01$be = $92;
      break L11;
      break;
     }
    case 26:
    case 32:
     {
      $114 = $34;
      $node$1 = $node$0;
      break;
     }
    default:
     {
      _prvTidyUngetToken($doc);
      $106 = HEAP32[(HEAP32[$28 >> 2] | 0) + 16 >> 2] | 0;
      if (!($106 & 24)) {
       $$0121$lcssa72 = $$0121;
       $node$0$lcssa75 = $node$0;
       label = 48;
       break L6;
      }
      if (!($106 & 16)) if (HEAP32[$12 >> 2] | 0) {
       label = 65;
       break L6;
      }
      $113 = _prvTidyInferredTag($doc, 26) | 0;
      _prvTidyReportError($doc, $$0121, $113, 212);
      $114 = HEAP32[$113 + 44 >> 2] | 0;
      $node$1 = $113;
     }
    }
    if (($114 | 0) == 6) {
     _prvTidyReportError($doc, $$0121, $node$1, 208);
     _prvTidyFreeNode($doc, $node$1);
     $$01$be = $$0121;
     break;
    }
    HEAP32[$node$1 >> 2] = $$0121;
    $116 = $$0121 + 16 | 0;
    $117 = HEAP32[$116 >> 2] | 0;
    HEAP32[$node$1 + 4 >> 2] = $117;
    if (!$117) HEAP32[$$0121 + 12 >> 2] = $node$1; else HEAP32[$117 + 8 >> 2] = $node$1;
    HEAP32[$116 >> 2] = $node$1;
    $123 = HEAP32[$0 >> 2] | 0;
    $125 = HEAP32[$node$1 + 28 >> 2] | 0;
    if (!$125) $$01$be = $$0121; else {
     $128 = HEAP32[$125 + 16 >> 2] | 0;
     if (!($128 & 1)) {
      if (!($128 & 16)) HEAP32[$123 + 16 >> 2] = 0;
     } else {
      HEAP32[$123 + 8 >> 2] = 0;
      if (!(HEAP32[$125 + 20 >> 2] | 0)) {
       $$01$be = $$0121;
       break;
      }
     }
     $139 = HEAP32[$125 + 20 >> 2] | 0;
     if (($139 | 0) == 0 | ($114 | 0) == 7) $$01$be = $$0121; else {
      HEAP32[$123 + 72 >> 2] = $node$1;
      FUNCTION_TABLE_viii[$139 & 63]($doc, $node$1, 0);
      $$01$be = $$0121;
     }
    }
   } else $$01$be = $$0121; while (0);
   $14 = _prvTidyGetToken($doc, 0) | 0;
   if (!$14) {
    $$01$lcssa = $$01$be;
    break L4;
   } else $$0121 = $$01$be;
  }
  if ((label | 0) == 6) {
   _prvTidyFreeNode($doc, $$lcssa);
   HEAP32[$$0121$lcssa + 56 >> 2] = 1;
   return;
  } else if ((label | 0) == 20) {
   _prvTidyReportError($doc, $$0121$lcssa71, $node$0$lcssa, 207);
   _prvTidyUngetToken($doc);
   return;
  } else if ((label | 0) == 48) {
   _prvTidyReportError($doc, $$0121$lcssa72, $node$0$lcssa75, 211);
   return;
  } else if ((label | 0) == 65) return;
 } while (0);
 _prvTidyReportError($doc, $$01$lcssa, 0, 206);
 return;
}

function _prvTidyParseNoFrames($doc, $noframes, $mode) {
 $doc = $doc | 0;
 $noframes = $noframes | 0;
 $mode = $mode | 0;
 var $$lcssa = 0, $$lcssa19 = 0, $$pre$i$i = 0, $0 = 0, $1 = 0, $10 = 0, $103 = 0, $105 = 0, $107 = 0, $109 = 0, $11 = 0, $112 = 0, $116 = 0, $117 = 0, $12 = 0, $129 = 0, $13 = 0, $134 = 0, $135 = 0, $136 = 0, $14 = 0, $142 = 0, $145 = 0, $15 = 0, $150 = 0, $152 = 0, $155 = 0, $16 = 0, $166 = 0, $17 = 0, $18 = 0, $38 = 0, $42 = 0, $45 = 0, $46 = 0, $47 = 0, $5 = 0, $51 = 0, $53 = 0, $64 = 0, $70 = 0, $72 = 0, $73 = 0, $79 = 0, $8 = 0, $86 = 0, $90 = 0, $96 = 0, $98 = 0, $node$0 = 0, $node$1 = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!(HEAP32[$doc + 408 >> 2] | 0)) {
  $5 = $doc + 6836 | 0;
  HEAP32[$5 >> 2] = HEAP32[$5 >> 2] | 32;
 }
 $8 = _prvTidyGetToken($doc, 0) | 0;
 L4 : do if ($8 | 0) {
  $10 = $noframes + 28 | 0;
  $11 = $1 + 76 | 0;
  $12 = $doc + 172 | 0;
  $13 = $noframes + 16 | 0;
  $14 = $noframes + 12 | 0;
  $15 = $doc + 6856 | 0;
  $17 = $8;
  L6 : while (1) {
   $16 = $17 + 28 | 0;
   $18 = HEAP32[$16 >> 2] | 0;
   if (($18 | 0) == (HEAP32[$10 >> 2] | 0)) if ((HEAP32[$17 + 44 >> 2] | 0) == 6) {
    $$lcssa = $17;
    label = 7;
    break;
   }
   L11 : do if (!$18) label = 18; else {
    if ((HEAP32[$18 >> 2] | 0) == 38) {
     $$lcssa19 = $17;
     break L6;
    }
    switch (HEAP32[$18 >> 2] | 0) {
    case 39:
     {
      $$lcssa19 = $17;
      break L6;
      break;
     }
    case 48:
     break;
    default:
     {
      label = 18;
      break L11;
     }
    }
    if (_prvTidynodeIsElement($17) | 0) _prvTidyReportError($doc, $noframes, $17, 208);
    _prvTidyFreeNode($doc, $17);
   } while (0);
   L18 : do if ((label | 0) == 18) {
    label = 0;
    if (!(_InsertMisc($noframes, $17) | 0)) {
     $38 = HEAP32[$16 >> 2] | 0;
     if ($38 | 0) if ((HEAP32[$38 >> 2] | 0) == 16) {
      $42 = $17 + 44 | 0;
      if ((HEAP32[$42 >> 2] | 0) == 5) {
       $45 = HEAP32[$11 >> 2] | 0;
       HEAP32[$17 >> 2] = $noframes;
       $46 = HEAP32[$13 >> 2] | 0;
       $47 = $17 + 4 | 0;
       HEAP32[$47 >> 2] = $46;
       if (!$46) HEAP32[$14 >> 2] = $17; else HEAP32[$46 + 8 >> 2] = $17;
       HEAP32[$13 >> 2] = $17;
       $51 = HEAP32[$0 >> 2] | 0;
       $53 = HEAP32[$38 + 16 >> 2] | 0;
       if (!($53 & 1)) if (!($53 & 16)) {
        HEAP32[$51 + 16 >> 2] = 0;
        label = 29;
       } else label = 29; else {
        HEAP32[$51 + 8 >> 2] = 0;
        if (HEAP32[$38 + 20 >> 2] | 0) label = 29;
       }
       if ((label | 0) == 29) {
        label = 0;
        $64 = HEAP32[$38 + 20 >> 2] | 0;
        if ($64 | 0) {
         HEAP32[$51 + 72 >> 2] = $17;
         FUNCTION_TABLE_viii[$64 & 63]($doc, $17, 0);
        }
       }
       if (!$45) break;
       if ((_prvTidyFindBody($doc) | 0) == ($17 | 0)) break;
       $70 = _prvTidyLookupTagDef(30) | 0;
       $72 = _prvTidyInferredTag($doc, HEAP32[$70 >> 2] | 0) | 0;
       _prvTidyReportNotice($doc, $17, $72, 283);
       $73 = HEAP32[$15 >> 2] | 0;
       FUNCTION_TABLE_vii[HEAP32[(HEAP32[$73 >> 2] | 0) + 8 >> 2] & 15]($73, HEAP32[$72 + 32 >> 2] | 0);
       $79 = HEAP32[$15 >> 2] | 0;
       FUNCTION_TABLE_vii[HEAP32[(HEAP32[$79 >> 2] | 0) + 8 >> 2] & 15]($79, $72);
       HEAP32[$17 + 24 >> 2] = HEAP32[$16 >> 2];
       HEAP32[$16 >> 2] = $70;
       HEAP32[$42 >> 2] = 5;
       HEAP32[$17 + 60 >> 2] = 1;
       $86 = HEAP32[$15 >> 2] | 0;
       $90 = $17 + 32 | 0;
       FUNCTION_TABLE_vii[HEAP32[(HEAP32[$86 >> 2] | 0) + 8 >> 2] & 15]($86, HEAP32[$90 >> 2] | 0);
       HEAP32[$90 >> 2] = _prvTidytmbstrdup(HEAP32[$15 >> 2] | 0, HEAP32[$70 + 4 >> 2] | 0) | 0;
       $96 = _prvTidyFindBody($doc) | 0;
       if (!$96) break;
       $98 = HEAP32[$47 >> 2] | 0;
       $$pre$i$i = $17 + 8 | 0;
       if ($98 | 0) HEAP32[$98 + 8 >> 2] = HEAP32[$$pre$i$i >> 2];
       $103 = HEAP32[$$pre$i$i >> 2] | 0;
       $105 = $103;
       if ($103 | 0) HEAP32[$103 + 4 >> 2] = $98;
       $107 = HEAP32[$17 >> 2] | 0;
       do if ($107 | 0) {
        $109 = $107 + 12 | 0;
        if ((HEAP32[$109 >> 2] | 0) == ($17 | 0)) HEAP32[$109 >> 2] = $105;
        $112 = $107 + 16 | 0;
        if ((HEAP32[$112 >> 2] | 0) != ($17 | 0)) break;
        HEAP32[$112 >> 2] = HEAP32[$47 >> 2];
       } while (0);
       HEAP32[$$pre$i$i >> 2] = 0;
       HEAP32[$17 >> 2] = $96;
       $116 = $96 + 16 | 0;
       $117 = HEAP32[$116 >> 2] | 0;
       HEAP32[$47 >> 2] = $117;
       if (!$117) HEAP32[$96 + 12 >> 2] = $17; else HEAP32[$117 + 8 >> 2] = $17;
       HEAP32[$116 >> 2] = $17;
       break;
      }
     }
     do if (!(_prvTidynodeIsText($17) | 0)) {
      if (HEAP32[$16 >> 2] | 0) if ((HEAP32[$17 + 44 >> 2] | 0) != 6) break;
      _prvTidyReportError($doc, $noframes, $17, 208);
      _prvTidyFreeNode($doc, $17);
      break L18;
     } while (0);
     $129 = _prvTidyFindBody($doc) | 0;
     if (!$129) {
      if (HEAP32[$11 >> 2] | 0) {
       _prvTidyReportError($doc, $noframes, $17, 208);
       _prvTidyFreeNode($doc, $17);
       break;
      }
      _prvTidyUngetToken($doc);
      $142 = _prvTidyInferredTag($doc, 16) | 0;
      if (HEAP32[$12 >> 2] | 0) _prvTidyReportError($doc, $noframes, $142, 215);
      HEAP32[$142 >> 2] = $noframes;
      $145 = HEAP32[$13 >> 2] | 0;
      HEAP32[$142 + 4 >> 2] = $145;
      if (!$145) HEAP32[$14 >> 2] = $142; else HEAP32[$145 + 8 >> 2] = $142;
      HEAP32[$13 >> 2] = $142;
      $node$1 = $142;
     } else {
      if (!(_prvTidynodeIsText($17) | 0)) $node$0 = $17; else {
       _prvTidyUngetToken($doc);
       $134 = _prvTidyInferredTag($doc, 80) | 0;
       _prvTidyReportError($doc, $noframes, $134, 227);
       $node$0 = $134;
      }
      HEAP32[$node$0 >> 2] = $129;
      $135 = $129 + 16 | 0;
      $136 = HEAP32[$135 >> 2] | 0;
      HEAP32[$node$0 + 4 >> 2] = $136;
      if (!$136) HEAP32[$129 + 12 >> 2] = $node$0; else HEAP32[$136 + 8 >> 2] = $node$0;
      HEAP32[$135 >> 2] = $node$0;
      $node$1 = $node$0;
     }
     $150 = HEAP32[$0 >> 2] | 0;
     $152 = HEAP32[$node$1 + 28 >> 2] | 0;
     if ($152 | 0) {
      $155 = HEAP32[$152 + 16 >> 2] | 0;
      if (!($155 & 1)) {
       if (!($155 & 16)) HEAP32[$150 + 16 >> 2] = 0;
      } else {
       HEAP32[$150 + 8 >> 2] = 0;
       if (!(HEAP32[$152 + 20 >> 2] | 0)) break;
      }
      $166 = HEAP32[$152 + 20 >> 2] | 0;
      if ($166 | 0) if ((HEAP32[$node$1 + 44 >> 2] | 0) != 7) {
       HEAP32[$150 + 72 >> 2] = $node$1;
       FUNCTION_TABLE_viii[$166 & 63]($doc, $node$1, 0);
      }
     }
    }
   } while (0);
   $17 = _prvTidyGetToken($doc, 0) | 0;
   if (!$17) break L4;
  }
  if ((label | 0) == 7) {
   _prvTidyFreeNode($doc, $$lcssa);
   HEAP32[$noframes + 56 >> 2] = 1;
   _TrimSpaces($doc, $noframes);
   return;
  }
  _TrimSpaces($doc, $noframes);
  if ((HEAP32[$$lcssa19 + 44 >> 2] | 0) == 6) {
   _prvTidyReportError($doc, $noframes, $$lcssa19, 208);
   _prvTidyFreeNode($doc, $$lcssa19);
   return;
  } else {
   _prvTidyReportError($doc, $noframes, $$lcssa19, 207);
   _prvTidyUngetToken($doc);
   return;
  }
 } while (0);
 _prvTidyReportError($doc, $noframes, 0, 206);
 return;
}

function _prvTidyParseHead($doc, $head, $mode) {
 $doc = $doc | 0;
 $head = $head | 0;
 $mode = $mode | 0;
 var $$0$i = 0, $$0$i$lcssa = 0, $$lcssa = 0, $$lcssa22 = 0, $$lcssa23 = 0, $0 = 0, $1 = 0, $10 = 0, $101 = 0, $102 = 0, $105 = 0, $11 = 0, $116 = 0, $2 = 0, $34 = 0, $38 = 0, $4 = 0, $42 = 0, $43 = 0, $45 = 0, $47 = 0, $48 = 0, $5 = 0, $51 = 0, $6 = 0, $62 = 0, $67 = 0, $69 = 0, $71 = 0, $72 = 0, $75 = 0, $78 = 0, $8 = 0, $89 = 0, $9 = 0, $92 = 0, $94 = 0, $96 = 0, $HasBase$0$be = 0, $HasBase$08 = 0, $HasBase$1 = 0, $HasTitle$0$be = 0, $HasTitle$07 = 0, $HasTitle$1 = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = _prvTidyGetToken($doc, 0) | 0;
 if (!$2) return;
 $4 = $head + 28 | 0;
 $5 = $head + 16 | 0;
 $6 = $head + 12 | 0;
 $8 = $head | 0 ? 246 : 238;
 $10 = $2;
 $HasBase$08 = 0;
 $HasTitle$07 = 0;
 L4 : while (1) {
  $9 = $10 + 28 | 0;
  $11 = HEAP32[$9 >> 2] | 0;
  if (($11 | 0) == (HEAP32[$4 >> 2] | 0)) if ((HEAP32[$10 + 44 >> 2] | 0) == 6) {
   $$lcssa = $10;
   label = 5;
   break;
  } else label = 8; else if (!$11) label = 11; else if ((HEAP32[$11 >> 2] | 0) == 48) label = 8; else label = 11;
  if ((label | 0) == 8) {
   label = 0;
   if ((HEAP32[$10 + 44 >> 2] | 0) == 5) {
    _prvTidyReportError($doc, $head, $10, 208);
    _prvTidyFreeNode($doc, $10);
    $HasBase$0$be = $HasBase$08;
    $HasTitle$0$be = $HasTitle$07;
   } else label = 11;
  }
  do if ((label | 0) == 11) {
   label = 0;
   if (_prvTidynodeIsText($10) | 0) {
    $$lcssa22 = $10;
    label = 12;
    break L4;
   }
   $34 = $10 + 44 | 0;
   if ((HEAP32[$34 >> 2] | 0) == 3) {
    $38 = HEAP32[$10 + 32 >> 2] | 0;
    if ($38 | 0) if (!(_prvTidytmbstrcmp($38, 308032) | 0)) {
     _prvTidyReportError($doc, $head, $10, 211);
     $42 = _prvTidyFindHTML($doc) | 0;
     $43 = HEAP32[$42 >> 2] | 0;
     HEAP32[$10 >> 2] = $43;
     HEAP32[$10 + 8 >> 2] = $42;
     $45 = $42 + 4 | 0;
     $47 = $10 + 4 | 0;
     HEAP32[$47 >> 2] = HEAP32[$45 >> 2];
     HEAP32[$45 >> 2] = $10;
     $48 = HEAP32[$47 >> 2] | 0;
     if ($48 | 0) HEAP32[$48 + 8 >> 2] = $10;
     $51 = $43 + 12 | 0;
     if ((HEAP32[$51 >> 2] | 0) != ($42 | 0)) {
      $HasBase$0$be = $HasBase$08;
      $HasTitle$0$be = $HasTitle$07;
      break;
     }
     HEAP32[$51 >> 2] = $10;
     $HasBase$0$be = $HasBase$08;
     $HasTitle$0$be = $HasTitle$07;
     break;
    }
   }
   if (!(_InsertMisc($head, $10) | 0)) {
    if ((HEAP32[$34 >> 2] | 0) == 1) {
     if (_prvTidyFindDocType($doc) | 0) {
      _prvTidyReportError($doc, $head, $10, 208);
      _prvTidyFreeNode($doc, $10);
      $HasBase$0$be = $HasBase$08;
      $HasTitle$0$be = $HasTitle$07;
      break;
     }
     _prvTidyReportError($doc, $head, $10, 234);
     $$0$i = $head;
     while (1) {
      if ($$0$i | 0) {
       $62 = HEAP32[$$0$i + 28 >> 2] | 0;
       if ($62 | 0) if ((HEAP32[$62 >> 2] | 0) == 48) {
        $$0$i$lcssa = $$0$i;
        break;
       }
      }
      $$0$i = HEAP32[$$0$i >> 2] | 0;
     }
     $67 = HEAP32[$$0$i$lcssa >> 2] | 0;
     HEAP32[$10 >> 2] = $67;
     HEAP32[$10 + 8 >> 2] = $$0$i$lcssa;
     $69 = $$0$i$lcssa + 4 | 0;
     $71 = $10 + 4 | 0;
     HEAP32[$71 >> 2] = HEAP32[$69 >> 2];
     HEAP32[$69 >> 2] = $10;
     $72 = HEAP32[$71 >> 2] | 0;
     if ($72 | 0) HEAP32[$72 + 8 >> 2] = $10;
     $75 = $67 + 12 | 0;
     if ((HEAP32[$75 >> 2] | 0) != ($$0$i$lcssa | 0)) {
      $HasBase$0$be = $HasBase$08;
      $HasTitle$0$be = $HasTitle$07;
      break;
     }
     HEAP32[$75 >> 2] = $10;
     $HasBase$0$be = $HasBase$08;
     $HasTitle$0$be = $HasTitle$07;
     break;
    }
    $78 = HEAP32[$9 >> 2] | 0;
    if (!$78) {
     _prvTidyReportError($doc, $head, $10, 208);
     _prvTidyFreeNode($doc, $10);
     $HasBase$0$be = $HasBase$08;
     $HasTitle$0$be = $HasTitle$07;
     break;
    }
    if (!(HEAP32[$78 + 16 >> 2] & 4)) {
     $$lcssa23 = $10;
     label = 39;
     break L4;
    }
    if (!(_prvTidynodeIsElement($10) | 0)) {
     _prvTidyReportError($doc, $head, $10, 208);
     _prvTidyFreeNode($doc, $10);
     $HasBase$0$be = $HasBase$08;
     $HasTitle$0$be = $HasTitle$07;
     break;
    }
    $89 = HEAP32[$9 >> 2] | 0;
    L50 : do if (!$89) {
     $HasBase$1 = $HasBase$08;
     $HasTitle$1 = $HasTitle$07;
    } else switch (HEAP32[$89 >> 2] | 0) {
    case 114:
     {
      $92 = $HasTitle$07 + 1 | 0;
      if (($HasTitle$07 | 0) <= 0) {
       $HasBase$1 = $HasBase$08;
       $HasTitle$1 = $92;
       break L50;
      }
      _prvTidyReportError($doc, $head, $10, $8);
      $HasBase$1 = $HasBase$08;
      $HasTitle$1 = $92;
      break L50;
      break;
     }
    case 9:
     {
      $94 = $HasBase$08 + 1 | 0;
      if (($HasBase$08 | 0) <= 0) {
       $HasBase$1 = $94;
       $HasTitle$1 = $HasTitle$07;
       break L50;
      }
      _prvTidyReportError($doc, $head, $10, $8);
      $HasBase$1 = $94;
      $HasTitle$1 = $HasTitle$07;
      break L50;
      break;
     }
    default:
     {
      $HasBase$1 = $HasBase$08;
      $HasTitle$1 = $HasTitle$07;
      break L50;
     }
    } while (0);
    HEAP32[$10 >> 2] = $head;
    $96 = HEAP32[$5 >> 2] | 0;
    HEAP32[$10 + 4 >> 2] = $96;
    if (!$96) HEAP32[$6 >> 2] = $10; else HEAP32[$96 + 8 >> 2] = $10;
    HEAP32[$5 >> 2] = $10;
    $101 = HEAP32[$0 >> 2] | 0;
    $102 = HEAP32[$9 >> 2] | 0;
    if (!$102) {
     $HasBase$0$be = $HasBase$1;
     $HasTitle$0$be = $HasTitle$1;
    } else {
     $105 = HEAP32[$102 + 16 >> 2] | 0;
     if (!($105 & 1)) {
      if (!($105 & 16)) HEAP32[$101 + 16 >> 2] = 0;
     } else {
      HEAP32[$101 + 8 >> 2] = 0;
      if (!(HEAP32[$102 + 20 >> 2] | 0)) {
       $HasBase$0$be = $HasBase$1;
       $HasTitle$0$be = $HasTitle$1;
       break;
      }
     }
     $116 = HEAP32[$102 + 20 >> 2] | 0;
     if (!$116) {
      $HasBase$0$be = $HasBase$1;
      $HasTitle$0$be = $HasTitle$1;
     } else if ((HEAP32[$34 >> 2] | 0) == 7) {
      $HasBase$0$be = $HasBase$1;
      $HasTitle$0$be = $HasTitle$1;
     } else {
      HEAP32[$101 + 72 >> 2] = $10;
      FUNCTION_TABLE_viii[$116 & 63]($doc, $10, 0);
      $HasBase$0$be = $HasBase$1;
      $HasTitle$0$be = $HasTitle$1;
     }
    }
   } else {
    $HasBase$0$be = $HasBase$08;
    $HasTitle$0$be = $HasTitle$07;
   }
  } while (0);
  $10 = _prvTidyGetToken($doc, 0) | 0;
  if (!$10) {
   label = 61;
   break;
  } else {
   $HasBase$08 = $HasBase$0$be;
   $HasTitle$07 = $HasTitle$0$be;
  }
 }
 if ((label | 0) == 5) {
  _prvTidyFreeNode($doc, $$lcssa);
  HEAP32[$head + 56 >> 2] = 1;
  return;
 } else if ((label | 0) == 12) {
  if (!(HEAP32[$doc + 160 >> 2] | 0)) if ((HEAP32[$doc + 328 >> 2] | 0) != 1) _prvTidyReportError($doc, $head, $$lcssa22, 211);
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 39) {
  if (HEAP32[$1 + 28 >> 2] | 0) _prvTidyReportError($doc, $head, $$lcssa23, 211);
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 61) return;
}

function _ParseXMLElement($doc, $element, $mode) {
 $doc = $doc | 0;
 $element = $element | 0;
 $mode = $mode | 0;
 var $$0$i = 0, $$lcssa9 = 0, $$pre$phiZ2D = 0, $1 = 0, $10 = 0, $100 = 0, $102 = 0, $105 = 0, $110 = 0, $113 = 0, $115 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $132 = 0, $134 = 0, $136 = 0, $138 = 0, $141 = 0, $15 = 0, $19 = 0, $28 = 0, $30 = 0, $31 = 0, $32 = 0, $34 = 0, $35 = 0, $36 = 0, $39 = 0, $41 = 0, $45 = 0, $46 = 0, $5 = 0, $53 = 0, $54 = 0, $55 = 0, $58 = 0, $60 = 0, $65 = 0, $68 = 0, $73 = 0, $76 = 0, $77 = 0, $78 = 0, $84 = 0, $88 = 0, $89 = 0, $90 = 0, $91 = 0, $96 = 0, $98 = 0, $attribute$05$i = 0, $attribute$06$i = 0, $attribute$06$i$lcssa = 0, $mode$ = 0, label = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $attribute$05$i = HEAP32[$element + 20 >> 2] | 0;
 L1 : do if (!$attribute$05$i) label = 8; else {
  $attribute$06$i = $attribute$05$i;
  while (1) {
   $5 = HEAP32[$attribute$06$i + 4 >> 2] | 0;
   if ($5 | 0) if ((HEAP32[$5 >> 2] | 0) == 162) {
    $attribute$06$i$lcssa = $attribute$06$i;
    break;
   }
   $attribute$06$i = HEAP32[$attribute$06$i >> 2] | 0;
   if (!$attribute$06$i) {
    label = 8;
    break L1;
   }
  }
  $10 = HEAP32[$attribute$06$i$lcssa + 24 >> 2] | 0;
  if ($10 | 0) if (!(_prvTidytmbstrcasecmp($10, 310885) | 0)) {
   $$0$i = 1;
   break;
  }
  $$0$i = 0;
 } while (0);
 L11 : do if ((label | 0) == 8) {
  $15 = $element + 32 | 0;
  if (!(HEAP32[$15 >> 2] | 0)) $$0$i = 0; else {
   $19 = HEAP32[$element + 28 >> 2] | 0;
   if ($19 | 0) switch (HEAP32[$19 >> 2] | 0) {
   case 103:
   case 94:
   case 84:
    {
     $$0$i = 1;
     break L11;
     break;
    }
   default:
    {}
   }
   if ((_prvTidyFindParser($doc, $element) | 0) == 35) $$0$i = 1; else $$0$i = (_prvTidytmbstrcasecmp(HEAP32[$15 >> 2] | 0, 308076) | 0) == 0 & 1;
  }
 } while (0);
 $mode$ = ($$0$i | 0) == 0 ? $mode : 2;
 $28 = _prvTidyGetToken($doc, $mode$) | 0;
 L19 : do if (!$28) $$pre$phiZ2D = $element + 12 | 0; else {
  $30 = $element + 32 | 0;
  $31 = $element + 16 | 0;
  $32 = $element + 12 | 0;
  L22 : do if (!$element) {
   $35 = $28;
   while (1) {
    $34 = $35 + 44 | 0;
    $36 = HEAP32[$34 >> 2] | 0;
    if (($36 | 0) == 6) {
     $39 = HEAP32[$35 + 32 >> 2] | 0;
     if (!$39) label = 23; else {
      $41 = HEAP32[$30 >> 2] | 0;
      if (!$41) label = 23; else {
       if (!(_prvTidytmbstrcmp($39, $41) | 0)) {
        $$lcssa9 = $35;
        break L22;
       }
       $45 = HEAP32[$34 >> 2] | 0;
       label = 21;
      }
     }
    } else {
     $45 = $36;
     label = 21;
    }
    L30 : do if ((label | 0) == 21) {
     label = 0;
     switch ($45 | 0) {
     case 6:
      {
       label = 23;
       break L30;
       break;
      }
     case 5:
      {
       _ParseXMLElement($doc, $35, $mode$);
       break;
      }
     default:
      {}
     }
     HEAP32[$35 >> 2] = 0;
     $46 = HEAP32[$31 >> 2] | 0;
     HEAP32[$35 + 4 >> 2] = $46;
     if (!$46) HEAP32[$32 >> 2] = $35; else HEAP32[$46 + 8 >> 2] = $35;
     HEAP32[$31 >> 2] = $35;
    } while (0);
    if ((label | 0) == 23) {
     label = 0;
     _prvTidyReportFatal($doc, 0, $35, 213);
     _prvTidyFreeNode($doc, $35);
    }
    $35 = _prvTidyGetToken($doc, $mode$) | 0;
    if (!$35) {
     $$pre$phiZ2D = $32;
     break L19;
    }
   }
  } else {
   $54 = $28;
   while (1) {
    $53 = $54 + 44 | 0;
    $55 = HEAP32[$53 >> 2] | 0;
    if (($55 | 0) == 6) {
     $58 = HEAP32[$54 + 32 >> 2] | 0;
     if (!$58) label = 36; else {
      $60 = HEAP32[$30 >> 2] | 0;
      if (!$60) label = 36; else {
       if (!(_prvTidytmbstrcmp($58, $60) | 0)) {
        $$lcssa9 = $54;
        break L22;
       }
       $65 = HEAP32[$53 >> 2] | 0;
       label = 35;
      }
     }
    } else {
     $65 = $55;
     label = 35;
    }
    L49 : do if ((label | 0) == 35) {
     label = 0;
     switch ($65 | 0) {
     case 6:
      {
       label = 36;
       break L49;
       break;
      }
     case 5:
      {
       _ParseXMLElement($doc, $54, $mode$);
       break;
      }
     default:
      {}
     }
     HEAP32[$54 >> 2] = $element;
     $68 = HEAP32[$31 >> 2] | 0;
     HEAP32[$54 + 4 >> 2] = $68;
     if (!$68) HEAP32[$32 >> 2] = $54; else HEAP32[$68 + 8 >> 2] = $54;
     HEAP32[$31 >> 2] = $54;
    } while (0);
    if ((label | 0) == 36) {
     label = 0;
     _prvTidyReportFatal($doc, $element, $54, 247);
     _prvTidyFreeNode($doc, $54);
    }
    $54 = _prvTidyGetToken($doc, $mode$) | 0;
    if (!$54) {
     $$pre$phiZ2D = $32;
     break L19;
    }
   }
  } while (0);
  _prvTidyFreeNode($doc, $$lcssa9);
  HEAP32[$element + 56 >> 2] = 1;
  $$pre$phiZ2D = $32;
 } while (0);
 $73 = HEAP32[$$pre$phiZ2D >> 2] | 0;
 $76 = ($mode$ | 0) != 2;
 if ($76 & (_prvTidynodeIsText($73) | 0) != 0) {
  $77 = $73 + 36 | 0;
  $78 = HEAP32[$77 >> 2] | 0;
  if ((HEAP8[(HEAP32[$1 + 84 >> 2] | 0) + $78 >> 0] | 0) == 32) {
   $84 = $78 + 1 | 0;
   HEAP32[$77 >> 2] = $84;
   if ($84 >>> 0 >= (HEAP32[$73 + 40 >> 2] | 0) >>> 0) {
    $88 = $73 + 8 | 0;
    $89 = HEAP32[$88 >> 2] | 0;
    $90 = $73 + 4 | 0;
    $91 = HEAP32[$90 >> 2] | 0;
    if (!$91) $96 = $89; else {
     HEAP32[$91 + 8 >> 2] = $89;
     $96 = HEAP32[$88 >> 2] | 0;
    }
    $98 = $96;
    if ($96 | 0) HEAP32[$96 + 4 >> 2] = $91;
    $100 = HEAP32[$73 >> 2] | 0;
    if ($100 | 0) {
     $102 = $100 + 12 | 0;
     if ((HEAP32[$102 >> 2] | 0) == ($73 | 0)) HEAP32[$102 >> 2] = $98;
     $105 = $100 + 16 | 0;
     if ((HEAP32[$105 >> 2] | 0) == ($73 | 0)) HEAP32[$105 >> 2] = HEAP32[$90 >> 2];
    }
    HEAP32[$88 >> 2] = 0;
    HEAP32[$90 >> 2] = 0;
    HEAP32[$73 >> 2] = 0;
    _prvTidyFreeNode($doc, $73);
   }
  }
 }
 $110 = HEAP32[$element + 16 >> 2] | 0;
 if (!($76 & (_prvTidynodeIsText($110) | 0) != 0)) return;
 $113 = $110 + 40 | 0;
 $115 = (HEAP32[$113 >> 2] | 0) + -1 | 0;
 if ((HEAP8[(HEAP32[$1 + 84 >> 2] | 0) + $115 >> 0] | 0) != 32) return;
 HEAP32[$113 >> 2] = $115;
 if ((HEAP32[$110 + 36 >> 2] | 0) >>> 0 < $115 >>> 0) return;
 $124 = $110 + 8 | 0;
 $125 = HEAP32[$124 >> 2] | 0;
 $126 = $110 + 4 | 0;
 $127 = HEAP32[$126 >> 2] | 0;
 if (!$127) $132 = $125; else {
  HEAP32[$127 + 8 >> 2] = $125;
  $132 = HEAP32[$124 >> 2] | 0;
 }
 $134 = $132;
 if ($132 | 0) HEAP32[$132 + 4 >> 2] = $127;
 $136 = HEAP32[$110 >> 2] | 0;
 if ($136 | 0) {
  $138 = $136 + 12 | 0;
  if ((HEAP32[$138 >> 2] | 0) == ($110 | 0)) HEAP32[$138 >> 2] = $134;
  $141 = $136 + 16 | 0;
  if ((HEAP32[$141 >> 2] | 0) == ($110 | 0)) HEAP32[$141 >> 2] = HEAP32[$126 >> 2];
 }
 HEAP32[$124 >> 2] = 0;
 HEAP32[$126 >> 2] = 0;
 HEAP32[$110 >> 2] = 0;
 _prvTidyFreeNode($doc, $110);
 return;
}

function _prvTidyWriteChar($c, $out) {
 $c = $c | 0;
 $out = $out | 0;
 var $$0 = 0, $$0$i = 0, $$1 = 0, $117 = 0, $119 = 0, $64 = 0, $66 = 0, $73 = 0, $89 = 0, $90 = 0, $92 = 0, $count = 0, $i$02$i = 0, $i$02$i$lcssa = 0, $i$02$i2 = 0, $i$02$i2$lcssa = 0, $i$04$i = 0, $i$04$i$lcssa = 0, $i$09 = 0, $numChars$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $count = sp;
 L1 : do if (($c | 0) == 10) switch (HEAP32[$out + 8 >> 2] | 0) {
 case 1:
  {
   _prvTidyWriteChar(13, $out);
   $$0 = 10;
   break L1;
   break;
  }
 case 2:
  {
   $$0 = 13;
   break L1;
   break;
  }
 default:
  {
   $$0 = 10;
   break L1;
  }
 } else $$0 = $c; while (0);
 switch (HEAP32[$out >> 2] | 0) {
 case 6:
  {
   if ($$0 >>> 0 < 128) {
    FUNCTION_TABLE_vii[HEAP32[$out + 20 >> 2] & 15](HEAP32[$out + 16 >> 2] | 0, $$0 & 255);
    STACKTOP = sp;
    return;
   } else $i$02$i = 128;
   while (1) {
    if ((HEAP32[5284 + ($i$02$i + -128 << 2) >> 2] | 0) == ($$0 | 0)) {
     $i$02$i$lcssa = $i$02$i;
     break;
    }
    $i$02$i = $i$02$i + 1 | 0;
    if (($i$02$i | 0) >= 256) {
     label = 62;
     break;
    }
   }
   if ((label | 0) == 62) {
    STACKTOP = sp;
    return;
   }
   FUNCTION_TABLE_vii[HEAP32[$out + 20 >> 2] & 15](HEAP32[$out + 16 >> 2] | 0, $i$02$i$lcssa & 255);
   STACKTOP = sp;
   return;
  }
 case 7:
  {
   if ($$0 >>> 0 < 128 | ($$0 + -160 | 0) >>> 0 < 96) {
    FUNCTION_TABLE_vii[HEAP32[$out + 20 >> 2] & 15](HEAP32[$out + 16 >> 2] | 0, $$0 & 255);
    STACKTOP = sp;
    return;
   } else $i$04$i = 128;
   while (1) {
    if ((HEAP32[6308 + ($i$04$i + -128 << 2) >> 2] | 0) == ($$0 | 0)) {
     $i$04$i$lcssa = $i$04$i;
     break;
    }
    $i$04$i = $i$04$i + 1 | 0;
    if (($i$04$i | 0) >= 160) {
     label = 62;
     break;
    }
   }
   if ((label | 0) == 62) {
    STACKTOP = sp;
    return;
   }
   FUNCTION_TABLE_vii[HEAP32[$out + 20 >> 2] & 15](HEAP32[$out + 16 >> 2] | 0, $i$04$i$lcssa & 255);
   STACKTOP = sp;
   return;
  }
 case 8:
  {
   if ($$0 >>> 0 < 128) {
    FUNCTION_TABLE_vii[HEAP32[$out + 20 >> 2] & 15](HEAP32[$out + 16 >> 2] | 0, $$0 & 255);
    STACKTOP = sp;
    return;
   } else $i$02$i2 = 128;
   while (1) {
    if ((HEAP32[5796 + ($i$02$i2 + -128 << 2) >> 2] | 0) == ($$0 | 0)) {
     $i$02$i2$lcssa = $i$02$i2;
     break;
    }
    $i$02$i2 = $i$02$i2 + 1 | 0;
    if (($i$02$i2 | 0) >= 256) {
     label = 62;
     break;
    }
   }
   if ((label | 0) == 62) {
    STACKTOP = sp;
    return;
   }
   FUNCTION_TABLE_vii[HEAP32[$out + 20 >> 2] & 15](HEAP32[$out + 16 >> 2] | 0, $i$02$i2$lcssa & 255);
   STACKTOP = sp;
   return;
  }
 case 2:
  {
   switch ($$0 | 0) {
   case 8364:
    {
     $$0$i = 164;
     break;
    }
   case 352:
    {
     $$0$i = 166;
     break;
    }
   case 353:
    {
     $$0$i = 168;
     break;
    }
   case 381:
    {
     $$0$i = 180;
     break;
    }
   case 382:
    {
     $$0$i = 184;
     break;
    }
   case 338:
    {
     $$0$i = 188;
     break;
    }
   case 339:
    {
     $$0$i = 189;
     break;
    }
   case 376:
    {
     $$0$i = 190;
     break;
    }
   default:
    $$0$i = $$0;
   }
   FUNCTION_TABLE_vii[HEAP32[$out + 20 >> 2] & 15](HEAP32[$out + 16 >> 2] | 0, $$0$i & 255);
   STACKTOP = sp;
   return;
  }
 case 4:
  {
   HEAP32[$count >> 2] = 0;
   _prvTidyEncodeCharToUTF8Bytes($$0, 0, $out + 16 | 0, $count) | 0;
   if ((HEAP32[$count >> 2] | 0) < 1) {
    $64 = $out + 20 | 0;
    $66 = $out + 16 | 0;
    FUNCTION_TABLE_vii[HEAP32[$64 >> 2] & 15](HEAP32[$66 >> 2] | 0, -17);
    FUNCTION_TABLE_vii[HEAP32[$64 >> 2] & 15](HEAP32[$66 >> 2] | 0, -65);
    FUNCTION_TABLE_vii[HEAP32[$64 >> 2] & 15](HEAP32[$66 >> 2] | 0, -65);
   }
   STACKTOP = sp;
   return;
  }
 case 5:
  {
   $73 = $out + 4 | 0;
   L61 : do if (($$0 | 0) == 27) {
    HEAP32[$73 >> 2] = 1;
    $$1 = 27;
   } else switch (HEAP32[$73 >> 2] | 0) {
   case 1:
    {
     switch ($$0 | 0) {
     case 36:
      {
       HEAP32[$73 >> 2] = 2;
       $$1 = 36;
       break L61;
       break;
      }
     case 40:
      {
       HEAP32[$73 >> 2] = 4;
       $$1 = 40;
       break L61;
       break;
      }
     default:
      {
       HEAP32[$73 >> 2] = 0;
       $$1 = $$0;
       break L61;
      }
     }
     break;
    }
   case 2:
    {
     if (($$0 | 0) == 40) {
      HEAP32[$73 >> 2] = 3;
      $$1 = 40;
      break L61;
     } else {
      HEAP32[$73 >> 2] = 5;
      $$1 = $$0;
      break L61;
     }
     break;
    }
   case 3:
    {
     HEAP32[$73 >> 2] = 5;
     $$1 = $$0;
     break L61;
     break;
    }
   case 4:
    {
     HEAP32[$73 >> 2] = 0;
     $$1 = $$0;
     break L61;
     break;
    }
   case 5:
    {
     $$1 = $$0 & 127;
     break L61;
     break;
    }
   default:
    {
     $$1 = $$0;
     break L61;
    }
   } while (0);
   FUNCTION_TABLE_vii[HEAP32[$out + 20 >> 2] & 15](HEAP32[$out + 16 >> 2] | 0, $$1 & 255);
   STACKTOP = sp;
   return;
  }
 case 11:
 case 10:
 case 9:
  {
   L80 : do if (_prvTidyIsValidUTF16FromUCS4($$0) | 0) {
    if (!(_prvTidyIsCombinedChar($$0) | 0)) {
     HEAP32[$count >> 2] = $$0;
     $numChars$0 = 1;
    } else if (!(_prvTidySplitSurrogatePair($$0, $count, $count + 4 | 0) | 0)) break; else $numChars$0 = 2;
    $89 = $out + 20 | 0;
    $90 = $out + 16 | 0;
    $i$09 = 0;
    while (1) {
     $92 = HEAP32[$count + ($i$09 << 2) >> 2] | 0;
     switch (HEAP32[$out >> 2] | 0) {
     case 9:
      {
       FUNCTION_TABLE_vii[HEAP32[$89 >> 2] & 15](HEAP32[$90 >> 2] | 0, $92 & 255);
       FUNCTION_TABLE_vii[HEAP32[$89 >> 2] & 15](HEAP32[$90 >> 2] | 0, $92 >>> 8 & 255);
       break;
      }
     case 11:
     case 10:
      {
       FUNCTION_TABLE_vii[HEAP32[$89 >> 2] & 15](HEAP32[$90 >> 2] | 0, $92 >>> 8 & 255);
       FUNCTION_TABLE_vii[HEAP32[$89 >> 2] & 15](HEAP32[$90 >> 2] | 0, $92 & 255);
       break;
      }
     default:
      {}
     }
     $i$09 = $i$09 + 1 | 0;
     if (($i$09 | 0) >= ($numChars$0 | 0)) break L80;
    }
   } while (0);
   STACKTOP = sp;
   return;
  }
 case 13:
 case 12:
  {
   if ($$0 >>> 0 < 128) {
    FUNCTION_TABLE_vii[HEAP32[$out + 20 >> 2] & 15](HEAP32[$out + 16 >> 2] | 0, $$0 & 255);
    STACKTOP = sp;
    return;
   } else {
    $117 = $out + 20 | 0;
    $119 = $out + 16 | 0;
    FUNCTION_TABLE_vii[HEAP32[$117 >> 2] & 15](HEAP32[$119 >> 2] | 0, $$0 >>> 8 & 255);
    FUNCTION_TABLE_vii[HEAP32[$117 >> 2] & 15](HEAP32[$119 >> 2] | 0, $$0 & 255);
    STACKTOP = sp;
    return;
   }
   break;
  }
 default:
  {
   FUNCTION_TABLE_vii[HEAP32[$out + 20 >> 2] & 15](HEAP32[$out + 16 >> 2] | 0, $$0 & 255);
   STACKTOP = sp;
   return;
  }
 }
}

function _PPrintText($doc, $mode, $indent, $node) {
 $doc = $doc | 0;
 $mode = $mode | 0;
 $indent = $indent | 0;
 $node = $node | 0;
 var $$ = 0, $$0$i = 0, $$1$i = 0, $$1$i2327 = 0, $$1$i2328 = 0, $$25 = 0, $$idx$i = 0, $$idx$val$i = 0, $0 = 0, $1 = 0, $10 = 0, $102 = 0, $107 = 0, $11 = 0, $15 = 0, $2 = 0, $25 = 0, $3 = 0, $31 = 0, $32 = 0, $35 = 0, $38 = 0, $4 = 0, $40 = 0, $48 = 0, $5 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $74 = 0, $75 = 0, $83 = 0, $84 = 0, $89 = 0, $90 = 0, $93 = 0, $96 = 0, $98 = 0, $c = 0, $ix$0$i = 0, $ix$0$lcssa$i = 0, $ix$0$lcssa$i15 = 0, $ix$0$lcssa$i3 = 0, $ix$026 = 0, $ix$06$i = 0, $ix$07$i = 0, $ix$07$i13 = 0, $ix$07$i2 = 0, $ix$1 = 0, $ix$2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 $0 = $node + 36 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $node + 40 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 HEAP32[$c >> 2] = 0;
 $4 = $doc + 68 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 $7 = ($mode & 18 | 0) == 0;
 L1 : do if ($7) {
  $$1$i2328 = -1;
  label = 17;
 } else {
  do if (!(_prvTidynodeIsText($node) | 0)) $$1$i2327 = -1; else {
   $10 = HEAP32[$2 >> 2] | 0;
   $11 = HEAP32[$0 >> 2] | 0;
   if ($10 >>> 0 > $11 >>> 0) {
    $ix$06$i = $10 + -1 | 0;
    $15 = HEAP32[$5 + 84 >> 2] | 0;
    L6 : do if ($ix$06$i >>> 0 > $11 >>> 0) {
     $ix$07$i = $ix$06$i;
     while (1) {
      switch (HEAP8[$15 + $ix$07$i >> 0] | 0) {
      case 9:
      case 32:
      case 13:
       break;
      default:
       {
        $ix$0$lcssa$i = $ix$07$i;
        break L6;
       }
      }
      $ix$0$i = $ix$07$i + -1 | 0;
      if ($ix$0$i >>> 0 > $11 >>> 0) $ix$07$i = $ix$0$i; else {
       $ix$0$lcssa$i = $ix$0$i;
       break L6;
      }
     }
    } else $ix$0$lcssa$i = $ix$06$i; while (0);
    $$1$i = (HEAP8[$15 + $ix$0$lcssa$i >> 0] | 0) == 10 ? $10 + ~$ix$0$lcssa$i | 0 : -1;
    if (!$node) ___assert_fail(310581, 310594, 1955, 310683); else if ($7) {
     $$1$i2328 = $$1$i;
     label = 17;
     break L1;
    } else {
     $$1$i2327 = $$1$i;
     break;
    }
   } else $$1$i2327 = -1;
  } while (0);
  $25 = HEAP32[$4 >> 2] | 0;
  if (!(_prvTidynodeIsText($node) | 0)) if ((HEAP32[$node + 44 >> 2] | 0) != 10) {
   $$1$i2328 = $$1$i2327;
   label = 17;
   break;
  }
  $31 = HEAP32[$2 >> 2] | 0;
  $32 = HEAP32[$0 >> 2] | 0;
  if ($31 >>> 0 > $1 >>> 0 & ($32 >>> 0 <= $1 >>> 0 & $31 >>> 0 > $32 >>> 0)) {
   $35 = HEAP32[$25 + 84 >> 2] | 0;
   $ix$07$i2 = $1;
   L19 : while (1) {
    switch (HEAP8[$35 + $ix$07$i2 >> 0] | 0) {
    case 9:
    case 32:
    case 13:
     break;
    default:
     {
      $ix$0$lcssa$i3 = $ix$07$i2;
      break L19;
     }
    }
    $38 = $ix$07$i2 + 1 | 0;
    if ($38 >>> 0 < $31 >>> 0) $ix$07$i2 = $38; else {
     $ix$0$lcssa$i3 = $38;
     break;
    }
   }
   $40 = $ix$0$lcssa$i3 - $1 | 0;
   if ($ix$0$lcssa$i3 >>> 0 > $1 >>> 0) {
    $$ = $3 - (($$1$i2327 | 0) > 0 ? $$1$i2327 : 0) | 0;
    if (($40 | 0) > 0) {
     $48 = ($40 >>> 0 < $indent >>> 0 ? $40 : $indent) + $1 | 0;
     $$0$i = $48 >>> 0 < $$ >>> 0 ? $48 : $$;
     $$25 = $$;
    } else {
     $$0$i = $1;
     $$25 = $$;
    }
   } else {
    $$1$i2328 = $$1$i2327;
    label = 17;
   }
  } else {
   $$1$i2328 = $$1$i2327;
   label = 17;
  }
 } while (0);
 if ((label | 0) == 17) {
  $$0$i = $1;
  $$25 = $3 - (($$1$i2328 | 0) > 0 ? $$1$i2328 : 0) | 0;
 }
 if ($$0$i >>> 0 >= $$25 >>> 0) {
  STACKTOP = sp;
  return;
 }
 $$idx$i = $doc + 6752 | 0;
 $52 = $doc + 6736 | 0;
 $53 = $doc + 80 | 0;
 $54 = $doc + 6780 | 0;
 $55 = $doc + 6744 | 0;
 $56 = $node + 44 | 0;
 $57 = $mode | 16;
 $ix$026 = $$0$i;
 do {
  $$idx$val$i = HEAP32[$$idx$i >> 2] | 0;
  if (((($$idx$val$i | 0) < 0 ? 0 : $$idx$val$i) + (HEAP32[$52 >> 2] | 0) | 0) >>> 0 >= (HEAP32[$53 >> 2] | 0) >>> 0) {
   _WrapLine($doc);
   if ((HEAP32[$$idx$i >> 2] | 0) < 0) HEAP32[$$idx$i >> 2] = $indent;
  }
  $69 = (HEAP32[(HEAP32[$4 >> 2] | 0) + 84 >> 2] | 0) + $ix$026 | 0;
  $70 = HEAP8[$69 >> 0] | 0;
  $71 = $70 & 255;
  HEAP32[$c >> 2] = $71;
  if ($70 << 24 >> 24 < 0) {
   $74 = (_prvTidyGetUTF8($69, $c) | 0) + $ix$026 | 0;
   $75 = HEAP32[$c >> 2] | 0;
   $ix$1 = $74;
  } else {
   $75 = $71;
   $ix$1 = $ix$026;
  }
  L40 : do switch ($75 | 0) {
  case 10:
   {
    if (HEAP32[$52 >> 2] | 0) _PFlushLineImpl($doc);
    _prvTidyWriteChar(10, HEAP32[$54 >> 2] | 0);
    HEAP32[$55 >> 2] = (HEAP32[$55 >> 2] | 0) + 1;
    if ((HEAP32[$$idx$i >> 2] | 0) != ($indent | 0)) HEAP32[$$idx$i >> 2] = $indent;
    $83 = HEAP32[$4 >> 2] | 0;
    $84 = $ix$1 + 1 | 0;
    if ($7) $ix$2 = $ix$1; else {
     if (!(_prvTidynodeIsText($node) | 0)) if ((HEAP32[$56 >> 2] | 0) != 10) {
      $ix$2 = $ix$1;
      break L40;
     }
     $89 = HEAP32[$2 >> 2] | 0;
     $90 = HEAP32[$0 >> 2] | 0;
     if ($89 >>> 0 > $84 >>> 0 & ($90 >>> 0 <= $84 >>> 0 & $89 >>> 0 > $90 >>> 0)) {
      $93 = HEAP32[$83 + 84 >> 2] | 0;
      $ix$07$i13 = $84;
      L53 : while (1) {
       switch (HEAP8[$93 + $ix$07$i13 >> 0] | 0) {
       case 9:
       case 32:
       case 13:
        break;
       default:
        {
         $ix$0$lcssa$i15 = $ix$07$i13;
         break L53;
        }
       }
       $96 = $ix$07$i13 + 1 | 0;
       if ($96 >>> 0 < $89 >>> 0) $ix$07$i13 = $96; else {
        $ix$0$lcssa$i15 = $96;
        break;
       }
      }
      $98 = $ix$0$lcssa$i15 - $84 | 0;
      if ($ix$0$lcssa$i15 >>> 0 > $84 >>> 0 & ($98 | 0) > 0) {
       $102 = ($98 >>> 0 < $indent >>> 0 ? $98 : $indent) + $ix$1 | 0;
       $ix$2 = $102 >>> 0 < $$25 >>> 0 ? $102 : $$25;
      } else $ix$2 = $ix$1;
     } else $ix$2 = $ix$1;
    }
    break;
   }
  case 38:
   {
    if ((_prvTidyHTMLVersion($doc) | 0) == 131072) {
     $107 = $ix$1 + 1 | 0;
     if (($107 | 0) != ($$25 | 0)) {
      if ($107 >>> 0 >= $$25 >>> 0) {
       label = 46;
       break L40;
      }
      if (!(_isspace(HEAPU8[(HEAP32[(HEAP32[$4 >> 2] | 0) + 84 >> 2] | 0) + $107 >> 0] | 0) | 0)) {
       label = 46;
       break L40;
      }
     }
     _PPrintChar($doc, HEAP32[$c >> 2] | 0, $57);
     $ix$2 = $ix$1;
    } else label = 46;
    break;
   }
  default:
   label = 46;
  } while (0);
  if ((label | 0) == 46) {
   label = 0;
   _PPrintChar($doc, HEAP32[$c >> 2] | 0, $mode);
   $ix$2 = $ix$1;
  }
  $ix$026 = $ix$2 + 1 | 0;
 } while ($ix$026 >>> 0 < $$25 >>> 0);
 STACKTOP = sp;
 return;
}

function _PPrintPI($doc, $indent, $node) {
 $doc = $doc | 0;
 $indent = $indent | 0;
 $node = $node | 0;
 var $$pre$i$i = 0, $$pre$i$i1 = 0, $$pre$phi$i$i14Z2D = 0, $$pre$phi$i$i8Z2D = 0, $0 = 0, $1 = 0, $101 = 0, $104 = 0, $106 = 0, $11 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $121 = 0, $125 = 0, $128 = 0, $130 = 0, $137 = 0, $141 = 0, $144 = 0, $147 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $23 = 0, $27 = 0, $30 = 0, $32 = 0, $45 = 0, $47 = 0, $49 = 0, $50 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $61 = 0, $67 = 0, $69 = 0, $7 = 0, $75 = 0, $90 = 0, $91 = 0, $92 = 0, $97 = 0, $buflen$0$i$i$i = 0, $buflen$0$i$i$i$lcssa = 0, $buflen$0$i$i$i13 = 0, $buflen$0$i$i$i13$lcssa = 0, $buflen$0$i$i$i3 = 0, $buflen$0$i$i$i3$lcssa = 0, $buflen$0$i$i$i7 = 0, $buflen$0$i$i$i7$lcssa = 0, $c = 0, $ix$01$i$i = 0, $s$01620 = 0, $s$1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 $0 = $doc + 6724 | 0;
 $1 = $doc + 6736 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 if (($2 + $indent | 0) >>> 0 < (HEAP32[$doc + 80 >> 2] | 0) >>> 0) {
  $7 = $doc + 6752 | 0;
  if ((HEAP32[$7 >> 2] | 0) < 0) HEAP32[$7 >> 2] = $indent;
  HEAP32[$doc + 6740 >> 2] = $2;
 } else {
  $11 = $doc + 6748 | 0;
  if (!(HEAP32[$11 >> 2] | 0)) {
   HEAP32[$doc + 6764 >> 2] = $indent;
   HEAP32[$11 >> 2] = 1;
  }
 }
 $15 = _prvTidytmbstrlen(310813) | 0;
 $16 = $15 + $2 | 0;
 $17 = $doc + 6732 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 if ($16 >>> 0 >= $18 >>> 0) {
  $buflen$0$i$i$i = ($18 | 0) == 0 ? 256 : $18;
  while (1) if ($buflen$0$i$i$i >>> 0 > $16 >>> 0) {
   $buflen$0$i$i$i$lcssa = $buflen$0$i$i$i;
   break;
  } else $buflen$0$i$i$i = $buflen$0$i$i$i << 1;
  $23 = HEAP32[$0 >> 2] | 0;
  $27 = $doc + 6728 | 0;
  $30 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$23 >> 2] | 0) + 4 >> 2] & 15]($23, HEAP32[$27 >> 2] | 0, $buflen$0$i$i$i$lcssa << 2) | 0;
  if ($30 | 0) {
   $32 = HEAP32[$17 >> 2] | 0;
   _memset($30 + ($32 << 2) | 0, 0, $buflen$0$i$i$i$lcssa - $32 << 2 | 0) | 0;
   HEAP32[$17 >> 2] = $buflen$0$i$i$i$lcssa;
   HEAP32[$27 >> 2] = $30;
  }
 }
 if ($15 | 0) {
  $$pre$i$i = HEAP32[$doc + 6728 >> 2] | 0;
  $ix$01$i$i = 0;
  do {
   HEAP32[$$pre$i$i + ($ix$01$i$i + $2 << 2) >> 2] = HEAP8[310813 + $ix$01$i$i >> 0];
   $ix$01$i$i = $ix$01$i$i + 1 | 0;
  } while (($ix$01$i$i | 0) != ($15 | 0));
 }
 HEAP32[$1 >> 2] = $16;
 $45 = HEAP32[$node + 32 >> 2] | 0;
 if ($45 | 0) {
  $$pre$i$i1 = $doc + 6728 | 0;
  $47 = HEAP8[$45 >> 0] | 0;
  if ($47 << 24 >> 24) {
   $147 = $16;
   $50 = $47;
   $s$01620 = $45;
   do {
    $49 = $50 & 255;
    HEAP32[$c >> 2] = $49;
    if ($50 << 24 >> 24 < 0) {
     $53 = $s$01620 + (_prvTidyGetUTF8($s$01620, $c) | 0) | 0;
     $55 = HEAP32[$1 >> 2] | 0;
     $75 = HEAP32[$c >> 2] | 0;
     $s$1 = $53;
    } else {
     $55 = $147;
     $75 = $49;
     $s$1 = $s$01620;
    }
    $54 = $55 + 1 | 0;
    $56 = HEAP32[$17 >> 2] | 0;
    if ($54 >>> 0 >= $56 >>> 0) {
     $buflen$0$i$i$i3 = ($56 | 0) == 0 ? 256 : $56;
     while (1) if ($buflen$0$i$i$i3 >>> 0 > $54 >>> 0) {
      $buflen$0$i$i$i3$lcssa = $buflen$0$i$i$i3;
      break;
     } else $buflen$0$i$i$i3 = $buflen$0$i$i$i3 << 1;
     $61 = HEAP32[$0 >> 2] | 0;
     $67 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$61 >> 2] | 0) + 4 >> 2] & 15]($61, HEAP32[$$pre$i$i1 >> 2] | 0, $buflen$0$i$i$i3$lcssa << 2) | 0;
     if ($67 | 0) {
      $69 = HEAP32[$17 >> 2] | 0;
      _memset($67 + ($69 << 2) | 0, 0, $buflen$0$i$i$i3$lcssa - $69 << 2 | 0) | 0;
      HEAP32[$17 >> 2] = $buflen$0$i$i$i3$lcssa;
      HEAP32[$$pre$i$i1 >> 2] = $67;
     }
    }
    HEAP32[(HEAP32[$$pre$i$i1 >> 2] | 0) + ($55 << 2) >> 2] = $75;
    $147 = (HEAP32[$1 >> 2] | 0) + 1 | 0;
    HEAP32[$1 >> 2] = $147;
    $s$01620 = $s$1 + 1 | 0;
    $50 = HEAP8[$s$01620 >> 0] | 0;
   } while ($50 << 24 >> 24 != 0);
  }
 }
 _PPrintText($doc, 16, $indent, $node);
 if (!(HEAP32[$doc + 172 >> 2] | 0)) if (!(HEAP32[$doc + 176 >> 2] | 0)) if (!(HEAP32[$node + 56 >> 2] | 0)) $115 = HEAP32[$1 >> 2] | 0; else label = 29; else label = 29; else label = 29;
 if ((label | 0) == 29) {
  $90 = HEAP32[$1 >> 2] | 0;
  $91 = $90 + 1 | 0;
  $92 = HEAP32[$17 >> 2] | 0;
  if ($91 >>> 0 < $92 >>> 0) $$pre$phi$i$i8Z2D = $doc + 6728 | 0; else {
   $buflen$0$i$i$i7 = ($92 | 0) == 0 ? 256 : $92;
   while (1) if ($buflen$0$i$i$i7 >>> 0 > $91 >>> 0) {
    $buflen$0$i$i$i7$lcssa = $buflen$0$i$i$i7;
    break;
   } else $buflen$0$i$i$i7 = $buflen$0$i$i$i7 << 1;
   $97 = HEAP32[$0 >> 2] | 0;
   $101 = $doc + 6728 | 0;
   $104 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$97 >> 2] | 0) + 4 >> 2] & 15]($97, HEAP32[$101 >> 2] | 0, $buflen$0$i$i$i7$lcssa << 2) | 0;
   if (!$104) $$pre$phi$i$i8Z2D = $101; else {
    $106 = HEAP32[$17 >> 2] | 0;
    _memset($104 + ($106 << 2) | 0, 0, $buflen$0$i$i$i7$lcssa - $106 << 2 | 0) | 0;
    HEAP32[$17 >> 2] = $buflen$0$i$i$i7$lcssa;
    HEAP32[$101 >> 2] = $104;
    $$pre$phi$i$i8Z2D = $101;
   }
  }
  HEAP32[(HEAP32[$$pre$phi$i$i8Z2D >> 2] | 0) + ($90 << 2) >> 2] = 63;
  $113 = (HEAP32[$1 >> 2] | 0) + 1 | 0;
  HEAP32[$1 >> 2] = $113;
  $115 = $113;
 }
 $114 = $115 + 1 | 0;
 $116 = HEAP32[$17 >> 2] | 0;
 if ($114 >>> 0 < $116 >>> 0) $$pre$phi$i$i14Z2D = $doc + 6728 | 0; else {
  $buflen$0$i$i$i13 = ($116 | 0) == 0 ? 256 : $116;
  while (1) if ($buflen$0$i$i$i13 >>> 0 > $114 >>> 0) {
   $buflen$0$i$i$i13$lcssa = $buflen$0$i$i$i13;
   break;
  } else $buflen$0$i$i$i13 = $buflen$0$i$i$i13 << 1;
  $121 = HEAP32[$0 >> 2] | 0;
  $125 = $doc + 6728 | 0;
  $128 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$121 >> 2] | 0) + 4 >> 2] & 15]($121, HEAP32[$125 >> 2] | 0, $buflen$0$i$i$i13$lcssa << 2) | 0;
  if (!$128) $$pre$phi$i$i14Z2D = $125; else {
   $130 = HEAP32[$17 >> 2] | 0;
   _memset($128 + ($130 << 2) | 0, 0, $buflen$0$i$i$i13$lcssa - $130 << 2 | 0) | 0;
   HEAP32[$17 >> 2] = $buflen$0$i$i$i13$lcssa;
   HEAP32[$125 >> 2] = $128;
   $$pre$phi$i$i14Z2D = $125;
  }
 }
 HEAP32[(HEAP32[$$pre$phi$i$i14Z2D >> 2] | 0) + ($115 << 2) >> 2] = 62;
 $137 = (HEAP32[$1 >> 2] | 0) + 1 | 0;
 HEAP32[$1 >> 2] = $137;
 if ($137 | 0) {
  _PFlushLineImpl($doc);
  _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
  $141 = $doc + 6744 | 0;
  HEAP32[$141 >> 2] = (HEAP32[$141 >> 2] | 0) + 1;
 }
 $144 = $doc + 6752 | 0;
 if ((HEAP32[$144 >> 2] | 0) == ($indent | 0)) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$144 >> 2] = $indent;
 STACKTOP = sp;
 return;
}

function _qsort($base, $nel, $width, $cmp) {
 $base = $base | 0;
 $nel = $nel | 0;
 $width = $width | 0;
 $cmp = $cmp | 0;
 var $$0$i = 0, $$0$i29 = 0, $$01$i5$i$ph = 0, $$02$i$i = 0, $$02$i3$i = 0, $$phi$trans$insert$i = 0, $$pre1$i = 0, $$pre1$i5 = 0, $$pre1$i8 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $110 = 0, $116 = 0, $16 = 0, $18 = 0, $20 = 0, $24 = 0, $27 = 0, $37 = 0, $40 = 0, $42 = 0, $45 = 0, $47 = 0, $49 = 0, $50 = 0, $52 = 0, $54 = 0, $56 = 0, $57 = 0, $59 = 0, $6 = 0, $60 = 0, $64 = 0, $69 = 0, $71 = 0, $76 = 0, $79 = 0, $81 = 0, $84 = 0, $88 = 0, $9 = 0, $9$phi = 0, $90 = 0, $92 = 0, $head$0$lcssa = 0, $head$033 = 0, $head$1$be = 0, $head$149 = 0, $i$0 = 0, $lp = 0, $nTrailingZeros$03$i$i = 0, $nTrailingZeros$03$i2$i = 0, $p = 0, $pshift$0$lcssa = 0, $pshift$034 = 0, $pshift$1 = 0, $pshift$2$be = 0, $pshift$250 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 208 | 0;
 $lp = sp + 8 | 0;
 $p = sp;
 $0 = Math_imul($width, $nel) | 0;
 $1 = $p;
 HEAP32[$1 >> 2] = 1;
 HEAP32[$1 + 4 >> 2] = 0;
 if ($0 | 0) {
  $6 = 0 - $width | 0;
  HEAP32[$lp + 4 >> 2] = $width;
  HEAP32[$lp >> 2] = $width;
  $11 = $width;
  $9 = $width;
  $i$0 = 2;
  while (1) {
   $10 = $9 + $width + $11 | 0;
   HEAP32[$lp + ($i$0 << 2) >> 2] = $10;
   if ($10 >>> 0 < $0 >>> 0) {
    $9$phi = $11;
    $11 = $10;
    $i$0 = $i$0 + 1 | 0;
    $9 = $9$phi;
   } else break;
  }
  $16 = $base + $0 + $6 | 0;
  $$phi$trans$insert$i = $p + 4 | 0;
  if ($16 >>> 0 > $base >>> 0) {
   $18 = $16;
   $20 = 1;
   $head$033 = $base;
   $pshift$034 = 1;
   while (1) {
    do if (($20 & 3 | 0) == 3) {
     _sift($head$033, $width, $cmp, $pshift$034, $lp);
     $$pre1$i = HEAP32[$$phi$trans$insert$i >> 2] | 0;
     $24 = $$pre1$i << 30 | (HEAP32[$p >> 2] | 0) >>> 2;
     HEAP32[$p >> 2] = $24;
     HEAP32[$$phi$trans$insert$i >> 2] = $$pre1$i >>> 2;
     $49 = $24;
     $pshift$1 = $pshift$034 + 2 | 0;
    } else {
     $27 = $pshift$034 + -1 | 0;
     if ((HEAP32[$lp + ($27 << 2) >> 2] | 0) >>> 0 < ($18 - $head$033 | 0) >>> 0) _sift($head$033, $width, $cmp, $pshift$034, $lp); else _trinkle($head$033, $width, $cmp, $p, $pshift$034, 0, $lp);
     if (($pshift$034 | 0) == 1) {
      $$pre1$i5 = HEAP32[$p >> 2] | 0;
      HEAP32[$$phi$trans$insert$i >> 2] = $$pre1$i5 >>> 31 | HEAP32[$$phi$trans$insert$i >> 2] << 1;
      $37 = $$pre1$i5 << 1;
      HEAP32[$p >> 2] = $37;
      $49 = $37;
      $pshift$1 = 0;
      break;
     }
     if ($27 >>> 0 > 31) {
      $40 = HEAP32[$p >> 2] | 0;
      HEAP32[$$phi$trans$insert$i >> 2] = $40;
      HEAP32[$p >> 2] = 0;
      $$0$i = $pshift$034 + -33 | 0;
      $42 = $40;
      $45 = 0;
     } else {
      $$0$i = $27;
      $42 = HEAP32[$$phi$trans$insert$i >> 2] | 0;
      $45 = HEAP32[$p >> 2] | 0;
     }
     HEAP32[$$phi$trans$insert$i >> 2] = $45 >>> (32 - $$0$i | 0) | $42 << $$0$i;
     $47 = $45 << $$0$i;
     HEAP32[$p >> 2] = $47;
     $49 = $47;
     $pshift$1 = 1;
    } while (0);
    $20 = $49 | 1;
    HEAP32[$p >> 2] = $20;
    $50 = $head$033 + $width | 0;
    if ($50 >>> 0 >= $16 >>> 0) {
     $head$0$lcssa = $50;
     $pshift$0$lcssa = $pshift$1;
     break;
    } else {
     $head$033 = $50;
     $pshift$034 = $pshift$1;
    }
   }
  } else {
   $head$0$lcssa = $base;
   $pshift$0$lcssa = 1;
  }
  _trinkle($head$0$lcssa, $width, $cmp, $p, $pshift$0$lcssa, 0, $lp);
  $52 = $p + 4 | 0;
  $54 = HEAP32[$p >> 2] | 0;
  $56 = HEAP32[$52 >> 2] | 0;
  $57 = ($56 | 0) == 0;
  if (!(($pshift$0$lcssa | 0) == 1 & ($54 | 0) == 1 & $57)) {
   $116 = $57;
   $60 = $54;
   $69 = $56;
   $head$149 = $head$0$lcssa;
   $pshift$250 = $pshift$0$lcssa;
   while (1) {
    if (($pshift$250 | 0) < 2) {
     $59 = $60 + -1 | 0;
     do if (!$59) {
      $79 = 32;
      label = 28;
     } else {
      if (!($59 & 1)) {
       $$02$i$i = $59;
       $nTrailingZeros$03$i$i = 0;
       while (1) {
        $64 = $nTrailingZeros$03$i$i + 1 | 0;
        $$02$i$i = $$02$i$i >>> 1;
        if ($$02$i$i & 1 | 0) {
         $76 = $64;
         break;
        } else $nTrailingZeros$03$i$i = $64;
       }
      } else {
       if ($116) $$01$i5$i$ph = 32; else {
        if (!($69 & 1)) {
         $$02$i3$i = $69;
         $nTrailingZeros$03$i2$i = 0;
        } else {
         $$0$i29 = 0;
         $81 = $60;
         $84 = $69;
         $88 = 0;
         break;
        }
        while (1) {
         $71 = $nTrailingZeros$03$i2$i + 1 | 0;
         $$02$i3$i = $$02$i3$i >>> 1;
         if ($$02$i3$i & 1 | 0) {
          $$01$i5$i$ph = $71;
          break;
         } else $nTrailingZeros$03$i2$i = $71;
        }
       }
       $76 = $$01$i5$i$ph + 32 | 0;
      }
      if ($76 >>> 0 > 31) {
       $79 = $76;
       label = 28;
      } else {
       $$0$i29 = $76;
       $81 = $60;
       $84 = $69;
       $88 = $76;
      }
     } while (0);
     if ((label | 0) == 28) {
      label = 0;
      HEAP32[$p >> 2] = $69;
      HEAP32[$$phi$trans$insert$i >> 2] = 0;
      $$0$i29 = $79 + -32 | 0;
      $81 = $69;
      $84 = 0;
      $88 = $79;
     }
     HEAP32[$p >> 2] = $84 << 32 - $$0$i29 | $81 >>> $$0$i29;
     HEAP32[$$phi$trans$insert$i >> 2] = $84 >>> $$0$i29;
     $head$1$be = $head$149 + $6 | 0;
     $pshift$2$be = $88 + $pshift$250 | 0;
    } else {
     $90 = $60 >>> 30;
     $92 = $pshift$250 + -2 | 0;
     HEAP32[$p >> 2] = ($60 << 1 & 2147483646 | $90 << 31) ^ 3;
     HEAP32[$$phi$trans$insert$i >> 2] = ($90 | $69 << 2) >>> 1;
     _trinkle($head$149 + (0 - (HEAP32[$lp + ($92 << 2) >> 2] | 0)) + $6 | 0, $width, $cmp, $p, $pshift$250 + -1 | 0, 1, $lp);
     $$pre1$i8 = HEAP32[$p >> 2] | 0;
     HEAP32[$$phi$trans$insert$i >> 2] = $$pre1$i8 >>> 31 | HEAP32[$$phi$trans$insert$i >> 2] << 1;
     HEAP32[$p >> 2] = $$pre1$i8 << 1 | 1;
     $110 = $head$149 + $6 | 0;
     _trinkle($110, $width, $cmp, $p, $92, 1, $lp);
     $head$1$be = $110;
     $pshift$2$be = $92;
    }
    $60 = HEAP32[$p >> 2] | 0;
    $69 = HEAP32[$52 >> 2] | 0;
    $116 = ($69 | 0) == 0;
    if (($pshift$2$be | 0) == 1 & ($60 | 0) == 1 & $116) break; else {
     $head$149 = $head$1$be;
     $pshift$250 = $pshift$2$be;
    }
   }
  }
 }
 STACKTOP = sp;
 return;
}

function _try_realloc_chunk($p, $nb) {
 $p = $p | 0;
 $nb = $nb | 0;
 var $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $101 = 0, $104 = 0, $106 = 0, $109 = 0, $112 = 0, $113 = 0, $114 = 0, $116 = 0, $118 = 0, $119 = 0, $121 = 0, $122 = 0, $127 = 0, $128 = 0, $137 = 0, $142 = 0, $145 = 0, $146 = 0, $152 = 0, $163 = 0, $166 = 0, $173 = 0, $2 = 0, $20 = 0, $22 = 0, $29 = 0, $3 = 0, $35 = 0, $37 = 0, $38 = 0, $4 = 0, $47 = 0, $49 = 0, $5 = 0, $51 = 0, $52 = 0, $58 = 0, $65 = 0, $71 = 0, $73 = 0, $74 = 0, $77 = 0, $79 = 0, $8 = 0, $81 = 0, $94 = 0, $99 = 0, $R$1 = 0, $R$1$lcssa = 0, $R$3 = 0, $RP$1 = 0, $RP$1$lcssa = 0, $newp$2 = 0, $storemerge = 0, $storemerge1 = 0;
 $0 = $p + 4 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $1 & -8;
 $3 = $p + $2 | 0;
 $4 = HEAP32[79272] | 0;
 $5 = $1 & 3;
 if (!(($5 | 0) != 1 & $p >>> 0 >= $4 >>> 0 & $p >>> 0 < $3 >>> 0)) _abort();
 $8 = HEAP32[$3 + 4 >> 2] | 0;
 if (!($8 & 1)) _abort();
 if (!$5) {
  if ($nb >>> 0 < 256) {
   $newp$2 = 0;
   return $newp$2 | 0;
  }
  if ($2 >>> 0 >= ($nb + 4 | 0) >>> 0) if (($2 - $nb | 0) >>> 0 <= HEAP32[79388] << 1 >>> 0) {
   $newp$2 = $p;
   return $newp$2 | 0;
  }
  $newp$2 = 0;
  return $newp$2 | 0;
 }
 if ($2 >>> 0 >= $nb >>> 0) {
  $20 = $2 - $nb | 0;
  if ($20 >>> 0 <= 15) {
   $newp$2 = $p;
   return $newp$2 | 0;
  }
  $22 = $p + $nb | 0;
  HEAP32[$0 >> 2] = $1 & 1 | $nb | 2;
  HEAP32[$22 + 4 >> 2] = $20 | 3;
  $29 = $22 + $20 + 4 | 0;
  HEAP32[$29 >> 2] = HEAP32[$29 >> 2] | 1;
  _dispose_chunk($22, $20);
  $newp$2 = $p;
  return $newp$2 | 0;
 }
 if (($3 | 0) == (HEAP32[79274] | 0)) {
  $35 = (HEAP32[79271] | 0) + $2 | 0;
  if ($35 >>> 0 <= $nb >>> 0) {
   $newp$2 = 0;
   return $newp$2 | 0;
  }
  $37 = $35 - $nb | 0;
  $38 = $p + $nb | 0;
  HEAP32[$0 >> 2] = $1 & 1 | $nb | 2;
  HEAP32[$38 + 4 >> 2] = $37 | 1;
  HEAP32[79274] = $38;
  HEAP32[79271] = $37;
  $newp$2 = $p;
  return $newp$2 | 0;
 }
 if (($3 | 0) == (HEAP32[79273] | 0)) {
  $47 = (HEAP32[79270] | 0) + $2 | 0;
  if ($47 >>> 0 < $nb >>> 0) {
   $newp$2 = 0;
   return $newp$2 | 0;
  }
  $49 = $47 - $nb | 0;
  if ($49 >>> 0 > 15) {
   $51 = $p + $nb | 0;
   $52 = $51 + $49 | 0;
   HEAP32[$0 >> 2] = $1 & 1 | $nb | 2;
   HEAP32[$51 + 4 >> 2] = $49 | 1;
   HEAP32[$52 >> 2] = $49;
   $58 = $52 + 4 | 0;
   HEAP32[$58 >> 2] = HEAP32[$58 >> 2] & -2;
   $storemerge = $51;
   $storemerge1 = $49;
  } else {
   HEAP32[$0 >> 2] = $1 & 1 | $47 | 2;
   $65 = $p + $47 + 4 | 0;
   HEAP32[$65 >> 2] = HEAP32[$65 >> 2] | 1;
   $storemerge = 0;
   $storemerge1 = 0;
  }
  HEAP32[79270] = $storemerge1;
  HEAP32[79273] = $storemerge;
  $newp$2 = $p;
  return $newp$2 | 0;
 }
 if ($8 & 2 | 0) {
  $newp$2 = 0;
  return $newp$2 | 0;
 }
 $71 = ($8 & -8) + $2 | 0;
 if ($71 >>> 0 < $nb >>> 0) {
  $newp$2 = 0;
  return $newp$2 | 0;
 }
 $73 = $71 - $nb | 0;
 $74 = $8 >>> 3;
 do if ($8 >>> 0 < 256) {
  $77 = HEAP32[$3 + 8 >> 2] | 0;
  $79 = HEAP32[$3 + 12 >> 2] | 0;
  $81 = 317112 + ($74 << 1 << 2) | 0;
  if (($77 | 0) != ($81 | 0)) {
   if ($77 >>> 0 < $4 >>> 0) _abort();
   if ((HEAP32[$77 + 12 >> 2] | 0) != ($3 | 0)) _abort();
  }
  if (($79 | 0) == ($77 | 0)) {
   HEAP32[79268] = HEAP32[79268] & ~(1 << $74);
   break;
  }
  if (($79 | 0) == ($81 | 0)) $$pre$phiZ2D = $79 + 8 | 0; else {
   if ($79 >>> 0 < $4 >>> 0) _abort();
   $94 = $79 + 8 | 0;
   if ((HEAP32[$94 >> 2] | 0) == ($3 | 0)) $$pre$phiZ2D = $94; else _abort();
  }
  HEAP32[$77 + 12 >> 2] = $79;
  HEAP32[$$pre$phiZ2D >> 2] = $77;
 } else {
  $99 = HEAP32[$3 + 24 >> 2] | 0;
  $101 = HEAP32[$3 + 12 >> 2] | 0;
  do if (($101 | 0) == ($3 | 0)) {
   $112 = $3 + 16 | 0;
   $113 = $112 + 4 | 0;
   $114 = HEAP32[$113 >> 2] | 0;
   if (!$114) {
    $116 = HEAP32[$112 >> 2] | 0;
    if (!$116) {
     $R$3 = 0;
     break;
    } else {
     $R$1 = $116;
     $RP$1 = $112;
    }
   } else {
    $R$1 = $114;
    $RP$1 = $113;
   }
   while (1) {
    $118 = $R$1 + 20 | 0;
    $119 = HEAP32[$118 >> 2] | 0;
    if ($119 | 0) {
     $R$1 = $119;
     $RP$1 = $118;
     continue;
    }
    $121 = $R$1 + 16 | 0;
    $122 = HEAP32[$121 >> 2] | 0;
    if (!$122) {
     $R$1$lcssa = $R$1;
     $RP$1$lcssa = $RP$1;
     break;
    } else {
     $R$1 = $122;
     $RP$1 = $121;
    }
   }
   if ($RP$1$lcssa >>> 0 < $4 >>> 0) _abort(); else {
    HEAP32[$RP$1$lcssa >> 2] = 0;
    $R$3 = $R$1$lcssa;
    break;
   }
  } else {
   $104 = HEAP32[$3 + 8 >> 2] | 0;
   if ($104 >>> 0 < $4 >>> 0) _abort();
   $106 = $104 + 12 | 0;
   if ((HEAP32[$106 >> 2] | 0) != ($3 | 0)) _abort();
   $109 = $101 + 8 | 0;
   if ((HEAP32[$109 >> 2] | 0) == ($3 | 0)) {
    HEAP32[$106 >> 2] = $101;
    HEAP32[$109 >> 2] = $104;
    $R$3 = $101;
    break;
   } else _abort();
  } while (0);
  if ($99 | 0) {
   $127 = HEAP32[$3 + 28 >> 2] | 0;
   $128 = 317376 + ($127 << 2) | 0;
   if (($3 | 0) == (HEAP32[$128 >> 2] | 0)) {
    HEAP32[$128 >> 2] = $R$3;
    if (!$R$3) {
     HEAP32[79269] = HEAP32[79269] & ~(1 << $127);
     break;
    }
   } else {
    if ($99 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort();
    $137 = $99 + 16 | 0;
    if ((HEAP32[$137 >> 2] | 0) == ($3 | 0)) HEAP32[$137 >> 2] = $R$3; else HEAP32[$99 + 20 >> 2] = $R$3;
    if (!$R$3) break;
   }
   $142 = HEAP32[79272] | 0;
   if ($R$3 >>> 0 < $142 >>> 0) _abort();
   HEAP32[$R$3 + 24 >> 2] = $99;
   $145 = $3 + 16 | 0;
   $146 = HEAP32[$145 >> 2] | 0;
   do if ($146 | 0) if ($146 >>> 0 < $142 >>> 0) _abort(); else {
    HEAP32[$R$3 + 16 >> 2] = $146;
    HEAP32[$146 + 24 >> 2] = $R$3;
    break;
   } while (0);
   $152 = HEAP32[$145 + 4 >> 2] | 0;
   if ($152 | 0) if ($152 >>> 0 < (HEAP32[79272] | 0) >>> 0) _abort(); else {
    HEAP32[$R$3 + 20 >> 2] = $152;
    HEAP32[$152 + 24 >> 2] = $R$3;
    break;
   }
  }
 } while (0);
 if ($73 >>> 0 < 16) {
  HEAP32[$0 >> 2] = $71 | $1 & 1 | 2;
  $163 = $p + $71 + 4 | 0;
  HEAP32[$163 >> 2] = HEAP32[$163 >> 2] | 1;
  $newp$2 = $p;
  return $newp$2 | 0;
 } else {
  $166 = $p + $nb | 0;
  HEAP32[$0 >> 2] = $1 & 1 | $nb | 2;
  HEAP32[$166 + 4 >> 2] = $73 | 3;
  $173 = $166 + $73 + 4 | 0;
  HEAP32[$173 >> 2] = HEAP32[$173 >> 2] | 1;
  _dispose_chunk($166, $73);
  $newp$2 = $p;
  return $newp$2 | 0;
 }
 return 0;
}

function _prvTidyFreeDeclaredTags($doc, $tagType) {
 $doc = $doc | 0;
 $tagType = $tagType | 0;
 var $$01$i$i = 0, $$01$i$i$us = 0, $$lcssa = 0, $$lcssa42 = 0, $$lcssa43 = 0, $$lcssa46 = 0, $$pre$i = 0, $0 = 0, $1 = 0, $10 = 0, $102 = 0, $11 = 0, $12 = 0, $15 = 0, $17 = 0, $21 = 0, $23 = 0, $29 = 0, $30 = 0, $33 = 0, $37 = 0, $42 = 0, $70 = 0, $71 = 0, $72 = 0, $75 = 0, $77 = 0, $81 = 0, $83 = 0, $89 = 0, $90 = 0, $93 = 0, $97 = 0, $curr$06 = 0, $curr$06$us = 0, $hashval$0$lcssa$i$i = 0, $hashval$0$lcssa$i$i$us = 0, $hashval$02$i$i = 0, $hashval$02$i$i$us = 0, $p$0$i = 0, $p$0$i$lcssa45 = 0, $p$0$i$us = 0, $p$0$i$us$lcssa41 = 0, $p$0$in$i = 0, $p$0$in$i$us = 0, $prev$0$be = 0, $prev$0$be$us = 0, $prev$0$i = 0, $prev$0$i$lcssa44 = 0, $prev$0$i$us = 0, $prev$0$i$us$lcssa40 = 0, $prev$07 = 0, $prev$07$us = 0, label = 0, $curr$06$us$looptemp = 0, $curr$06$looptemp = 0;
 $0 = $doc + 880 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) return;
 $$pre$i = $doc + 6856 | 0;
 if (($tagType | 0) == 1) {
  $curr$06$us = $1;
  $prev$07$us = 0;
  while (1) {
   $curr$06$us$looptemp = $curr$06$us;
   $curr$06$us = HEAP32[$curr$06$us + 28 >> 2] | 0;
   do if (!(HEAP32[$curr$06$us$looptemp + 16 >> 2] & 1)) $prev$0$be$us = $curr$06$us$looptemp; else {
    $10 = $curr$06$us$looptemp + 4 | 0;
    $11 = HEAP32[$10 >> 2] | 0;
    $12 = HEAP8[$11 >> 0] | 0;
    if (!($12 << 24 >> 24)) $hashval$0$lcssa$i$i$us = 0; else {
     $$01$i$i$us = $11;
     $15 = $12;
     $hashval$02$i$i$us = 0;
     while (1) {
      $17 = ($hashval$02$i$i$us * 31 | 0) + ($15 << 24 >> 24) | 0;
      $$01$i$i$us = $$01$i$i$us + 1 | 0;
      $15 = HEAP8[$$01$i$i$us >> 0] | 0;
      if (!($15 << 24 >> 24)) {
       $$lcssa = $17;
       break;
      } else $hashval$02$i$i$us = $17;
     }
     $hashval$0$lcssa$i$i$us = ($$lcssa >>> 0) % 178 | 0;
    }
    $21 = $doc + 884 + ($hashval$0$lcssa$i$i$us << 2) | 0;
    $p$0$in$i$us = $21;
    $prev$0$i$us = 0;
    while (1) {
     $p$0$i$us = HEAP32[$p$0$in$i$us >> 2] | 0;
     if (!$p$0$i$us) break;
     $23 = HEAP32[$p$0$i$us >> 2] | 0;
     if (!$23) break;
     $29 = $p$0$i$us + 4 | 0;
     if (!(_prvTidytmbstrcmp($11, HEAP32[$23 + 4 >> 2] | 0) | 0)) {
      $$lcssa42 = $29;
      $p$0$i$us$lcssa41 = $p$0$i$us;
      $prev$0$i$us$lcssa40 = $prev$0$i$us;
      label = 11;
      break;
     } else {
      $p$0$in$i$us = $29;
      $prev$0$i$us = $p$0$i$us;
     }
    }
    if ((label | 0) == 11) {
     label = 0;
     $30 = HEAP32[$$lcssa42 >> 2] | 0;
     if (!$prev$0$i$us$lcssa40) HEAP32[$21 >> 2] = $30; else HEAP32[$prev$0$i$us$lcssa40 + 4 >> 2] = $30;
     $33 = HEAP32[$$pre$i >> 2] | 0;
     FUNCTION_TABLE_vii[HEAP32[(HEAP32[$33 >> 2] | 0) + 8 >> 2] & 15]($33, $p$0$i$us$lcssa41);
    }
    $37 = HEAP32[$$pre$i >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$37 >> 2] | 0) + 8 >> 2] & 15]($37, HEAP32[$10 >> 2] | 0);
    $42 = HEAP32[$$pre$i >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$42 >> 2] | 0) + 8 >> 2] & 15]($42, $curr$06$us$looptemp);
    if (!$prev$07$us) {
     HEAP32[$0 >> 2] = $curr$06$us;
     $prev$0$be$us = 0;
     break;
    } else {
     HEAP32[$prev$07$us + 28 >> 2] = $curr$06$us;
     $prev$0$be$us = $prev$07$us;
     break;
    }
   } while (0);
   if (!$curr$06$us) break; else $prev$07$us = $prev$0$be$us;
  }
  return;
 } else {
  $curr$06 = $1;
  $prev$07 = 0;
 }
 while (1) {
  $curr$06$looptemp = $curr$06;
  $curr$06 = HEAP32[$curr$06 + 28 >> 2] | 0;
  switch ($tagType | 0) {
  case 8:
   {
    if (!(HEAP32[$curr$06$looptemp + 16 >> 2] & 8)) $prev$0$be = $curr$06$looptemp; else if ((HEAP32[$curr$06$looptemp + 20 >> 2] | 0) == 35) label = 26; else $prev$0$be = $curr$06$looptemp;
    break;
   }
  case 2:
   {
    if (!(HEAP32[$curr$06$looptemp + 16 >> 2] & 16)) $prev$0$be = $curr$06$looptemp; else label = 26;
    break;
   }
  case 4:
   {
    if (!(HEAP32[$curr$06$looptemp + 16 >> 2] & 8)) $prev$0$be = $curr$06$looptemp; else if ((HEAP32[$curr$06$looptemp + 20 >> 2] | 0) == 25) label = 26; else $prev$0$be = $curr$06$looptemp;
    break;
   }
  default:
   label = 26;
  }
  do if ((label | 0) == 26) {
   label = 0;
   $70 = $curr$06$looptemp + 4 | 0;
   $71 = HEAP32[$70 >> 2] | 0;
   $72 = HEAP8[$71 >> 0] | 0;
   if (!($72 << 24 >> 24)) $hashval$0$lcssa$i$i = 0; else {
    $$01$i$i = $71;
    $75 = $72;
    $hashval$02$i$i = 0;
    while (1) {
     $77 = ($hashval$02$i$i * 31 | 0) + ($75 << 24 >> 24) | 0;
     $$01$i$i = $$01$i$i + 1 | 0;
     $75 = HEAP8[$$01$i$i >> 0] | 0;
     if (!($75 << 24 >> 24)) {
      $$lcssa43 = $77;
      break;
     } else $hashval$02$i$i = $77;
    }
    $hashval$0$lcssa$i$i = ($$lcssa43 >>> 0) % 178 | 0;
   }
   $81 = $doc + 884 + ($hashval$0$lcssa$i$i << 2) | 0;
   $p$0$in$i = $81;
   $prev$0$i = 0;
   while (1) {
    $p$0$i = HEAP32[$p$0$in$i >> 2] | 0;
    if (!$p$0$i) break;
    $83 = HEAP32[$p$0$i >> 2] | 0;
    if (!$83) break;
    $89 = $p$0$i + 4 | 0;
    if (!(_prvTidytmbstrcmp($71, HEAP32[$83 + 4 >> 2] | 0) | 0)) {
     $$lcssa46 = $89;
     $p$0$i$lcssa45 = $p$0$i;
     $prev$0$i$lcssa44 = $prev$0$i;
     label = 33;
     break;
    } else {
     $p$0$in$i = $89;
     $prev$0$i = $p$0$i;
    }
   }
   if ((label | 0) == 33) {
    label = 0;
    $90 = HEAP32[$$lcssa46 >> 2] | 0;
    if (!$prev$0$i$lcssa44) HEAP32[$81 >> 2] = $90; else HEAP32[$prev$0$i$lcssa44 + 4 >> 2] = $90;
    $93 = HEAP32[$$pre$i >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$93 >> 2] | 0) + 8 >> 2] & 15]($93, $p$0$i$lcssa45);
   }
   $97 = HEAP32[$$pre$i >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$97 >> 2] | 0) + 8 >> 2] & 15]($97, HEAP32[$70 >> 2] | 0);
   $102 = HEAP32[$$pre$i >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$102 >> 2] | 0) + 8 >> 2] & 15]($102, $curr$06$looptemp);
   if (!$prev$07) {
    HEAP32[$0 >> 2] = $curr$06;
    $prev$0$be = 0;
    break;
   } else {
    HEAP32[$prev$07 + 28 >> 2] = $curr$06;
    $prev$0$be = $prev$07;
    break;
   }
  } while (0);
  if (!$curr$06) break; else $prev$07 = $prev$0$be;
 }
 return;
}

function _prvTidyParseNamespace($doc, $basenode, $mode) {
 $doc = $doc | 0;
 $basenode = $basenode | 0;
 $mode = $mode | 0;
 var $$lcssa = 0, $$lcssa10 = 0, $$lcssa12 = 0, $$lcssa9 = 0, $$lcssa90 = 0, $$lcssa90$lcssa = 0, $$pre$phiZ2D = 0, $1 = 0, $10 = 0, $12 = 0, $13 = 0, $15 = 0, $16 = 0, $2 = 0, $20 = 0, $24 = 0, $3 = 0, $32 = 0, $35 = 0, $36 = 0, $40 = 0, $41 = 0, $44 = 0, $47 = 0, $48 = 0, $55 = 0, $6 = 0, $66 = 0, $72 = 0, $8 = 0, $82 = 0, $9 = 0, $90 = 0, $av$016 = 0, $av$114 = 0, $av$114$us = 0, $cb_data$i = 0, $n$019$lcssa = 0, $n$01969 = 0, $or$cond = 0, $or$cond68 = 0, $parent$0$ph$be = 0, $parent$0$ph24 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $cb_data$i = sp;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 _prvTidyDeferDup($doc);
 $2 = $1 + 116 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 HEAP32[$2 >> 2] = HEAP32[$1 + 112 >> 2];
 $6 = _prvTidyGetToken($doc, 4) | 0;
 L1 : do if (!$6) $$pre$phiZ2D = $basenode; else {
  $8 = $cb_data$i + 8 | 0;
  $9 = $cb_data$i + 12 | 0;
  $10 = $cb_data$i + 16 | 0;
  $90 = $6;
  $parent$0$ph24 = $basenode;
  L4 : while (1) {
   $12 = $parent$0$ph24 + 16 | 0;
   $13 = $parent$0$ph24 + 12 | 0;
   L6 : do if (!$parent$0$ph24) {
    $15 = $90;
    while (1) {
     $16 = HEAP32[$15 + 44 >> 2] | 0;
     if (($16 | 0) == 6) {
      $$lcssa90 = $15;
      break;
     }
     $20 = HEAP32[$15 + 20 >> 2] | 0;
     if (($16 | 0) == 5) {
      $$lcssa = $20;
      $$lcssa9 = $15;
      label = 29;
      break L6;
     }
     if ($20 | 0) {
      $av$114$us = $20;
      do {
       HEAP32[$av$114$us + 4 >> 2] = 0;
       $av$114$us = HEAP32[$av$114$us >> 2] | 0;
      } while (($av$114$us | 0) != 0);
     }
     HEAP32[$15 >> 2] = 0;
     $24 = HEAP32[$12 >> 2] | 0;
     HEAP32[$15 + 4 >> 2] = $24;
     if (!$24) HEAP32[$13 >> 2] = $15; else HEAP32[$24 + 8 >> 2] = $15;
     HEAP32[$12 >> 2] = $15;
     $15 = _prvTidyGetToken($doc, 4) | 0;
     if (!$15) {
      $$pre$phiZ2D = $basenode;
      break L1;
     }
    }
    HEAP32[$cb_data$i >> 2] = 0;
    HEAP32[$cb_data$i + 4 >> 2] = 0;
    HEAP32[$cb_data$i + 8 >> 2] = 0;
    HEAP32[$cb_data$i + 12 >> 2] = 0;
    HEAP32[$cb_data$i + 16 >> 2] = 0;
    $32 = HEAP32[$$lcssa90 + 28 >> 2] | 0;
    if (!$32) $35 = 0; else $35 = HEAP32[$32 >> 2] | 0;
    HEAP32[$8 >> 2] = $35;
    HEAP32[$9 >> 2] = $$lcssa90;
    HEAP32[$10 >> 2] = $basenode;
    _prvTidyTraverseNodeTree(0, 0, 7, $cb_data$i) | 0;
    $36 = HEAP32[$cb_data$i >> 2] | 0;
    if (!$36) {
     $$lcssa90$lcssa = $$lcssa90;
     label = 15;
     break L4;
    } else {
     $$lcssa10 = $$lcssa90;
     $$lcssa12 = $36;
     label = 21;
    }
   } else {
    $40 = $90;
    while (1) {
     $41 = HEAP32[$40 + 44 >> 2] | 0;
     if (($41 | 0) == 6) {
      HEAP32[$cb_data$i >> 2] = 0;
      HEAP32[$cb_data$i + 4 >> 2] = 0;
      HEAP32[$cb_data$i + 8 >> 2] = 0;
      HEAP32[$cb_data$i + 12 >> 2] = 0;
      HEAP32[$cb_data$i + 16 >> 2] = 0;
      $44 = HEAP32[$40 + 28 >> 2] | 0;
      if (!$44) $47 = 0; else $47 = HEAP32[$44 >> 2] | 0;
      HEAP32[$8 >> 2] = $47;
      HEAP32[$9 >> 2] = $40;
      HEAP32[$10 >> 2] = $basenode;
      _prvTidyTraverseNodeTree(0, $parent$0$ph24, 7, $cb_data$i) | 0;
      $48 = HEAP32[$cb_data$i >> 2] | 0;
      if ($48 | 0) {
       $$lcssa10 = $40;
       $$lcssa12 = $48;
       label = 21;
       break L6;
      }
      _prvTidyReportError($doc, $parent$0$ph24, $40, 208);
      _prvTidyFreeNode($doc, $40);
     } else {
      $66 = HEAP32[$40 + 20 >> 2] | 0;
      if (($41 | 0) == 5) {
       $$lcssa = $66;
       $$lcssa9 = $40;
       label = 29;
       break L6;
      }
      if ($66 | 0) {
       $av$114 = $66;
       do {
        HEAP32[$av$114 + 4 >> 2] = 0;
        $av$114 = HEAP32[$av$114 >> 2] | 0;
       } while (($av$114 | 0) != 0);
      }
      HEAP32[$40 >> 2] = $parent$0$ph24;
      $82 = HEAP32[$12 >> 2] | 0;
      HEAP32[$40 + 4 >> 2] = $82;
      if (!$82) HEAP32[$13 >> 2] = $40; else HEAP32[$82 + 8 >> 2] = $40;
      HEAP32[$12 >> 2] = $40;
     }
     $40 = _prvTidyGetToken($doc, 4) | 0;
     if (!$40) {
      $$pre$phiZ2D = $basenode;
      break L1;
     }
    }
   } while (0);
   if ((label | 0) == 21) {
    label = 0;
    $or$cond68 = ($parent$0$ph24 | 0) == ($$lcssa12 | 0) ? 1 : ($parent$0$ph24 | 0) == (HEAP32[$basenode >> 2] | 0);
    HEAP32[$parent$0$ph24 + 56 >> 2] = 1;
    if ($or$cond68) $n$019$lcssa = $parent$0$ph24; else {
     $n$01969 = $parent$0$ph24;
     while (1) {
      _prvTidyReportError($doc, HEAP32[$n$01969 >> 2] | 0, $n$01969, 207);
      $55 = HEAP32[$n$01969 >> 2] | 0;
      $or$cond = ($55 | 0) == ($$lcssa12 | 0) ? 1 : ($55 | 0) == (HEAP32[$basenode >> 2] | 0);
      HEAP32[$55 + 56 >> 2] = 1;
      if ($or$cond) {
       $n$019$lcssa = $55;
       break;
      } else $n$01969 = $55;
     }
    }
    _prvTidyFreeNode($doc, $$lcssa10);
    if (($n$019$lcssa | 0) == ($basenode | 0)) break; else $parent$0$ph$be = HEAP32[$n$019$lcssa >> 2] | 0;
   } else if ((label | 0) == 29) {
    label = 0;
    if ($$lcssa | 0) {
     $av$016 = $$lcssa;
     do {
      HEAP32[$av$016 + 4 >> 2] = 0;
      $av$016 = HEAP32[$av$016 >> 2] | 0;
     } while (($av$016 | 0) != 0);
    }
    HEAP32[$$lcssa9 >> 2] = $parent$0$ph24;
    $72 = HEAP32[$12 >> 2] | 0;
    HEAP32[$$lcssa9 + 4 >> 2] = $72;
    if (!$72) HEAP32[$13 >> 2] = $$lcssa9; else HEAP32[$72 + 8 >> 2] = $$lcssa9;
    HEAP32[$12 >> 2] = $$lcssa9;
    $parent$0$ph$be = $$lcssa9;
   }
   $90 = _prvTidyGetToken($doc, 4) | 0;
   if (!$90) {
    $$pre$phiZ2D = $basenode;
    break L1;
   } else $parent$0$ph24 = $parent$0$ph$be;
  }
  if ((label | 0) == 15) {
   _prvTidyReportError($doc, 0, $$lcssa90$lcssa, 208);
   ___assert_fail(307968, 307744, 1604, 307975);
  }
  HEAP32[$2 >> 2] = $3;
  if ((HEAP32[$basenode + 56 >> 2] | 0) == 1) {
   STACKTOP = sp;
   return;
  } else ___assert_fail(307997, 307744, 1595, 307975);
 } while (0);
 _prvTidyReportError($doc, HEAP32[$$pre$phiZ2D >> 2] | 0, $basenode, 206);
 STACKTOP = sp;
 return;
}

function _prvTidyDecodeUTF8BytesToChar($c, $firstByte, $successorBytes, $inp, $count) {
 $c = $c | 0;
 $firstByte = $firstByte | 0;
 $successorBytes = $successorBytes | 0;
 $inp = $inp | 0;
 $count = $count | 0;
 var $$0 = 0, $$hasError$4 = 0, $$lcssa76 = 0, $$lcssa77 = 0, $0 = 0, $16 = 0, $18 = 0, $21 = 0, $23 = 0, $29 = 0, $33 = 0, $35 = 0, $36 = 0, $43 = 0, $44 = 0, $49 = 0, $56 = 0, $59 = 0, $68 = 0, $70 = 0, $80 = 0, $85 = 0, $bytes$0 = 0, $bytes$3 = 0, $hasError$0 = 0, $hasError$11 = 0, $hasError$3 = 0, $hasError$4 = 0, $hasError$629$us = 0, $hasError$7$lcssa$us = 0, $hasError$722$us = 0, $i$032 = 0, $i$032$lcssa = 0, $i$136 = 0, $i$136$lcssa74 = 0, $i$227$us = 0, $n$0 = 0, $n$131 = 0, $n$131$lcssa = 0, $n$235 = 0, $n$235$lcssa75 = 0, $n$4 = 0, $successorBytes$ = 0, $tempCount$023$us = 0, $theByte$0$us = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $0 = ($successorBytes | 0) != 0;
 $successorBytes$ = $0 ? $successorBytes : sp;
 if (($firstByte | 0) == -1) {
  HEAP32[$c >> 2] = -1;
  HEAP32[$count >> 2] = 1;
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 do if ($firstByte >>> 0 < 128) {
  $bytes$0 = 1;
  $hasError$0 = 0;
  $n$0 = $firstByte;
 } else {
  if (($firstByte & 224 | 0) == 192) {
   $bytes$0 = 2;
   $hasError$0 = 0;
   $n$0 = $firstByte & 31;
   break;
  }
  if (($firstByte & 240 | 0) == 224) {
   $bytes$0 = 3;
   $hasError$0 = 0;
   $n$0 = $firstByte & 15;
   break;
  }
  if (($firstByte & 248 | 0) == 240) {
   $bytes$0 = 4;
   $hasError$0 = 0;
   $n$0 = $firstByte & 7;
   break;
  }
  if (($firstByte & 252 | 0) == 248) {
   $bytes$0 = 5;
   $hasError$0 = 1;
   $n$0 = $firstByte & 3;
   break;
  } else {
   $16 = ($firstByte & 254 | 0) == 252;
   $bytes$0 = $16 ? 6 : 1;
   $hasError$0 = 1;
   $n$0 = $16 ? $firstByte & 1 : $firstByte;
   break;
  }
 } while (0);
 L20 : do if ($0) {
  $18 = $bytes$0 + -1 | 0;
  if ($bytes$0 >>> 0 > 1) {
   $i$032 = 0;
   $n$131 = $n$0;
   while (1) {
    $21 = HEAP8[$successorBytes$ + $i$032 >> 0] | 0;
    if (!($21 << 24 >> 24)) {
     $i$032$lcssa = $i$032;
     $n$131$lcssa = $n$131;
     break;
    }
    $23 = $21 & 255;
    if (($23 & 192 | 0) != 128) {
     $i$032$lcssa = $i$032;
     $n$131$lcssa = $n$131;
     break;
    }
    $29 = $23 & 63 | $n$131 << 6;
    $i$032 = $i$032 + 1 | 0;
    if (($i$032 | 0) >= ($18 | 0)) {
     $bytes$3 = $bytes$0;
     $hasError$3 = $hasError$0;
     $n$4 = $29;
     break L20;
    } else $n$131 = $29;
   }
   $bytes$3 = $i$032$lcssa + 1 | 0;
   $hasError$3 = 1;
   $n$4 = $n$131$lcssa;
  } else {
   $bytes$3 = $bytes$0;
   $hasError$3 = $hasError$0;
   $n$4 = $n$0;
  }
 } else {
  if (!$inp) {
   $59 = $bytes$0 >>> 0 > 1;
   $bytes$3 = $59 ? 1 : $bytes$0;
   $hasError$3 = $59 ? 1 : $hasError$0;
   $n$4 = $n$0;
   break;
  }
  $33 = $bytes$0 + -1 | 0;
  if ($bytes$0 >>> 0 > 1) {
   $35 = $inp + 12 | 0;
   $36 = $inp + 4 | 0;
   $i$136 = 0;
   $n$235 = $n$0;
   while (1) {
    if (FUNCTION_TABLE_ii[HEAP32[$35 >> 2] & 31](HEAP32[$inp >> 2] | 0) | 0) {
     $bytes$3 = $bytes$0;
     $hasError$3 = $hasError$0;
     $n$4 = $n$235;
     break L20;
    }
    $43 = FUNCTION_TABLE_ii[HEAP32[$36 >> 2] & 31](HEAP32[$inp >> 2] | 0) | 0;
    $44 = $43 & 255;
    HEAP8[$successorBytes$ + $i$136 >> 0] = $44;
    if (!(($43 | 0) != -1 & ($43 & 192 | 0) == 128)) {
     $$lcssa76 = $43;
     $$lcssa77 = $44;
     $i$136$lcssa74 = $i$136;
     $n$235$lcssa75 = $n$235;
     break;
    }
    $56 = $43 & 63 | $n$235 << 6;
    $i$136 = $i$136 + 1 | 0;
    if (($i$136 | 0) >= ($33 | 0)) {
     $bytes$3 = $bytes$0;
     $hasError$3 = $hasError$0;
     $n$4 = $56;
     break L20;
    } else $n$235 = $56;
   }
   $49 = $i$136$lcssa74 + 1 | 0;
   if (($$lcssa76 | 0) == -1) {
    $bytes$3 = $49;
    $hasError$3 = 1;
    $n$4 = $n$235$lcssa75;
   } else {
    FUNCTION_TABLE_vii[HEAP32[$inp + 8 >> 2] & 15](HEAP32[$inp >> 2] | 0, $$lcssa77);
    $bytes$3 = $49;
    $hasError$3 = 1;
    $n$4 = $n$235$lcssa75;
   }
  } else {
   $bytes$3 = $bytes$0;
   $hasError$3 = $hasError$0;
   $n$4 = $n$0;
  }
 } while (0);
 $hasError$4 = ($n$4 | 1 | 0) == 65535 & ($hasError$3 | 0) == 0 ? 1 : $hasError$3;
 $$hasError$4 = $n$4 >>> 0 > 1114111 & ($hasError$4 | 0) == 0 ? 1 : $hasError$4;
 if (!$$hasError$4) {
  $68 = HEAP32[6604 + ($bytes$3 + -1 << 2) >> 2] | 0;
  $70 = HEAP32[6604 + ($bytes$3 << 2) >> 2] | 0;
  if ($n$4 >>> 0 < (HEAP32[6624 + ($68 * 20 | 0) >> 2] | 0) >>> 0) $hasError$11 = 1; else if (($68 | 0) < ($70 | 0) ? $n$4 >>> 0 <= (HEAP32[6624 + (($70 + -1 | 0) * 20 | 0) + 4 >> 2] | 0) >>> 0 : 0) {
   $80 = $firstByte & 255;
   if (($bytes$3 | 0) > 0) {
    $hasError$629$us = 1;
    $i$227$us = $68;
    while (1) {
     $hasError$722$us = $hasError$629$us;
     $tempCount$023$us = 0;
     while (1) {
      if (!$tempCount$023$us) $theByte$0$us = $80; else $theByte$0$us = HEAP8[$successorBytes$ + ($tempCount$023$us + -1) >> 0] | 0;
      $85 = $tempCount$023$us << 1;
      if (($theByte$0$us & 255) < (HEAPU8[6624 + ($i$227$us * 20 | 0) + 12 + $85 >> 0] | 0)) {
       if ($hasError$722$us | 0) {
        $hasError$7$lcssa$us = $hasError$722$us;
        break;
       }
      } else if (!(($hasError$722$us | 0) == 0 ? 1 : ($theByte$0$us & 255) <= (HEAPU8[($85 | 1) + (6624 + ($i$227$us * 20 | 0) + 12) >> 0] | 0))) {
       $hasError$7$lcssa$us = $hasError$722$us;
       break;
      }
      $tempCount$023$us = $tempCount$023$us + 1 | 0;
      if (($tempCount$023$us | 0) >= ($bytes$3 | 0)) {
       $hasError$7$lcssa$us = 0;
       break;
      } else $hasError$722$us = 0;
     }
     $i$227$us = $i$227$us + 1 | 0;
     if (($i$227$us | 0) == ($70 | 0)) {
      $hasError$11 = $hasError$7$lcssa$us;
      break;
     } else $hasError$629$us = $hasError$7$lcssa$us;
    }
   } else $hasError$11 = 1;
  } else $hasError$11 = 1;
 } else $hasError$11 = $$hasError$4;
 HEAP32[$count >> 2] = $bytes$3;
 HEAP32[$c >> 2] = $n$4;
 $$0 = (($hasError$11 | 0) != 0) << 31 >> 31;
 STACKTOP = sp;
 return $$0 | 0;
}

function _messagePos($doc, $level, $code, $line, $col, $msg, $args) {
 $doc = $doc | 0;
 $level = $level | 0;
 $code = $code | 0;
 $line = $line | 0;
 $col = $col | 0;
 $msg = $msg | 0;
 $args = $args | 0;
 var $0 = 0, $1 = 0, $10 = 0, $103 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $14 = 0, $21 = 0, $22 = 0, $25 = 0, $29 = 0, $34 = 0, $37 = 0, $4 = 0, $40 = 0, $41 = 0, $44 = 0, $47 = 0, $48 = 0, $5 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $58 = 0, $6 = 0, $65 = 0, $67 = 0, $68 = 0, $70 = 0, $73 = 0, $84 = 0, $86 = 0, $87 = 0, $89 = 0, $9 = 0, $92 = 0, $98 = 0, $args_copy = 0, $cp$05 = 0, $cp$13 = 0, $cp$22 = 0, $go$0 = 0, $go$0$i = 0, $go$1 = 0, $go$2 = 0, $vararg_buffer = 0, $vararg_buffer9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer9 = sp + 16 | 0;
 $vararg_buffer = sp;
 $args_copy = sp + 32 | 0;
 $0 = $doc + 6856 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $4 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1 >> 2] >> 2] & 31]($1, 2048) | 0;
 $5 = $doc + 6812 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $9 = $6 >>> 0 < (HEAP32[$doc + 352 >> 2] | 0) >>> 0;
 $10 = $9 & 1;
 switch ($level | 0) {
 case 0:
  {
   $11 = $doc + 6824 | 0;
   HEAP32[$11 >> 2] = (HEAP32[$11 >> 2] | 0) + 1;
   $go$0$i = $10;
   break;
  }
 case 1:
  {
   $14 = $doc + 6816 | 0;
   HEAP32[$14 >> 2] = (HEAP32[$14 >> 2] | 0) + 1;
   if ($9) $21 = (HEAP32[$doc + 144 >> 2] | 0) != 0; else $21 = 0;
   $go$0$i = $21 & 1;
   break;
  }
 case 2:
  {
   $22 = $doc + 6808 | 0;
   HEAP32[$22 >> 2] = (HEAP32[$22 >> 2] | 0) + 1;
   $go$0$i = $10;
   break;
  }
 case 3:
  {
   $25 = $doc + 6820 | 0;
   HEAP32[$25 >> 2] = (HEAP32[$25 >> 2] | 0) + 1;
   $go$0$i = $10;
   break;
  }
 case 4:
  {
   HEAP32[$5 >> 2] = $6 + 1;
   $go$0$i = $10;
   break;
  }
 case 5:
  {
   $29 = $doc + 6828 | 0;
   HEAP32[$29 >> 2] = (HEAP32[$29 >> 2] | 0) + 1;
   $go$0$i = $10;
   break;
  }
 default:
  $go$0$i = $10;
 }
 if (!$go$0$i) {
  $107 = HEAP32[$0 >> 2] | 0;
  $108 = HEAP32[$107 >> 2] | 0;
  $109 = $108 + 8 | 0;
  $110 = HEAP32[$109 >> 2] | 0;
  FUNCTION_TABLE_vii[$110 & 15]($107, $4);
  STACKTOP = sp;
  return;
 }
 HEAP32[$args_copy >> 2] = HEAP32[$args >> 2];
 _prvTidytmbvsnprintf($4, 2048, $msg, $args_copy) | 0;
 $34 = HEAP32[$doc + 6788 >> 2] | 0;
 if (!$34) $go$0 = $go$0$i; else $go$0 = FUNCTION_TABLE_iiiiii[$34 & 0]($doc, $level, $line, $col, $4) | 0;
 $37 = $doc + 6792 | 0;
 if (!(HEAP32[$37 >> 2] | 0)) $go$1 = $go$0; else {
  HEAP32[$args_copy >> 2] = HEAP32[$args >> 2];
  $40 = HEAP32[$37 >> 2] | 0;
  $41 = _tidyDefaultString($code) | 0;
  $go$1 = FUNCTION_TABLE_iiiiiii[$40 & 0]($doc, $level, $line, $col, $41, $args_copy) | 0 | $go$0;
 }
 $44 = $doc + 6796 | 0;
 if (!(HEAP32[$44 >> 2] | 0)) $go$2 = $go$1; else {
  HEAP32[$args_copy >> 2] = HEAP32[$args >> 2];
  $47 = HEAP32[$44 >> 2] | 0;
  $48 = _tidyErrorCodeAsString($code) | 0;
  $go$2 = FUNCTION_TABLE_iiiiiii[$47 & 0]($doc, $level, $line, $col, $48, $args_copy) | 0 | $go$1;
 }
 if (!$go$2) {
  $107 = HEAP32[$0 >> 2] | 0;
  $108 = HEAP32[$107 >> 2] | 0;
  $109 = $108 + 8 | 0;
  $110 = HEAP32[$109 >> 2] | 0;
  FUNCTION_TABLE_vii[$110 & 15]($107, $4);
  STACKTOP = sp;
  return;
 }
 $52 = $doc + 6784 | 0;
 $53 = HEAP32[$52 >> 2] | 0;
 $54 = $53 + 16 | 0;
 $55 = HEAP32[$0 >> 2] | 0;
 $58 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$55 >> 2] >> 2] & 31]($55, 1024) | 0;
 if (($line | 0) > 0 & ($col | 0) > 0) {
  HEAP8[$58 >> 0] = 0;
  if (!(HEAP32[$doc + 316 >> 2] | 0)) label = 22; else {
   $65 = HEAP32[$doc + 320 >> 2] | 0;
   if (!$65) label = 22; else {
    HEAP32[$vararg_buffer >> 2] = $65;
    HEAP32[$vararg_buffer + 4 >> 2] = $line;
    HEAP32[$vararg_buffer + 8 >> 2] = $col;
    _prvTidytmbsnprintf($58, 1024, 223352, $vararg_buffer) | 0;
   }
  }
  if ((label | 0) == 22) {
   $67 = HEAP32[79117] | 0;
   HEAP32[$vararg_buffer9 >> 2] = $line;
   HEAP32[$vararg_buffer9 + 4 >> 2] = $col;
   HEAP32[$vararg_buffer9 + 8 >> 2] = $67;
   HEAP32[$vararg_buffer9 + 12 >> 2] = $level;
   _prvTidytmbsnprintf($58, 1024, 223363, $vararg_buffer9) | 0;
  }
  $68 = HEAP8[$58 >> 0] | 0;
  if ($68 << 24 >> 24) {
   $70 = $53 + 20 | 0;
   $73 = $68;
   $cp$05 = $58;
   do {
    FUNCTION_TABLE_vii[HEAP32[$70 >> 2] & 15](HEAP32[$54 >> 2] | 0, $73);
    $cp$05 = $cp$05 + 1 | 0;
    $73 = HEAP8[$cp$05 >> 0] | 0;
   } while ($73 << 24 >> 24 != 0);
  }
 }
 HEAP8[$58 >> 0] = 0;
 switch ($level | 0) {
 case 0:
  {
   _prvTidytmbstrncpy($58, _tidyLocalizedString(600) | 0, 1024) | 0;
   break;
  }
 case 1:
  {
   _prvTidytmbstrncpy($58, _tidyLocalizedString(601) | 0, 1024) | 0;
   break;
  }
 case 2:
  {
   _prvTidytmbstrncpy($58, _tidyLocalizedString(602) | 0, 1024) | 0;
   break;
  }
 case 3:
  {
   _prvTidytmbstrncpy($58, _tidyLocalizedString(603) | 0, 1024) | 0;
   break;
  }
 case 4:
  {
   _prvTidytmbstrncpy($58, _tidyLocalizedString(604) | 0, 1024) | 0;
   break;
  }
 case 5:
  {
   _prvTidytmbstrncpy($58, _tidyLocalizedString(605) | 0, 1024) | 0;
   break;
  }
 case 6:
  {
   _prvTidytmbstrncpy($58, _tidyLocalizedString(606) | 0, 1024) | 0;
   break;
  }
 default:
  {}
 }
 $84 = HEAP8[$58 >> 0] | 0;
 if ($84 << 24 >> 24) {
  $86 = $53 + 20 | 0;
  $92 = $84;
  $cp$13 = $58;
  do {
   FUNCTION_TABLE_vii[HEAP32[$86 >> 2] & 15](HEAP32[$54 >> 2] | 0, $92);
   $cp$13 = $cp$13 + 1 | 0;
   $92 = HEAP8[$cp$13 >> 0] | 0;
  } while ($92 << 24 >> 24 != 0);
 }
 $87 = HEAP8[$4 >> 0] | 0;
 if ($87 << 24 >> 24) {
  $89 = $53 + 20 | 0;
  $98 = $87;
  $cp$22 = $4;
  do {
   FUNCTION_TABLE_vii[HEAP32[$89 >> 2] & 15](HEAP32[$54 >> 2] | 0, $98);
   $cp$22 = $cp$22 + 1 | 0;
   $98 = HEAP8[$cp$22 >> 0] | 0;
  } while ($98 << 24 >> 24 != 0);
 }
 _prvTidyWriteChar(10, HEAP32[$52 >> 2] | 0);
 $103 = HEAP32[$0 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$103 >> 2] | 0) + 8 >> 2] & 15]($103, $58);
 $107 = HEAP32[$0 >> 2] | 0;
 $108 = HEAP32[$107 >> 2] | 0;
 $109 = $108 + 8 | 0;
 $110 = HEAP32[$109 >> 2] | 0;
 FUNCTION_TABLE_vii[$110 & 15]($107, $4);
 STACKTOP = sp;
 return;
}

function _prvTidyReportError($doc, $element, $node, $code) {
 $doc = $doc | 0;
 $element = $element | 0;
 $node = $node | 0;
 $code = $code | 0;
 var $1 = 0, $14 = 0, $18 = 0, $2 = 0, $20 = 0, $25 = 0, $29 = 0, $32 = 0, $33 = 0, $37 = 0, $46 = 0, $47 = 0, $48 = 0, $52 = 0, $7 = 0, $9 = 0, $elemdesc = 0, $extra_string$0 = 0, $extra_string$1 = 0, $nodedesc = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer12 = 0, $vararg_buffer15 = 0, $vararg_buffer19 = 0, $vararg_buffer23 = 0, $vararg_buffer26 = 0, $vararg_buffer29 = 0, $vararg_buffer32 = 0, $vararg_buffer35 = 0, $vararg_buffer39 = 0, $vararg_buffer4 = 0, $vararg_buffer42 = 0, $vararg_buffer46 = 0, $vararg_buffer49 = 0, $vararg_buffer53 = 0, $vararg_buffer8 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 656 | 0;
 $vararg_buffer53 = sp + 128 | 0;
 $vararg_buffer49 = sp + 120 | 0;
 $vararg_buffer46 = sp + 112 | 0;
 $vararg_buffer42 = sp + 104 | 0;
 $vararg_buffer39 = sp + 96 | 0;
 $vararg_buffer35 = sp + 88 | 0;
 $vararg_buffer32 = sp + 80 | 0;
 $vararg_buffer29 = sp + 72 | 0;
 $vararg_buffer26 = sp + 64 | 0;
 $vararg_buffer23 = sp + 56 | 0;
 $vararg_buffer19 = sp + 48 | 0;
 $vararg_buffer15 = sp + 40 | 0;
 $vararg_buffer12 = sp + 32 | 0;
 $vararg_buffer8 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $nodedesc = sp + 392 | 0;
 $elemdesc = sp + 136 | 0;
 _memset($nodedesc | 0, 0, 256) | 0;
 _memset($elemdesc | 0, 0, 256) | 0;
 $1 = $element | 0 ? $element : $node;
 $2 = _tidyLocalizedString($code) | 0;
 if (!$2) ___assert_fail(223545, 223391, 749, 223671);
 _TagToString($node, $nodedesc, 256);
 do switch ($code | 0) {
 case 215:
 case 238:
 case 213:
 case 212:
  {
   HEAP32[$vararg_buffer >> 2] = HEAP32[$node + 32 >> 2];
   _messageNode($doc, 1, $code, $node, $2, $vararg_buffer);
   STACKTOP = sp;
   return;
  }
 case 226:
 case 239:
 case 221:
 case 219:
 case 214:
  {
   HEAP32[$vararg_buffer1 >> 2] = $nodedesc;
   _messageNode($doc, 1, $code, $node, $2, $vararg_buffer1);
   STACKTOP = sp;
   return;
  }
 case 701:
  {
   $7 = HEAP32[$doc + 68 >> 2] | 0;
   $9 = HEAP32[$7 + 40 >> 2] | 0;
   $14 = _prvTidyHTMLVersionNameFromCode(($9 | 0) == 0 ? HEAP32[$7 + 36 >> 2] | 0 : $9, 0) | 0;
   if (!$14) $extra_string$0 = _tidyLocalizedString(2059) | 0; else $extra_string$0 = $14;
   HEAP32[$vararg_buffer4 >> 2] = $nodedesc;
   HEAP32[$vararg_buffer4 + 4 >> 2] = $extra_string$0;
   _messageNode($doc, 1, 701, $node, $2, $vararg_buffer4);
   STACKTOP = sp;
   return;
  }
 case 700:
  {
   $18 = HEAP32[$doc + 68 >> 2] | 0;
   $20 = HEAP32[$18 + 40 >> 2] | 0;
   $25 = _prvTidyHTMLVersionNameFromCode(($20 | 0) == 0 ? HEAP32[$18 + 36 >> 2] | 0 : $20, 0) | 0;
   if (!$25) $extra_string$1 = _tidyLocalizedString(2059) | 0; else $extra_string$1 = $25;
   HEAP32[$vararg_buffer8 >> 2] = $nodedesc;
   HEAP32[$vararg_buffer8 + 4 >> 2] = $extra_string$1;
   _messageNode($doc, 4, 700, $node, $2, $vararg_buffer8);
   STACKTOP = sp;
   return;
  }
 case 237:
 case 234:
 case 233:
 case 232:
 case 231:
 case 230:
 case 229:
 case 227:
 case 235:
 case 228:
 case 217:
  {
   HEAP32[$vararg_buffer12 >> 2] = $2;
   _messageNode($doc, 1, $code, $1, 223602, $vararg_buffer12);
   STACKTOP = sp;
   return;
  }
 case 210:
 case 224:
  {
   $29 = HEAP32[$node + 32 >> 2] | 0;
   HEAP32[$vararg_buffer15 >> 2] = $29;
   HEAP32[$vararg_buffer15 + 4 >> 2] = $29;
   _messageNode($doc, 1, $code, $1, $2, $vararg_buffer15);
   STACKTOP = sp;
   return;
  }
 case 246:
 case 247:
  {
   $32 = $element + 32 | 0;
   $33 = HEAP32[$32 >> 2] | 0;
   HEAP32[$vararg_buffer19 >> 2] = HEAP32[$node + 32 >> 2];
   HEAP32[$vararg_buffer19 + 4 >> 2] = $33;
   _messageNode($doc, 1, $code, $node, $2, $vararg_buffer19);
   if (!(HEAP32[$doc + 144 >> 2] | 0)) {
    STACKTOP = sp;
    return;
   }
   $37 = _tidyLocalizedString(290) | 0;
   HEAP32[$vararg_buffer23 >> 2] = HEAP32[$32 >> 2];
   _messageNode($doc, 0, 290, $node, $37, $vararg_buffer23);
   STACKTOP = sp;
   return;
  }
 case 245:
 case 244:
 case 242:
  {
   HEAP32[$vararg_buffer26 >> 2] = $2;
   _messageNode($doc, 1, $code, $node, 223602, $vararg_buffer26);
   STACKTOP = sp;
   return;
  }
 case 241:
 case 236:
 case 225:
 case 223:
  {
   _TagToString($element, $elemdesc, 256);
   HEAP32[$vararg_buffer29 >> 2] = $elemdesc;
   _messageNode($doc, 1, $code, $element, $2, $vararg_buffer29);
   STACKTOP = sp;
   return;
  }
 case 206:
  {
   HEAP32[$vararg_buffer32 >> 2] = HEAP32[$element + 32 >> 2];
   _messageNode($doc, 1, 206, $1, $2, $vararg_buffer32);
   STACKTOP = sp;
   return;
  }
 case 207:
  {
   HEAP32[$vararg_buffer35 >> 2] = HEAP32[$element + 32 >> 2];
   HEAP32[$vararg_buffer35 + 4 >> 2] = $nodedesc;
   _messageNode($doc, 1, 207, $1, $2, $vararg_buffer35);
   STACKTOP = sp;
   return;
  }
 case 208:
  {
   $46 = HEAP32[$doc + 6848 >> 2] | 0 ? 4 : 1;
   HEAP32[$vararg_buffer39 >> 2] = $nodedesc;
   _messageNode($doc, $46, 208, $node, $2, $vararg_buffer39);
   STACKTOP = sp;
   return;
  }
 case 211:
  {
   $47 = $element + 32 | 0;
   $48 = HEAP32[$47 >> 2] | 0;
   HEAP32[$vararg_buffer42 >> 2] = $nodedesc;
   HEAP32[$vararg_buffer42 + 4 >> 2] = $48;
   _messageNode($doc, 1, 211, $node, $2, $vararg_buffer42);
   if (!(HEAP32[$doc + 144 >> 2] | 0)) {
    STACKTOP = sp;
    return;
   }
   $52 = _tidyLocalizedString(290) | 0;
   HEAP32[$vararg_buffer46 >> 2] = HEAP32[$47 >> 2];
   _messageNode($doc, 0, 290, $element, $52, $vararg_buffer46);
   STACKTOP = sp;
   return;
  }
 case 284:
  {
   _TagToString($element, $elemdesc, 256);
   HEAP32[$vararg_buffer49 >> 2] = $elemdesc;
   HEAP32[$vararg_buffer49 + 4 >> 2] = $nodedesc;
   _messageNode($doc, 1, 284, $1, $2, $vararg_buffer49);
   STACKTOP = sp;
   return;
  }
 case 288:
  {
   HEAP32[$vararg_buffer53 >> 2] = $nodedesc;
   _messageNode($doc, 4, 288, $1, $2, $vararg_buffer53);
   STACKTOP = sp;
   return;
  }
 default:
  {
   STACKTOP = sp;
   return;
  }
 } while (0);
}

function _ParseTagNames($doc, $option) {
 $doc = $doc | 0;
 $option = $option | 0;
 var $$0 = 0, $$0$i$i = 0, $$0$i$i17 = 0, $$0$i$i26 = 0, $$lcssa80 = 0, $0 = 0, $11 = 0, $12 = 0, $16 = 0, $22 = 0, $23 = 0, $29 = 0, $38 = 0, $45 = 0, $49 = 0, $62 = 0, $66 = 0, $71 = 0, $buf = 0, $c$0 = 0, $c$1 = 0, $c$1$lcssa = 0, $c$2$lcssa$ph = 0, $c$2$lcssa52 = 0, $c$2$ph = 0, $c$244 = 0, $c$244$lcssa = 0, $c$3 = 0, $config$idx$i = 0, $config$idx$i19 = 0, $config$idx$val$i = 0, $config$idx$val$i16 = 0, $config$idx$val$i20 = 0, $config$idx$val$i25 = 0, $config$idx$val$i30 = 0, $i$143 = 0, $i$143$lcssa = 0, $nTags$0 = 0, $nTags$0$lcssa81 = 0, $nTags$0$lcssa82 = 0, $nTags$1 = 0, $nTags$2 = 0, $storemerge = 0, $ttyp$035 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1024 | 0;
 $buf = sp;
 $0 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$0 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$0 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$0 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $11 = HEAP32[$0 >> 2] | 0;
 $12 = HEAP32[$option >> 2] | 0;
 switch ($12 | 0) {
 case 80:
  {
   $16 = 80;
   $ttyp$035 = 2;
   break;
  }
 case 81:
  {
   $16 = $12;
   $ttyp$035 = 4;
   break;
  }
 case 82:
  {
   $16 = $12;
   $ttyp$035 = 1;
   break;
  }
 case 83:
  {
   $16 = $12;
   $ttyp$035 = 8;
   break;
  }
 default:
  {
   _prvTidyReportUnknownOption($doc, HEAP32[$option + 8 >> 2] | 0);
   $$0 = 0;
   STACKTOP = sp;
   return $$0 | 0;
  }
 }
 if ((HEAP32[1892 + ($16 << 5) >> 2] | 0) != ($16 | 0)) ___assert_fail(224036, 223800, 383, 224086);
 if (HEAP32[1892 + ($16 << 5) + 12 >> 2] | 0) ___assert_fail(224036, 223800, 383, 224086);
 $22 = $doc + 72 + ($16 << 2) | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 if ($23 | 0) if (($23 | 0) != (HEAP32[1892 + ($16 << 5) + 28 >> 2] | 0)) {
  $29 = HEAP32[$doc + 6856 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$29 >> 2] | 0) + 8 >> 2] & 15]($29, $23);
 }
 if (!(_prvTidytmbstrlen(0) | 0)) $storemerge = 0; else $storemerge = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, 0) | 0;
 HEAP32[$22 >> 2] = $storemerge;
 _prvTidyFreeDeclaredTags($doc, $ttyp$035);
 $38 = $doc + 864 | 0;
 HEAP32[$38 >> 2] = HEAP32[$38 >> 2] | $ttyp$035;
 $config$idx$i19 = $doc + 872 | 0;
 $c$0 = $11;
 $nTags$0 = 0;
 L30 : while (1) {
  L32 : do switch ($c$0 | 0) {
  case 9:
  case 32:
  case 44:
   {
    if ((HEAP32[$0 >> 2] | 0) == -1) {
     $nTags$2 = $nTags$0;
     break L30;
    }
    $config$idx$val$i16 = HEAP32[$config$idx$i19 >> 2] | 0;
    if (!$config$idx$val$i16) $$0$i$i17 = -1; else $$0$i$i17 = _prvTidyReadChar($config$idx$val$i16) | 0;
    HEAP32[$0 >> 2] = $$0$i$i17;
    $c$3 = $$0$i$i17;
    $nTags$1 = $nTags$0;
    break;
   }
  default:
   {
    $45 = ($c$0 | 0) == 13;
    switch ($c$0 | 0) {
    case 10:
    case 13:
     {
      do if ((HEAP32[$0 >> 2] | 0) == -1) $c$1 = -1; else {
       $config$idx$val$i20 = HEAP32[$config$idx$i19 >> 2] | 0;
       if (!$config$idx$val$i20) {
        HEAP32[$0 >> 2] = -1;
        $c$1 = -1;
        break;
       }
       $49 = _prvTidyReadChar($config$idx$val$i20) | 0;
       HEAP32[$0 >> 2] = $49;
       if ($45 & ($49 | 0) == 10) {
        $config$idx$val$i25 = HEAP32[$config$idx$i19 >> 2] | 0;
        if (!$config$idx$val$i25) $$0$i$i26 = -1; else $$0$i$i26 = _prvTidyReadChar($config$idx$val$i25) | 0;
        HEAP32[$0 >> 2] = $$0$i$i26;
        $c$1 = $$0$i$i26;
       } else $c$1 = $49;
      } while (0);
      if (!(_prvTidyIsWhite($c$1) | 0)) {
       $c$1$lcssa = $c$1;
       $nTags$0$lcssa81 = $nTags$0;
       label = 37;
       break L30;
      } else $c$2$ph = $c$1;
      break;
     }
    default:
     $c$2$ph = $c$0;
    }
    if (($c$2$ph | 0) == -1) {
     $nTags$0$lcssa82 = $nTags$0;
     label = 36;
     break L30;
    } else {
     $c$244 = $c$2$ph;
     $i$143 = 0;
    }
    while (1) {
     if (!(($c$244 | 0) != 44 & (_prvTidyIsWhite($c$244) | 0) == 0)) {
      $c$244$lcssa = $c$244;
      $i$143$lcssa = $i$143;
      label = 44;
      break;
     }
     $62 = $i$143 + 1 | 0;
     HEAP8[$buf + $i$143 >> 0] = $c$244;
     if ((HEAP32[$0 >> 2] | 0) == -1) {
      $71 = $62;
      $c$2$lcssa$ph = -1;
      label = 43;
      break;
     }
     $config$idx$val$i30 = HEAP32[$config$idx$i19 >> 2] | 0;
     if (!$config$idx$val$i30) {
      $$lcssa80 = $62;
      label = 42;
      break;
     }
     $66 = _prvTidyReadChar($config$idx$val$i30) | 0;
     HEAP32[$0 >> 2] = $66;
     if ($62 >>> 0 < 1022 & ($66 | 0) != -1) {
      $c$244 = $66;
      $i$143 = $62;
     } else {
      $71 = $62;
      $c$2$lcssa$ph = $66;
      label = 43;
      break;
     }
    }
    if ((label | 0) == 42) {
     label = 0;
     HEAP32[$0 >> 2] = -1;
     $71 = $$lcssa80;
     $c$2$lcssa$ph = -1;
     label = 43;
    } else if ((label | 0) == 44) {
     label = 0;
     HEAP8[$buf + $i$143$lcssa >> 0] = 0;
     if (!$i$143$lcssa) {
      $c$3 = $c$244$lcssa;
      $nTags$1 = $nTags$0;
      break L32;
     } else $c$2$lcssa52 = $c$244$lcssa;
    }
    if ((label | 0) == 43) {
     label = 0;
     HEAP8[$buf + $71 >> 0] = 0;
     $c$2$lcssa52 = $c$2$lcssa$ph;
    }
    _DeclareUserTag($doc, HEAP32[$option >> 2] | 0, $ttyp$035, $buf);
    $c$3 = $c$2$lcssa52;
    $nTags$1 = $nTags$0 + 1 | 0;
   }
  } while (0);
  if (($c$3 | 0) == -1) {
   $nTags$2 = $nTags$1;
   break;
  } else {
   $c$0 = $c$3;
   $nTags$0 = $nTags$1;
  }
 }
 if ((label | 0) == 36) {
  HEAP8[$buf >> 0] = 0;
  $nTags$2 = $nTags$0$lcssa82;
 } else if ((label | 0) == 37) {
  HEAP8[$buf >> 0] = 0;
  _prvTidyUngetChar($c$1$lcssa, HEAP32[$config$idx$i19 >> 2] | 0);
  _prvTidyUngetChar(10, HEAP32[$config$idx$i19 >> 2] | 0);
  $nTags$2 = $nTags$0$lcssa81;
 }
 $$0 = ($nTags$2 | 0) != 0 & 1;
 STACKTOP = sp;
 return $$0 | 0;
}

function _prvTidyIsXMLNamechar($c) {
 $c = $c | 0;
 var $11 = 0, $19 = 0, $3 = 0, $31 = 0, $67 = 0, $68 = 0, $switch$tableidx = 0, $switch$tableidx443 = 0, $switch$tableidx450 = 0, $switch$tableidx457 = 0, $switch$tableidx464 = 0;
 if (_prvTidyIsXMLLetter($c) | 0) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 switch ($c | 0) {
 case 45:
 case 46:
 case 58:
 case 95:
  {
   $68 = 1;
   $67 = $68 & 1;
   return $67 | 0;
  }
 default:
  {}
 }
 $3 = $c & -2;
 if (($c + -1443 | 0) >>> 0 < 23 | (($c + -1425 | 0) >>> 0 < 17 | (($c + -1155 | 0) >>> 0 < 4 | (($c + -768 | 0) >>> 0 < 70 | ($3 | 0) == 864)))) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 $switch$tableidx = $c + -1467 | 0;
 if ($switch$tableidx >>> 0 < 5) if (23 >>> ($switch$tableidx & 255) & 1) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 switch ($c | 0) {
 case 2305:
 case 2306:
 case 2307:
 case 2364:
 case 1750:
 case 1751:
 case 1752:
 case 1753:
 case 1754:
 case 1755:
 case 1756:
 case 1757:
 case 1758:
 case 1759:
 case 1760:
 case 1761:
 case 1762:
 case 1763:
 case 1764:
 case 1767:
 case 1768:
 case 1770:
 case 1771:
 case 1772:
 case 1773:
 case 1611:
 case 1612:
 case 1613:
 case 1614:
 case 1615:
 case 1616:
 case 1617:
 case 1618:
 case 1648:
 case 1473:
 case 1474:
 case 1476:
  {
   $68 = 1;
   $67 = $68 & 1;
   return $67 | 0;
  }
 default:
  {}
 }
 if (($c + -2366 | 0) >>> 0 < 16) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 $switch$tableidx464 = $c + -2385 | 0;
 if ($switch$tableidx464 >>> 0 < 19) if (393231 >>> $switch$tableidx464 & 1 | 0) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 $11 = $c | 2;
 if (($11 | 0) == 2494) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 switch ($c | 0) {
 case 2433:
 case 2434:
 case 2435:
 case 2495:
 case 2496:
 case 2497:
 case 2498:
 case 2499:
 case 2500:
 case 2503:
 case 2504:
  {
   $68 = 1;
   $67 = $68 & 1;
   return $67 | 0;
  }
 default:
  {}
 }
 $switch$tableidx443 = $c + -2507 | 0;
 if ($switch$tableidx443 >>> 0 < 13) {
  if ((4103 >>> ($switch$tableidx443 & 65535) & 1) != 0 | ($11 | 0) == 2622) {
   $68 = 1;
   $67 = $68 & 1;
   return $67 | 0;
  }
 } else if (($11 | 0) == 2622) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 switch ($c | 0) {
 case 3402:
 case 3403:
 case 3404:
 case 3405:
 case 3415:
 case 3633:
 case 3073:
 case 3074:
 case 3075:
 case 3134:
 case 3135:
 case 3136:
 case 3137:
 case 3138:
 case 3139:
 case 3140:
 case 3142:
 case 3143:
 case 3144:
 case 3146:
 case 3147:
 case 3148:
 case 3149:
 case 3157:
 case 3158:
 case 3202:
 case 3203:
 case 3262:
 case 3263:
 case 3264:
 case 3265:
 case 3266:
 case 3267:
 case 3268:
 case 3270:
 case 3271:
 case 3272:
 case 3274:
 case 3275:
 case 3276:
 case 3277:
 case 3285:
 case 3286:
 case 3330:
 case 3331:
 case 3390:
 case 3391:
 case 3392:
 case 3393:
 case 3394:
 case 3395:
 case 3398:
 case 3399:
 case 3400:
 case 3018:
 case 3019:
 case 3020:
 case 3021:
 case 3031:
 case 2878:
 case 2879:
 case 2880:
 case 2881:
 case 2882:
 case 2883:
 case 2887:
 case 2888:
 case 2891:
 case 2892:
 case 2893:
 case 2902:
 case 2903:
 case 2946:
 case 2947:
 case 3006:
 case 3007:
 case 3008:
 case 3009:
 case 3010:
 case 3014:
 case 3015:
 case 3016:
 case 2817:
 case 2818:
 case 2819:
 case 2876:
 case 2750:
 case 2751:
 case 2752:
 case 2753:
 case 2754:
 case 2755:
 case 2756:
 case 2757:
 case 2759:
 case 2760:
 case 2761:
 case 2763:
 case 2764:
 case 2765:
 case 2689:
 case 2690:
 case 2691:
 case 2748:
 case 2530:
 case 2531:
 case 2562:
 case 2623:
 case 2624:
 case 2625:
 case 2626:
 case 2631:
 case 2632:
 case 2635:
 case 2636:
 case 2637:
 case 2672:
 case 2673:
  {
   $68 = 1;
   $67 = $68 & 1;
   return $67 | 0;
  }
 default:
  {}
 }
 if (($c + -3636 | 0) >>> 0 < 7) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 switch ($c | 0) {
 case 3764:
 case 3765:
 case 3766:
 case 3767:
 case 3768:
 case 3769:
 case 3771:
 case 3772:
 case 3784:
 case 3785:
 case 3786:
 case 3787:
 case 3788:
 case 3789:
 case 3655:
 case 3656:
 case 3657:
 case 3658:
 case 3659:
 case 3660:
 case 3661:
 case 3662:
 case 3761:
  {
   $68 = 1;
   $67 = $68 & 1;
   return $67 | 0;
  }
 default:
  {}
 }
 $19 = $c | 1;
 if (($c + -3974 | 0) >>> 0 < 6 | (($c + -3953 | 0) >>> 0 < 20 | (($19 | 0) == 3903 | (($c | 0) == 3897 | (($11 | 0) == 3895 | ($3 | 0) == 3864))))) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 $switch$tableidx450 = $c + -3984 | 0;
 if ($switch$tableidx450 >>> 0 < 8) {
  if (($c + -3993 | 0) >>> 0 < 21 | ((-65 & 255) >>> ($switch$tableidx450 & 255) & 1) != 0) {
   $68 = 1;
   $67 = $68 & 1;
   return $67 | 0;
  }
 } else if (($c + -3993 | 0) >>> 0 < 21) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 $switch$tableidx457 = $c + -4017 | 0;
 if ($switch$tableidx457 >>> 0 < 9) if (383 >>> ($switch$tableidx457 & 65535) & 1) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 if (($c | 0) == 8417 | ($c + -8400 | 0) >>> 0 < 13) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 switch ($c | 0) {
 case 12330:
 case 12331:
 case 12332:
 case 12333:
 case 12334:
 case 12335:
 case 12441:
 case 12442:
  {
   $68 = 1;
   $67 = $68 & 1;
   return $67 | 0;
  }
 default:
  {}
 }
 $31 = $c & -129;
 if (($31 + -3664 | 0) >>> 0 < 10 | (($c + -3430 | 0) >>> 0 < 10 | (($31 + -3174 | 0) >>> 0 < 10 | (($c + -3047 | 0) >>> 0 < 9 | (($c + -2918 | 0) >>> 0 < 10 | (($31 + -2662 | 0) >>> 0 < 10 | (($31 + -2406 | 0) >>> 0 < 10 | (($c + -1776 | 0) >>> 0 < 10 | (($c + -48 | 0) >>> 0 < 10 | ($c + -1632 | 0) >>> 0 < 10))))))))) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 if (($c + -12445 | 0) >>> 0 < 2 | (($c + -12337 | 0) >>> 0 < 5 | (($c | 0) == 12293 | (($c | 128 | 0) == 3782 | (($c | 0) == 1600 | (($c | 0) == 903 | (($19 | 0) == 721 | (($c | 0) == 183 | ($c + -3872 | 0) >>> 0 < 10)))))))) {
  $68 = 1;
  $67 = $68 & 1;
  return $67 | 0;
 }
 $68 = ($c + -12540 | 0) >>> 0 < 3;
 $67 = $68 & 1;
 return $67 | 0;
}

function _prvTidyParseList($doc, $list, $mode) {
 $doc = $doc | 0;
 $list = $list | 0;
 $mode = $mode | 0;
 var $$lcssa = 0, $$lcssa29 = 0, $$lcssa30 = 0, $$lcssa31 = 0, $0 = 0, $1 = 0, $102 = 0, $11 = 0, $113 = 0, $119 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $28 = 0, $30 = 0, $31 = 0, $43 = 0, $53 = 0, $66 = 0, $70 = 0, $76 = 0, $82 = 0, $83 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $92 = 0, $97 = 0, $99 = 0, $lastli$0 = 0, $lastli$1 = 0, $lastli$1$lcssa = 0, $list$pn = 0, $node$0 = 0, $node$01$i = 0, $node$02$i = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $list + 28 | 0;
 if (HEAP32[(HEAP32[$2 >> 2] | 0) + 16 >> 2] & 1 | 0) return;
 HEAP32[$1 + 100 >> 2] = 0;
 $9 = _prvTidyGetToken($doc, 0) | 0;
 L4 : do if ($9 | 0) {
  $11 = $1 + 24 | 0;
  $12 = $list + 16 | 0;
  $13 = $list + 12 | 0;
  $14 = $1 + 20 | 0;
  $15 = $doc + 6848 | 0;
  $17 = $9;
  L6 : while (1) {
   $16 = $17 + 28 | 0;
   if ((HEAP32[$16 >> 2] | 0) == (HEAP32[$2 >> 2] | 0)) if ((HEAP32[$17 + 44 >> 2] | 0) == 6) {
    $$lcssa29 = $17;
    label = 6;
    break;
   }
   do if (!(_InsertMisc($list, $17) | 0)) {
    $28 = HEAP32[$17 + 44 >> 2] | 0;
    $30 = HEAP32[$16 >> 2] | 0;
    $31 = ($30 | 0) == 0;
    if (($28 | 0) == 4) if ($31) label = 25; else label = 24; else {
     if ($31) {
      _prvTidyReportError($doc, $list, $17, 208);
      _prvTidyFreeNode($doc, $17);
      break;
     }
     if (($28 | 0) == 6) {
      if ((HEAP32[$30 >> 2] | 0) == 37) {
       HEAP32[$15 >> 2] = HEAP32[$15 >> 2] | 1;
       _prvTidyReportError($doc, $list, $17, 208);
       _prvTidyFreeNode($doc, $17);
       break;
      }
      if (!(_prvTidynodeHasCM($17, 16) | 0)) $list$pn = $list; else {
       _prvTidyReportError($doc, $list, $17, 208);
       _prvTidyPopInline($doc, $17);
       _prvTidyFreeNode($doc, $17);
       break;
      }
      while (1) {
       $list$pn = HEAP32[$list$pn >> 2] | 0;
       if (!$list$pn) break;
       $43 = HEAP32[$list$pn + 28 >> 2] | 0;
       if ($43 | 0) if ((HEAP32[$43 >> 2] | 0) == 16) break;
       if ((HEAP32[$16 >> 2] | 0) == ($43 | 0)) {
        $$lcssa30 = $17;
        label = 22;
        break L6;
       }
      }
      _prvTidyReportError($doc, $list, $17, 208);
      _prvTidyFreeNode($doc, $17);
      break;
     } else label = 24;
    }
    if ((label | 0) == 24) {
     label = 0;
     if ((HEAP32[$30 >> 2] | 0) == 61) label = 26; else label = 25;
    }
    do if ((label | 0) == 25) {
     label = 0;
     if (!(_prvTidyIsHTML5Mode($doc) | 0)) {
      _prvTidyUngetToken($doc);
      if (_prvTidynodeHasCM($17, 8) | 0) if (HEAP32[$14 >> 2] | 0) {
       $$lcssa31 = $17;
       label = 32;
       break L6;
      }
      if (HEAP32[$11 >> 2] | 0) {
       if (_prvTidynodeHasCM($17, 896) | 0) {
        label = 59;
        break L6;
       }
       $66 = HEAP32[$16 >> 2] | 0;
       if ($66 | 0) if ((HEAP32[$66 >> 2] | 0) == 107) {
        label = 59;
        break L6;
       }
      }
      $70 = HEAP32[$2 >> 2] | 0;
      if ($70 | 0) if ((HEAP32[$70 >> 2] | 0) == 77) {
       $node$01$i = HEAP32[$13 >> 2] | 0;
       if ($node$01$i | 0) {
        $83 = 0;
        $lastli$0 = 0;
        $node$02$i = $node$01$i;
        while (1) {
         $76 = HEAP32[$node$02$i + 28 >> 2] | 0;
         if (!$76) {
          $119 = $83;
          $lastli$1 = $lastli$0;
         } else if ((HEAP32[$76 >> 2] | 0) == 61) {
          $82 = (HEAP32[$node$02$i + 44 >> 2] | 0) == 5;
          $119 = $82 ? $node$02$i : $83;
          $lastli$1 = $82 ? $node$02$i : $lastli$0;
         } else {
          $119 = $83;
          $lastli$1 = $lastli$0;
         }
         $node$02$i = HEAP32[$node$02$i + 8 >> 2] | 0;
         if (!$node$02$i) {
          $$lcssa = $119;
          $lastli$1$lcssa = $lastli$1;
          break;
         } else {
          $83 = $119;
          $lastli$0 = $lastli$1;
         }
        }
        if ($$lcssa | 0) {
         $87 = _prvTidyInferredTag($doc, 61) | 0;
         _prvTidyReportError($doc, $list, $87, 212);
         _prvTidyFreeNode($doc, $87);
         $node$0 = $lastli$1$lcssa;
         break;
        }
       }
      }
      $88 = _prvTidynodeHasCM($17, 8) | 0;
      $89 = _prvTidyInferredTag($doc, 61) | 0;
      _prvTidyAddStyleProperty($doc, $89, $88 | 0 ? 307917 : 307951);
      _prvTidyReportError($doc, $list, $89, 212);
      HEAP32[$89 >> 2] = $list;
      $92 = HEAP32[$12 >> 2] | 0;
      HEAP32[$89 + 4 >> 2] = $92;
      if (!$92) HEAP32[$13 >> 2] = $89; else HEAP32[$92 + 8 >> 2] = $89;
      HEAP32[$12 >> 2] = $89;
      $node$0 = $89;
     } else label = 26;
    } while (0);
    if ((label | 0) == 26) {
     label = 0;
     HEAP32[$17 >> 2] = $list;
     $53 = HEAP32[$12 >> 2] | 0;
     HEAP32[$17 + 4 >> 2] = $53;
     if (!$53) HEAP32[$13 >> 2] = $17; else HEAP32[$53 + 8 >> 2] = $17;
     HEAP32[$12 >> 2] = $17;
     $node$0 = $17;
    }
    $97 = HEAP32[$0 >> 2] | 0;
    $99 = HEAP32[$node$0 + 28 >> 2] | 0;
    if ($99 | 0) {
     $102 = HEAP32[$99 + 16 >> 2] | 0;
     if (!($102 & 1)) {
      if (!($102 & 16)) HEAP32[$97 + 16 >> 2] = 0;
     } else {
      HEAP32[$97 + 8 >> 2] = 0;
      if (!(HEAP32[$99 + 20 >> 2] | 0)) break;
     }
     $113 = HEAP32[$99 + 20 >> 2] | 0;
     if ($113 | 0) if ((HEAP32[$node$0 + 44 >> 2] | 0) != 7) {
      HEAP32[$97 + 72 >> 2] = $node$0;
      FUNCTION_TABLE_viii[$113 & 63]($doc, $node$0, 0);
     }
    }
   } while (0);
   $17 = _prvTidyGetToken($doc, 0) | 0;
   if (!$17) break L4;
  }
  if ((label | 0) == 6) {
   _prvTidyFreeNode($doc, $$lcssa29);
   HEAP32[$list + 56 >> 2] = 1;
   return;
  } else if ((label | 0) == 22) {
   _prvTidyReportError($doc, $list, $$lcssa30, 207);
   _prvTidyUngetToken($doc);
   return;
  } else if ((label | 0) == 32) {
   _prvTidyReportError($doc, $list, $$lcssa31, 207);
   return;
  } else if ((label | 0) == 59) return;
 } while (0);
 _prvTidyReportError($doc, $list, 0, 206);
 return;
}

function _fmod($x, $y) {
 $x = +$x;
 $y = +$y;
 var $$0 = 0.0, $$lcssa7 = 0, $0 = 0, $1 = 0, $10 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $107 = 0, $108 = 0, $11 = 0, $113 = 0, $114 = 0, $116 = 0, $119 = 0, $12 = 0, $121 = 0, $127 = 0, $128 = 0, $129 = 0, $130 = 0, $131 = 0, $138 = 0, $139 = 0, $140 = 0, $141 = 0, $142 = 0, $147 = 0, $150 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $17 = 0, $2 = 0, $24 = 0.0, $26 = 0, $27 = 0, $3 = 0, $38 = 0, $39 = 0, $4 = 0, $45 = 0, $46 = 0, $47 = 0, $56 = 0, $6 = 0, $61 = 0, $62 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $79 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $94 = 0, $95 = 0, $97 = 0, $ex$0$lcssa = 0, $ex$026 = 0, $ex$1 = 0, $ex$2$lcssa = 0, $ex$212 = 0, $ex$3$lcssa = 0, $ex$39 = 0, $ey$0$lcssa = 0, $ey$020 = 0, $ey$1$ph = 0, $fabs = 0.0, label = 0;
 HEAPF64[tempDoublePtr >> 3] = $x;
 $0 = HEAP32[tempDoublePtr >> 2] | 0;
 $1 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 HEAPF64[tempDoublePtr >> 3] = $y;
 $2 = HEAP32[tempDoublePtr >> 2] | 0;
 $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $4 = _bitshift64Lshr($0 | 0, $1 | 0, 52) | 0;
 $6 = $4 & 2047;
 $7 = _bitshift64Lshr($2 | 0, $3 | 0, 52) | 0;
 $9 = $7 & 2047;
 $10 = $1 & -2147483648;
 $11 = _bitshift64Shl($2 | 0, $3 | 0, 1) | 0;
 $12 = tempRet0;
 L1 : do if (($11 | 0) == 0 & ($12 | 0) == 0) label = 3; else {
  $fabs = +Math_abs(+$y);
  HEAPF64[tempDoublePtr >> 3] = $fabs;
  $17 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  if ($17 >>> 0 > 2146435072 | ($17 | 0) == 2146435072 & (HEAP32[tempDoublePtr >> 2] | 0) >>> 0 > 0 | ($6 | 0) == 2047) label = 3; else {
   $26 = _bitshift64Shl($0 | 0, $1 | 0, 1) | 0;
   $27 = tempRet0;
   if (!($27 >>> 0 > $12 >>> 0 | ($27 | 0) == ($12 | 0) & $26 >>> 0 > $11 >>> 0)) return +(($26 | 0) == ($11 | 0) & ($27 | 0) == ($12 | 0) ? $x * 0.0 : $x);
   if (!$6) {
    $38 = _bitshift64Shl($0 | 0, $1 | 0, 12) | 0;
    $39 = tempRet0;
    if (($39 | 0) > -1 | ($39 | 0) == -1 & $38 >>> 0 > 4294967295) {
     $46 = $38;
     $47 = $39;
     $ex$026 = 0;
     while (1) {
      $45 = $ex$026 + -1 | 0;
      $46 = _bitshift64Shl($46 | 0, $47 | 0, 1) | 0;
      $47 = tempRet0;
      if (!(($47 | 0) > -1 | ($47 | 0) == -1 & $46 >>> 0 > 4294967295)) {
       $ex$0$lcssa = $45;
       break;
      } else $ex$026 = $45;
     }
    } else $ex$0$lcssa = 0;
    $56 = _bitshift64Shl($0 | 0, $1 | 0, 1 - $ex$0$lcssa | 0) | 0;
    $84 = $56;
    $85 = tempRet0;
    $ex$1 = $ex$0$lcssa;
   } else {
    $84 = $0;
    $85 = $1 & 1048575 | 1048576;
    $ex$1 = $6;
   }
   if (!$9) {
    $61 = _bitshift64Shl($2 | 0, $3 | 0, 12) | 0;
    $62 = tempRet0;
    if (($62 | 0) > -1 | ($62 | 0) == -1 & $61 >>> 0 > 4294967295) {
     $69 = $61;
     $70 = $62;
     $ey$020 = 0;
     while (1) {
      $68 = $ey$020 + -1 | 0;
      $69 = _bitshift64Shl($69 | 0, $70 | 0, 1) | 0;
      $70 = tempRet0;
      if (!(($70 | 0) > -1 | ($70 | 0) == -1 & $69 >>> 0 > 4294967295)) {
       $ey$0$lcssa = $68;
       break;
      } else $ey$020 = $68;
     }
    } else $ey$0$lcssa = 0;
    $79 = _bitshift64Shl($2 | 0, $3 | 0, 1 - $ey$0$lcssa | 0) | 0;
    $86 = $79;
    $87 = tempRet0;
    $ey$1$ph = $ey$0$lcssa;
   } else {
    $86 = $2;
    $87 = $3 & 1048575 | 1048576;
    $ey$1$ph = $9;
   }
   $88 = _i64Subtract($84 | 0, $85 | 0, $86 | 0, $87 | 0) | 0;
   $89 = tempRet0;
   $94 = ($89 | 0) > -1 | ($89 | 0) == -1 & $88 >>> 0 > 4294967295;
   L23 : do if (($ex$1 | 0) > ($ey$1$ph | 0)) {
    $153 = $94;
    $154 = $88;
    $155 = $89;
    $95 = $84;
    $97 = $85;
    $ex$212 = $ex$1;
    while (1) {
     if ($153) if (($95 | 0) == ($86 | 0) & ($97 | 0) == ($87 | 0)) break; else {
      $101 = $154;
      $102 = $155;
     } else {
      $101 = $95;
      $102 = $97;
     }
     $103 = _bitshift64Shl($101 | 0, $102 | 0, 1) | 0;
     $104 = tempRet0;
     $105 = $ex$212 + -1 | 0;
     $107 = _i64Subtract($103 | 0, $104 | 0, $86 | 0, $87 | 0) | 0;
     $108 = tempRet0;
     $113 = ($108 | 0) > -1 | ($108 | 0) == -1 & $107 >>> 0 > 4294967295;
     if (($105 | 0) > ($ey$1$ph | 0)) {
      $153 = $113;
      $154 = $107;
      $155 = $108;
      $95 = $103;
      $97 = $104;
      $ex$212 = $105;
     } else {
      $$lcssa7 = $113;
      $114 = $103;
      $116 = $104;
      $156 = $107;
      $157 = $108;
      $ex$2$lcssa = $105;
      break L23;
     }
    }
    $$0 = $x * 0.0;
    break L1;
   } else {
    $$lcssa7 = $94;
    $114 = $84;
    $116 = $85;
    $156 = $88;
    $157 = $89;
    $ex$2$lcssa = $ex$1;
   } while (0);
   if ($$lcssa7) if (($114 | 0) == ($86 | 0) & ($116 | 0) == ($87 | 0)) {
    $$0 = $x * 0.0;
    break;
   } else {
    $119 = $157;
    $121 = $156;
   } else {
    $119 = $116;
    $121 = $114;
   }
   if ($119 >>> 0 < 1048576 | ($119 | 0) == 1048576 & $121 >>> 0 < 0) {
    $127 = $121;
    $128 = $119;
    $ex$39 = $ex$2$lcssa;
    while (1) {
     $129 = _bitshift64Shl($127 | 0, $128 | 0, 1) | 0;
     $130 = tempRet0;
     $131 = $ex$39 + -1 | 0;
     if ($130 >>> 0 < 1048576 | ($130 | 0) == 1048576 & $129 >>> 0 < 0) {
      $127 = $129;
      $128 = $130;
      $ex$39 = $131;
     } else {
      $138 = $129;
      $139 = $130;
      $ex$3$lcssa = $131;
      break;
     }
    }
   } else {
    $138 = $121;
    $139 = $119;
    $ex$3$lcssa = $ex$2$lcssa;
   }
   if (($ex$3$lcssa | 0) > 0) {
    $140 = _i64Add($138 | 0, $139 | 0, 0, -1048576) | 0;
    $141 = tempRet0;
    $142 = _bitshift64Shl($ex$3$lcssa | 0, 0, 52) | 0;
    $150 = $141 | tempRet0;
    $152 = $140 | $142;
   } else {
    $147 = _bitshift64Lshr($138 | 0, $139 | 0, 1 - $ex$3$lcssa | 0) | 0;
    $150 = tempRet0;
    $152 = $147;
   }
   HEAP32[tempDoublePtr >> 2] = $152;
   HEAP32[tempDoublePtr + 4 >> 2] = $150 | $10;
   $$0 = +HEAPF64[tempDoublePtr >> 3];
  }
 } while (0);
 if ((label | 0) == 3) {
  $24 = $x * $y;
  $$0 = $24 / $24;
 }
 return +$$0;
}

function _prvTidyParseTableTag($doc, $table, $mode) {
 $doc = $doc | 0;
 $table = $table | 0;
 $mode = $mode | 0;
 var $$lcssa = 0, $$pre$phi15Z2D = 0, $0 = 0, $1 = 0, $10 = 0, $103 = 0, $108 = 0, $109 = 0, $11 = 0, $112 = 0, $12 = 0, $123 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $25 = 0, $27 = 0, $28 = 0, $3 = 0, $34 = 0, $39 = 0, $42 = 0, $43 = 0, $46 = 0, $49 = 0, $51 = 0, $52 = 0, $55 = 0, $6 = 0, $66 = 0, $75 = 0, $8 = 0, $80 = 0, $9 = 0, $90 = 0, $node$0 = 0, $node$0$lcssa = 0, $node$0$lcssa35 = 0, $table$pn = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 _prvTidyDeferDup($doc);
 $2 = $1 + 116 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 HEAP32[$2 >> 2] = HEAP32[$1 + 112 >> 2];
 $6 = _prvTidyGetToken($doc, 0) | 0;
 L1 : do if ($6 | 0) {
  $8 = $table + 28 | 0;
  $9 = $doc + 6848 | 0;
  $10 = $table + 16 | 0;
  $11 = $table + 12 | 0;
  $12 = $table + 4 | 0;
  $13 = $1 + 24 | 0;
  $15 = $6;
  L3 : while (1) {
   $14 = $15 + 28 | 0;
   if ((HEAP32[$14 >> 2] | 0) == (HEAP32[$8 >> 2] | 0)) if ((HEAP32[$15 + 44 >> 2] | 0) == 6) {
    $$lcssa = $15;
    label = 5;
    break;
   }
   L8 : do if (!(_InsertMisc($table, $15) | 0)) {
    $25 = HEAP32[$14 >> 2] | 0;
    $27 = $15 + 44 | 0;
    $28 = HEAP32[$27 >> 2] | 0;
    L10 : do if (!$25) if (($28 | 0) == 4) label = 14; else {
     _prvTidyReportError($doc, $table, $15, 208);
     _prvTidyFreeNode($doc, $15);
     break L8;
    } else if (($28 | 0) == 6) $node$0 = $15; else {
     switch (HEAP32[$25 >> 2] | 0) {
     case 107:
     case 112:
     case 109:
      break;
     default:
      {
       label = 14;
       break L10;
      }
     }
     _prvTidyUngetToken($doc);
     $34 = _prvTidyInferredTag($doc, 115) | 0;
     _prvTidyReportError($doc, $table, $34, 212);
     $node$0 = $34;
    } while (0);
    do if ((label | 0) == 14) {
     label = 0;
     if (!(_prvTidynodeIsText($15) | 0)) if (!(_prvTidynodeHasCM($15, 24) | 0)) {
      if (!(HEAP32[(HEAP32[$14 >> 2] | 0) + 16 >> 2] & 4)) {
       $node$0 = $15;
       break;
      }
      _MoveToHead($doc, $table, $15);
      break L8;
     }
     $39 = HEAP32[$table >> 2] | 0;
     HEAP32[$15 >> 2] = $39;
     HEAP32[$15 + 8 >> 2] = $table;
     $42 = $15 + 4 | 0;
     HEAP32[$42 >> 2] = HEAP32[$12 >> 2];
     HEAP32[$12 >> 2] = $15;
     $43 = HEAP32[$42 >> 2] | 0;
     if ($43 | 0) HEAP32[$43 + 8 >> 2] = $15;
     $46 = $39 + 12 | 0;
     if ((HEAP32[$46 >> 2] | 0) == ($table | 0)) HEAP32[$46 >> 2] = $15;
     _prvTidyReportError($doc, $table, $15, 211);
     HEAP32[$13 >> 2] = 1;
     $49 = HEAP32[$27 >> 2] | 0;
     do if (($49 | 0) != 4) {
      $51 = HEAP32[$0 >> 2] | 0;
      $52 = HEAP32[$14 >> 2] | 0;
      if ($52 | 0) {
       $55 = HEAP32[$52 + 16 >> 2] | 0;
       if (!($55 & 1)) {
        if (!($55 & 16)) HEAP32[$51 + 16 >> 2] = 0;
       } else {
        HEAP32[$51 + 8 >> 2] = 0;
        if (!(HEAP32[$52 + 20 >> 2] | 0)) break;
       }
       $66 = HEAP32[$52 + 20 >> 2] | 0;
       if (!(($66 | 0) == 0 | ($49 | 0) == 7)) {
        HEAP32[$51 + 72 >> 2] = $15;
        FUNCTION_TABLE_viii[$66 & 63]($doc, $15, 0);
       }
      }
     } while (0);
     HEAP32[$13 >> 2] = 0;
     break L8;
    } while (0);
    $75 = $node$0 + 44 | 0;
    L40 : do if ((HEAP32[$75 >> 2] | 0) == 6) {
     if ($node$0 | 0) {
      $80 = HEAP32[$node$0 + 28 >> 2] | 0;
      if ($80 | 0) if ((HEAP32[$80 >> 2] | 0) == 37) {
       HEAP32[$9 >> 2] = HEAP32[$9 >> 2] | 1;
       _prvTidyReportError($doc, $table, $node$0, 208);
       _prvTidyFreeNode($doc, $node$0);
       break L8;
      }
     }
     if (!(_prvTidynodeHasCM($node$0, 640) | 0)) if (!(_prvTidynodeHasCM($node$0, 24) | 0)) {
      $90 = $node$0 + 28 | 0;
      $table$pn = $table;
      while (1) {
       $table$pn = HEAP32[$table$pn >> 2] | 0;
       if (!$table$pn) {
        $$pre$phi15Z2D = $90;
        break L40;
       }
       if ((HEAP32[$90 >> 2] | 0) == (HEAP32[$table$pn + 28 >> 2] | 0)) {
        $node$0$lcssa = $node$0;
        label = 43;
        break L3;
       }
      }
     }
     _prvTidyReportError($doc, $table, $node$0, 208);
     _prvTidyFreeNode($doc, $node$0);
     break L8;
    } else $$pre$phi15Z2D = $node$0 + 28 | 0; while (0);
    if (!(HEAP32[(HEAP32[$$pre$phi15Z2D >> 2] | 0) + 16 >> 2] & 128)) {
     $node$0$lcssa35 = $node$0;
     label = 45;
     break L3;
    }
    if (!(_prvTidynodeIsElement($node$0) | 0)) {
     _prvTidyReportError($doc, $table, $node$0, 208);
     _prvTidyFreeNode($doc, $node$0);
     break;
    }
    HEAP32[$node$0 >> 2] = $table;
    $103 = HEAP32[$10 >> 2] | 0;
    HEAP32[$node$0 + 4 >> 2] = $103;
    if (!$103) HEAP32[$11 >> 2] = $node$0; else HEAP32[$103 + 8 >> 2] = $node$0;
    HEAP32[$10 >> 2] = $node$0;
    $108 = HEAP32[$0 >> 2] | 0;
    $109 = HEAP32[$$pre$phi15Z2D >> 2] | 0;
    if ($109 | 0) {
     $112 = HEAP32[$109 + 16 >> 2] | 0;
     if (!($112 & 1)) {
      if (!($112 & 16)) HEAP32[$108 + 16 >> 2] = 0;
     } else {
      HEAP32[$108 + 8 >> 2] = 0;
      if (!(HEAP32[$109 + 20 >> 2] | 0)) break;
     }
     $123 = HEAP32[$109 + 20 >> 2] | 0;
     if ($123 | 0) if ((HEAP32[$75 >> 2] | 0) != 7) {
      HEAP32[$108 + 72 >> 2] = $node$0;
      FUNCTION_TABLE_viii[$123 & 63]($doc, $node$0, 0);
     }
    }
   } while (0);
   $15 = _prvTidyGetToken($doc, 0) | 0;
   if (!$15) break L1;
  }
  if ((label | 0) == 5) {
   _prvTidyFreeNode($doc, $$lcssa);
   HEAP32[$2 >> 2] = $3;
   HEAP32[$table + 56 >> 2] = 1;
   return;
  } else if ((label | 0) == 43) {
   _prvTidyReportError($doc, $table, $node$0$lcssa, 207);
   _prvTidyUngetToken($doc);
   HEAP32[$2 >> 2] = $3;
   return;
  } else if ((label | 0) == 45) {
   _prvTidyUngetToken($doc);
   _prvTidyReportError($doc, $table, $node$0$lcssa35, 211);
   HEAP32[$2 >> 2] = $3;
   return;
  }
 } while (0);
 _prvTidyReportError($doc, $table, 0, 206);
 HEAP32[$2 >> 2] = $3;
 return;
}

function _prvTidyVerifyHTTPEquiv($doc, $head) {
 $doc = $doc | 0;
 $head = $head | 0;
 var $$01$i = 0, $$05 = 0, $$lcssa30 = 0, $10 = 0, $14 = 0, $15 = 0, $16 = 0, $18 = 0, $2 = 0, $25 = 0, $30 = 0, $32 = 0, $34 = 0, $39 = 0, $47 = 0, $50 = 0, $57 = 0, $6 = 0, $64 = 0, $69 = 0, $71 = 0, $73 = 0, $74 = 0, $77 = 0, $78 = 0, $88 = 0, $93 = 0, $99 = 0, $pLastProp$1$ph = 0, $pLastProp$1$ph$ph = 0, $pLastProp$1$ph$ph$lcssa = 0, $pNode$012 = 0, $pNode$013 = 0, $prop$011 = 0, $pszBegin$0 = 0, $pszBegin$0$ph = 0, $pszBegin$0$ph$ph = 0, $pszBegin$0$pn = 0, $pszBegin$1$lcssa = 0, $pszBegin$1$lcssa$lcssa = 0, $pszEnd$0 = 0, $pszEnd$0$lcssa = 0, $pszEnd$1 = 0, $pszEnd$1$lcssa = 0, label = 0, $$01$i$looptemp = 0;
 $2 = _prvTidyGetEncodingNameFromTidyId(HEAP32[$doc + 96 >> 2] | 0) | 0;
 if (!$2) return;
 if (!$head) label = 5; else {
  $6 = HEAP32[$head + 28 >> 2] | 0;
  if (!$6) label = 5; else if ((HEAP32[$6 >> 2] | 0) == 46) $$05 = $head; else label = 5;
 }
 if ((label | 0) == 5) {
  $10 = _prvTidyFindHEAD($doc) | 0;
  if (!$10) return; else $$05 = $10;
 }
 $pNode$012 = HEAP32[$$05 + 12 >> 2] | 0;
 if (!$pNode$012) return;
 $14 = $doc + 6856 | 0;
 $pNode$013 = $pNode$012;
 while (1) {
  $15 = _prvTidyAttrGetById($pNode$013, 62) | 0;
  $16 = _prvTidyAttrGetById($pNode$013, 36) | 0;
  $18 = HEAP32[$pNode$013 + 28 >> 2] | 0;
  if ($18 | 0) if (($15 | 0) != 0 & (($16 | 0) != 0 & (HEAP32[$18 >> 2] | 0) == 68)) {
   $25 = HEAP32[$15 + 24 >> 2] | 0;
   if ($25 | 0) if (!(_prvTidytmbstrcasecmp($25, 311587) | 0)) {
    $30 = $16 + 24 | 0;
    $32 = _prvTidytmbstrdup(HEAP32[$14 >> 2] | 0, HEAP32[$30 >> 2] | 0) | 0;
    $pLastProp$1$ph$ph = 0;
    $pszBegin$0$ph$ph = $32;
    L21 : while (1) {
     $pLastProp$1$ph = $pLastProp$1$ph$ph;
     $pszBegin$0$ph = $pszBegin$0$ph$ph;
     while (1) {
      $pszBegin$0 = $pszBegin$0$ph;
      while (1) {
       if (!$pszBegin$0) {
        $pLastProp$1$ph$ph$lcssa = $pLastProp$1$ph$ph;
        break L21;
       }
       $34 = HEAP8[$pszBegin$0 >> 0] | 0;
       if (!($34 << 24 >> 24)) {
        $pLastProp$1$ph$ph$lcssa = $pLastProp$1$ph$ph;
        break L21;
       }
       if (!(_isspace($34 << 24 >> 24) | 0)) $pszBegin$1$lcssa = $pszBegin$0; else {
        $pszBegin$0$pn = $pszBegin$0;
        while (1) {
         $39 = $pszBegin$0$pn + 1 | 0;
         if (!(_isspace(HEAP8[$39 >> 0] | 0) | 0)) {
          $pszBegin$1$lcssa = $39;
          break;
         } else $pszBegin$0$pn = $39;
        }
       }
       $pszEnd$0 = $pszBegin$1$lcssa;
       L33 : while (1) {
        switch (HEAP8[$pszEnd$0 >> 0] | 0) {
        case 59:
         {
          $pszEnd$0$lcssa = $pszEnd$0;
          label = 22;
          break L33;
          break;
         }
        case 0:
         {
          $pszEnd$1 = $pszEnd$0;
          break L33;
          break;
         }
        default:
         {}
        }
        $pszEnd$0 = $pszEnd$0 + 1 | 0;
       }
       if ((label | 0) == 22) {
        label = 0;
        HEAP8[$pszEnd$0$lcssa >> 0] = 0;
        $pszEnd$1 = $pszEnd$0$lcssa + 1 | 0;
       }
       if ($pszEnd$1 >>> 0 > $pszBegin$1$lcssa >>> 0) {
        $pszBegin$1$lcssa$lcssa = $pszBegin$1$lcssa;
        $pszEnd$1$lcssa = $pszEnd$1;
        break;
       } else $pszBegin$0 = $pszBegin$1$lcssa;
      }
      $47 = HEAP32[$14 >> 2] | 0;
      $50 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$47 >> 2] >> 2] & 31]($47, 12) | 0;
      HEAP32[$50 >> 2] = _prvTidytmbstrdup(HEAP32[$14 >> 2] | 0, $pszBegin$1$lcssa$lcssa) | 0;
      HEAP32[$50 + 4 >> 2] = 0;
      HEAP32[$50 + 8 >> 2] = 0;
      if (!$pLastProp$1$ph) {
       $pLastProp$1$ph$ph = $50;
       $pszBegin$0$ph$ph = $pszEnd$1$lcssa;
       continue L21;
      }
      HEAP32[$pLastProp$1$ph + 8 >> 2] = $50;
      $pLastProp$1$ph = $50;
      $pszBegin$0$ph = $pszEnd$1$lcssa;
     }
    }
    $57 = HEAP32[$14 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$57 >> 2] | 0) + 8 >> 2] & 15]($57, $32);
    if ($pLastProp$1$ph$ph$lcssa | 0) {
     $prop$011 = $pLastProp$1$ph$ph$lcssa;
     while (1) {
      if (!(_prvTidytmbstrncasecmp(HEAP32[$prop$011 >> 2] | 0, 311600, 7) | 0)) {
       $$lcssa30 = $prop$011;
       label = 28;
       break;
      }
      $prop$011 = HEAP32[$prop$011 + 8 >> 2] | 0;
      if (!$prop$011) {
       $$01$i = $pLastProp$1$ph$ph$lcssa;
       break;
      }
     }
     if ((label | 0) == 28) {
      label = 0;
      $64 = HEAP32[$14 >> 2] | 0;
      FUNCTION_TABLE_vii[HEAP32[(HEAP32[$64 >> 2] | 0) + 8 >> 2] & 15]($64, HEAP32[$$lcssa30 >> 2] | 0);
      $69 = HEAP32[$14 >> 2] | 0;
      $71 = HEAP32[HEAP32[$69 >> 2] >> 2] | 0;
      $73 = (_prvTidytmbstrlen($2) | 0) + 9 | 0;
      $74 = FUNCTION_TABLE_iii[$71 & 31]($69, $73) | 0;
      HEAP32[$$lcssa30 >> 2] = $74;
      _prvTidytmbstrcpy($74, 311608) | 0;
      _prvTidytmbstrcpy((HEAP32[$$lcssa30 >> 2] | 0) + 8 | 0, $2) | 0;
      $77 = _CreatePropString($doc, $pLastProp$1$ph$ph$lcssa) | 0;
      $78 = HEAP32[$14 >> 2] | 0;
      FUNCTION_TABLE_vii[HEAP32[(HEAP32[$78 >> 2] | 0) + 8 >> 2] & 15]($78, HEAP32[$30 >> 2] | 0);
      HEAP32[$30 >> 2] = $77;
      $$01$i = $pLastProp$1$ph$ph$lcssa;
     }
     do {
      $$01$i$looptemp = $$01$i;
      $$01$i = HEAP32[$$01$i + 8 >> 2] | 0;
      $88 = HEAP32[$14 >> 2] | 0;
      FUNCTION_TABLE_vii[HEAP32[(HEAP32[$88 >> 2] | 0) + 8 >> 2] & 15]($88, HEAP32[$$01$i$looptemp >> 2] | 0);
      $93 = HEAP32[$14 >> 2] | 0;
      FUNCTION_TABLE_vii[HEAP32[(HEAP32[$93 >> 2] | 0) + 8 >> 2] & 15]($93, HEAP32[$$01$i$looptemp + 4 >> 2] | 0);
      $99 = HEAP32[$14 >> 2] | 0;
      FUNCTION_TABLE_vii[HEAP32[(HEAP32[$99 >> 2] | 0) + 8 >> 2] & 15]($99, $$01$i$looptemp);
     } while (($$01$i | 0) != 0);
    }
   }
  }
  $pNode$013 = HEAP32[$pNode$013 + 8 >> 2] | 0;
  if (!$pNode$013) break;
 }
 return;
}

function _prvTidyCheckUrl($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $1 = 0, $15 = 0, $16 = 0, $18 = 0, $2 = 0, $25 = 0, $28 = 0, $32 = 0, $33 = 0, $34 = 0, $37 = 0, $39 = 0, $5 = 0, $56 = 0, $6 = 0, $66 = 0, $8 = 0, $backslash_count$0 = 0, $backslash_count$0$lcssa = 0, $backslash_count$0$us = 0, $backslash_count$1 = 0, $backslash_count$1$us = 0, $escape_count$0 = 0, $escape_count$0$lcssa = 0, $escape_count$0$us = 0, $escape_count$1 = 0, $escape_count$1$us = 0, $hadnonspace$0 = 0, $hadnonspace$1 = 0, $i$0 = 0, $i$0$us = 0, $i$1 = 0, $pos$0 = 0, $pos$0$lcssa = 0, $pos$1 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 if ($attval | 0) {
  $1 = $attval + 24 | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  if ($2 | 0) {
   $5 = (_prvTidytmbstrncmp($2, 310471, 11) | 0) == 0;
   $6 = $doc + 280 | 0;
   L4 : do if ($5) {
    $backslash_count$0$us = 0;
    $escape_count$0$us = 0;
    $i$0$us = 0;
    while (1) {
     $8 = HEAP8[$2 + $i$0$us >> 0] | 0;
     switch ($8 << 24 >> 24) {
     case 0:
      {
       $backslash_count$0$lcssa = $backslash_count$0$us;
       $escape_count$0$lcssa = $escape_count$0$us;
       break L4;
       break;
      }
     case 92:
      {
       $backslash_count$1$us = $backslash_count$0$us + 1 | 0;
       $escape_count$1$us = $escape_count$0$us;
       break;
      }
     case 127:
      {
       label = 9;
       break;
      }
     default:
      if ($8 << 24 >> 24 < 33) label = 9; else if (!(_memchr(304502, $8 << 24 >> 24, 3) | 0)) {
       $backslash_count$1$us = $backslash_count$0$us;
       $escape_count$1$us = $escape_count$0$us;
      } else label = 9;
     }
     if ((label | 0) == 9) {
      label = 0;
      $backslash_count$1$us = $backslash_count$0$us;
      $escape_count$1$us = $escape_count$0$us + 1 | 0;
     }
     $backslash_count$0$us = $backslash_count$1$us;
     $escape_count$0$us = $escape_count$1$us;
     $i$0$us = $i$0$us + 1 | 0;
    }
   } else {
    $backslash_count$0 = 0;
    $escape_count$0 = 0;
    $i$0 = 0;
    while (1) {
     $15 = $2 + $i$0 | 0;
     $16 = HEAP8[$15 >> 0] | 0;
     switch ($16 << 24 >> 24) {
     case 0:
      {
       $backslash_count$0$lcssa = $backslash_count$0;
       $escape_count$0$lcssa = $escape_count$0;
       break L4;
       break;
      }
     case 92:
      {
       $18 = $backslash_count$0 + 1 | 0;
       if (!(HEAP32[$6 >> 2] | 0)) {
        $backslash_count$1 = $18;
        $escape_count$1 = $escape_count$0;
       } else {
        HEAP8[$15 >> 0] = 47;
        $backslash_count$1 = $18;
        $escape_count$1 = $escape_count$0;
       }
       break;
      }
     case 127:
      {
       label = 16;
       break;
      }
     default:
      if ($16 << 24 >> 24 < 33) label = 16; else if (!(_memchr(304502, $16 << 24 >> 24, 3) | 0)) {
       $backslash_count$1 = $backslash_count$0;
       $escape_count$1 = $escape_count$0;
      } else label = 16;
     }
     if ((label | 0) == 16) {
      label = 0;
      $backslash_count$1 = $backslash_count$0;
      $escape_count$1 = $escape_count$0 + 1 | 0;
     }
     $backslash_count$0 = $backslash_count$1;
     $escape_count$0 = $escape_count$1;
     $i$0 = $i$0 + 1 | 0;
    }
   } while (0);
   $25 = $doc + 332 | 0;
   $28 = ($escape_count$0$lcssa | 0) != 0;
   if ($28 & (HEAP32[$25 >> 2] | 0) != 0) {
    $32 = ($escape_count$0$lcssa << 1 | 1) + (_prvTidytmbstrlen($2) | 0) | 0;
    $33 = $doc + 6856 | 0;
    $34 = HEAP32[$33 >> 2] | 0;
    $37 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$34 >> 2] >> 2] & 31]($34, $32) | 0;
    $hadnonspace$0 = 0;
    $i$1 = 0;
    $pos$0 = 0;
    L27 : while (1) {
     $39 = HEAP8[$2 + $i$1 >> 0] | 0;
     L29 : do switch ($39 << 24 >> 24) {
     case 0:
      {
       $pos$0$lcssa = $pos$0;
       break L27;
       break;
      }
     case 127:
      {
       label = 26;
       break;
      }
     default:
      {
       if ($39 << 24 >> 24 >= 33) {
        if (_memchr(304502, $39 << 24 >> 24, 3) | 0) {
         label = 26;
         break L29;
        }
        HEAP8[$37 + $pos$0 >> 0] = $39;
        $hadnonspace$1 = 1;
        $pos$1 = $pos$0 + 1 | 0;
        break L29;
       }
       if ($39 << 24 >> 24 == 32) if (!$hadnonspace$0) {
        $hadnonspace$1 = 0;
        $pos$1 = $pos$0;
       } else {
        HEAP32[$vararg_buffer >> 2] = 32;
        $hadnonspace$1 = $hadnonspace$0;
        $pos$1 = (_sprintf($37 + $pos$0 | 0, 304505, $vararg_buffer) | 0) + $pos$0 | 0;
       } else label = 26;
      }
     } while (0);
     if ((label | 0) == 26) {
      label = 0;
      HEAP32[$vararg_buffer1 >> 2] = $39 & 255;
      $hadnonspace$1 = 1;
      $pos$1 = (_sprintf($37 + $pos$0 | 0, 304505, $vararg_buffer1) | 0) + $pos$0 | 0;
     }
     $hadnonspace$0 = $hadnonspace$1;
     $i$1 = $i$1 + 1 | 0;
     $pos$0 = $pos$1;
    }
    HEAP8[$37 + $pos$0$lcssa >> 0] = 0;
    $56 = HEAP32[$33 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$56 >> 2] | 0) + 8 >> 2] & 15]($56, HEAP32[$1 >> 2] | 0);
    HEAP32[$1 >> 2] = $37;
   }
   do if ($backslash_count$0$lcssa | 0) if ($5 | (HEAP32[$6 >> 2] | 0) == 0) {
    _prvTidyReportAttrError($doc, $node, $attval, 261);
    break;
   } else {
    _prvTidyReportAttrError($doc, $node, $attval, 262);
    break;
   } while (0);
   if (!$28) {
    STACKTOP = sp;
    return;
   }
   if (!(HEAP32[$25 >> 2] | 0)) _prvTidyReportAttrError($doc, $node, $attval, 263); else _prvTidyReportAttrError($doc, $node, $attval, 264);
   $66 = $doc + 6844 | 0;
   HEAP32[$66 >> 2] = HEAP32[$66 >> 2] | 32;
   STACKTOP = sp;
   return;
  }
 }
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 STACKTOP = sp;
 return;
}

function _prvTidySetXHTMLDocType($doc) {
 $doc = $doc | 0;
 var $$0 = 0, $$0$i = 0, $$0$i4 = 0, $1 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $21 = 0, $28 = 0, $31 = 0, $39 = 0, $4 = 0, $42 = 0, $48 = 0, $53 = 0, $55 = 0, $doctype$0 = 0, $node$0$lcssa$i = 0, $node$01$i = 0, $node$02$i$i = 0, $node$02$i$i$lcssa = 0, dest = 0, label = 0, stop = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $2 = ($doc | 0) == 0;
 L1 : do if ($2) $node$0$lcssa$i = 0; else {
  $4 = HEAP32[$doc + 12 >> 2] | 0;
  if (!$4) $node$0$lcssa$i = 0; else {
   $node$01$i = $4;
   while (1) {
    if ((HEAP32[$node$01$i + 44 >> 2] | 0) == 1) {
     $node$0$lcssa$i = $node$01$i;
     break L1;
    }
    $node$01$i = HEAP32[$node$01$i + 8 >> 2] | 0;
    if (!$node$01$i) {
     $node$0$lcssa$i = 0;
     break;
    }
   }
  }
 } while (0);
 $13 = HEAP32[$doc + 104 >> 2] | 0;
 $14 = $1 + 36 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 switch ($15 | 0) {
 case 4096:
 case 2048:
  {
   if (!(HEAP32[$1 + 32 >> 2] & $15)) label = 7; else $$0$i4 = $15;
   break;
  }
 default:
  label = 7;
 }
 if ((label | 0) == 7) $$0$i4 = _prvTidyHTMLVersion($doc) | 0;
 $21 = $1 + 40 | 0;
 HEAP32[$21 >> 2] = $$0$i4;
 switch ($13 | 0) {
 case 1:
  {
   if (!$node$0$lcssa$i) {
    $$0 = 1;
    return $$0 | 0;
   }
   _prvTidyDiscardElement($doc, $node$0$lcssa$i) | 0;
   $$0 = 1;
   return $$0 | 0;
  }
 case 5:
  {
   if (!(HEAP32[$doc + 108 >> 2] | 0)) {
    $$0 = 0;
    return $$0 | 0;
   }
   break;
  }
 default:
  {}
 }
 if (!$node$0$lcssa$i) {
  L23 : do if ($2) $$0$i = 0; else {
   $28 = HEAP32[$doc + 12 >> 2] | 0;
   if (!$28) $$0$i = 0; else {
    $node$02$i$i = $28;
    while (1) {
     $31 = HEAP32[$node$02$i$i + 28 >> 2] | 0;
     if ($31 | 0) if ((HEAP32[$31 >> 2] | 0) == 48) {
      $node$02$i$i$lcssa = $node$02$i$i;
      break;
     }
     $node$02$i$i = HEAP32[$node$02$i$i + 8 >> 2] | 0;
     if (!$node$02$i$i) {
      $$0$i = 0;
      break L23;
     }
    }
    $39 = HEAP32[$doc + 6856 >> 2] | 0;
    $42 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$39 >> 2] >> 2] & 31]($39, 68) | 0;
    dest = $42;
    stop = dest + 68 | 0;
    do {
     HEAP32[dest >> 2] = 0;
     dest = dest + 4 | 0;
    } while ((dest | 0) < (stop | 0));
    HEAP32[$42 + 44 >> 2] = 1;
    _prvTidyInsertNodeBeforeElement($node$02$i$i$lcssa, $42);
    $$0$i = $42;
   }
  } while (0);
  HEAP32[$$0$i + 32 >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, 310346) | 0;
  $doctype$0 = $$0$i;
 } else {
  $48 = $node$0$lcssa$i + 32 | 0;
  HEAP32[$48 >> 2] = _prvTidytmbstrtolower(HEAP32[$48 >> 2] | 0) | 0;
  $doctype$0 = $node$0$lcssa$i;
 }
 switch ($13 | 0) {
 case 0:
  {
   _prvTidyRepairAttrValue($doc, $doctype$0, 310770, 0) | 0;
   _prvTidyRepairAttrValue($doc, $doctype$0, 310777, 0) | 0;
   HEAP32[$21 >> 2] = 262144;
   $$0 = 0;
   return $$0 | 0;
  }
 case 3:
  {
   _prvTidyRepairAttrValue($doc, $doctype$0, 310770, 309677) | 0;
   _prvTidyRepairAttrValue($doc, $doctype$0, 310777, 309710) | 0;
   HEAP32[$21 >> 2] = 256;
   $$0 = 0;
   return $$0 | 0;
  }
 case 4:
  {
   _prvTidyRepairAttrValue($doc, $doctype$0, 310770, 309783) | 0;
   _prvTidyRepairAttrValue($doc, $doctype$0, 310777, 309822) | 0;
   HEAP32[$21 >> 2] = 512;
   $$0 = 0;
   return $$0 | 0;
  }
 case 5:
  {
   _prvTidyRepairAttrValue($doc, $doctype$0, 310770, HEAP32[$doc + 108 >> 2] | 0) | 0;
   _prvTidyRepairAttrValue($doc, $doctype$0, 310777, 317568) | 0;
   $$0 = 0;
   return $$0 | 0;
  }
 case 2:
  {
   $53 = HEAP32[$14 >> 2] | 0;
   if (($53 | 0) < 393216) switch ($53 | 0) {
   case 0:
    {
     label = 27;
     break;
    }
   default:
    {}
   } else switch ($53 | 0) {
   case 393216:
    {
     label = 27;
     break;
    }
   default:
    {}
   }
   if ((label | 0) == 27) {
    HEAP32[$21 >> 2] = 262144;
    $$0 = 1;
    return $$0 | 0;
   }
   $55 = HEAP32[$1 + 32 >> 2] | 0;
   if (($53 | 0) == 2048 & ($55 & 2048 | 0) != 0) {
    if (!(_prvTidyGetAttrByName($doctype$0, 310777) | 0)) _prvTidyRepairAttrValue($doc, $doctype$0, 310777, 310020) | 0;
    HEAP32[$21 >> 2] = 2048;
    $$0 = 1;
    return $$0 | 0;
   }
   if (($55 & 4092 | 0) == 2048) {
    _prvTidyRepairAttrValue($doc, $doctype$0, 310770, 309994) | 0;
    _prvTidyRepairAttrValue($doc, $doctype$0, 310777, 310020) | 0;
    HEAP32[$21 >> 2] = 2048;
    $$0 = 0;
    return $$0 | 0;
   }
   if (($53 | 0) == 4096 & ($55 & 4096 | 0) != 0) {
    if (!(_prvTidyGetAttrByName($doctype$0, 310777) | 0)) _prvTidyRepairAttrValue($doc, $doctype$0, 310777, 310113) | 0;
    HEAP32[$21 >> 2] = 4096;
    $$0 = 1;
    return $$0 | 0;
   }
   if ($55 & 292 | 0) {
    _prvTidyRepairAttrValue($doc, $doctype$0, 310770, 309677) | 0;
    _prvTidyRepairAttrValue($doc, $doctype$0, 310777, 309710) | 0;
    HEAP32[$21 >> 2] = 256;
    $$0 = 0;
    return $$0 | 0;
   }
   if ($55 & 1168 | 0) {
    _prvTidyRepairAttrValue($doc, $doctype$0, 310770, 309897) | 0;
    _prvTidyRepairAttrValue($doc, $doctype$0, 310777, 309932) | 0;
    HEAP32[$21 >> 2] = 1024;
    $$0 = 0;
    return $$0 | 0;
   }
   if ($55 & 1755 | 0) {
    _prvTidyRepairAttrValue($doc, $doctype$0, 310770, 309783) | 0;
    _prvTidyRepairAttrValue($doc, $doctype$0, 310777, 309822) | 0;
    HEAP32[$21 >> 2] = 512;
    $$0 = 0;
    return $$0 | 0;
   }
   if (($doctype$0 | 0) == 0 | ($55 & 393216 | 0) != 0) {
    $$0 = 0;
    return $$0 | 0;
   }
   _prvTidyDiscardElement($doc, $doctype$0) | 0;
   $$0 = 0;
   return $$0 | 0;
  }
 case 1:
  {
   ___assert_fail(310351, 310231, 1953, 310353);
   break;
  }
 default:
  {
   $$0 = 0;
   return $$0 | 0;
  }
 }
 return 0;
}

function _prvTidyErrorSummary($doc) {
 $doc = $doc | 0;
 var $0 = 0, $10 = 0, $11 = 0, $15 = 0, $17 = 0, $19 = 0, $2 = 0, $21 = 0, $25 = 0, $29 = 0, $32 = 0, $33 = 0, $38 = 0, $4 = 0, $41 = 0, $43 = 0, $5 = 0, $50 = 0, $54 = 0, $58 = 0, $62 = 0, $69 = 0, $70 = 0, $76 = 0, $80 = 0, $84 = 0, $88 = 0, $encnam$0 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer10 = 0, $vararg_buffer13 = 0, $vararg_buffer16 = 0, $vararg_buffer19 = 0, $vararg_buffer22 = 0, $vararg_buffer25 = 0, $vararg_buffer28 = 0, $vararg_buffer31 = 0, $vararg_buffer34 = 0, $vararg_buffer37 = 0, $vararg_buffer4 = 0, $vararg_buffer40 = 0, $vararg_buffer42 = 0, $vararg_buffer45 = 0, $vararg_buffer48 = 0, $vararg_buffer51 = 0, $vararg_buffer54 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 $vararg_buffer54 = sp + 152 | 0;
 $vararg_buffer51 = sp + 144 | 0;
 $vararg_buffer48 = sp + 136 | 0;
 $vararg_buffer45 = sp + 128 | 0;
 $vararg_buffer42 = sp + 120 | 0;
 $vararg_buffer40 = sp + 112 | 0;
 $vararg_buffer37 = sp + 104 | 0;
 $vararg_buffer34 = sp + 96 | 0;
 $vararg_buffer31 = sp + 88 | 0;
 $vararg_buffer28 = sp + 80 | 0;
 $vararg_buffer25 = sp + 72 | 0;
 $vararg_buffer22 = sp + 64 | 0;
 $vararg_buffer19 = sp + 56 | 0;
 $vararg_buffer16 = sp + 48 | 0;
 $vararg_buffer13 = sp + 40 | 0;
 $vararg_buffer10 = sp + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = _tidyLocalizedString(2066) | 0;
 $2 = HEAP32[$doc + 88 >> 2] | 0;
 switch ($2 | 0) {
 case 7:
  {
   $encnam$0 = 223699;
   break;
  }
 case 6:
  {
   $encnam$0 = 223690;
   break;
  }
 case 8:
  {
   $encnam$0 = 226196;
   break;
  }
 default:
  $encnam$0 = ($2 | 0) == 2 ? 226165 : $0;
 }
 $4 = $doc + 6836 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 if (($5 & 32 | 16 | 0) != 16) HEAP32[$4 >> 2] = $5 & -49;
 $10 = $doc + 6844 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 if ($11 | 0) {
  if (!($11 & 1)) $17 = $11; else {
   $15 = _tidyLocalizedString(2093) | 0;
   HEAP32[$vararg_buffer >> 2] = $encnam$0;
   _tidy_out($doc, $15, $vararg_buffer);
   $17 = HEAP32[$10 >> 2] | 0;
  }
  if (!($17 & 66)) $21 = $17; else {
   $19 = _tidyLocalizedString(2086) | 0;
   HEAP32[$vararg_buffer1 >> 2] = $encnam$0;
   _tidy_out($doc, $19, $vararg_buffer1);
   $21 = HEAP32[$10 >> 2] | 0;
  }
  if (!($21 & 4)) $25 = $21; else {
   HEAP32[$vararg_buffer4 >> 2] = _tidyLocalizedString(2080) | 0;
   _tidy_out($doc, 223602, $vararg_buffer4);
   $25 = HEAP32[$10 >> 2] | 0;
  }
  if (!($25 & 8)) $29 = $25; else {
   HEAP32[$vararg_buffer7 >> 2] = _tidyLocalizedString(2079) | 0;
   _tidy_out($doc, 223602, $vararg_buffer7);
   $29 = HEAP32[$10 >> 2] | 0;
  }
  if ($29 & 32 | 0) {
   HEAP32[$vararg_buffer10 >> 2] = _tidyLocalizedString(2078) | 0;
   _tidy_out($doc, 223602, $vararg_buffer10);
  }
 }
 $32 = $doc + 6848 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 if (!($33 & 1)) $38 = $33; else {
  HEAP32[$vararg_buffer13 >> 2] = _tidyLocalizedString(2073) | 0;
  _tidy_out($doc, 223602, $vararg_buffer13);
  $38 = HEAP32[$32 >> 2] | 0;
 }
 if ($38 & 2 | 0) {
  HEAP32[$vararg_buffer16 >> 2] = _tidyLocalizedString(2074) | 0;
  _tidy_out($doc, 223602, $vararg_buffer16);
 }
 $41 = HEAP32[$4 >> 2] | 0;
 if ($41 | 0) {
  $43 = $doc + 408 | 0;
  if (!(HEAP32[$43 >> 2] | 0)) {
   if (!($41 & 4)) $50 = $41; else {
    HEAP32[$vararg_buffer19 >> 2] = _tidyLocalizedString(2084) | 0;
    _tidy_out($doc, 223602, $vararg_buffer19);
    $50 = HEAP32[$4 >> 2] | 0;
   }
   if (!($50 & 1)) $54 = $50; else {
    HEAP32[$vararg_buffer22 >> 2] = _tidyLocalizedString(2081) | 0;
    _tidy_out($doc, 223602, $vararg_buffer22);
    $54 = HEAP32[$4 >> 2] | 0;
   }
   if (!($54 & 8)) $58 = $54; else {
    HEAP32[$vararg_buffer25 >> 2] = _tidyLocalizedString(2082) | 0;
    _tidy_out($doc, 223602, $vararg_buffer25);
    $58 = HEAP32[$4 >> 2] | 0;
   }
   if (!($58 & 2)) $62 = $58; else {
    HEAP32[$vararg_buffer28 >> 2] = _tidyLocalizedString(2083) | 0;
    _tidy_out($doc, 223602, $vararg_buffer28);
    $62 = HEAP32[$4 >> 2] | 0;
   }
   if (($62 & 48 | 0) == 16) {
    HEAP32[$vararg_buffer31 >> 2] = _tidyLocalizedString(2089) | 0;
    _tidy_out($doc, 223602, $vararg_buffer31);
   }
  }
  HEAP32[$vararg_buffer34 >> 2] = _tidyLocalizedString(2071) | 0;
  _tidy_out($doc, 223602, $vararg_buffer34);
  if (HEAP32[$43 >> 2] | 0) {
   HEAP32[$vararg_buffer37 >> 2] = _tidyLocalizedString(2072) | 0;
   _tidy_out($doc, 223602, $vararg_buffer37);
  }
  _tidy_out($doc, 223712, $vararg_buffer40);
 }
 $69 = $doc + 6840 | 0;
 $70 = HEAP32[$69 >> 2] | 0;
 if (!$70) {
  STACKTOP = sp;
  return;
 }
 if (!($70 & 2)) $76 = $70; else {
  HEAP32[$vararg_buffer42 >> 2] = _tidyLocalizedString(2090) | 0;
  _tidy_out($doc, 223602, $vararg_buffer42);
  $76 = HEAP32[$69 >> 2] | 0;
 }
 if (!($76 & 1)) $80 = $76; else {
  HEAP32[$vararg_buffer45 >> 2] = _tidyLocalizedString(2092) | 0;
  _tidy_out($doc, 223602, $vararg_buffer45);
  $80 = HEAP32[$69 >> 2] | 0;
 }
 if (!($80 & 8)) $84 = $80; else {
  HEAP32[$vararg_buffer48 >> 2] = _tidyLocalizedString(2088) | 0;
  _tidy_out($doc, 223602, $vararg_buffer48);
  $84 = HEAP32[$69 >> 2] | 0;
 }
 if (!($84 & 4)) $88 = $84; else {
  HEAP32[$vararg_buffer51 >> 2] = _tidyLocalizedString(2091) | 0;
  _tidy_out($doc, 223602, $vararg_buffer51);
  $88 = HEAP32[$69 >> 2] | 0;
 }
 if (!($88 & 16)) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$vararg_buffer54 >> 2] = _tidyLocalizedString(2087) | 0;
 _tidy_out($doc, 223602, $vararg_buffer54);
 STACKTOP = sp;
 return;
}

function _CleanSpaces($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$014 = 0, $$pr1$i = 0, $1 = 0, $100 = 0, $111 = 0, $125 = 0, $126 = 0, $127 = 0, $131 = 0, $14 = 0, $151 = 0, $152 = 0, $157 = 0, $159 = 0, $161 = 0, $163 = 0, $166 = 0, $172 = 0, $2 = 0, $21 = 0, $26 = 0, $27 = 0, $30 = 0, $37 = 0, $44 = 0, $51 = 0, $52 = 0, $53 = 0, $60 = 0, $73 = 0, $79 = 0, $8 = 0, $86 = 0, $91 = 0, $97 = 0, $parent$03$i$i = 0, $parent$03$i$i2 = 0, label = 0, $$014$looptemp = 0;
 if (!$node) return;
 $1 = $doc + 68 | 0;
 $$014 = $node;
 do {
  $2 = $$014 + 8 | 0;
  $$014$looptemp = $$014;
  $$014 = HEAP32[$2 >> 2] | 0;
  L6 : do if (_prvTidynodeIsText($$014$looptemp) | 0) if (_prvTidynodeIsText($$014$looptemp) | 0) {
   $8 = HEAP32[$$014$looptemp >> 2] | 0;
   if ((HEAP32[$8 + 44 >> 2] | 0) != 1) {
    if ($8 | 0) {
     $parent$03$i$i = $8;
     do {
      $14 = HEAP32[$parent$03$i$i + 28 >> 2] | 0;
      if ($14 | 0) if ((HEAP32[$14 + 20 >> 2] | 0) == 35) break L6;
      $parent$03$i$i = HEAP32[$parent$03$i$i >> 2] | 0;
     } while (($parent$03$i$i | 0) != 0);
    }
    $21 = HEAP32[$8 + 28 >> 2] | 0;
    if ($21 | 0) if ((HEAP32[$21 + 20 >> 2] | 0) == 40) break;
    $26 = $$014$looptemp + 4 | 0;
    $27 = HEAP32[$26 >> 2] | 0;
    if (!$27) {
     if (_prvTidynodeHasCM($8, 16) | 0) {
      $$pr1$i = HEAP32[$26 >> 2] | 0;
      if (!$$pr1$i) label = 20; else {
       $37 = $$pr1$i;
       label = 17;
      }
     }
    } else {
     $30 = HEAP32[$27 + 28 >> 2] | 0;
     if (!$30) {
      $37 = $27;
      label = 17;
     } else if ((HEAP32[$30 >> 2] | 0) != 17) {
      $37 = $27;
      label = 17;
     }
    }
    do if ((label | 0) == 17) {
     label = 0;
     if (!(_prvTidynodeHasCM($37, 16) | 0)) if (_prvTidynodeIsElement(HEAP32[$26 >> 2] | 0) | 0) break;
     if (!(HEAP32[$26 >> 2] | 0)) label = 20; else break L6;
    } while (0);
    if ((label | 0) == 20) {
     label = 0;
     $44 = HEAP32[$$014$looptemp >> 2] | 0;
     if (HEAP32[$44 + 4 >> 2] | 0) break;
     if (_prvTidynodeHasCM(HEAP32[$44 >> 2] | 0, 16) | 0) break;
    }
    $51 = $$014$looptemp + 36 | 0;
    $52 = HEAP32[$51 >> 2] | 0;
    $53 = $$014$looptemp + 40 | 0;
    if ($52 >>> 0 < (HEAP32[$53 >> 2] | 0) >>> 0) {
     $60 = $52;
     do {
      if (!(_prvTidyIsWhite(HEAP8[(HEAP32[(HEAP32[$1 >> 2] | 0) + 84 >> 2] | 0) + $60 >> 0] | 0) | 0)) break L6;
      $60 = (HEAP32[$51 >> 2] | 0) + 1 | 0;
      HEAP32[$51 >> 2] = $60;
     } while ($60 >>> 0 < (HEAP32[$53 >> 2] | 0) >>> 0);
    }
   }
  } while (0);
  L38 : do if (_prvTidynodeIsText($$014$looptemp) | 0) if (_prvTidynodeIsText($$014$looptemp) | 0) {
   $73 = HEAP32[$$014$looptemp >> 2] | 0;
   if ((HEAP32[$73 + 44 >> 2] | 0) != 1) {
    if ($73 | 0) {
     $parent$03$i$i2 = $73;
     do {
      $79 = HEAP32[$parent$03$i$i2 + 28 >> 2] | 0;
      if ($79 | 0) if ((HEAP32[$79 + 20 >> 2] | 0) == 35) break L38;
      $parent$03$i$i2 = HEAP32[$parent$03$i$i2 >> 2] | 0;
     } while (($parent$03$i$i2 | 0) != 0);
    }
    $86 = HEAP32[$73 + 28 >> 2] | 0;
    if ($86 | 0) if ((HEAP32[$86 + 20 >> 2] | 0) == 40) break;
    $91 = HEAP32[$2 >> 2] | 0;
    L52 : do if (!$91) {
     if (_prvTidynodeHasCM($73, 16) | 0) {
      $97 = HEAP32[(HEAP32[$$014$looptemp >> 2] | 0) + 8 >> 2] | 0;
      if (!$97) break L38;
      if (_prvTidynodeHasCM($97, 16) | 0) break L38;
     }
    } else {
     $100 = HEAP32[$91 + 28 >> 2] | 0;
     if ($100 | 0) if ((HEAP32[$100 >> 2] | 0) == 17) break;
     if (_prvTidynodeHasCM($91, 16) | 0) break L38;
     switch (HEAP32[$91 + 44 >> 2] | 0) {
     case 7:
     case 5:
      {
       break L52;
       break;
      }
     default:
      {}
     }
     if (!(_prvTidynodeIsText($91) | 0)) break L38;
     $111 = HEAP32[$91 + 36 >> 2] | 0;
     if ($111 >>> 0 >= (HEAP32[$91 + 40 >> 2] | 0) >>> 0) break L38;
     if (!(_prvTidyIsWhite(HEAP8[(HEAP32[(HEAP32[$1 >> 2] | 0) + 84 >> 2] | 0) + $111 >> 0] | 0) | 0)) break L38;
    } while (0);
    $125 = $$014$looptemp + 40 | 0;
    $126 = HEAP32[$125 >> 2] | 0;
    $127 = $$014$looptemp + 36 | 0;
    if ($126 >>> 0 > (HEAP32[$127 >> 2] | 0) >>> 0) {
     $131 = $126;
     do {
      if (!(_prvTidyIsWhite(HEAP8[(HEAP32[(HEAP32[$1 >> 2] | 0) + 84 >> 2] | 0) + ($131 + -1) >> 0] | 0) | 0)) break L38;
      $131 = (HEAP32[$125 >> 2] | 0) + -1 | 0;
      HEAP32[$125 >> 2] = $131;
     } while ($131 >>> 0 > (HEAP32[$127 >> 2] | 0) >>> 0);
    }
   }
  } while (0);
  if (!(_prvTidynodeIsText($$014$looptemp) | 0)) label = 61; else if ((HEAP32[$$014$looptemp + 36 >> 2] | 0) >>> 0 < (HEAP32[$$014$looptemp + 40 >> 2] | 0) >>> 0) label = 61; else {
   $151 = $$014$looptemp + 4 | 0;
   $152 = HEAP32[$151 >> 2] | 0;
   if ($152 | 0) HEAP32[$152 + 8 >> 2] = HEAP32[$2 >> 2];
   $157 = HEAP32[$2 >> 2] | 0;
   $159 = $157;
   if ($157 | 0) HEAP32[$157 + 4 >> 2] = $152;
   $161 = HEAP32[$$014$looptemp >> 2] | 0;
   if ($161 | 0) {
    $163 = $161 + 12 | 0;
    if ((HEAP32[$163 >> 2] | 0) == ($$014$looptemp | 0)) HEAP32[$163 >> 2] = $159;
    $166 = $161 + 16 | 0;
    if ((HEAP32[$166 >> 2] | 0) == ($$014$looptemp | 0)) HEAP32[$166 >> 2] = HEAP32[$151 >> 2];
   }
   HEAP32[$2 >> 2] = 0;
   HEAP32[$151 >> 2] = 0;
   HEAP32[$$014$looptemp >> 2] = 0;
   _prvTidyFreeNode($doc, $$014$looptemp);
  }
  if ((label | 0) == 61) {
   label = 0;
   $172 = HEAP32[$$014$looptemp + 12 >> 2] | 0;
   if ($172 | 0) _CleanSpaces($doc, $172);
  }
 } while (($$014 | 0) != 0);
 return;
}

function _ParseString($doc, $option) {
 $doc = $doc | 0;
 $option = $option | 0;
 var $$0$i$i = 0, $$0$i$i10 = 0, $$0$i$i14$us = 0, $$0$i$i14$us46 = 0, $$0$i$i19 = 0, $0 = 0, $11 = 0, $14 = 0, $17 = 0, $26 = 0, $34 = 0, $42 = 0, $50 = 0, $51 = 0, $57 = 0, $buf = 0, $c$0$ph = 0, $c$0$ph23$be = 0, $c$0$ph2334 = 0, $c$024$us = 0, $c$024$us43 = 0, $c$1 = 0, $config$idx$i = 0, $config$idx$i12$pre$phiZZZ2D = 0, $config$idx$i8 = 0, $config$idx$val$i = 0, $config$idx$val$i13$us = 0, $config$idx$val$i13$us44 = 0, $config$idx$val$i18 = 0, $config$idx$val$i9 = 0, $delim$0$ph = 0, $i$0$ph$lcssa = 0, $i$0$ph32 = 0, $waswhite$0$ph33 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 8192 | 0;
 $buf = sp;
 $0 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$0 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$0 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$0 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $11 = HEAP32[$0 >> 2] | 0;
 switch ($11 | 0) {
 case 34:
 case 39:
  {
   $config$idx$i8 = $doc + 872 | 0;
   $config$idx$val$i9 = HEAP32[$config$idx$i8 >> 2] | 0;
   if (!$config$idx$val$i9) $$0$i$i10 = -1; else $$0$i$i10 = _prvTidyReadChar($config$idx$val$i9) | 0;
   HEAP32[$0 >> 2] = $$0$i$i10;
   $c$0$ph = $$0$i$i10;
   $config$idx$i12$pre$phiZZZ2D = $config$idx$i8;
   $delim$0$ph = $11;
   break;
  }
 default:
  {
   $c$0$ph = $11;
   $config$idx$i12$pre$phiZZZ2D = $doc + 872 | 0;
   $delim$0$ph = 0;
  }
 }
 $14 = ($delim$0$ph | 0) == 0;
 $c$0$ph2334 = $c$0$ph;
 $i$0$ph32 = 0;
 $waswhite$0$ph33 = 0;
 L17 : while (1) {
  L19 : do if ($14) {
   if ($waswhite$0$ph33) {
    switch ($c$0$ph2334 | 0) {
    case 10:
    case 13:
    case -1:
     {
      $i$0$ph$lcssa = $i$0$ph32;
      break L17;
      break;
     }
    default:
     {}
    }
    $26 = (_prvTidyIsWhite($c$0$ph2334) | 0) == 0;
    $c$1 = $26 ? $c$0$ph2334 : 32;
    break;
   } else $c$024$us43 = $c$0$ph2334;
   while (1) {
    switch ($c$024$us43 | 0) {
    case 10:
    case 13:
    case -1:
     {
      $i$0$ph$lcssa = $i$0$ph32;
      break L17;
      break;
     }
    default:
     {}
    }
    if (!(_prvTidyIsWhite($c$024$us43) | 0)) {
     $c$1 = $c$024$us43;
     break L19;
    }
    if ((HEAP32[$0 >> 2] | 0) == -1) {
     $c$024$us43 = -1;
     continue;
    }
    $config$idx$val$i13$us44 = HEAP32[$config$idx$i12$pre$phiZZZ2D >> 2] | 0;
    if (!$config$idx$val$i13$us44) $$0$i$i14$us46 = -1; else $$0$i$i14$us46 = _prvTidyReadChar($config$idx$val$i13$us44) | 0;
    HEAP32[$0 >> 2] = $$0$i$i14$us46;
    $c$024$us43 = $$0$i$i14$us46;
   }
  } else {
   if ($waswhite$0$ph33) {
    switch ($c$0$ph2334 | 0) {
    case 10:
    case 13:
    case -1:
     {
      $i$0$ph$lcssa = $i$0$ph32;
      break L17;
      break;
     }
    default:
     {}
    }
    if (($c$0$ph2334 | 0) == ($delim$0$ph | 0)) {
     $i$0$ph$lcssa = $i$0$ph32;
     break L17;
    }
    $17 = (_prvTidyIsWhite($c$0$ph2334) | 0) == 0;
    $c$1 = $17 ? $c$0$ph2334 : 32;
    break;
   } else $c$024$us = $c$0$ph2334;
   while (1) {
    switch ($c$024$us | 0) {
    case 10:
    case 13:
    case -1:
     {
      $i$0$ph$lcssa = $i$0$ph32;
      break L17;
      break;
     }
    default:
     {}
    }
    if (($c$024$us | 0) == ($delim$0$ph | 0)) {
     $i$0$ph$lcssa = $i$0$ph32;
     break L17;
    }
    if (!(_prvTidyIsWhite($c$024$us) | 0)) {
     $c$1 = $c$024$us;
     break L19;
    }
    if ((HEAP32[$0 >> 2] | 0) == -1) {
     $c$024$us = -1;
     continue;
    }
    $config$idx$val$i13$us = HEAP32[$config$idx$i12$pre$phiZZZ2D >> 2] | 0;
    if (!$config$idx$val$i13$us) $$0$i$i14$us = -1; else $$0$i$i14$us = _prvTidyReadChar($config$idx$val$i13$us) | 0;
    HEAP32[$0 >> 2] = $$0$i$i14$us;
    $c$024$us = $$0$i$i14$us;
   }
  } while (0);
  $34 = $i$0$ph32 + 1 | 0;
  HEAP8[$buf + $i$0$ph32 >> 0] = $c$1;
  if ((HEAP32[$0 >> 2] | 0) == -1) $c$0$ph23$be = -1; else {
   $config$idx$val$i18 = HEAP32[$config$idx$i12$pre$phiZZZ2D >> 2] | 0;
   if (!$config$idx$val$i18) $$0$i$i19 = -1; else $$0$i$i19 = _prvTidyReadChar($config$idx$val$i18) | 0;
   HEAP32[$0 >> 2] = $$0$i$i19;
   $c$0$ph23$be = $$0$i$i19;
  }
  if ($34 >>> 0 < 8190) {
   $c$0$ph2334 = $c$0$ph23$be;
   $i$0$ph32 = $34;
   $waswhite$0$ph33 = 1;
  } else {
   $i$0$ph$lcssa = $34;
   break;
  }
 }
 HEAP8[$buf + $i$0$ph$lcssa >> 0] = 0;
 $42 = HEAP32[$option >> 2] | 0;
 if ($42 >>> 0 >= 98) {
  STACKTOP = sp;
  return 1;
 }
 if ((HEAP32[1892 + ($42 << 5) >> 2] | 0) != ($42 | 0)) ___assert_fail(224036, 223800, 383, 224086);
 if (HEAP32[1892 + ($42 << 5) + 12 >> 2] | 0) ___assert_fail(224036, 223800, 383, 224086);
 $50 = $doc + 72 + ($42 << 2) | 0;
 $51 = HEAP32[$50 >> 2] | 0;
 if ($51 | 0) if (($51 | 0) != (HEAP32[1892 + ($42 << 5) + 28 >> 2] | 0)) {
  $57 = HEAP32[$doc + 6856 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$57 >> 2] | 0) + 8 >> 2] & 15]($57, $51);
 }
 if (!(_prvTidytmbstrlen($buf) | 0)) {
  HEAP32[$50 >> 2] = 0;
  STACKTOP = sp;
  return 1;
 } else {
  HEAP32[$50 >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, $buf) | 0;
  STACKTOP = sp;
  return 1;
 }
 return 0;
}

function _CheckColor($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $$lcssa$i = 0, $$pn = 0, $1 = 0, $109 = 0, $11 = 0, $13 = 0, $14 = 0, $16 = 0, $18 = 0, $2 = 0, $25 = 0, $6 = 0, $64 = 0, $66 = 0, $67 = 0, $73 = 0, $8 = 0, $9 = 0, $given$0 = 0, $given$158 = 0, $given$314 = 0, $given$31416 = 0, $valid$110 = 0, label = 0;
 if ($attval | 0) {
  $1 = $attval + 24 | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  if ($2 | 0) {
   do if ((HEAP8[$2 >> 0] | 0) == 35) label = 10; else {
    $6 = _IsValidColorCode($2) | 0;
    if (!$6) if ((HEAP8[$2 >> 0] | 0) == 35) {
     label = 10;
     break;
    } else {
     label = 31;
     break;
    }
    $8 = $doc + 6856 | 0;
    $9 = HEAP32[$8 >> 2] | 0;
    $11 = HEAP32[HEAP32[$9 >> 2] >> 2] | 0;
    $13 = (_prvTidytmbstrlen($2) | 0) + 2 | 0;
    $14 = FUNCTION_TABLE_iii[$11 & 31]($9, $13) | 0;
    HEAP8[$14 >> 0] = 35;
    $$pn = $14;
    $given$0 = $2;
    while (1) {
     $$pn = $$pn + 1 | 0;
     $16 = HEAP8[$given$0 >> 0] | 0;
     HEAP8[$$pn >> 0] = $16;
     if (!($16 << 24 >> 24)) break; else $given$0 = $given$0 + 1 | 0;
    }
    _prvTidyReportAttrError($doc, $node, $attval, 272);
    $18 = HEAP32[$8 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$18 >> 2] | 0) + 8 >> 2] & 15]($18, HEAP32[$1 >> 2] | 0);
    HEAP32[$1 >> 2] = $14;
    $given$158 = $14;
    $valid$110 = $6;
    label = 11;
   } while (0);
   if ((label | 0) == 10) {
    $25 = _IsValidColorCode($2 + 1 | 0) | 0;
    if (!$25) label = 31; else {
     $given$158 = $2;
     $valid$110 = $25;
     label = 11;
    }
   }
   if ((label | 0) == 11) {
    L32 : do if ((HEAP8[$given$158 >> 0] | 0) == 35) if (!(HEAP32[$doc + 384 >> 2] | 0)) $given$314 = $given$158; else {
     do if (!(_prvTidytmbstrcasecmp($given$158, 304602) | 0)) $$lcssa$i = 58396; else if (!(_prvTidytmbstrcasecmp($given$158, 304610) | 0)) $$lcssa$i = 58404; else if (!(_prvTidytmbstrcasecmp($given$158, 304618) | 0)) $$lcssa$i = 58412; else if (!(_prvTidytmbstrcasecmp($given$158, 304626) | 0)) $$lcssa$i = 58420; else if (!(_prvTidytmbstrcasecmp($given$158, 304634) | 0)) $$lcssa$i = 58428; else if (!(_prvTidytmbstrcasecmp($given$158, 304642) | 0)) $$lcssa$i = 58436; else if (!(_prvTidytmbstrcasecmp($given$158, 304650) | 0)) $$lcssa$i = 58444; else if (!(_prvTidytmbstrcasecmp($given$158, 304658) | 0)) $$lcssa$i = 58452; else if (!(_prvTidytmbstrcasecmp($given$158, 304666) | 0)) $$lcssa$i = 58460; else if (!(_prvTidytmbstrcasecmp($given$158, 304674) | 0)) $$lcssa$i = 58468; else if (!(_prvTidytmbstrcasecmp($given$158, 304682) | 0)) $$lcssa$i = 58476; else {
      if (!(_prvTidytmbstrcasecmp($given$158, 304690) | 0)) {
       $$lcssa$i = 58484;
       break;
      }
      if (!(_prvTidytmbstrcasecmp($given$158, 304698) | 0)) {
       $$lcssa$i = 58492;
       break;
      }
      if (!(_prvTidytmbstrcasecmp($given$158, 304706) | 0)) {
       $$lcssa$i = 58500;
       break;
      }
      if (!(_prvTidytmbstrcasecmp($given$158, 304714) | 0)) {
       $$lcssa$i = 58508;
       break;
      }
      if (!(_prvTidytmbstrcasecmp($given$158, 304722) | 0)) $$lcssa$i = 58516; else {
       $given$314 = $given$158;
       break L32;
      }
     } while (0);
     $64 = HEAP32[$$lcssa$i >> 2] | 0;
     if (!$64) $given$314 = $given$158; else {
      $66 = $doc + 6856 | 0;
      $67 = HEAP32[$66 >> 2] | 0;
      FUNCTION_TABLE_vii[HEAP32[(HEAP32[$67 >> 2] | 0) + 8 >> 2] & 15]($67, HEAP32[$1 >> 2] | 0);
      $73 = _prvTidytmbstrdup(HEAP32[$66 >> 2] | 0, $64) | 0;
      HEAP32[$1 >> 2] = $73;
      $given$314 = $73;
     }
    } else $given$314 = $given$158; while (0);
    if (!$valid$110) label = 51; else $given$31416 = $given$314;
   } else if ((label | 0) == 31) if (!(_prvTidytmbstrcasecmp($2, 311730) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311780) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311736) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311786) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 304730) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311791) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311748) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311797) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311754) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311804) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311761) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311809) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311765) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311814) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311772) | 0)) $given$31416 = $2; else if (!(_prvTidytmbstrcasecmp($2, 311819) | 0)) $given$31416 = $2; else label = 51;
   if ((label | 0) == 51) {
    _prvTidyReportAttrError($doc, $node, $attval, 251);
    return;
   }
   $109 = HEAP32[$1 >> 2] | 0;
   if ((HEAP8[$given$31416 >> 0] | 0) == 35) {
    HEAP32[$1 >> 2] = _prvTidytmbstrtoupper($109) | 0;
    return;
   } else {
    HEAP32[$1 >> 2] = _prvTidytmbstrtolower($109) | 0;
    return;
   }
  }
 }
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 return;
}

function _PPrintXmlDecl($doc, $indent, $node) {
 $doc = $doc | 0;
 $indent = $indent | 0;
 $node = $node | 0;
 var $$pre$i$i = 0, $$pre$phi$i$i8Z2D = 0, $$pre$phi$i$iZ2D = 0, $0 = 0, $1 = 0, $102 = 0, $104 = 0, $11 = 0, $119 = 0, $122 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $26 = 0, $30 = 0, $33 = 0, $35 = 0, $47 = 0, $49 = 0, $5 = 0, $51 = 0, $54 = 0, $64 = 0, $65 = 0, $66 = 0, $7 = 0, $71 = 0, $75 = 0, $78 = 0, $80 = 0, $87 = 0, $88 = 0, $89 = 0, $90 = 0, $95 = 0, $99 = 0, $buflen$0$i$i$i = 0, $buflen$0$i$i$i$lcssa = 0, $buflen$0$i$i$i3 = 0, $buflen$0$i$i$i3$lcssa = 0, $buflen$0$i$i$i7 = 0, $buflen$0$i$i$i7$lcssa = 0, $ix$01$i$i = 0, label = 0;
 $0 = $doc + 6724 | 0;
 $1 = $doc + 6736 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 $5 = HEAP32[$doc + 80 >> 2] | 0;
 if (($2 + $indent | 0) >>> 0 < $5 >>> 0) {
  $7 = $doc + 6752 | 0;
  if ((HEAP32[$7 >> 2] | 0) < 0) HEAP32[$7 >> 2] = $indent;
  HEAP32[$doc + 6740 >> 2] = $2;
 } else {
  $11 = $doc + 6748 | 0;
  if (!(HEAP32[$11 >> 2] | 0)) {
   HEAP32[$doc + 6764 >> 2] = $indent;
   HEAP32[$11 >> 2] = 1;
  }
 }
 _prvTidySetOptionInt($doc, 2, -1) | 0;
 $16 = HEAP32[$doc + 192 >> 2] | 0;
 _prvTidySetOptionBool($doc, 30, 0) | 0;
 $17 = HEAP32[$1 >> 2] | 0;
 $18 = _prvTidytmbstrlen(310816) | 0;
 $19 = $18 + $17 | 0;
 $20 = $doc + 6732 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 if ($19 >>> 0 >= $21 >>> 0) {
  $buflen$0$i$i$i = ($21 | 0) == 0 ? 256 : $21;
  while (1) if ($buflen$0$i$i$i >>> 0 > $19 >>> 0) {
   $buflen$0$i$i$i$lcssa = $buflen$0$i$i$i;
   break;
  } else $buflen$0$i$i$i = $buflen$0$i$i$i << 1;
  $26 = HEAP32[$0 >> 2] | 0;
  $30 = $doc + 6728 | 0;
  $33 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$26 >> 2] | 0) + 4 >> 2] & 15]($26, HEAP32[$30 >> 2] | 0, $buflen$0$i$i$i$lcssa << 2) | 0;
  if ($33 | 0) {
   $35 = HEAP32[$20 >> 2] | 0;
   _memset($33 + ($35 << 2) | 0, 0, $buflen$0$i$i$i$lcssa - $35 << 2 | 0) | 0;
   HEAP32[$20 >> 2] = $buflen$0$i$i$i$lcssa;
   HEAP32[$30 >> 2] = $33;
  }
 }
 if ($18 | 0) {
  $$pre$i$i = HEAP32[$doc + 6728 >> 2] | 0;
  $ix$01$i$i = 0;
  do {
   HEAP32[$$pre$i$i + ($ix$01$i$i + $17 << 2) >> 2] = HEAP8[310816 + $ix$01$i$i >> 0];
   $ix$01$i$i = $ix$01$i$i + 1 | 0;
  } while (($ix$01$i$i | 0) != ($18 | 0));
 }
 HEAP32[$1 >> 2] = $19;
 $47 = _prvTidyAttrGetById($node, 156) | 0;
 if ($47 | 0) _PPrintAttribute($doc, $indent, $node, $47);
 $49 = _prvTidyAttrGetById($node, 48) | 0;
 if ($49 | 0) _PPrintAttribute($doc, $indent, $node, $49);
 $51 = _prvTidyGetAttrByName($node, 310828) | 0;
 if ($51 | 0) _PPrintAttribute($doc, $indent, $node, $51);
 _prvTidySetOptionBool($doc, 30, $16) | 0;
 $54 = HEAP32[$node + 40 >> 2] | 0;
 if (!$54) label = 24; else if ((HEAP8[(HEAP32[(HEAP32[$doc + 68 >> 2] | 0) + 84 >> 2] | 0) + ($54 + -1) >> 0] | 0) == 63) $89 = HEAP32[$1 >> 2] | 0; else label = 24;
 if ((label | 0) == 24) {
  $64 = HEAP32[$1 >> 2] | 0;
  $65 = $64 + 1 | 0;
  $66 = HEAP32[$20 >> 2] | 0;
  if ($65 >>> 0 < $66 >>> 0) $$pre$phi$i$iZ2D = $doc + 6728 | 0; else {
   $buflen$0$i$i$i3 = ($66 | 0) == 0 ? 256 : $66;
   while (1) if ($buflen$0$i$i$i3 >>> 0 > $65 >>> 0) {
    $buflen$0$i$i$i3$lcssa = $buflen$0$i$i$i3;
    break;
   } else $buflen$0$i$i$i3 = $buflen$0$i$i$i3 << 1;
   $71 = HEAP32[$0 >> 2] | 0;
   $75 = $doc + 6728 | 0;
   $78 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$71 >> 2] | 0) + 4 >> 2] & 15]($71, HEAP32[$75 >> 2] | 0, $buflen$0$i$i$i3$lcssa << 2) | 0;
   if (!$78) $$pre$phi$i$iZ2D = $75; else {
    $80 = HEAP32[$20 >> 2] | 0;
    _memset($78 + ($80 << 2) | 0, 0, $buflen$0$i$i$i3$lcssa - $80 << 2 | 0) | 0;
    HEAP32[$20 >> 2] = $buflen$0$i$i$i3$lcssa;
    HEAP32[$75 >> 2] = $78;
    $$pre$phi$i$iZ2D = $75;
   }
  }
  HEAP32[(HEAP32[$$pre$phi$i$iZ2D >> 2] | 0) + ($64 << 2) >> 2] = 63;
  $87 = (HEAP32[$1 >> 2] | 0) + 1 | 0;
  HEAP32[$1 >> 2] = $87;
  $89 = $87;
 }
 $88 = $89 + 1 | 0;
 $90 = HEAP32[$20 >> 2] | 0;
 if ($88 >>> 0 < $90 >>> 0) $$pre$phi$i$i8Z2D = $doc + 6728 | 0; else {
  $buflen$0$i$i$i7 = ($90 | 0) == 0 ? 256 : $90;
  while (1) if ($buflen$0$i$i$i7 >>> 0 > $88 >>> 0) {
   $buflen$0$i$i$i7$lcssa = $buflen$0$i$i$i7;
   break;
  } else $buflen$0$i$i$i7 = $buflen$0$i$i$i7 << 1;
  $95 = HEAP32[$0 >> 2] | 0;
  $99 = $doc + 6728 | 0;
  $102 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$95 >> 2] | 0) + 4 >> 2] & 15]($95, HEAP32[$99 >> 2] | 0, $buflen$0$i$i$i7$lcssa << 2) | 0;
  if (!$102) $$pre$phi$i$i8Z2D = $99; else {
   $104 = HEAP32[$20 >> 2] | 0;
   _memset($102 + ($104 << 2) | 0, 0, $buflen$0$i$i$i7$lcssa - $104 << 2 | 0) | 0;
   HEAP32[$20 >> 2] = $buflen$0$i$i$i7$lcssa;
   HEAP32[$99 >> 2] = $102;
   $$pre$phi$i$i8Z2D = $99;
  }
 }
 HEAP32[(HEAP32[$$pre$phi$i$i8Z2D >> 2] | 0) + ($89 << 2) >> 2] = 62;
 HEAP32[$1 >> 2] = (HEAP32[$1 >> 2] | 0) + 1;
 _prvTidySetOptionInt($doc, 2, $5) | 0;
 if (HEAP32[$1 >> 2] | 0) _PFlushLineImpl($doc);
 if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
  _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
  $119 = $doc + 6744 | 0;
  HEAP32[$119 >> 2] = (HEAP32[$119 >> 2] | 0) + 1;
 }
 $122 = $doc + 6752 | 0;
 if ((HEAP32[$122 >> 2] | 0) == ($indent | 0)) return;
 HEAP32[$122 >> 2] = $indent;
 return;
}

function _prvTidySortAttributes($node, $strat) {
 $node = $node | 0;
 $strat = $strat | 0;
 var $$0$i = 0, $$02$i = 0, $$025 = 0, $$116$us$i = 0, $$2$ph$us$i = 0, $$2$ph$us$i$lcssa = 0, $$2$ph$us$i$lcssa$lcssa = 0, $$lcssa56 = 0, $1 = 0, $2 = 0, $32 = 0, $5 = 0, $6 = 0, $8 = 0, $AlphaComparator$$i$i = 0, $e$0$us$i = 0, $i$011$us$i = 0, $insize$0$i = 0, $nmerges$019$us$i = 0, $p$017$us$i = 0, $p$1$ph$us$i = 0, $p$1$us$i = 0, $p$2$us$i = 0, $psize$2$ph4$us$i = 0, $psize$2$us$i = 0, $psize$3$us$i = 0, $q$09$us$i = 0, $q$2$ph3$us$i = 0, $q$2$us$i = 0, $q$2$us$i$lcssa = 0, $q$3$us$i = 0, $qsize$0$ph$us$i = 0, $qsize$0$us$i = 0, $qsize$1$us$i = 0, $tail$018$us$i = 0, $tail$1$ph$us$i = 0, $tail$1$us$i = 0, $tail$1$us$i$lcssa = 0, $tail$1$us$i$lcssa$lcssa = 0, label = 0;
 if (!$node) return;
 $AlphaComparator$$i$i = ($strat | 0) == 1 ? 16 : 0;
 $$025 = $node;
 L4 : while (1) {
  $1 = $$025 + 20 | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  if (!$2) $$0$i = 0; else {
   $$02$i = $2;
   $insize$0$i = 1;
   while (1) {
    if (($insize$0$i | 0) > 0) {
     $$116$us$i = 0;
     $nmerges$019$us$i = 0;
     $p$017$us$i = $$02$i;
     $tail$018$us$i = 0;
    } else {
     label = 21;
     break L4;
    }
    while (1) {
     $5 = $nmerges$019$us$i + 1 | 0;
     $i$011$us$i = 0;
     $q$09$us$i = $p$017$us$i;
     while (1) {
      $6 = $i$011$us$i + 1 | 0;
      $8 = HEAP32[$q$09$us$i >> 2] | 0;
      if (!$8) {
       $$2$ph$us$i = $$116$us$i;
       $p$1$ph$us$i = $p$017$us$i;
       $psize$2$ph4$us$i = $6;
       $q$2$ph3$us$i = 0;
       $qsize$0$ph$us$i = $insize$0$i;
       $tail$1$ph$us$i = $tail$018$us$i;
       break;
      }
      if (($6 | 0) < ($insize$0$i | 0)) {
       $i$011$us$i = $6;
       $q$09$us$i = $8;
      } else {
       $$2$ph$us$i = $$116$us$i;
       $p$1$ph$us$i = $p$017$us$i;
       $psize$2$ph4$us$i = $6;
       $q$2$ph3$us$i = $8;
       $qsize$0$ph$us$i = $insize$0$i;
       $tail$1$ph$us$i = $tail$018$us$i;
       break;
      }
     }
     L14 : while (1) {
      $p$1$us$i = $p$1$ph$us$i;
      $psize$2$us$i = $psize$2$ph4$us$i;
      $q$2$us$i = $q$2$ph3$us$i;
      $qsize$0$us$i = $qsize$0$ph$us$i;
      $tail$1$us$i = $tail$1$ph$us$i;
      while (1) {
       if (($psize$2$us$i | 0) > 0) label = 12; else {
        if (!(($q$2$us$i | 0) != 0 & ($qsize$0$us$i | 0) > 0)) {
         $$2$ph$us$i$lcssa = $$2$ph$us$i;
         $q$2$us$i$lcssa = $q$2$us$i;
         $tail$1$us$i$lcssa = $tail$1$us$i;
         break L14;
        }
        if (!$psize$2$us$i) {
         $e$0$us$i = $q$2$us$i;
         $p$2$us$i = $p$1$us$i;
         $psize$3$us$i = 0;
         $q$3$us$i = HEAP32[$q$2$us$i >> 2] | 0;
         $qsize$1$us$i = $qsize$0$us$i + -1 | 0;
        } else label = 12;
       }
       do if ((label | 0) == 12) {
        label = 0;
        if (!(($q$2$us$i | 0) != 0 & ($qsize$0$us$i | 0) != 0)) {
         $e$0$us$i = $p$1$us$i;
         $p$2$us$i = HEAP32[$p$1$us$i >> 2] | 0;
         $psize$3$us$i = $psize$2$us$i + -1 | 0;
         $q$3$us$i = $q$2$us$i;
         $qsize$1$us$i = $qsize$0$us$i;
         break;
        }
        if ((FUNCTION_TABLE_iii[$AlphaComparator$$i$i & 31]($p$1$us$i, $q$2$us$i) | 0) < 1) {
         $e$0$us$i = $p$1$us$i;
         $p$2$us$i = HEAP32[$p$1$us$i >> 2] | 0;
         $psize$3$us$i = $psize$2$us$i + -1 | 0;
         $q$3$us$i = $q$2$us$i;
         $qsize$1$us$i = $qsize$0$us$i;
         break;
        } else {
         $e$0$us$i = $q$2$us$i;
         $p$2$us$i = $p$1$us$i;
         $psize$3$us$i = $psize$2$us$i;
         $q$3$us$i = HEAP32[$q$2$us$i >> 2] | 0;
         $qsize$1$us$i = $qsize$0$us$i + -1 | 0;
         break;
        }
       } while (0);
       if (!$tail$1$us$i) {
        $$2$ph$us$i = $e$0$us$i;
        $p$1$ph$us$i = $p$2$us$i;
        $psize$2$ph4$us$i = $psize$3$us$i;
        $q$2$ph3$us$i = $q$3$us$i;
        $qsize$0$ph$us$i = $qsize$1$us$i;
        $tail$1$ph$us$i = $e$0$us$i;
        continue L14;
       }
       HEAP32[$tail$1$us$i >> 2] = $e$0$us$i;
       $p$1$us$i = $p$2$us$i;
       $psize$2$us$i = $psize$3$us$i;
       $q$2$us$i = $q$3$us$i;
       $qsize$0$us$i = $qsize$1$us$i;
       $tail$1$us$i = $e$0$us$i;
      }
     }
     if (!$q$2$us$i$lcssa) {
      $$2$ph$us$i$lcssa$lcssa = $$2$ph$us$i$lcssa;
      $$lcssa56 = $5;
      $tail$1$us$i$lcssa$lcssa = $tail$1$us$i$lcssa;
      break;
     } else {
      $$116$us$i = $$2$ph$us$i$lcssa;
      $nmerges$019$us$i = $5;
      $p$017$us$i = $q$2$us$i$lcssa;
      $tail$018$us$i = $tail$1$us$i$lcssa;
     }
    }
    HEAP32[$tail$1$us$i$lcssa$lcssa >> 2] = 0;
    if (($$lcssa56 | 0) < 2) {
     $$0$i = $$2$ph$us$i$lcssa$lcssa;
     break;
    } else {
     $$02$i = $$2$ph$us$i$lcssa$lcssa;
     $insize$0$i = $insize$0$i << 1;
    }
   }
  }
  HEAP32[$1 >> 2] = $$0$i;
  $32 = HEAP32[$$025 + 12 >> 2] | 0;
  if ($32 | 0) _prvTidySortAttributes($32, $strat);
  $$025 = HEAP32[$$025 + 8 >> 2] | 0;
  if (!$$025) {
   label = 26;
   break;
  }
 }
 if ((label | 0) == 21) while (1) {
  label = 0;
  label = 21;
 } else if ((label | 0) == 26) return;
}

function _prvTidyCleanDocument($doc) {
 $doc = $doc | 0;
 var $22 = 0, $25 = 0, $27 = 0, $3 = 0, $34 = 0, $35 = 0, $39 = 0, $4 = 0, $40 = 0, $42 = 0, $43 = 0, $44 = 0, $46 = 0, $47 = 0, $48 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $59 = 0, $63 = 0, $67 = 0, $70 = 0, $72 = 0, $75 = 0, $77 = 0, $8 = 0, $80 = 0, $93 = 0, $bgcolor$0$i$i = 0, $bgurl$0$i$i = 0, $color$0$i$i = 0, $style$01$i = 0, $style$02$i = 0;
 _CleanTree($doc, $doc) | 0;
 if (!(HEAP32[$doc + 200 >> 2] | 0)) return;
 _DefineStyleRules($doc, $doc);
 $3 = $doc + 68 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $4 + 120 | 0;
 if (!(HEAP32[$5 >> 2] | 0)) {
  $8 = _prvTidyFindBody($doc) | 0;
  if (!$8) return;
  if (!(_prvTidyAttrGetById($8, 13) | 0)) if (!(_prvTidyAttrGetById($8, 14) | 0)) if (!(_prvTidyAttrGetById($8, 147) | 0)) if (!(_prvTidyAttrGetById($8, 76) | 0)) if (!(_prvTidyAttrGetById($8, 157) | 0)) if (!(_prvTidyAttrGetById($8, 8) | 0)) return;
  $22 = $doc + 6840 | 0;
  HEAP32[$22 >> 2] = HEAP32[$22 >> 2] | 16;
 }
 $25 = $doc + 6856 | 0;
 $27 = _prvTidyNewNode(HEAP32[$25 >> 2] | 0, $4) | 0;
 HEAP32[$27 + 44 >> 2] = 5;
 HEAP32[$27 + 60 >> 2] = 1;
 HEAP32[$27 + 32 >> 2] = _prvTidytmbstrdup(HEAP32[$25 >> 2] | 0, 310951) | 0;
 _prvTidyFindTag($doc, $27) | 0;
 _prvTidyInsertAttributeAtStart($27, _prvTidyNewAttributeEx($doc, 311272, 311277, 34) | 0);
 $34 = _prvTidyFindBody($doc) | 0;
 $35 = $4 + 92 | 0;
 HEAP32[$4 + 48 >> 2] = HEAP32[$35 >> 2];
 if ($34 | 0) {
  $39 = HEAP32[$3 >> 2] | 0;
  $40 = _prvTidyAttrGetById($34, 13) | 0;
  if (!$40) $bgurl$0$i$i = 0; else {
   $42 = $40 + 24 | 0;
   $43 = HEAP32[$42 >> 2] | 0;
   HEAP32[$42 >> 2] = 0;
   _prvTidyRemoveAttribute($doc, $34, $40);
   $bgurl$0$i$i = $43;
  }
  $44 = _prvTidyAttrGetById($34, 14) | 0;
  if (!$44) $bgcolor$0$i$i = 0; else {
   $46 = $44 + 24 | 0;
   $47 = HEAP32[$46 >> 2] | 0;
   HEAP32[$46 >> 2] = 0;
   _prvTidyRemoveAttribute($doc, $34, $44);
   $bgcolor$0$i$i = $47;
  }
  $48 = _prvTidyAttrGetById($34, 147) | 0;
  if (!$48) $color$0$i$i = 0; else {
   $50 = $48 + 24 | 0;
   $51 = HEAP32[$50 >> 2] | 0;
   HEAP32[$50 >> 2] = 0;
   _prvTidyRemoveAttribute($doc, $34, $48);
   $color$0$i$i = $51;
  }
  $52 = ($bgurl$0$i$i | 0) != 0;
  $53 = ($bgcolor$0$i$i | 0) != 0;
  $54 = ($color$0$i$i | 0) != 0;
  if ($52 | $53 | $54) {
   _prvTidyAddStringLiteral($39, 311286);
   if ($52) {
    _prvTidyAddStringLiteral($39, 311295);
    _prvTidyAddStringLiteral($39, $bgurl$0$i$i);
    _prvTidyAddStringLiteral($39, 311320);
    $55 = HEAP32[$25 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$55 >> 2] | 0) + 8 >> 2] & 15]($55, $bgurl$0$i$i);
   }
   if ($53) {
    _prvTidyAddStringLiteral($39, 311324);
    _prvTidyAddStringLiteral($39, $bgcolor$0$i$i);
    _prvTidyAddStringLiteral($39, 311345);
    $59 = HEAP32[$25 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$59 >> 2] | 0) + 8 >> 2] & 15]($59, $bgcolor$0$i$i);
   }
   if ($54) {
    _prvTidyAddStringLiteral($39, 311348);
    _prvTidyAddStringLiteral($39, $color$0$i$i);
    _prvTidyAddStringLiteral($39, 311345);
    $63 = HEAP32[$25 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$63 >> 2] | 0) + 8 >> 2] & 15]($63, $color$0$i$i);
   }
   _prvTidyAddStringLiteral($39, 311358);
  }
  $67 = _prvTidyAttrGetById($34, 76) | 0;
  if ($67 | 0) {
   $70 = HEAP32[$67 + 24 >> 2] | 0;
   if ($70 | 0) {
    _prvTidyAddStringLiteral($39, 311362);
    _prvTidyAddStringLiteral($39, 311369);
    _prvTidyAddStringLiteral($39, $70);
    _prvTidyAddStringLiteral($39, 311358);
   }
   _prvTidyRemoveAttribute($doc, $34, $67);
  }
  $72 = _prvTidyAttrGetById($34, 157) | 0;
  if ($72 | 0) {
   $75 = HEAP32[$72 + 24 >> 2] | 0;
   if ($75 | 0) {
    _prvTidyAddStringLiteral($39, 311380);
    _prvTidyAddStringLiteral($39, 311369);
    _prvTidyAddStringLiteral($39, $75);
    _prvTidyAddStringLiteral($39, 311358);
   }
   _prvTidyRemoveAttribute($doc, $34, $72);
  }
  $77 = _prvTidyAttrGetById($34, 8) | 0;
  if ($77 | 0) {
   $80 = HEAP32[$77 + 24 >> 2] | 0;
   if ($80 | 0) {
    _prvTidyAddStringLiteral($39, 311390);
    _prvTidyAddStringLiteral($39, 311369);
    _prvTidyAddStringLiteral($39, $80);
    _prvTidyAddStringLiteral($39, 311358);
   }
   _prvTidyRemoveAttribute($doc, $34, $77);
  }
 }
 $style$01$i = HEAP32[$5 >> 2] | 0;
 if ($style$01$i | 0) {
  $style$02$i = $style$01$i;
  do {
   _prvTidyAddCharToLexer($4, 32);
   _prvTidyAddStringLiteral($4, HEAP32[$style$02$i >> 2] | 0);
   _prvTidyAddCharToLexer($4, 46);
   _prvTidyAddStringLiteral($4, HEAP32[$style$02$i + 4 >> 2] | 0);
   _prvTidyAddCharToLexer($4, 32);
   _prvTidyAddCharToLexer($4, 123);
   _prvTidyAddStringLiteral($4, HEAP32[$style$02$i + 8 >> 2] | 0);
   _prvTidyAddCharToLexer($4, 125);
   _prvTidyAddCharToLexer($4, 10);
   $style$02$i = HEAP32[$style$02$i + 12 >> 2] | 0;
  } while (($style$02$i | 0) != 0);
 }
 HEAP32[$4 + 52 >> 2] = HEAP32[$35 >> 2];
 _prvTidyInsertNodeAtEnd($27, _prvTidyTextToken($4) | 0);
 $93 = _prvTidyFindHEAD($doc) | 0;
 if (!$93) return;
 _prvTidyInsertNodeAtEnd($93, $27);
 return;
}

function _prvTidyReportEncodingError($doc, $code, $c, $discarded) {
 $doc = $doc | 0;
 $code = $code | 0;
 $c = $c | 0;
 $discarded = $discarded | 0;
 var $$03$i = 0, $$03$i20 = 0, $$03$i7 = 0, $$lcssa = 0, $$lcssa37 = 0, $$lcssa38 = 0, $10 = 0, $2 = 0, $24 = 0, $3 = 0, $33 = 0, $47 = 0, $50 = 0, $53 = 0, $62 = 0, $76 = 0, $buf = 0, $buf$i = 0, $i$0$lcssa7$i = 0, $i$0$lcssa7$i12 = 0, $i$0$lcssa7$i25 = 0, $i$0$lcssa8$i = 0, $i$0$lcssa8$i17 = 0, $i$0$lcssa8$i4 = 0, $i$04$i = 0, $i$04$i$lcssa = 0, $i$04$i19 = 0, $i$04$i19$lcssa = 0, $i$04$i6 = 0, $i$04$i6$lcssa = 0, $i$11$i = 0, $i$11$i10 = 0, $i$11$i23 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $buf$i = sp + 56 | 0;
 $buf = sp + 24 | 0;
 dest = $buf;
 stop = dest + 32 | 0;
 do {
  HEAP8[dest >> 0] = 0;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 $2 = _tidyLocalizedString($discarded | 0 ? 2053 : 2065) | 0;
 $3 = _tidyLocalizedString($code) | 0;
 switch ($code | 0) {
 case 291:
  {
   HEAP8[$buf$i >> 0] = (($c | 0) % 10 | 0) + 48;
   if (($c + 9 | 0) >>> 0 < 19) {
    $i$0$lcssa8$i = 0;
    label = 4;
   } else {
    $$03$i = $c;
    $i$04$i = 0;
    while (1) {
     $$03$i = ($$03$i | 0) / 10 | 0;
     $10 = $i$04$i + 1 | 0;
     HEAP8[$buf$i + $10 >> 0] = (($$03$i | 0) % 10 | 0) + 48;
     if (($$03$i + 9 | 0) >>> 0 < 19) {
      $$lcssa = $10;
      $i$04$i$lcssa = $i$04$i;
      break;
     } else $i$04$i = $10;
    }
    if (($i$04$i$lcssa | 0) > -2) {
     $i$0$lcssa8$i = $$lcssa;
     label = 4;
    } else $i$0$lcssa7$i = $$lcssa;
   }
   if ((label | 0) == 4) {
    $i$11$i = $i$0$lcssa8$i;
    while (1) {
     HEAP8[$buf + ($i$0$lcssa8$i - $i$11$i) >> 0] = HEAP8[$buf$i + $i$11$i >> 0] | 0;
     if (($i$11$i | 0) > 0) $i$11$i = $i$11$i + -1 | 0; else {
      $i$0$lcssa7$i = $i$0$lcssa8$i;
      break;
     }
    }
   }
   HEAP8[$buf + ($i$0$lcssa7$i + 1) >> 0] = 0;
   $24 = $doc + 6844 | 0;
   HEAP32[$24 >> 2] = HEAP32[$24 >> 2] | 1;
   break;
  }
 case 292:
  {
   HEAP8[$buf$i >> 0] = (($c | 0) % 10 | 0) + 48;
   if (($c + 9 | 0) >>> 0 < 19) {
    $i$0$lcssa8$i4 = 0;
    label = 10;
   } else {
    $$03$i7 = $c;
    $i$04$i6 = 0;
    while (1) {
     $$03$i7 = ($$03$i7 | 0) / 10 | 0;
     $33 = $i$04$i6 + 1 | 0;
     HEAP8[$buf$i + $33 >> 0] = (($$03$i7 | 0) % 10 | 0) + 48;
     if (($$03$i7 + 9 | 0) >>> 0 < 19) {
      $$lcssa37 = $33;
      $i$04$i6$lcssa = $i$04$i6;
      break;
     } else $i$04$i6 = $33;
    }
    if (($i$04$i6$lcssa | 0) > -2) {
     $i$0$lcssa8$i4 = $$lcssa37;
     label = 10;
    } else $i$0$lcssa7$i12 = $$lcssa37;
   }
   if ((label | 0) == 10) {
    $i$11$i10 = $i$0$lcssa8$i4;
    while (1) {
     HEAP8[$buf + ($i$0$lcssa8$i4 - $i$11$i10) >> 0] = HEAP8[$buf$i + $i$11$i10 >> 0] | 0;
     if (($i$11$i10 | 0) > 0) $i$11$i10 = $i$11$i10 + -1 | 0; else {
      $i$0$lcssa7$i12 = $i$0$lcssa8$i4;
      break;
     }
    }
   }
   HEAP8[$buf + ($i$0$lcssa7$i12 + 1) >> 0] = 0;
   $47 = $doc + 6844 | 0;
   HEAP32[$47 >> 2] = HEAP32[$47 >> 2] | 2;
   break;
  }
 case 293:
  {
   HEAP32[$vararg_buffer >> 2] = $c;
   _prvTidytmbsnprintf($buf, 32, 223533, $vararg_buffer) | 0;
   $50 = $doc + 6844 | 0;
   HEAP32[$50 >> 2] = HEAP32[$50 >> 2] | 4;
   break;
  }
 case 294:
  {
   HEAP32[$vararg_buffer1 >> 2] = $c;
   _prvTidytmbsnprintf($buf, 32, 223533, $vararg_buffer1) | 0;
   $53 = $doc + 6844 | 0;
   HEAP32[$53 >> 2] = HEAP32[$53 >> 2] | 8;
   break;
  }
 case 297:
  {
   HEAP8[$buf$i >> 0] = (($c | 0) % 10 | 0) + 48;
   if (($c + 9 | 0) >>> 0 < 19) {
    $i$0$lcssa8$i17 = 0;
    label = 18;
   } else {
    $$03$i20 = $c;
    $i$04$i19 = 0;
    while (1) {
     $$03$i20 = ($$03$i20 | 0) / 10 | 0;
     $62 = $i$04$i19 + 1 | 0;
     HEAP8[$buf$i + $62 >> 0] = (($$03$i20 | 0) % 10 | 0) + 48;
     if (($$03$i20 + 9 | 0) >>> 0 < 19) {
      $$lcssa38 = $62;
      $i$04$i19$lcssa = $i$04$i19;
      break;
     } else $i$04$i19 = $62;
    }
    if (($i$04$i19$lcssa | 0) > -2) {
     $i$0$lcssa8$i17 = $$lcssa38;
     label = 18;
    } else $i$0$lcssa7$i25 = $$lcssa38;
   }
   if ((label | 0) == 18) {
    $i$11$i23 = $i$0$lcssa8$i17;
    while (1) {
     HEAP8[$buf + ($i$0$lcssa8$i17 - $i$11$i23) >> 0] = HEAP8[$buf$i + $i$11$i23 >> 0] | 0;
     if (($i$11$i23 | 0) > 0) $i$11$i23 = $i$11$i23 + -1 | 0; else {
      $i$0$lcssa7$i25 = $i$0$lcssa8$i17;
      break;
     }
    }
   }
   HEAP8[$buf + ($i$0$lcssa7$i25 + 1) >> 0] = 0;
   $76 = $doc + 6844 | 0;
   HEAP32[$76 >> 2] = HEAP32[$76 >> 2] | 64;
   break;
  }
 default:
  {}
 }
 if (!$3) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$vararg_buffer4 >> 2] = $2;
 HEAP32[$vararg_buffer4 + 4 >> 2] = $buf;
 _messageLexer($doc, 0, $code, $3, $vararg_buffer4);
 STACKTOP = sp;
 return;
}

function _CreateProps($doc, $prop, $style) {
 $doc = $doc | 0;
 $prop = $prop | 0;
 $style = $style | 0;
 var $$0$i = 0, $$015 = 0, $$016$i = 0, $$016$i$lcssa83 = 0, $$1 = 0, $$lcssa = 0, $$lcssa76 = 0, $$lcssa78 = 0, $$pr57 = 0, $$pre = 0, $0 = 0, $13 = 0, $16 = 0, $17 = 0, $2 = 0, $20 = 0, $23 = 0, $26 = 0, $3 = 0, $36 = 0, $38 = 0, $41 = 0, $5 = 0, $53 = 0, $8 = 0, $more$0 = 0, $name$014 = 0, $name$014$pn = 0, $name$1$lcssa = 0, $name_end$058 = 0, $name_end$058$lcssa = 0, $prev$0$lcssa$i = 0, $prev$07$i = 0, $prev$07$i$lcssa81 = 0, $prev$07$i$phi = 0, $value$2 = 0, $value$2$lcssa = 0, $value_end$0 = 0, $value_end$0$lcssa = 0, $value_end$080 = 0, label = 0, $name_end$058$looptemp = 0;
 $0 = $doc + 6856 | 0;
 $2 = _prvTidytmbstrdup(HEAP32[$0 >> 2] | 0, $style) | 0;
 $3 = HEAP8[$2 >> 0] | 0;
 L1 : do if (!($3 << 24 >> 24)) $$1 = $prop; else {
  $$015 = $prop;
  $5 = $3;
  $name$014 = $2;
  while (1) {
   if ($5 << 24 >> 24 == 32) {
    $name$014$pn = $name$014;
    while (1) {
     $8 = $name$014$pn + 1 | 0;
     $$pre = HEAP8[$8 >> 0] | 0;
     if ($$pre << 24 >> 24 == 32) $name$014$pn = $8; else {
      $$lcssa = $$pre;
      $name$1$lcssa = $8;
      break;
     }
    }
   } else {
    $$lcssa = $5;
    $name$1$lcssa = $name$014;
   }
   if (!($$lcssa << 24 >> 24)) {
    $$1 = $$015;
    break L1;
   } else {
    $$pr57 = $$lcssa;
    $name_end$058 = $name$1$lcssa;
   }
   while (1) {
    $name_end$058$looptemp = $name_end$058;
    $name_end$058 = $name_end$058 + 1 | 0;
    if ($$pr57 << 24 >> 24 == 58) {
     $$lcssa76 = $name_end$058;
     $name_end$058$lcssa = $name_end$058$looptemp;
     break;
    }
    $$pr57 = HEAP8[$name_end$058 >> 0] | 0;
    if (!($$pr57 << 24 >> 24)) {
     $$1 = $$015;
     break L1;
    }
   }
   $value$2 = $$lcssa76;
   while (1) {
    $13 = HEAP8[$value$2 >> 0] | 0;
    if ($13 << 24 >> 24 == 32) $value$2 = $value$2 + 1 | 0; else {
     $$lcssa78 = $13;
     $value$2$lcssa = $value$2;
     break;
    }
   }
   $16 = $$lcssa78;
   $value_end$0 = $value$2$lcssa;
   L15 : while (1) {
    switch ($16 << 24 >> 24) {
    case 0:
     {
      $value_end$0$lcssa = $value_end$0;
      label = 12;
      break L15;
      break;
     }
    case 59:
     {
      $more$0 = 1;
      $value_end$080 = $value_end$0;
      break L15;
      break;
     }
    default:
     {}
    }
    $17 = $value_end$0 + 1 | 0;
    $16 = HEAP8[$17 >> 0] | 0;
    $value_end$0 = $17;
   }
   if ((label | 0) == 12) {
    label = 0;
    $more$0 = 0;
    $value_end$080 = $value_end$0$lcssa;
   }
   HEAP8[$name_end$058$lcssa >> 0] = 0;
   HEAP8[$value_end$080 >> 0] = 0;
   L21 : do if (!$$015) {
    $prev$0$lcssa$i = 0;
    label = 20;
   } else {
    $$016$i = $$015;
    $prev$07$i = 0;
    while (1) {
     $20 = _prvTidytmbstrcmp(HEAP32[$$016$i >> 2] | 0, $name$1$lcssa) | 0;
     if (!$20) {
      $$0$i = $$015;
      break L21;
     }
     if (($20 | 0) > 0) {
      $$016$i$lcssa83 = $$016$i;
      $prev$07$i$lcssa81 = $prev$07$i;
      break;
     }
     $36 = HEAP32[$$016$i + 8 >> 2] | 0;
     if (!$36) {
      $prev$0$lcssa$i = $$016$i;
      label = 20;
      break L21;
     } else {
      $prev$07$i$phi = $$016$i;
      $$016$i = $36;
      $prev$07$i = $prev$07$i$phi;
     }
    }
    $23 = HEAP32[$0 >> 2] | 0;
    $26 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$23 >> 2] >> 2] & 31]($23, 12) | 0;
    HEAP32[$26 >> 2] = _prvTidytmbstrdup(HEAP32[$0 >> 2] | 0, $name$1$lcssa) | 0;
    HEAP32[$26 + 4 >> 2] = _prvTidytmbstrdup(HEAP32[$0 >> 2] | 0, $value$2$lcssa) | 0;
    HEAP32[$26 + 8 >> 2] = $$016$i$lcssa83;
    if (!$prev$07$i$lcssa81) {
     $$0$i = $26;
     break;
    } else {
     HEAP32[$prev$07$i$lcssa81 + 8 >> 2] = $26;
     $$0$i = $$015;
     break;
    }
   } while (0);
   do if ((label | 0) == 20) {
    label = 0;
    $38 = HEAP32[$0 >> 2] | 0;
    $41 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$38 >> 2] >> 2] & 31]($38, 12) | 0;
    HEAP32[$41 >> 2] = _prvTidytmbstrdup(HEAP32[$0 >> 2] | 0, $name$1$lcssa) | 0;
    HEAP32[$41 + 4 >> 2] = _prvTidytmbstrdup(HEAP32[$0 >> 2] | 0, $value$2$lcssa) | 0;
    HEAP32[$41 + 8 >> 2] = 0;
    if (!$prev$0$lcssa$i) {
     $$0$i = $41;
     break;
    } else {
     HEAP32[$prev$0$lcssa$i + 8 >> 2] = $41;
     $$0$i = $$015;
     break;
    }
   } while (0);
   HEAP8[$name_end$058$lcssa >> 0] = 58;
   if (!$more$0) {
    $$1 = $$0$i;
    break L1;
   }
   HEAP8[$value_end$080 >> 0] = 59;
   $name$014 = $value_end$080 + 1 | 0;
   $5 = HEAP8[$name$014 >> 0] | 0;
   if (!($5 << 24 >> 24)) {
    $$1 = $$0$i;
    break;
   } else $$015 = $$0$i;
  }
 } while (0);
 $53 = HEAP32[$0 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$53 >> 2] | 0) + 8 >> 2] & 15]($53, $2);
 return $$1 | 0;
}

function _prvTidyHTMLVersion($doc) {
 $doc = $doc | 0;
 var $$0 = 0, $1 = 0, $17 = 0, $19 = 0, $20 = 0, $24 = 0, $25 = 0, $3 = 0, $38 = 0, $5 = 0, $53 = 0, $63 = 0, $7 = 0, $75 = 0, $i$015 = 0, $i$015$us = 0, $i$015$us$us = 0, $i$015$us17 = 0, $j$0$lcssa = 0, $j$014 = 0, $j$014$us = 0, $j$014$us$us = 0, $j$014$us18 = 0, $j$1 = 0, $j$1$us = 0, $j$1$us$us = 0, $j$1$us26 = 0, $or$cond9 = 0, $or$cond9$us = 0, $or$cond9$us$us = 0, $or$cond9$us21 = 0, $score$0$lcssa = 0, $score$013 = 0, $score$013$us = 0, $score$013$us$us = 0, $score$013$us19 = 0, $score$1 = 0, $score$1$us = 0, $score$1$us$us = 0, $score$1$us25 = 0, label = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $3 = HEAP32[$1 + 32 >> 2] | 0;
 $5 = HEAP32[$1 + 36 >> 2] | 0;
 $7 = HEAP32[$doc + 104 >> 2] | 0;
 if (!(HEAP32[$doc + 172 >> 2] | 0)) if (!(HEAP32[$1 + 28 >> 2] | 0)) $25 = 0; else label = 3; else label = 3;
 if ((label | 0) == 3) $25 = (HEAP32[$doc + 180 >> 2] | 0) == 0;
 $17 = ($7 + -3 | 0) >>> 0 < 2;
 $19 = ($5 & 8188 | 0) != 0;
 $20 = $19 | $17;
 $24 = ($5 | 0) == 0;
 if ($24) {
  $$0 = $24 & $25 ? 262144 : 131072;
  return $$0 | 0;
 }
 if (($5 | 0) == 393216 & ($25 ^ 1)) {
  $$0 = 131072;
  return $$0 | 0;
 }
 if (($3 & 393216 | 0) == 262144 & (($7 | 2 | 0) == 2 & (($19 | $17) ^ 1) & $25)) {
  $$0 = 262144;
  return $$0 | 0;
 }
 L15 : do if ($25) if ($20) {
  $i$015$us = 0;
  $j$014$us = 0;
  $score$013$us = 0;
  while (1) {
   if ((389120 >>> $i$015$us & 1 | 0) != 0 & ($i$015$us + -6 | 0) >>> 0 < 11) if (!(HEAP32[63656 + ($i$015$us * 20 | 0) + 4 >> 2] & $3)) {
    $j$1$us = $j$014$us;
    $score$1$us = $score$013$us;
   } else {
    $53 = HEAP32[63656 + ($i$015$us * 20 | 0) >> 2] | 0;
    $or$cond9$us = ($score$013$us | 0) != 0 & $53 >>> 0 >= $score$013$us >>> 0;
    $j$1$us = $or$cond9$us ? $j$014$us : $i$015$us;
    $score$1$us = $or$cond9$us ? $score$013$us : $53;
   } else {
    $j$1$us = $j$014$us;
    $score$1$us = $score$013$us;
   }
   $i$015$us = $i$015$us + 1 | 0;
   if (($i$015$us | 0) == 19) {
    $j$0$lcssa = $j$1$us;
    $score$0$lcssa = $score$1$us;
    break;
   } else {
    $j$014$us = $j$1$us;
    $score$013$us = $score$1$us;
   }
  }
 } else {
  $i$015$us$us = 0;
  $j$014$us$us = 0;
  $score$013$us$us = 0;
  while (1) {
   if (!(389120 >>> $i$015$us$us & 1)) {
    $j$1$us$us = $j$014$us$us;
    $score$1$us$us = $score$013$us$us;
   } else if (!(HEAP32[63656 + ($i$015$us$us * 20 | 0) + 4 >> 2] & $3)) {
    $j$1$us$us = $j$014$us$us;
    $score$1$us$us = $score$013$us$us;
   } else {
    $38 = HEAP32[63656 + ($i$015$us$us * 20 | 0) >> 2] | 0;
    $or$cond9$us$us = ($score$013$us$us | 0) != 0 & $38 >>> 0 >= $score$013$us$us >>> 0;
    $j$1$us$us = $or$cond9$us$us ? $j$014$us$us : $i$015$us$us;
    $score$1$us$us = $or$cond9$us$us ? $score$013$us$us : $38;
   }
   $i$015$us$us = $i$015$us$us + 1 | 0;
   if (($i$015$us$us | 0) == 19) {
    $j$0$lcssa = $j$1$us$us;
    $score$0$lcssa = $score$1$us$us;
    break;
   } else {
    $j$014$us$us = $j$1$us$us;
    $score$013$us$us = $score$1$us$us;
   }
  }
 } else {
  if ($20) {
   $i$015 = 0;
   $j$014 = 0;
   $score$013 = 0;
  } else {
   $i$015$us17 = 0;
   $j$014$us18 = 0;
   $score$013$us19 = 0;
   while (1) {
    if (!(HEAP32[63656 + ($i$015$us17 * 20 | 0) + 4 >> 2] & $3)) {
     $j$1$us26 = $j$014$us18;
     $score$1$us25 = $score$013$us19;
    } else {
     $63 = HEAP32[63656 + ($i$015$us17 * 20 | 0) >> 2] | 0;
     $or$cond9$us21 = ($score$013$us19 | 0) != 0 & $63 >>> 0 >= $score$013$us19 >>> 0;
     $j$1$us26 = $or$cond9$us21 ? $j$014$us18 : $i$015$us17;
     $score$1$us25 = $or$cond9$us21 ? $score$013$us19 : $63;
    }
    $i$015$us17 = $i$015$us17 + 1 | 0;
    if (($i$015$us17 | 0) == 19) {
     $j$0$lcssa = $j$1$us26;
     $score$0$lcssa = $score$1$us25;
     break L15;
    } else {
     $j$014$us18 = $j$1$us26;
     $score$013$us19 = $score$1$us25;
    }
   }
  }
  while (1) {
   if (($i$015 + -6 | 0) >>> 0 < 11) if (!(HEAP32[63656 + ($i$015 * 20 | 0) + 4 >> 2] & $3)) {
    $j$1 = $j$014;
    $score$1 = $score$013;
   } else {
    $75 = HEAP32[63656 + ($i$015 * 20 | 0) >> 2] | 0;
    $or$cond9 = ($score$013 | 0) != 0 & $75 >>> 0 >= $score$013 >>> 0;
    $j$1 = $or$cond9 ? $j$014 : $i$015;
    $score$1 = $or$cond9 ? $score$013 : $75;
   } else {
    $j$1 = $j$014;
    $score$1 = $score$013;
   }
   $i$015 = $i$015 + 1 | 0;
   if (($i$015 | 0) == 19) {
    $j$0$lcssa = $j$1;
    $score$0$lcssa = $score$1;
    break;
   } else {
    $j$014 = $j$1;
    $score$013 = $score$1;
   }
  }
 } while (0);
 if (!$score$0$lcssa) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = HEAP32[63656 + ($j$0$lcssa * 20 | 0) + 4 >> 2] | 0;
 return $$0 | 0;
}

function _prvTidyCheckHTML5($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$030 = 0, $1 = 0, $11 = 0, $18 = 0, $20 = 0, $22 = 0, $23 = 0, $28 = 0, $3 = 0, $36 = 0, $4 = 0, $41 = 0, $43 = 0, $45 = 0, $47 = 0, $49 = 0, $6 = 0, $7 = 0, $av$01$i = 0, $av$02$i = 0;
 $1 = HEAP32[$doc + 200 >> 2] | 0;
 $3 = HEAP32[$doc + 456 >> 2] | 0;
 $4 = _prvTidyFindBody($doc) | 0;
 if (!$node) return;
 $6 = ($3 | 0) != 0;
 $7 = ($1 | 0) == 0;
 $$030 = $node;
 do {
  $av$01$i = HEAP32[$$030 + 20 >> 2] | 0;
  L6 : do if (!$av$01$i) $49 = $6; else {
   $av$02$i = $av$01$i;
   while (1) {
    $11 = HEAP32[$av$02$i + 4 >> 2] | 0;
    if ($11 | 0) if ((HEAP32[$11 >> 2] | 0) == 7) break;
    $av$02$i = HEAP32[$av$02$i >> 2] | 0;
    if (!$av$02$i) {
     $49 = $6;
     break L6;
    }
   }
   if ($6) $49 = 1; else {
    _prvTidyReportAttrError($doc, $$030, _prvTidyAttrGetById($$030, 7) | 0, 704);
    $49 = 0;
   }
  } while (0);
  L15 : do if (($$030 | 0) == ($4 | 0)) {
   if (!$49) {
    $18 = _prvTidyAttrGetById($4, 13) | 0;
    if ($18 | 0) _prvTidyReportAttrError($doc, $4, $18, 704);
    $20 = _prvTidyAttrGetById($4, 14) | 0;
    if ($20 | 0) _prvTidyReportAttrError($doc, $4, $20, 704);
    $41 = _prvTidyAttrGetById($4, 147) | 0;
    if ($41 | 0) _prvTidyReportAttrError($doc, $4, $41, 704);
    $43 = _prvTidyAttrGetById($4, 76) | 0;
    if ($43 | 0) _prvTidyReportAttrError($doc, $4, $43, 704);
    $45 = _prvTidyAttrGetById($4, 157) | 0;
    if ($45 | 0) _prvTidyReportAttrError($doc, $4, $45, 704);
    $47 = _prvTidyAttrGetById($4, 8) | 0;
    if ($47 | 0) _prvTidyReportAttrError($doc, $4, $47, 704);
   }
  } else {
   $22 = $$030 + 28 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   L35 : do if ($23 | 0) do switch (HEAP32[$23 >> 2] | 0) {
   case 3:
    {
     if (!$7) {
      _prvTidyCoerceNode($doc, $$030, 2, 1, 0);
      break L15;
     }
     if ($49) break L15;
     _prvTidyReportWarning($doc, $$030, $$030, 288);
     break L15;
     break;
    }
   case 6:
    {
     if (!$7) {
      _prvTidyCoerceNode($doc, $$030, 76, 1, 0);
      break L15;
     }
     if ($49) break L15;
     _prvTidyReportWarning($doc, $$030, $$030, 288);
     break L15;
     break;
    }
   case 10:
    {
     if ($49) break L15;
     _prvTidyReportWarning($doc, $$030, $$030, 288);
     break L15;
     break;
    }
   case 13:
    {
     if (!$7) {
      _prvTidyAddStyleProperty($doc, $$030, 226663);
      _prvTidyCoerceNode($doc, $$030, 100, 1, 0);
      break L15;
     }
     if ($49) break L15;
     _prvTidyReportWarning($doc, $$030, $$030, 288);
     break L15;
     break;
    }
   case 20:
    {
     if ($49) break L15;
     _prvTidyReportWarning($doc, $$030, $$030, 288);
     break L15;
     break;
    }
   case 29:
    {
     if ($49) break L15;
     _prvTidyReportWarning($doc, $$030, $$030, 288);
     break L15;
     break;
    }
   case 36:
    {
     if ($49) break L15;
     _prvTidyReportWarning($doc, $$030, $$030, 288);
     break L15;
     break;
    }
   case 72:
   case 39:
   case 38:
    {
     if ($49) break L15;
     _prvTidyReportWarning($doc, $$030, $$030, 288);
     break L15;
     break;
    }
   case 101:
    {
     if (!$7) {
      _prvTidyAddStyleProperty($doc, $$030, 311068);
      _prvTidyCoerceNode($doc, $$030, 100, 1, 0);
      break L15;
     }
     if ($49) break L15;
     _prvTidyReportWarning($doc, $$030, $$030, 288);
     break L15;
     break;
    }
   case 116:
    {
     if (!$7) {
      _prvTidyAddStyleProperty($doc, $$030, 226681);
      _prvTidyCoerceNode($doc, $$030, 100, 1, 0);
      break L15;
     }
     if ($49) break L15;
     _prvTidyReportWarning($doc, $$030, $$030, 288);
     break L15;
     break;
    }
   default:
    break L35;
   } while (0); while (0);
   if (_prvTidynodeIsElement($$030) | 0) {
    $28 = HEAP32[$22 >> 2] | 0;
    if ($28 | 0) {
     if (!(HEAP32[$28 + 8 >> 2] & 450560)) {
      if ($49) break;
     } else {
      switch (HEAP32[$28 >> 2] | 0) {
      case 116:
      case 101:
      case 72:
      case 39:
      case 38:
      case 36:
      case 29:
      case 20:
      case 13:
      case 10:
      case 6:
      case 3:
       break;
      default:
       break L15;
      }
      if ($49) break;
     }
     _prvTidyReportWarning($doc, $$030, $$030, 288);
    }
   }
  } while (0);
  $36 = HEAP32[$$030 + 12 >> 2] | 0;
  if ($36 | 0) _prvTidyCheckHTML5($doc, $36);
  $$030 = HEAP32[$$030 + 8 >> 2] | 0;
 } while (($$030 | 0) != 0);
 return;
}

function _trinkle($head, $width, $cmp, $pp, $pshift, $trusty, $lp) {
 $head = $head | 0;
 $width = $width | 0;
 $cmp = $cmp | 0;
 $pp = $pp | 0;
 $pshift = $pshift | 0;
 $trusty = $trusty | 0;
 $lp = $lp | 0;
 var $$0$i = 0, $$0$lcssa = 0, $$0$lcssa32 = 0, $$01$i5$i$ph = 0, $$01245 = 0, $$01245$phi = 0, $$02$i$i = 0, $$02$i3$i = 0, $$02$lcssa = 0, $$02$lcssa34 = 0, $$021047 = 0, $$03$lcssa = 0, $$03948 = 0, $0 = 0, $10 = 0, $14 = 0, $17 = 0, $18 = 0, $2 = 0, $25 = 0, $27 = 0, $3 = 0, $31 = 0, $38 = 0, $43 = 0, $46 = 0, $48 = 0, $51 = 0, $54 = 0, $55 = 0, $62 = 0, $ar = 0, $i$0$lcssa = 0, $i$0$lcssa33 = 0, $i$01146 = 0, $nTrailingZeros$03$i$i = 0, $nTrailingZeros$03$i2$i = 0, $p$sroa$0$0849 = 0, $p$sroa$8$0650 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 240 | 0;
 $ar = sp;
 $0 = HEAP32[$pp >> 2] | 0;
 $2 = HEAP32[$pp + 4 >> 2] | 0;
 HEAP32[$ar >> 2] = $head;
 $3 = 0 - $width | 0;
 L1 : do if (($2 | 0) != 0 | ($0 | 0) != 1) {
  $10 = $head + (0 - (HEAP32[$lp + ($pshift << 2) >> 2] | 0)) | 0;
  if ((FUNCTION_TABLE_iii[$cmp & 31]($10, $head) | 0) < 1) {
   $$0$lcssa = $head;
   $$02$lcssa = $pshift;
   $$03$lcssa = $trusty;
   $i$0$lcssa = 1;
   label = 18;
  } else {
   $$01245 = $head;
   $$021047 = $pshift;
   $$03948 = ($trusty | 0) == 0;
   $18 = $10;
   $i$01146 = 1;
   $p$sroa$0$0849 = $0;
   $p$sroa$8$0650 = $2;
   while (1) {
    if ($$03948 & ($$021047 | 0) > 1) {
     $14 = $$01245 + $3 | 0;
     $17 = HEAP32[$lp + ($$021047 + -2 << 2) >> 2] | 0;
     if ((FUNCTION_TABLE_iii[$cmp & 31]($14, $18) | 0) > -1) {
      $$0$lcssa32 = $$01245;
      $$02$lcssa34 = $$021047;
      $i$0$lcssa33 = $i$01146;
      label = 19;
      break L1;
     }
     if ((FUNCTION_TABLE_iii[$cmp & 31]($14 + (0 - $17) | 0, $18) | 0) > -1) {
      $$0$lcssa32 = $$01245;
      $$02$lcssa34 = $$021047;
      $i$0$lcssa33 = $i$01146;
      label = 19;
      break L1;
     }
    }
    $25 = $i$01146 + 1 | 0;
    HEAP32[$ar + ($i$01146 << 2) >> 2] = $18;
    $27 = $p$sroa$0$0849 + -1 | 0;
    do if (!$27) {
     $46 = 32;
     label = 15;
    } else {
     if (!($27 & 1)) {
      $$02$i$i = $27;
      $nTrailingZeros$03$i$i = 0;
      while (1) {
       $31 = $nTrailingZeros$03$i$i + 1 | 0;
       $$02$i$i = $$02$i$i >>> 1;
       if ($$02$i$i & 1 | 0) {
        $43 = $31;
        break;
       } else $nTrailingZeros$03$i$i = $31;
      }
     } else {
      if (!$p$sroa$8$0650) $$01$i5$i$ph = 32; else {
       if (!($p$sroa$8$0650 & 1)) {
        $$02$i3$i = $p$sroa$8$0650;
        $nTrailingZeros$03$i2$i = 0;
       } else {
        $$0$i = 0;
        $48 = $p$sroa$0$0849;
        $51 = $p$sroa$8$0650;
        $55 = 0;
        break;
       }
       while (1) {
        $38 = $nTrailingZeros$03$i2$i + 1 | 0;
        $$02$i3$i = $$02$i3$i >>> 1;
        if ($$02$i3$i & 1 | 0) {
         $$01$i5$i$ph = $38;
         break;
        } else $nTrailingZeros$03$i2$i = $38;
       }
      }
      $43 = $$01$i5$i$ph + 32 | 0;
     }
     if ($43 >>> 0 > 31) {
      $46 = $43;
      label = 15;
     } else {
      $$0$i = $43;
      $48 = $p$sroa$0$0849;
      $51 = $p$sroa$8$0650;
      $55 = $43;
     }
    } while (0);
    if ((label | 0) == 15) {
     label = 0;
     $$0$i = $46 + -32 | 0;
     $48 = $p$sroa$8$0650;
     $51 = 0;
     $55 = $46;
    }
    $p$sroa$0$0849 = $51 << 32 - $$0$i | $48 >>> $$0$i;
    $p$sroa$8$0650 = $51 >>> $$0$i;
    $54 = $55 + $$021047 | 0;
    if (!(($p$sroa$8$0650 | 0) != 0 | ($p$sroa$0$0849 | 0) != 1)) {
     $$0$lcssa32 = $18;
     $$02$lcssa34 = $54;
     $i$0$lcssa33 = $25;
     label = 19;
     break L1;
    }
    $62 = $18 + (0 - (HEAP32[$lp + ($54 << 2) >> 2] | 0)) | 0;
    if ((FUNCTION_TABLE_iii[$cmp & 31]($62, HEAP32[$ar >> 2] | 0) | 0) < 1) {
     $$0$lcssa = $18;
     $$02$lcssa = $54;
     $$03$lcssa = 0;
     $i$0$lcssa = $25;
     label = 18;
     break;
    } else {
     $$01245$phi = $18;
     $$021047 = $54;
     $$03948 = 1;
     $18 = $62;
     $i$01146 = $25;
     $$01245 = $$01245$phi;
    }
   }
  }
 } else {
  $$0$lcssa = $head;
  $$02$lcssa = $pshift;
  $$03$lcssa = $trusty;
  $i$0$lcssa = 1;
  label = 18;
 } while (0);
 if ((label | 0) == 18) if (!$$03$lcssa) {
  $$0$lcssa32 = $$0$lcssa;
  $$02$lcssa34 = $$02$lcssa;
  $i$0$lcssa33 = $i$0$lcssa;
  label = 19;
 }
 if ((label | 0) == 19) {
  _cycle($width, $ar, $i$0$lcssa33);
  _sift($$0$lcssa32, $width, $cmp, $$02$lcssa34, $lp);
 }
 STACKTOP = sp;
 return;
}

function _WrapLine($doc) {
 $doc = $doc | 0;
 var $$idx$val$i = 0, $$idx1$val = 0, $$idx2 = 0, $$idx2$val = 0, $$idx3$val$i = 0, $$idx5$val$i = 0, $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $12 = 0, $14 = 0, $16 = 0, $17 = 0, $18 = 0, $27 = 0, $3 = 0, $32 = 0, $35 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $43 = 0, $44 = 0, $45 = 0, $51 = 0, $52 = 0, $53 = 0, $60 = 0, $61 = 0, $62 = 0, $65 = 0, $66 = 0, $69 = 0, $71 = 0, $74 = 0, $75 = 0, $79 = 0, $82 = 0, $9 = 0, $i$08 = 0, $i$17 = 0, $p$03$i = 0, $pprint$idx1$val$i = 0, $q$04$i = 0, $q$1$ph$i = 0, $q$12$i = 0, $storemerge$i = 0, $wantIt$0$i = 0, label = 0;
 $0 = $doc + 6740 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) return;
 $$idx$val$i = HEAP32[$doc + 6752 >> 2] | 0;
 $3 = ($$idx$val$i | 0) > 0;
 $4 = $3 & 1;
 if ($3) {
  $$idx3$val$i = HEAP32[$doc + 6756 >> 2] | 0;
  if (!$$idx3$val$i) $9 = 0; else $9 = ($$idx3$val$i | 0) < 1 | ($$idx3$val$i | 0) >= ($1 | 0);
  if ((HEAP32[$doc + 284 >> 2] | 0) != 0 | $9) {
   $$idx5$val$i = HEAP32[$doc + 6760 >> 2] | 0;
   if (!$$idx5$val$i) $12 = 0; else $12 = ($$idx5$val$i | 0) < 1 | ($$idx5$val$i | 0) >= ($1 | 0);
  } else $12 = 0;
  $wantIt$0$i = $12 & 1;
 } else $wantIt$0$i = $4;
 if (($wantIt$0$i | 0) == 0 | $3 ^ 1) $14 = $1; else {
  $18 = $doc + 6780 | 0;
  $i$08 = 0;
  do {
   _prvTidyWriteChar(HEAP32[16017] | 0, HEAP32[$18 >> 2] | 0);
   $i$08 = $i$08 + 1 | 0;
  } while (($i$08 | 0) != ($$idx$val$i | 0));
  $14 = HEAP32[$0 >> 2] | 0;
 }
 if (!$14) $$idx1$val = 0; else {
  $16 = $doc + 6728 | 0;
  $17 = $doc + 6780 | 0;
  $i$17 = 0;
  do {
   _prvTidyWriteChar(HEAP32[(HEAP32[$16 >> 2] | 0) + ($i$17 << 2) >> 2] | 0, HEAP32[$17 >> 2] | 0);
   $i$17 = $i$17 + 1 | 0;
   $27 = HEAP32[$0 >> 2] | 0;
  } while ($i$17 >>> 0 < $27 >>> 0);
  $$idx1$val = $27;
 }
 $$idx2 = $doc + 6760 | 0;
 $$idx2$val = HEAP32[$$idx2 >> 2] | 0;
 if (!$$idx2$val) label = 19; else if (($$idx2$val | 0) > 0 & ($$idx2$val | 0) < ($$idx1$val | 0)) label = 19; else $$pre$phiZ2D = $doc + 6780 | 0;
 if ((label | 0) == 19) {
  $32 = $doc + 6780 | 0;
  _prvTidyWriteChar(92, HEAP32[$32 >> 2] | 0);
  $$pre$phiZ2D = $32;
 }
 _prvTidyWriteChar(10, HEAP32[$$pre$phiZ2D >> 2] | 0);
 $35 = $doc + 6744 | 0;
 HEAP32[$35 >> 2] = (HEAP32[$35 >> 2] | 0) + 1;
 $38 = $doc + 6736 | 0;
 $39 = HEAP32[$38 >> 2] | 0;
 $40 = HEAP32[$0 >> 2] | 0;
 if ($39 >>> 0 > $40 >>> 0) {
  $43 = HEAP32[$doc + 6728 >> 2] | 0;
  $44 = $43 + ($40 << 2) | 0;
  $45 = $43 + ($39 << 2) | 0;
  $pprint$idx1$val$i = HEAP32[$doc + 6756 >> 2] | 0;
  L33 : do if (!$pprint$idx1$val$i) {
   $82 = $40;
   $q$1$ph$i = $44;
  } else if (($40 | 0) < ($39 | 0) & (($pprint$idx1$val$i | 0) >= ($40 | 0) | ($pprint$idx1$val$i | 0) < 1)) {
   $53 = $40;
   $q$04$i = $44;
   while (1) {
    if ((HEAP32[$q$04$i >> 2] | 0) != 32) {
     $82 = $53;
     $q$1$ph$i = $q$04$i;
     break L33;
    }
    $51 = $q$04$i + 4 | 0;
    $52 = $53 + 1 | 0;
    HEAP32[$0 >> 2] = $52;
    if ($51 >>> 0 < $45 >>> 0) {
     $53 = $52;
     $q$04$i = $51;
    } else {
     $82 = $52;
     $q$1$ph$i = $51;
     break;
    }
   }
  } else {
   $82 = $40;
   $q$1$ph$i = $44;
  } while (0);
  if ($q$1$ph$i >>> 0 < $45 >>> 0) {
   $p$03$i = $43;
   $q$12$i = $q$1$ph$i;
   while (1) {
    HEAP32[$p$03$i >> 2] = HEAP32[$q$12$i >> 2];
    $q$12$i = $q$12$i + 4 | 0;
    if ($q$12$i >>> 0 >= $45 >>> 0) break; else $p$03$i = $p$03$i + 4 | 0;
   }
   $60 = HEAP32[$0 >> 2] | 0;
   $61 = HEAP32[$38 >> 2] | 0;
  } else {
   $60 = $82;
   $61 = $39;
  }
  $69 = $60;
  $storemerge$i = $61 - $60 | 0;
 } else {
  $69 = $40;
  $storemerge$i = 0;
 }
 HEAP32[$38 >> 2] = $storemerge$i;
 $62 = $doc + 6748 | 0;
 if (HEAP32[$62 >> 2] | 0) {
  $65 = $doc + 6752 | 0;
  $66 = $doc + 6764 | 0;
  HEAP32[$65 >> 2] = HEAP32[$66 >> 2];
  HEAP32[$65 + 4 >> 2] = HEAP32[$66 + 4 >> 2];
  HEAP32[$65 + 8 >> 2] = HEAP32[$66 + 8 >> 2];
  HEAP32[$66 >> 2] = -1;
  HEAP32[$doc + 6768 >> 2] = -1;
  HEAP32[$doc + 6772 >> 2] = -1;
 }
 $71 = HEAP32[$$idx2 >> 2] | 0;
 if (!$69) {
  if (($71 | 0) > 0) HEAP32[$$idx2 >> 2] = 0;
  $79 = $doc + 6756 | 0;
  if ((HEAP32[$79 >> 2] | 0) > 0) HEAP32[$79 >> 2] = 0;
 } else {
  if (($71 | 0) > ($69 | 0)) HEAP32[$$idx2 >> 2] = $71 - $69;
  $74 = $doc + 6756 | 0;
  $75 = HEAP32[$74 >> 2] | 0;
  if (($75 | 0) > ($69 | 0)) HEAP32[$74 >> 2] = $75 - $69;
 }
 HEAP32[$62 >> 2] = 0;
 HEAP32[$0 >> 2] = 0;
 return;
}

function _prvTidyReportAttrError($doc, $node, $av, $code) {
 $doc = $doc | 0;
 $node = $node | 0;
 $av = $av | 0;
 $code = $code | 0;
 var $0 = 0, $10 = 0, $12 = 0, $16 = 0, $17 = 0, $21 = 0, $23 = 0, $27 = 0, $28 = 0, $31 = 0, $35 = 0, $39 = 0, $4 = 0, $7 = 0, $extra_string$0 = 0, $extra_string$1 = 0, $name$1 = 0, $tagdesc = 0, $value$0 = 0, $vararg_buffer = 0, $vararg_buffer12 = 0, $vararg_buffer17 = 0, $vararg_buffer2 = 0, $vararg_buffer20 = 0, $vararg_buffer24 = 0, $vararg_buffer27 = 0, $vararg_buffer32 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 $vararg_buffer32 = sp + 96 | 0;
 $vararg_buffer27 = sp + 80 | 0;
 $vararg_buffer24 = sp + 72 | 0;
 $vararg_buffer20 = sp + 64 | 0;
 $vararg_buffer17 = sp + 56 | 0;
 $vararg_buffer12 = sp + 40 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $tagdesc = sp + 104 | 0;
 $0 = _tidyLocalizedString($code) | 0;
 if (!$0) ___assert_fail(223545, 223391, 551, 223557);
 _TagToString($node, $tagdesc, 64);
 if (!$av) {
  $name$1 = 223540;
  $value$0 = 223540;
 } else {
  $4 = HEAP32[$av + 20 >> 2] | 0;
  $7 = HEAP32[$av + 24 >> 2] | 0;
  $name$1 = ($4 | 0) == 0 ? 223540 : $4;
  $value$0 = ($7 | 0) == 0 ? 223540 : $7;
 }
 do switch ($code | 0) {
 case 267:
 case 253:
 case 257:
 case 702:
 case 249:
 case 248:
  {
   HEAP32[$vararg_buffer >> 2] = $tagdesc;
   HEAP32[$vararg_buffer + 4 >> 2] = $name$1;
   _messageNode($doc, 1, $code, $node, $0, $vararg_buffer);
   STACKTOP = sp;
   return;
  }
 case 704:
  {
   $10 = HEAP32[$doc + 68 >> 2] | 0;
   $12 = HEAP32[$10 + 40 >> 2] | 0;
   if (!$12) $16 = HEAP32[$10 + 36 >> 2] | 0; else $16 = $12;
   $17 = _prvTidyHTMLVersionNameFromCode($16, 0) | 0;
   if (!$17) $extra_string$0 = _tidyLocalizedString(2059) | 0; else $extra_string$0 = $17;
   HEAP32[$vararg_buffer2 >> 2] = $tagdesc;
   HEAP32[$vararg_buffer2 + 4 >> 2] = $name$1;
   HEAP32[$vararg_buffer2 + 8 >> 2] = $extra_string$0;
   _messageNode($doc, 1, 704, $node, $0, $vararg_buffer2);
   STACKTOP = sp;
   return;
  }
 case 703:
  {
   $21 = HEAP32[$doc + 68 >> 2] | 0;
   $23 = HEAP32[$21 + 40 >> 2] | 0;
   if (!$23) $27 = HEAP32[$21 + 36 >> 2] | 0; else $27 = $23;
   $28 = _prvTidyHTMLVersionNameFromCode($27, 0) | 0;
   if (!$28) $extra_string$1 = _tidyLocalizedString(2059) | 0; else $extra_string$1 = $28;
   HEAP32[$vararg_buffer7 >> 2] = $tagdesc;
   HEAP32[$vararg_buffer7 + 4 >> 2] = $name$1;
   HEAP32[$vararg_buffer7 + 8 >> 2] = $extra_string$1;
   _messageNode($doc, 4, 703, $node, $0, $vararg_buffer7);
   STACKTOP = sp;
   return;
  }
 case 250:
 case 271:
 case 272:
 case 251:
  {
   HEAP32[$vararg_buffer12 >> 2] = $tagdesc;
   HEAP32[$vararg_buffer12 + 4 >> 2] = $name$1;
   HEAP32[$vararg_buffer12 + 8 >> 2] = $value$0;
   _messageNode($doc, 1, $code, $node, $0, $vararg_buffer12);
   STACKTOP = sp;
   return;
  }
 case 268:
 case 273:
 case 252:
 case 287:
 case 265:
 case 264:
 case 263:
 case 262:
 case 261:
 case 260:
 case 259:
 case 258:
  {
   HEAP32[$vararg_buffer17 >> 2] = $tagdesc;
   _messageNode($doc, 1, $code, $node, $0, $vararg_buffer17);
   STACKTOP = sp;
   return;
  }
 case 269:
 case 266:
 case 254:
 case 270:
  {
   HEAP32[$vararg_buffer20 >> 2] = $tagdesc;
   HEAP32[$vararg_buffer20 + 4 >> 2] = $value$0;
   _messageNode($doc, 1, $code, $node, $0, $vararg_buffer20);
   STACKTOP = sp;
   return;
  }
 case 256:
  {
   HEAP32[$vararg_buffer24 >> 2] = $tagdesc;
   _messageNode($doc, 1, 256, $node, $0, $vararg_buffer24);
   $31 = $doc + 6836 | 0;
   HEAP32[$31 >> 2] = HEAP32[$31 >> 2] | 8;
   STACKTOP = sp;
   return;
  }
 case 255:
  {
   HEAP32[$vararg_buffer27 >> 2] = $tagdesc;
   HEAP32[$vararg_buffer27 + 4 >> 2] = $value$0;
   HEAP32[$vararg_buffer27 + 8 >> 2] = $name$1;
   _messageNode($doc, 1, 255, $node, $0, $vararg_buffer27);
   STACKTOP = sp;
   return;
  }
 case 274:
  {
   $35 = HEAP32[$doc + 6776 >> 2] | 0;
   $39 = HEAP32[$doc + 68 >> 2] | 0;
   HEAP32[$39 >> 2] = HEAP32[$35 + 292 >> 2];
   HEAP32[$39 + 4 >> 2] = HEAP32[$35 + 288 >> 2];
   HEAP32[$vararg_buffer32 >> 2] = $tagdesc;
   _messageLexer($doc, 0, 274, $0, $vararg_buffer32);
   STACKTOP = sp;
   return;
  }
 default:
  {
   STACKTOP = sp;
   return;
  }
 } while (0);
}

function _MergeStyles($doc, $node, $child) {
 $doc = $doc | 0;
 $node = $node | 0;
 $child = $child | 0;
 var $$01$i$i = 0, $$pre = 0, $0 = 0, $10 = 0, $14 = 0, $19 = 0, $20 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $3 = 0, $31 = 0, $32 = 0, $34 = 0, $42 = 0, $52 = 0, $57 = 0, $58 = 0, $60 = 0, $62 = 0, $63 = 0, $67 = 0, $72 = 0, $78 = 0, $83 = 0, $av$05$i = 0, $av$06$i = 0, $av$06$i$lcssa = 0, $av$07 = 0, $av$08 = 0, $av$08$lcssa = 0, $av$13$i = 0, $av$14$i = 0, $av$14$i$lcssa = 0, $av$15 = 0, $av$16 = 0, $av$16$lcssa = 0, $s2$0 = 0, $s2$0$i = 0, label = 0, $$01$i$i$looptemp = 0;
 $0 = $child + 20 | 0;
 $av$05$i = HEAP32[$0 >> 2] | 0;
 L1 : do if (!$av$05$i) $s2$0$i = 0; else {
  $av$06$i = $av$05$i;
  while (1) {
   $3 = HEAP32[$av$06$i + 4 >> 2] | 0;
   if ($3 | 0) if ((HEAP32[$3 >> 2] | 0) == 26) {
    $av$06$i$lcssa = $av$06$i;
    break;
   }
   $av$06$i = HEAP32[$av$06$i >> 2] | 0;
   if (!$av$06$i) {
    $s2$0$i = 0;
    break L1;
   }
  }
  $s2$0$i = HEAP32[$av$06$i$lcssa + 24 >> 2] | 0;
 } while (0);
 $10 = $node + 20 | 0;
 $av$13$i = HEAP32[$10 >> 2] | 0;
 L9 : do if (!$av$13$i) label = 7; else {
  $av$14$i = $av$13$i;
  while (1) {
   $14 = HEAP32[$av$14$i + 4 >> 2] | 0;
   if ($14 | 0) if ((HEAP32[$14 >> 2] | 0) == 26) {
    $av$14$i$lcssa = $av$14$i;
    break;
   }
   $av$14$i = HEAP32[$av$14$i >> 2] | 0;
   if (!$av$14$i) {
    label = 7;
    break L9;
   }
  }
  $19 = $av$14$i$lcssa + 24 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $22 = ($s2$0$i | 0) != 0;
  if (!$20) if ($22) {
   label = 15;
   break;
  } else break;
  if ($22) {
   $23 = _prvTidytmbstrlen($20) | 0;
   $24 = _prvTidytmbstrlen($s2$0$i) | 0;
   $25 = $doc + 6856 | 0;
   $26 = HEAP32[$25 >> 2] | 0;
   $31 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$26 >> 2] >> 2] & 31]($26, $23 + 2 + $24 | 0) | 0;
   _prvTidytmbstrcpy($31, $20) | 0;
   $32 = $31 + $23 | 0;
   HEAP8[$32 >> 0] = 32;
   _prvTidytmbstrcpy($32 + 1 | 0, $s2$0$i) | 0;
   $34 = HEAP32[$25 >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$34 >> 2] | 0) + 8 >> 2] & 15]($34, HEAP32[$19 >> 2] | 0);
   HEAP32[$19 >> 2] = $31;
  }
 } while (0);
 if ((label | 0) == 7) if ($s2$0$i | 0) label = 15;
 if ((label | 0) == 15) _prvTidyInsertAttributeAtStart($node, _prvTidyNewAttributeEx($doc, 310945, $s2$0$i, 34) | 0);
 $av$07 = HEAP32[$0 >> 2] | 0;
 L25 : do if (!$av$07) $s2$0 = 0; else {
  $av$08 = $av$07;
  while (1) {
   $42 = HEAP32[$av$08 + 4 >> 2] | 0;
   if ($42 | 0) if ((HEAP32[$42 >> 2] | 0) == 143) {
    $av$08$lcssa = $av$08;
    break;
   }
   $av$08 = HEAP32[$av$08 >> 2] | 0;
   if (!$av$08) {
    $s2$0 = 0;
    break L25;
   }
  }
  $s2$0 = HEAP32[$av$08$lcssa + 24 >> 2] | 0;
 } while (0);
 $av$15 = HEAP32[$10 >> 2] | 0;
 L33 : do if (!$av$15) label = 22; else {
  $av$16 = $av$15;
  while (1) {
   $52 = HEAP32[$av$16 + 4 >> 2] | 0;
   if ($52 | 0) if ((HEAP32[$52 >> 2] | 0) == 143) {
    $av$16$lcssa = $av$16;
    break;
   }
   $av$16 = HEAP32[$av$16 >> 2] | 0;
   if (!$av$16) {
    label = 22;
    break L33;
   }
  }
  $57 = $av$16$lcssa + 24 | 0;
  $58 = HEAP32[$57 >> 2] | 0;
  $60 = ($s2$0 | 0) != 0;
  if (!$58) {
   if ($60) break;
   return;
  }
  if (!$60) return;
  $62 = _CreateProps($doc, _CreateProps($doc, 0, $58) | 0, $s2$0) | 0;
  $63 = _CreatePropString($doc, $62) | 0;
  $$pre = $doc + 6856 | 0;
  if ($62 | 0) {
   $$01$i$i = $62;
   do {
    $$01$i$i$looptemp = $$01$i$i;
    $$01$i$i = HEAP32[$$01$i$i + 8 >> 2] | 0;
    $67 = HEAP32[$$pre >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$67 >> 2] | 0) + 8 >> 2] & 15]($67, HEAP32[$$01$i$i$looptemp >> 2] | 0);
    $72 = HEAP32[$$pre >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$72 >> 2] | 0) + 8 >> 2] & 15]($72, HEAP32[$$01$i$i$looptemp + 4 >> 2] | 0);
    $78 = HEAP32[$$pre >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$78 >> 2] | 0) + 8 >> 2] & 15]($78, $$01$i$i$looptemp);
   } while (($$01$i$i | 0) != 0);
  }
  $83 = HEAP32[$$pre >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$83 >> 2] | 0) + 8 >> 2] & 15]($83, HEAP32[$57 >> 2] | 0);
  HEAP32[$57 >> 2] = $63;
  return;
 } while (0);
 if ((label | 0) == 22) if (!$s2$0) return;
 _prvTidyInsertAttributeAtStart($node, _prvTidyNewAttributeEx($doc, 310951, $s2$0, 34) | 0);
 return;
}

function _tagsLookup($doc, $tags, $s) {
 $doc = $doc | 0;
 $tags = $tags | 0;
 $s = $s | 0;
 var $$0 = 0, $$01$i = 0, $$01$i$i = 0, $$01$i$i2 = 0, $$lcssa = 0, $$lcssa63 = 0, $$lcssa65 = 0, $$lcssa68 = 0, $$lcssa71 = 0, $$lcssa72 = 0, $1 = 0, $14 = 0, $21 = 0, $26 = 0, $29 = 0, $30 = 0, $31 = 0, $34 = 0, $36 = 0, $4 = 0, $40 = 0, $47 = 0, $52 = 0, $55 = 0, $56 = 0, $57 = 0, $6 = 0, $60 = 0, $62 = 0, $66 = 0, $hashval$0$lcssa$i = 0, $hashval$0$lcssa$i$i = 0, $hashval$0$lcssa$i$i6 = 0, $hashval$02$i = 0, $hashval$02$i$i = 0, $hashval$02$i$i1 = 0, $np$018 = 0, $np$018$lcssa = 0, $np$116 = 0, $np$117 = 0, $np$117$lcssa = 0, $p$019 = 0, $p$020 = 0, label = 0;
 if (!$s) {
  $$0 = 0;
  return $$0 | 0;
 }
 $1 = HEAP8[$s >> 0] | 0;
 if (!($1 << 24 >> 24)) $hashval$0$lcssa$i = 0; else {
  $$01$i = $s;
  $4 = $1;
  $hashval$02$i = 0;
  while (1) {
   $6 = ($hashval$02$i * 31 | 0) + ($4 << 24 >> 24) | 0;
   $$01$i = $$01$i + 1 | 0;
   $4 = HEAP8[$$01$i >> 0] | 0;
   if (!($4 << 24 >> 24)) {
    $$lcssa72 = $6;
    break;
   } else $hashval$02$i = $6;
  }
  $hashval$0$lcssa$i = ($$lcssa72 >>> 0) % 178 | 0;
 }
 $p$019 = HEAP32[$tags + 8 + ($hashval$0$lcssa$i << 2) >> 2] | 0;
 L9 : do if (!$p$019) $np$018 = 58824; else {
  $p$020 = $p$019;
  while (1) {
   $14 = HEAP32[$p$020 >> 2] | 0;
   if (!$14) {
    $np$018 = 58824;
    break L9;
   }
   if (!(_prvTidytmbstrcmp($s, HEAP32[$14 + 4 >> 2] | 0) | 0)) {
    $$lcssa71 = $p$020;
    break;
   }
   $p$020 = HEAP32[$p$020 + 4 >> 2] | 0;
   if (!$p$020) {
    $np$018 = 58824;
    break L9;
   }
  }
  $$0 = HEAP32[$$lcssa71 >> 2] | 0;
  return $$0 | 0;
 } while (0);
 do {
  $21 = $np$018 + 4 | 0;
  if (!(_prvTidytmbstrcmp($s, HEAP32[$21 >> 2] | 0) | 0)) {
   $$lcssa68 = $21;
   $np$018$lcssa = $np$018;
   label = 11;
   break;
  }
  $np$018 = $np$018 + 32 | 0;
 } while ($np$018 >>> 0 < 63624 >>> 0);
 if ((label | 0) == 11) {
  $26 = HEAP32[$doc + 6856 >> 2] | 0;
  $29 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$26 >> 2] >> 2] & 31]($26, 8) | 0;
  HEAP32[$29 >> 2] = $np$018$lcssa;
  $30 = HEAP32[$$lcssa68 >> 2] | 0;
  $31 = HEAP8[$30 >> 0] | 0;
  if (!($31 << 24 >> 24)) $hashval$0$lcssa$i$i6 = 0; else {
   $$01$i$i2 = $30;
   $34 = $31;
   $hashval$02$i$i1 = 0;
   while (1) {
    $36 = ($hashval$02$i$i1 * 31 | 0) + ($34 << 24 >> 24) | 0;
    $$01$i$i2 = $$01$i$i2 + 1 | 0;
    $34 = HEAP8[$$01$i$i2 >> 0] | 0;
    if (!($34 << 24 >> 24)) {
     $$lcssa = $36;
     break;
    } else $hashval$02$i$i1 = $36;
   }
   $hashval$0$lcssa$i$i6 = ($$lcssa >>> 0) % 178 | 0;
  }
  $40 = $tags + 8 + ($hashval$0$lcssa$i$i6 << 2) | 0;
  HEAP32[$29 + 4 >> 2] = HEAP32[$40 >> 2];
  HEAP32[$40 >> 2] = $29;
  $$0 = $np$018$lcssa;
  return $$0 | 0;
 }
 $np$116 = HEAP32[$tags + 4 >> 2] | 0;
 if (!$np$116) {
  $$0 = 0;
  return $$0 | 0;
 } else $np$117 = $np$116;
 while (1) {
  $47 = $np$117 + 4 | 0;
  if (!(_prvTidytmbstrcmp($s, HEAP32[$47 >> 2] | 0) | 0)) {
   $$lcssa65 = $47;
   $np$117$lcssa = $np$117;
   break;
  }
  $np$117 = HEAP32[$np$117 + 28 >> 2] | 0;
  if (!$np$117) {
   $$0 = 0;
   label = 23;
   break;
  }
 }
 if ((label | 0) == 23) return $$0 | 0;
 $52 = HEAP32[$doc + 6856 >> 2] | 0;
 $55 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$52 >> 2] >> 2] & 31]($52, 8) | 0;
 HEAP32[$55 >> 2] = $np$117$lcssa;
 $56 = HEAP32[$$lcssa65 >> 2] | 0;
 $57 = HEAP8[$56 >> 0] | 0;
 if (!($57 << 24 >> 24)) $hashval$0$lcssa$i$i = 0; else {
  $$01$i$i = $56;
  $60 = $57;
  $hashval$02$i$i = 0;
  while (1) {
   $62 = ($hashval$02$i$i * 31 | 0) + ($60 << 24 >> 24) | 0;
   $$01$i$i = $$01$i$i + 1 | 0;
   $60 = HEAP8[$$01$i$i >> 0] | 0;
   if (!($60 << 24 >> 24)) {
    $$lcssa63 = $62;
    break;
   } else $hashval$02$i$i = $62;
  }
  $hashval$0$lcssa$i$i = ($$lcssa63 >>> 0) % 178 | 0;
 }
 $66 = $tags + 8 + ($hashval$0$lcssa$i$i << 2) | 0;
 HEAP32[$55 + 4 >> 2] = HEAP32[$66 >> 2];
 HEAP32[$66 >> 2] = $55;
 $$0 = $np$117$lcssa;
 return $$0 | 0;
}

function _prvTidyAddGenerator($doc) {
 $doc = $doc | 0;
 var $$0 = 0, $$lcssa = 0, $15 = 0, $2 = 0, $25 = 0, $29 = 0, $32 = 0, $36 = 0, $38 = 0, $39 = 0, $43 = 0, $44 = 0, $5 = 0, $57 = 0, $59 = 0, $62 = 0, $69 = 0, $70 = 0, $86 = 0, $buf = 0, $node$02$i$i = 0, $node$02$i$i$lcssa = 0, $node$04 = 0, $node$04$i = 0, $node$05 = 0, $node$05$i = 0, $node$05$i$lcssa = 0, $vararg_buffer = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 272 | 0;
 $vararg_buffer = sp;
 $buf = sp + 8 | 0;
 L1 : do if ($doc | 0) {
  $2 = HEAP32[$doc + 12 >> 2] | 0;
  if ($2 | 0) {
   $node$02$i$i = $2;
   while (1) {
    $5 = HEAP32[$node$02$i$i + 28 >> 2] | 0;
    if ($5 | 0) if ((HEAP32[$5 >> 2] | 0) == 48) {
     $node$02$i$i$lcssa = $node$02$i$i;
     break;
    }
    $node$02$i$i = HEAP32[$node$02$i$i + 8 >> 2] | 0;
    if (!$node$02$i$i) break L1;
   }
   $node$04$i = HEAP32[$node$02$i$i$lcssa + 12 >> 2] | 0;
   if ($node$04$i | 0) {
    $node$05$i = $node$04$i;
    while (1) {
     $15 = HEAP32[$node$05$i + 28 >> 2] | 0;
     if ($15 | 0) if ((HEAP32[$15 >> 2] | 0) == 46) {
      $node$05$i$lcssa = $node$05$i;
      break;
     }
     $node$05$i = HEAP32[$node$05$i + 8 >> 2] | 0;
     if (!$node$05$i) break L1;
    }
    HEAP32[$vararg_buffer >> 2] = _tidyLibraryVersion() | 0;
    _prvTidytmbsnprintf($buf, 256, 310177, $vararg_buffer) | 0;
    $node$04 = HEAP32[$node$05$i$lcssa + 12 >> 2] | 0;
    L15 : do if ($node$04 | 0) {
     $node$05 = $node$04;
     while (1) {
      $25 = HEAP32[$node$05 + 28 >> 2] | 0;
      if ($25 | 0) if ((HEAP32[$25 >> 2] | 0) == 68) {
       $29 = _prvTidyAttrGetById($node$05, 85) | 0;
       if ($29 | 0) {
        $32 = HEAP32[$29 + 24 >> 2] | 0;
        if ($32 | 0) if (!(_prvTidytmbstrcasecmp($32, 311567) | 0)) {
         $36 = _prvTidyAttrGetById($node$05, 36) | 0;
         if ($36 | 0) {
          $38 = $36 + 24 | 0;
          $39 = HEAP32[$38 >> 2] | 0;
          if ($39 | 0) if (!(_prvTidytmbstrncasecmp($39, 310208, 9) | 0)) {
           $$lcssa = $38;
           break;
          }
         }
        }
       }
      }
      $node$05 = HEAP32[$node$05 + 8 >> 2] | 0;
      if (!$node$05) break L15;
     }
     $43 = $doc + 6856 | 0;
     $44 = HEAP32[$43 >> 2] | 0;
     FUNCTION_TABLE_vii[HEAP32[(HEAP32[$44 >> 2] | 0) + 8 >> 2] & 15]($44, HEAP32[$$lcssa >> 2] | 0);
     HEAP32[$$lcssa >> 2] = _prvTidytmbstrdup(HEAP32[$43 >> 2] | 0, $buf) | 0;
     $$0 = 0;
     $86 = $buf;
     STACKTOP = sp;
     return $$0 | 0;
    } while (0);
    if (HEAP32[$doc + 408 >> 2] | 0) {
     $$0 = 0;
     $86 = $buf;
     STACKTOP = sp;
     return $$0 | 0;
    }
    $57 = HEAP32[$doc + 68 >> 2] | 0;
    $59 = HEAP32[$57 + 124 >> 2] | 0;
    $62 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$59 >> 2] >> 2] & 31]($59, 68) | 0;
    dest = $62;
    stop = dest + 68 | 0;
    do {
     HEAP32[dest >> 2] = 0;
     dest = dest + 4 | 0;
    } while ((dest | 0) < (stop | 0));
    if ($57 | 0) {
     HEAP32[$62 + 48 >> 2] = HEAP32[$57 >> 2];
     HEAP32[$62 + 52 >> 2] = HEAP32[$57 + 4 >> 2];
    }
    $69 = $62 + 44 | 0;
    HEAP32[$69 >> 2] = 4;
    $70 = _prvTidyLookupTagDef(68) | 0;
    if (!$70) ___assert_fail(310218, 310231, 2095, 310319);
    HEAP32[$69 >> 2] = 5;
    HEAP32[$62 + 60 >> 2] = 1;
    HEAP32[$62 + 32 >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, HEAP32[$70 + 4 >> 2] | 0) | 0;
    HEAP32[$62 + 28 >> 2] = $70;
    HEAP32[$62 + 36 >> 2] = HEAP32[$57 + 48 >> 2];
    HEAP32[$62 + 40 >> 2] = HEAP32[$57 + 52 >> 2];
    _prvTidyAddAttribute($doc, $62, 311658, 311567) | 0;
    _prvTidyAddAttribute($doc, $62, 310338, $buf) | 0;
    _prvTidyInsertNodeAtStart($node$05$i$lcssa, $62);
    $$0 = 1;
    $86 = $buf;
    STACKTOP = sp;
    return $$0 | 0;
   }
  }
 } while (0);
 $$0 = 0;
 $86 = $buf;
 STACKTOP = sp;
 return $$0 | 0;
}

function _CheckColorContrast($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$idx = 0, $$idx$val = 0, $$idx12 = 0, $$idx12$val = 0, $$idx14 = 0, $$idx14$val = 0, $$idx15 = 0, $$idx15$val = 0, $$val = 0, $$val13 = 0, $1 = 0, $11 = 0, $12 = 0, $14 = 0, $24 = 0, $26 = 0, $31 = 0, $32 = 0, $34 = 0, $48 = 0, $54 = 0, $7 = 0, $av$031 = 0, $av$033 = 0, $av$128$pre = 0, $av$129 = 0, $cp$03$i$i = 0, $cp$03$i$i16 = 0, $errcode$025 = 0, $gotBG$032 = 0, $gotBG$1 = 0, $gotBG$1$lcssa = 0, $rgbBG = 0, $rgbFG = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $rgbBG = sp + 12 | 0;
 $rgbFG = sp;
 HEAP32[$rgbBG >> 2] = HEAP32[54208];
 HEAP32[$rgbBG + 4 >> 2] = HEAP32[54209];
 HEAP32[$rgbBG + 8 >> 2] = HEAP32[54210];
 if ((HEAP32[$doc + 6396 >> 2] | 0) != 3) {
  STACKTOP = sp;
  return;
 }
 $1 = $node + 20 | 0;
 $av$031 = HEAP32[$1 >> 2] | 0;
 if (!$av$031) {
  STACKTOP = sp;
  return;
 }
 $av$033 = $av$031;
 $gotBG$032 = 1;
 while (1) {
  $7 = HEAP32[$av$033 + 4 >> 2] | 0;
  L9 : do if (!$7) $gotBG$1 = $gotBG$032; else if ((HEAP32[$7 >> 2] | 0) == 14) {
   $11 = $av$033 + 24 | 0;
   $12 = HEAP32[$11 >> 2] | 0;
   if (!$12) $gotBG$1 = $gotBG$032; else {
    $cp$03$i$i = $12;
    while (1) {
     $14 = HEAP8[$cp$03$i$i >> 0] | 0;
     if (!($14 << 24 >> 24)) {
      $gotBG$1 = $gotBG$032;
      break L9;
     }
     if (!(_prvTidyIsWhite($14 << 24 >> 24) | 0)) break; else $cp$03$i$i = $cp$03$i$i + 1 | 0;
    }
    $gotBG$1 = _GetRgb(HEAP32[$11 >> 2] | 0, $rgbBG) | 0;
   }
  } else $gotBG$1 = $gotBG$032; while (0);
  $av$033 = HEAP32[$av$033 >> 2] | 0;
  if (!$av$033) {
   $gotBG$1$lcssa = $gotBG$1;
   break;
  } else $gotBG$032 = $gotBG$1;
 }
 $av$128$pre = HEAP32[$1 >> 2] | 0;
 if (!(($gotBG$1$lcssa | 0) != 0 & ($av$128$pre | 0) != 0)) {
  STACKTOP = sp;
  return;
 }
 $$idx = $rgbBG + 4 | 0;
 $$idx12 = $rgbBG + 8 | 0;
 $$idx14 = $rgbFG + 4 | 0;
 $$idx15 = $rgbFG + 8 | 0;
 $av$129 = $av$128$pre;
 do {
  $24 = HEAP32[$av$129 + 4 >> 2] | 0;
  L23 : do if ($24 | 0) {
   $26 = HEAP32[$24 >> 2] | 0;
   if (($26 | 0) == 147) $errcode$025 = 332; else if (($26 | 0) == 76) $errcode$025 = 333; else if (($26 | 0) == 8) $errcode$025 = 334; else if (($26 | 0) == 157) $errcode$025 = 335; else break;
   $31 = $av$129 + 24 | 0;
   $32 = HEAP32[$31 >> 2] | 0;
   if ($32 | 0) {
    $cp$03$i$i16 = $32;
    while (1) {
     $34 = HEAP8[$cp$03$i$i16 >> 0] | 0;
     if (!($34 << 24 >> 24)) break L23;
     if (!(_prvTidyIsWhite($34 << 24 >> 24) | 0)) break; else $cp$03$i$i16 = $cp$03$i$i16 + 1 | 0;
    }
    HEAP32[$rgbFG >> 2] = 0;
    HEAP32[$rgbFG + 4 >> 2] = 0;
    HEAP32[$rgbFG + 8 >> 2] = 0;
    if (_GetRgb(HEAP32[$31 >> 2] | 0, $rgbFG) | 0) {
     $$val = HEAP32[$rgbBG >> 2] | 0;
     $$idx$val = HEAP32[$$idx >> 2] | 0;
     $$idx12$val = HEAP32[$$idx12 >> 2] | 0;
     $$val13 = HEAP32[$rgbFG >> 2] | 0;
     $$idx14$val = HEAP32[$$idx14 >> 2] | 0;
     $$idx15$val = HEAP32[$$idx15 >> 2] | 0;
     $48 = (($$idx$val * 587 | 0) + ($$val * 299 | 0) + ($$idx12$val * 114 | 0) | 0) / 1e3 | 0;
     $54 = (($$idx14$val * 587 | 0) + ($$val13 * 299 | 0) + ($$idx15$val * 114 | 0) | 0) / 1e3 | 0;
     if (!(((($48 | 0) > ($54 | 0) ? $48 : $54) - (($48 | 0) < ($54 | 0) ? $48 : $54) | 0) > 180 ? ((($$val | 0) > ($$val13 | 0) ? $$val : $$val13) - (($$val | 0) < ($$val13 | 0) ? $$val : $$val13) - (($$idx$val | 0) < ($$idx14$val | 0) ? $$idx$val : $$idx14$val) + (($$idx$val | 0) > ($$idx14$val | 0) ? $$idx$val : $$idx14$val) - (($$idx12$val | 0) < ($$idx15$val | 0) ? $$idx12$val : $$idx15$val) + (($$idx12$val | 0) > ($$idx15$val | 0) ? $$idx12$val : $$idx15$val) | 0) > 500 : 0)) _prvTidyReportAccessWarning($doc, $node, $errcode$025);
    }
   }
  } while (0);
  $av$129 = HEAP32[$av$129 >> 2] | 0;
 } while (($av$129 | 0) != 0);
 STACKTOP = sp;
 return;
}

function _prvTidyParseFrameSet($doc, $frameset, $mode) {
 $doc = $doc | 0;
 $frameset = $frameset | 0;
 $mode = $mode | 0;
 var $$lcssa = 0, $$pr$pre = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $31 = 0, $32 = 0, $39 = 0, $43 = 0, $45 = 0, $48 = 0, $5 = 0, $53 = 0, $65 = 0, $69 = 0, $74 = 0, $8 = 0, $80 = 0, $node$0 = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!(HEAP32[$doc + 408 >> 2] | 0)) {
  $5 = $doc + 6836 | 0;
  HEAP32[$5 >> 2] = HEAP32[$5 >> 2] | 16;
 }
 $8 = _prvTidyGetToken($doc, 0) | 0;
 L4 : do if ($8 | 0) {
  $10 = $frameset + 28 | 0;
  $11 = $frameset + 16 | 0;
  $12 = $frameset + 12 | 0;
  $13 = $1 + 20 | 0;
  $14 = $doc + 6836 | 0;
  $16 = $8;
  while (1) {
   $15 = $16 + 28 | 0;
   if ((HEAP32[$15 >> 2] | 0) == (HEAP32[$10 >> 2] | 0)) if ((HEAP32[$16 + 44 >> 2] | 0) == 6) {
    $$lcssa = $16;
    break;
   }
   L11 : do if (!(_InsertMisc($frameset, $16) | 0)) {
    if (!(HEAP32[$15 >> 2] | 0)) {
     _prvTidyReportError($doc, $frameset, $16, 208);
     _prvTidyFreeNode($doc, $16);
     break;
    }
    $31 = (_prvTidynodeIsElement($16) | 0) == 0;
    $$pr$pre = HEAP32[$15 >> 2] | 0;
    $32 = ($$pr$pre | 0) == 0;
    if ($31) if ($32) $node$0 = $16; else label = 17; else if ($32) $node$0 = $16; else if (!(HEAP32[$$pr$pre + 16 >> 2] & 4)) label = 17; else {
     _MoveToHead($doc, $frameset, $16);
     break;
    }
    if ((label | 0) == 17) {
     label = 0;
     if ((HEAP32[$$pr$pre >> 2] | 0) == 16) {
      _prvTidyUngetToken($doc);
      $39 = _prvTidyInferredTag($doc, 72) | 0;
      _prvTidyReportError($doc, $frameset, $39, 215);
      $node$0 = $39;
     } else $node$0 = $16;
    }
    switch (HEAP32[$node$0 + 44 >> 2] | 0) {
    case 5:
     {
      $43 = HEAP32[$node$0 + 28 >> 2] | 0;
      $45 = HEAP32[$43 + 16 >> 2] | 0;
      if (!($45 & 8192)) label = 37; else {
       HEAP32[$node$0 >> 2] = $frameset;
       $48 = HEAP32[$11 >> 2] | 0;
       HEAP32[$node$0 + 4 >> 2] = $48;
       if (!$48) HEAP32[$12 >> 2] = $node$0; else HEAP32[$48 + 8 >> 2] = $node$0;
       HEAP32[$11 >> 2] = $node$0;
       HEAP32[$13 >> 2] = 0;
       $53 = HEAP32[$0 >> 2] | 0;
       if (!$43) break L11;
       if (!($45 & 1)) {
        if (!($45 & 16)) HEAP32[$53 + 16 >> 2] = 0;
       } else {
        HEAP32[$53 + 8 >> 2] = 0;
        if (!(HEAP32[$43 + 20 >> 2] | 0)) break L11;
       }
       $65 = HEAP32[$43 + 20 >> 2] | 0;
       if (!$65) break L11;
       HEAP32[$53 + 72 >> 2] = $node$0;
       FUNCTION_TABLE_viii[$65 & 63]($doc, $node$0, 1);
       break L11;
      }
      break;
     }
    case 7:
     {
      $69 = HEAP32[$node$0 + 28 >> 2] | 0;
      if (!(HEAP32[$69 + 16 >> 2] & 8192)) {
       $80 = $69;
       label = 38;
      } else {
       HEAP32[$node$0 >> 2] = $frameset;
       $74 = HEAP32[$11 >> 2] | 0;
       HEAP32[$node$0 + 4 >> 2] = $74;
       if (!$74) HEAP32[$12 >> 2] = $node$0; else HEAP32[$74 + 8 >> 2] = $node$0;
       HEAP32[$11 >> 2] = $node$0;
       break L11;
      }
      break;
     }
    default:
     if ($node$0 | 0) label = 37;
    }
    if ((label | 0) == 37) {
     label = 0;
     $80 = HEAP32[$node$0 + 28 >> 2] | 0;
     label = 38;
    }
    if ((label | 0) == 38) {
     label = 0;
     if ($80 | 0) if ((HEAP32[$80 >> 2] | 0) == 1) HEAP32[$14 >> 2] = HEAP32[$14 >> 2] | 64;
    }
    _prvTidyReportError($doc, $frameset, $node$0, 208);
    _prvTidyFreeNode($doc, $node$0);
   } while (0);
   $16 = _prvTidyGetToken($doc, 0) | 0;
   if (!$16) break L4;
  }
  _prvTidyFreeNode($doc, $$lcssa);
  HEAP32[$frameset + 56 >> 2] = 1;
  _TrimSpaces($doc, $frameset);
  return;
 } while (0);
 _prvTidyReportError($doc, $frameset, 0, 206);
 return;
}

function _ReadCharFromStream($in) {
 $in = $in | 0;
 var $$2 = 0, $$4 = 0, $12 = 0, $19 = 0, $2 = 0, $22 = 0, $25 = 0, $28 = 0, $31 = 0, $32 = 0, $39 = 0, $41 = 0, $52 = 0, $55 = 0, $6 = 0, $9 = 0, $count = 0, $n = 0, $or$cond3 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $n = sp + 4 | 0;
 $count = sp;
 $2 = $in + 304 | 0;
 L1 : do if (!(FUNCTION_TABLE_ii[HEAP32[$in + 316 >> 2] & 31](HEAP32[$2 >> 2] | 0) | 0)) {
  $6 = $in + 308 | 0;
  $9 = FUNCTION_TABLE_ii[HEAP32[$6 >> 2] & 31](HEAP32[$2 >> 2] | 0) | 0;
  if (($9 | 0) == -1) $$4 = -1; else {
   $12 = HEAP32[$in + 296 >> 2] | 0;
   switch ($12 | 0) {
   case 5:
    {
     if (($9 | 0) == 27) {
      HEAP32[$in >> 2] = 1;
      $$4 = 27;
      break L1;
     }
     switch (HEAP32[$in >> 2] | 0) {
     case 1:
      {
       switch ($9 | 0) {
       case 36:
        {
         HEAP32[$in >> 2] = 2;
         $$4 = 36;
         break L1;
         break;
        }
       case 40:
        {
         HEAP32[$in >> 2] = 4;
         $$4 = 40;
         break L1;
         break;
        }
       default:
        {
         HEAP32[$in >> 2] = 0;
         $$4 = $9;
         break L1;
        }
       }
       break;
      }
     case 2:
      {
       if (($9 | 0) == 40) {
        HEAP32[$in >> 2] = 3;
        $$4 = 40;
        break L1;
       } else {
        HEAP32[$in >> 2] = 5;
        $$4 = $9;
        break L1;
       }
       break;
      }
     case 3:
      {
       HEAP32[$in >> 2] = 5;
       $$4 = $9;
       break L1;
       break;
      }
     case 4:
      {
       HEAP32[$in >> 2] = 0;
       $$4 = $9;
       break L1;
       break;
      }
     case 5:
      {
       $$4 = $9 | 128;
       break L1;
       break;
      }
     default:
      {
       $$4 = $9;
       break L1;
      }
     }
     break;
    }
   case 9:
    {
     $19 = FUNCTION_TABLE_ii[HEAP32[$6 >> 2] & 31](HEAP32[$2 >> 2] | 0) | 0;
     if (($19 | 0) == -1) {
      $$4 = -1;
      break L1;
     }
     $22 = ($19 << 8) + $9 | 0;
     HEAP32[$n >> 2] = $22;
     $$4 = $22;
     break L1;
     break;
    }
   case 10:
   case 11:
    {
     $25 = FUNCTION_TABLE_ii[HEAP32[$6 >> 2] & 31](HEAP32[$2 >> 2] | 0) | 0;
     if (($25 | 0) == -1) {
      $$4 = -1;
      break L1;
     }
     $28 = $25 + ($9 << 8) | 0;
     HEAP32[$n >> 2] = $28;
     $$4 = $28;
     break L1;
     break;
    }
   case 4:
    {
     HEAP32[$count >> 2] = 0;
     $31 = (_prvTidyDecodeUTF8BytesToChar($n, $9, 0, $in + 304 | 0, $count) | 0) == 0;
     $32 = HEAP32[$n >> 2] | 0;
     $or$cond3 = $31 & ($32 | 0) == -1 & (HEAP32[$count >> 2] | 0) == 1;
     if ($or$cond3 | $31) $$2 = $or$cond3 ? -1 : $32; else {
      $39 = HEAP32[$in + 320 >> 2] | 0;
      $41 = HEAP32[$39 + 68 >> 2] | 0;
      HEAP32[$41 >> 2] = HEAP32[$in + 292 >> 2];
      HEAP32[$41 + 4 >> 2] = HEAP32[$in + 288 >> 2];
      _prvTidyReportEncodingError($39, 293, HEAP32[$n >> 2] | 0, 0);
      HEAP32[$n >> 2] = 65533;
      $$2 = 65533;
     }
     $$4 = $$2;
     break L1;
     break;
    }
   case 13:
   case 12:
    {
     if ($9 >>> 0 < 128) {
      $$4 = $9;
      break L1;
     }
     if (($9 + -161 | 0) >>> 0 < 63 & ($12 | 0) == 13) {
      $$4 = $9;
      break L1;
     }
     $52 = FUNCTION_TABLE_ii[HEAP32[$6 >> 2] & 31](HEAP32[$2 >> 2] | 0) | 0;
     if (($52 | 0) == -1) {
      $$4 = -1;
      break L1;
     }
     $55 = $52 + ($9 << 8) | 0;
     HEAP32[$n >> 2] = $55;
     $$4 = $55;
     break L1;
     break;
    }
   default:
    {
     HEAP32[$n >> 2] = $9;
     $$4 = $9;
     break L1;
    }
   }
  }
 } else $$4 = -1; while (0);
 STACKTOP = sp;
 return $$4 | 0;
}

function _GetOption($tdoc, $topt, $d) {
 $tdoc = $tdoc | 0;
 $topt = $topt | 0;
 $d = $d | 0;
 var $$0$i = 0, $0 = 0, $1 = 0, $10 = 0, $12 = 0, $13 = 0, $14 = 0, $18 = 0, $20 = 0, $27 = 0, $3 = 0, $33 = 0, $44 = 0, $9 = 0, $pos$i = 0, $sdef$0 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $pos$i = sp + 12 | 0;
 $0 = _tidyOptGetId($topt) | 0;
 $1 = _tidyOptGetType($topt) | 0;
 HEAP32[$d >> 2] = _tidyOptGetName($topt) | 0;
 $3 = _tidyOptGetCategory($topt) | 0;
 switch ($3 | 0) {
 case 0:
  {
   $$0$i = _tidyLocalizedString(4102) | 0;
   break;
  }
 case 1:
  {
   $$0$i = _tidyLocalizedString(4100) | 0;
   break;
  }
 case 2:
  {
   $$0$i = _tidyLocalizedString(4104) | 0;
   break;
  }
 case 3:
  {
   $$0$i = _tidyLocalizedString(4101) | 0;
   break;
  }
 case 4:
  {
   $$0$i = _tidyLocalizedString(4103) | 0;
   break;
  }
 default:
  {
   $9 = HEAP32[55027] | 0;
   $10 = _tidyLocalizedString(4161) | 0;
   HEAP32[$vararg_buffer >> 2] = $3;
   _fprintf($9, $10, $vararg_buffer) | 0;
   _fputc(10, $9) | 0;
   ___assert_fail(310351, 222525, 573, 222616);
  }
 }
 HEAP32[$d + 4 >> 2] = $$0$i;
 $12 = $d + 12 | 0;
 HEAP32[$12 >> 2] = 0;
 $13 = $d + 16 | 0;
 HEAP32[$13 >> 2] = 0;
 $14 = $d + 100 | 0;
 HEAP32[$14 >> 2] = 1;
 switch ($0 | 0) {
 case 84:
 case 7:
 case 91:
 case 10:
  {
   HEAP32[$d + 8 >> 2] = 222301;
   HEAP32[$12 >> 2] = 0;
   if (($0 | 0) == 7) $18 = 222306; else $18 = _tidyOptGetCurrPick($tdoc, $0) | 0;
   HEAP32[$13 >> 2] = $18;
   STACKTOP = sp;
   return;
  }
 case 9:
  {
   HEAP32[$d + 8 >> 2] = 222334;
   HEAP32[$12 >> 2] = 0;
   $20 = _tidyOptGetCurrPick($tdoc, 8) | 0;
   if (!$20) label = 14; else if ((HEAP8[$20 >> 0] | 0) == 42) label = 14; else $sdef$0 = $20;
   if ((label | 0) == 14) $sdef$0 = _tidyOptGetValue($tdoc, 9) | 0;
   HEAP32[$13 >> 2] = $sdef$0;
   STACKTOP = sp;
   return;
  }
 case 83:
 case 82:
 case 81:
 case 80:
  {
   HEAP32[$d + 8 >> 2] = 222342;
   HEAP32[$12 >> 2] = 222352;
   HEAP32[$13 >> 2] = 0;
   STACKTOP = sp;
   return;
  }
 case 6:
 case 5:
 case 4:
  {
   HEAP32[$d + 8 >> 2] = 222368;
   $27 = _tidyOptGetEncName($tdoc, $0) | 0;
   HEAP32[$13 >> 2] = ($27 | 0) == 0 ? 222377 : $27;
   HEAP32[$12 >> 2] = 0;
   STACKTOP = sp;
   return;
  }
 default:
  switch ($1 | 0) {
  case 2:
   {
    HEAP32[$d + 8 >> 2] = 222379;
    HEAP32[$12 >> 2] = 222387;
    HEAP32[$13 >> 2] = _tidyOptGetCurrPick($tdoc, $0) | 0;
    STACKTOP = sp;
    return;
   }
  case 1:
   {
    L15 : do if ((_tidyOptGetType($topt) | 0) == 1) {
     $33 = _tidyOptGetPickList($topt) | 0;
     HEAP32[$pos$i >> 2] = $33;
     if ($33 | 0) {
      while (1) {
       if (!(_strcmp(_tidyOptGetNextPick($topt, $pos$i) | 0, 305751) | 0)) break;
       if (!(HEAP32[$pos$i >> 2] | 0)) break L15;
      }
      HEAP32[$d + 8 >> 2] = 222421;
      HEAP32[$12 >> 2] = 222430;
      HEAP32[$13 >> 2] = _tidyOptGetCurrPick($tdoc, $0) | 0;
      STACKTOP = sp;
      return;
     }
    } while (0);
    HEAP32[$d + 8 >> 2] = 222470;
    HEAP32[$12 >> 2] = ($0 | 0) == 2 ? 222478 : 222505;
    $44 = $d + 20 | 0;
    HEAP32[$vararg_buffer1 >> 2] = _tidyOptGetInt($tdoc, $0) | 0;
    _sprintf($44, 312312, $vararg_buffer1) | 0;
    HEAP32[$13 >> 2] = $44;
    STACKTOP = sp;
    return;
   }
  case 0:
   {
    HEAP32[$d + 8 >> 2] = 222518;
    HEAP32[$12 >> 2] = 0;
    HEAP32[$14 >> 2] = 0;
    HEAP32[$13 >> 2] = _tidyOptGetValue($tdoc, $0) | 0;
    STACKTOP = sp;
    return;
   }
  default:
   {
    STACKTOP = sp;
    return;
   }
  }
 }
}

function _PPrintCDATA($doc, $indent, $node) {
 $doc = $doc | 0;
 $indent = $indent | 0;
 $node = $node | 0;
 var $$indent = 0, $$pre$i$i = 0, $$pre$i$i4 = 0, $0 = 0, $12 = 0, $15 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $29 = 0, $33 = 0, $36 = 0, $38 = 0, $4 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $58 = 0, $62 = 0, $65 = 0, $67 = 0, $85 = 0, $buflen$0$i$i$i = 0, $buflen$0$i$i$i$lcssa = 0, $buflen$0$i$i$i2 = 0, $buflen$0$i$i$i2$lcssa = 0, $ix$01$i$i = 0, $ix$01$i$i6 = 0;
 $0 = $doc + 6724 | 0;
 $$indent = (HEAP32[$doc + 344 >> 2] | 0) == 0 ? 0 : $indent;
 $4 = $doc + 6736 | 0;
 if (HEAP32[$4 >> 2] | 0) {
  _PFlushLineImpl($doc);
  if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
   _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
   $12 = $doc + 6744 | 0;
   HEAP32[$12 >> 2] = (HEAP32[$12 >> 2] | 0) + 1;
  }
 }
 $15 = $doc + 6752 | 0;
 if ((HEAP32[$15 >> 2] | 0) != ($$indent | 0)) HEAP32[$15 >> 2] = $$indent;
 $19 = HEAP32[$doc + 80 >> 2] | 0;
 _prvTidySetOptionInt($doc, 2, -1) | 0;
 $20 = HEAP32[$4 >> 2] | 0;
 $21 = _prvTidytmbstrlen(310839) | 0;
 $22 = $21 + $20 | 0;
 $23 = $doc + 6732 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 if ($22 >>> 0 >= $24 >>> 0) {
  $buflen$0$i$i$i = ($24 | 0) == 0 ? 256 : $24;
  while (1) if ($buflen$0$i$i$i >>> 0 > $22 >>> 0) {
   $buflen$0$i$i$i$lcssa = $buflen$0$i$i$i;
   break;
  } else $buflen$0$i$i$i = $buflen$0$i$i$i << 1;
  $29 = HEAP32[$0 >> 2] | 0;
  $33 = $doc + 6728 | 0;
  $36 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$29 >> 2] | 0) + 4 >> 2] & 15]($29, HEAP32[$33 >> 2] | 0, $buflen$0$i$i$i$lcssa << 2) | 0;
  if ($36 | 0) {
   $38 = HEAP32[$23 >> 2] | 0;
   _memset($36 + ($38 << 2) | 0, 0, $buflen$0$i$i$i$lcssa - $38 << 2 | 0) | 0;
   HEAP32[$23 >> 2] = $buflen$0$i$i$i$lcssa;
   HEAP32[$33 >> 2] = $36;
  }
 }
 if ($21 | 0) {
  $$pre$i$i = HEAP32[$doc + 6728 >> 2] | 0;
  $ix$01$i$i = 0;
  do {
   HEAP32[$$pre$i$i + ($ix$01$i$i + $20 << 2) >> 2] = HEAP8[310839 + $ix$01$i$i >> 0];
   $ix$01$i$i = $ix$01$i$i + 1 | 0;
  } while (($ix$01$i$i | 0) != ($21 | 0));
 }
 HEAP32[$4 >> 2] = $22;
 _PPrintText($doc, 2, $$indent, $node);
 $50 = HEAP32[$4 >> 2] | 0;
 $51 = _prvTidytmbstrlen(310849) | 0;
 $52 = $51 + $50 | 0;
 $53 = HEAP32[$23 >> 2] | 0;
 if ($52 >>> 0 >= $53 >>> 0) {
  $buflen$0$i$i$i2 = ($53 | 0) == 0 ? 256 : $53;
  while (1) if ($buflen$0$i$i$i2 >>> 0 > $52 >>> 0) {
   $buflen$0$i$i$i2$lcssa = $buflen$0$i$i$i2;
   break;
  } else $buflen$0$i$i$i2 = $buflen$0$i$i$i2 << 1;
  $58 = HEAP32[$0 >> 2] | 0;
  $62 = $doc + 6728 | 0;
  $65 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$58 >> 2] | 0) + 4 >> 2] & 15]($58, HEAP32[$62 >> 2] | 0, $buflen$0$i$i$i2$lcssa << 2) | 0;
  if ($65 | 0) {
   $67 = HEAP32[$23 >> 2] | 0;
   _memset($65 + ($67 << 2) | 0, 0, $buflen$0$i$i$i2$lcssa - $67 << 2 | 0) | 0;
   HEAP32[$23 >> 2] = $buflen$0$i$i$i2$lcssa;
   HEAP32[$62 >> 2] = $65;
  }
 }
 if ($51 | 0) {
  $$pre$i$i4 = HEAP32[$doc + 6728 >> 2] | 0;
  $ix$01$i$i6 = 0;
  do {
   HEAP32[$$pre$i$i4 + ($ix$01$i$i6 + $50 << 2) >> 2] = HEAP8[310849 + $ix$01$i$i6 >> 0];
   $ix$01$i$i6 = $ix$01$i$i6 + 1 | 0;
  } while (($ix$01$i$i6 | 0) != ($51 | 0));
 }
 HEAP32[$4 >> 2] = $52;
 if ($52 | 0) {
  _PFlushLineImpl($doc);
  if ((HEAP32[$doc + 412 >> 2] | 0) != 2) {
   _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
   $85 = $doc + 6744 | 0;
   HEAP32[$85 >> 2] = (HEAP32[$85 >> 2] | 0) + 1;
  }
 }
 if ((HEAP32[$15 >> 2] | 0) == ($$indent | 0)) {
  _prvTidySetOptionInt($doc, 2, $19) | 0;
  return;
 }
 HEAP32[$15 >> 2] = $$indent;
 _prvTidySetOptionInt($doc, 2, $19) | 0;
 return;
}

function _tidyCleanAndRepair($tdoc) {
 $tdoc = $tdoc | 0;
 var $$0 = 0, $$pre13$i = 0, $10 = 0, $12 = 0, $14 = 0, $16 = 0, $18 = 0, $2 = 0, $20 = 0, $24 = 0, $4 = 0, $50 = 0, $54 = 0, $56 = 0, $58 = 0, $59 = 0, $6 = 0, $61 = 0, $62 = 0, $64 = 0, $69 = 0, $8 = 0, $80 = 0, $87 = 0, label = 0;
 if (!$tdoc) {
  $$0 = -22;
  return $$0 | 0;
 }
 $2 = HEAP32[$tdoc + 308 >> 2] | 0;
 $4 = HEAP32[$tdoc + 208 >> 2] | 0;
 $6 = HEAP32[$tdoc + 200 >> 2] | 0;
 $8 = HEAP32[$tdoc + 204 >> 2] | 0;
 $10 = HEAP32[$tdoc + 216 >> 2] | 0;
 $12 = HEAP32[$tdoc + 180 >> 2] | 0;
 $14 = HEAP32[$tdoc + 172 >> 2] | 0;
 $16 = HEAP32[$tdoc + 176 >> 2] | 0;
 $18 = HEAP32[$tdoc + 184 >> 2] | 0;
 $20 = HEAP32[$tdoc + 312 >> 2] | 0;
 $24 = HEAP32[$tdoc + 444 >> 2] | 0;
 if (HEAP32[$tdoc + 168 >> 2] | 0) {
  if (HEAP32[$tdoc + 6812 >> 2] | 0) {
   $$0 = 2;
   return $$0 | 0;
  }
  if (HEAP32[$tdoc + 6816 >> 2] | 0) {
   $$0 = 1;
   return $$0 | 0;
  }
  $$0 = (HEAP32[$tdoc + 6820 >> 2] | 0) != 0 & 1;
  return $$0 | 0;
 }
 if (HEAP32[$tdoc + 420 >> 2] | 0) _prvTidyNestedEmphasis($tdoc, $tdoc);
 _prvTidyList2BQ($tdoc, $tdoc);
 _prvTidyBQ2Div($tdoc, $tdoc);
 if ($4 | 0) _prvTidyEmFromI($tdoc, $tdoc);
 if ($2 | 0) if (_prvTidyIsWord2000($tdoc) | 0) {
  _prvTidyDropSections($tdoc, $tdoc);
  _prvTidyCleanWord2000($tdoc, $tdoc);
  _prvTidyDropEmptyElements($tdoc, $tdoc) | 0;
 }
 if ($10 | $6 | 0) _prvTidyCleanDocument($tdoc);
 if ($8 | 0) _prvTidyCleanGoogleDocument($tdoc);
 switch (HEAP32[$tdoc + 96 >> 2] | 0) {
 case 5:
 case 0:
  break;
 default:
  _prvTidyVerifyHTTPEquiv($tdoc, _prvTidyFindHEAD($tdoc) | 0);
 }
 if (!(_prvTidyCheckNodeIntegrity($tdoc) | 0)) {
  $50 = HEAP32[$tdoc + 6856 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$50 >> 2] | 0) + 12 >> 2] & 15]($50, 226625);
 }
 $54 = _prvTidyFindDocType($tdoc) | 0;
 if ($54 | 0) {
  $56 = _prvTidyGetAttrByName($54, 310770) | 0;
  if ($56 | 0) {
   $58 = $56 + 24 | 0;
   $59 = HEAP32[$58 >> 2] | 0;
   if ($59 | 0) {
    $61 = $tdoc + 6872 | 0;
    $62 = HEAP32[$61 >> 2] | 0;
    $$pre13$i = $tdoc + 6856 | 0;
    if (!$62) $69 = $59; else {
     $64 = HEAP32[$$pre13$i >> 2] | 0;
     FUNCTION_TABLE_vii[HEAP32[(HEAP32[$64 >> 2] | 0) + 8 >> 2] & 15]($64, $62);
     $69 = HEAP32[$58 >> 2] | 0;
    }
    HEAP32[$61 >> 2] = _prvTidytmbstrdup(HEAP32[$$pre13$i >> 2] | 0, $69) | 0;
   }
  }
 }
 if (HEAP32[$tdoc + 12 >> 2] | 0) {
  if (!$12) if (!$16) label = 34; else {
   _prvTidySetXHTMLDocType($tdoc) | 0;
   _prvTidyFixAnchors($tdoc, $tdoc, $24, 1);
   _prvTidyFixXhtmlNamespace($tdoc, 1);
   _prvTidyFixLanguageInformation($tdoc, $tdoc, 1, 1);
  } else if (!(HEAP32[(HEAP32[$tdoc + 68 >> 2] | 0) + 28 >> 2] | 0)) label = 34; else {
   $80 = _prvTidyFindDocType($tdoc) | 0;
   if (!$80) label = 34; else {
    _prvTidyRemoveNode($80) | 0;
    label = 34;
   }
  }
  if ((label | 0) == 34) {
   _prvTidyFixDocType($tdoc) | 0;
   _prvTidyFixAnchors($tdoc, $tdoc, $24, 1);
   _prvTidyFixXhtmlNamespace($tdoc, 0);
   _prvTidyFixLanguageInformation($tdoc, $tdoc, 0, 1);
  }
  if ($20 | 0) _prvTidyAddGenerator($tdoc) | 0;
 }
 if (($14 | 0) != 0 & ($18 | 0) != 0) _prvTidyFixXmlDecl($tdoc) | 0;
 $87 = HEAP32[$tdoc + 68 >> 2] | 0;
 if ($87 | 0) {
  if (HEAP32[$87 + 40 >> 2] & 393216 | 0) _prvTidyCheckHTML5($tdoc, $tdoc);
  _prvTidyCheckHTMLTagsAttribsVersions($tdoc, $tdoc);
 }
 if (HEAP32[$tdoc + 6812 >> 2] | 0) {
  $$0 = 2;
  return $$0 | 0;
 }
 if (HEAP32[$tdoc + 6816 >> 2] | 0) {
  $$0 = 1;
  return $$0 | 0;
 }
 $$0 = (HEAP32[$tdoc + 6820 >> 2] | 0) != 0 & 1;
 return $$0 | 0;
}

function _CheckScriptKeyboardAccessible($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $5 = 0, $7 = 0, $HasOnClick$0110 = 0, $HasOnClick$251 = 0, $HasOnClick$251$lcssa = 0, $HasOnMouseDown$0108 = 0, $HasOnMouseDown$2374050 = 0, $HasOnMouseDown$2374050$lcssa = 0, $HasOnMouseMove$0113 = 0, $HasOnMouseMove$130334348 = 0, $HasOnMouseMove$130334348$lcssa = 0, $HasOnMouseOut$0111 = 0, $HasOnMouseOut$2 = 0, $HasOnMouseOut$2$lcssa = 0, $HasOnMouseOver$0112 = 0, $HasOnMouseOver$12326364149 = 0, $HasOnMouseOver$12326364149$lcssa = 0, $HasOnMouseUp$0109 = 0, $HasOnMouseUp$24447 = 0, $HasOnMouseUp$24447$lcssa = 0, $av$0107 = 0, $av$0114 = 0, $content$0105 = 0, $content$0106 = 0;
 if ((HEAP32[$doc + 6396 >> 2] | 1 | 0) != 3) return;
 $av$0107 = HEAP32[$node + 20 >> 2] | 0;
 if ($av$0107 | 0) {
  $HasOnClick$0110 = 0;
  $HasOnMouseDown$0108 = 0;
  $HasOnMouseMove$0113 = 0;
  $HasOnMouseOut$0111 = 0;
  $HasOnMouseOver$0112 = 0;
  $HasOnMouseUp$0109 = 0;
  $av$0114 = $av$0107;
  while (1) {
   $5 = HEAP32[$av$0114 + 4 >> 2] | 0;
   if (!$5) {
    $HasOnClick$251 = $HasOnClick$0110;
    $HasOnMouseDown$2374050 = $HasOnMouseDown$0108;
    $HasOnMouseMove$130334348 = $HasOnMouseMove$0113;
    $HasOnMouseOut$2 = $HasOnMouseOut$0111;
    $HasOnMouseOver$12326364149 = $HasOnMouseOver$0112;
    $HasOnMouseUp$24447 = $HasOnMouseUp$0109;
   } else {
    $7 = HEAP32[$5 >> 2] | 0;
    $HasOnClick$251 = (($7 | 0) == 104 & 1) + ((($7 | 0) == 96 & 1) + $HasOnClick$0110) | 0;
    $HasOnMouseDown$2374050 = (($7 | 0) == 103 & 1) + ((($7 | 0) == 107 & 1) + $HasOnMouseDown$0108) | 0;
    $HasOnMouseMove$130334348 = (($7 | 0) == 108 & 1) + $HasOnMouseMove$0113 | 0;
    $HasOnMouseOut$2 = (($7 | 0) == 94 & 1) + ((($7 | 0) == 109 & 1) + $HasOnMouseOut$0111) | 0;
    $HasOnMouseOver$12326364149 = (($7 | 0) == 110 & 1) + $HasOnMouseOver$0112 | 0;
    $HasOnMouseUp$24447 = (($7 | 0) == 105 & 1) + ((($7 | 0) == 111 & 1) + $HasOnMouseUp$0109) | 0;
   }
   $av$0114 = HEAP32[$av$0114 >> 2] | 0;
   if (!$av$0114) {
    $HasOnClick$251$lcssa = $HasOnClick$251;
    $HasOnMouseDown$2374050$lcssa = $HasOnMouseDown$2374050;
    $HasOnMouseMove$130334348$lcssa = $HasOnMouseMove$130334348;
    $HasOnMouseOut$2$lcssa = $HasOnMouseOut$2;
    $HasOnMouseOver$12326364149$lcssa = $HasOnMouseOver$12326364149;
    $HasOnMouseUp$24447$lcssa = $HasOnMouseUp$24447;
    break;
   } else {
    $HasOnClick$0110 = $HasOnClick$251;
    $HasOnMouseDown$0108 = $HasOnMouseDown$2374050;
    $HasOnMouseMove$0113 = $HasOnMouseMove$130334348;
    $HasOnMouseOut$0111 = $HasOnMouseOut$2;
    $HasOnMouseOver$0112 = $HasOnMouseOver$12326364149;
    $HasOnMouseUp$0109 = $HasOnMouseUp$24447;
   }
  }
  if (($HasOnMouseDown$2374050$lcssa | 0) == 1) _prvTidyReportAccessError($doc, $node, 392);
  if (($HasOnMouseUp$24447$lcssa | 0) == 1) _prvTidyReportAccessError($doc, $node, 393);
  if (($HasOnClick$251$lcssa | 0) == 1) _prvTidyReportAccessError($doc, $node, 394);
  if (($HasOnMouseOut$2$lcssa | 0) == 1) _prvTidyReportAccessError($doc, $node, 396);
  if (($HasOnMouseOver$12326364149$lcssa | 0) == 1) _prvTidyReportAccessError($doc, $node, 395);
  if (($HasOnMouseMove$130334348$lcssa | 0) == 1) _prvTidyReportAccessError($doc, $node, 397);
 }
 $content$0105 = HEAP32[$node + 12 >> 2] | 0;
 if (!$content$0105) return; else $content$0106 = $content$0105;
 do {
  _CheckScriptKeyboardAccessible($doc, $content$0106);
  $content$0106 = HEAP32[$content$0106 + 8 >> 2] | 0;
 } while (($content$0106 | 0) != 0);
 return;
}

function _GetRgb($color, $rgb) {
 $color = $color | 0;
 $rgb = $rgb | 0;
 var $$0 = 0, $15 = 0, $16 = 0, $23 = 0, $24 = 0, $26 = 0, $27 = 0, $35 = 0, $37 = 0, $38 = 0, $45 = 0, $46 = 0, $48 = 0, $49 = 0, $57 = 0, $60 = 0, $61 = 0, $68 = 0, $69 = 0, $71 = 0, $72 = 0, $80 = 0, $x$032$lcssa = 0;
 if (!(_strstr(311730, $color) | 0)) if (!(_strstr(311736, $color) | 0)) if (!(_strstr(311743, $color) | 0)) if (!(_strstr(311748, $color) | 0)) if (!(_strstr(311754, $color) | 0)) if (!(_strstr(311761, $color) | 0)) if (!(_strstr(311765, $color) | 0)) if (!(_strstr(311772, $color) | 0)) if (!(_strstr(311780, $color) | 0)) if (!(_strstr(311786, $color) | 0)) if (!(_strstr(311791, $color) | 0)) if (!(_strstr(311797, $color) | 0)) if (!(_strstr(311804, $color) | 0)) if (!(_strstr(311809, $color) | 0)) if (!(_strstr(311814, $color) | 0)) if (!(_strstr(311819, $color) | 0)) {
  if ((_prvTidytmbstrlen($color) | 0) != 7) {
   $$0 = 0;
   return $$0 | 0;
  }
  if ((HEAP8[$color >> 0] | 0) != 35) {
   $$0 = 0;
   return $$0 | 0;
  }
  $15 = HEAP8[$color + 1 >> 0] | 0;
  $16 = $15 << 24 >> 24;
  do if (($15 + -48 & 255) < 10) $24 = $16 + -48 | 0; else if (($15 + -97 & 255) < 6) {
   $24 = $16 + -87 | 0;
   break;
  } else {
   $24 = ($15 + -65 & 255) < 6 ? $16 + -55 | 0 : -1;
   break;
  } while (0);
  $23 = $24 << 4;
  $26 = HEAP8[$color + 2 >> 0] | 0;
  $27 = $26 << 24 >> 24;
  do if (($26 + -48 & 255) < 10) $35 = $27 + -48 | 0; else if (($26 + -97 & 255) < 6) {
   $35 = $27 + -87 | 0;
   break;
  } else {
   $35 = ($26 + -65 & 255) < 6 ? $27 + -55 | 0 : -1;
   break;
  } while (0);
  HEAP32[$rgb >> 2] = $35 + $23;
  $37 = HEAP8[$color + 3 >> 0] | 0;
  $38 = $37 << 24 >> 24;
  do if (($37 + -48 & 255) < 10) $46 = $38 + -48 | 0; else if (($37 + -97 & 255) < 6) {
   $46 = $38 + -87 | 0;
   break;
  } else {
   $46 = ($37 + -65 & 255) < 6 ? $38 + -55 | 0 : -1;
   break;
  } while (0);
  $45 = $46 << 4;
  $48 = HEAP8[$color + 4 >> 0] | 0;
  $49 = $48 << 24 >> 24;
  do if (($48 + -48 & 255) < 10) $57 = $49 + -48 | 0; else if (($48 + -97 & 255) < 6) {
   $57 = $49 + -87 | 0;
   break;
  } else {
   $57 = ($48 + -65 & 255) < 6 ? $49 + -55 | 0 : -1;
   break;
  } while (0);
  HEAP32[$rgb + 4 >> 2] = $57 + $45;
  $60 = HEAP8[$color + 5 >> 0] | 0;
  $61 = $60 << 24 >> 24;
  do if (($60 + -48 & 255) < 10) $69 = $61 + -48 | 0; else if (($60 + -97 & 255) < 6) {
   $69 = $61 + -87 | 0;
   break;
  } else {
   $69 = ($60 + -65 & 255) < 6 ? $61 + -55 | 0 : -1;
   break;
  } while (0);
  $68 = $69 << 4;
  $71 = HEAP8[$color + 6 >> 0] | 0;
  $72 = $71 << 24 >> 24;
  do if (($71 + -48 & 255) < 10) $80 = $72 + -48 | 0; else if (($71 + -97 & 255) < 6) {
   $80 = $72 + -87 | 0;
   break;
  } else {
   $80 = ($71 + -65 & 255) < 6 ? $72 + -55 | 0 : -1;
   break;
  } while (0);
  HEAP32[$rgb + 8 >> 2] = $80 + $68;
  $$0 = 1;
  return $$0 | 0;
 } else $x$032$lcssa = 15; else $x$032$lcssa = 14; else $x$032$lcssa = 13; else $x$032$lcssa = 12; else $x$032$lcssa = 11; else $x$032$lcssa = 10; else $x$032$lcssa = 9; else $x$032$lcssa = 8; else $x$032$lcssa = 7; else $x$032$lcssa = 6; else $x$032$lcssa = 5; else $x$032$lcssa = 4; else $x$032$lcssa = 3; else $x$032$lcssa = 2; else $x$032$lcssa = 1; else $x$032$lcssa = 0;
 HEAP32[$rgb >> 2] = HEAP32[216844 + ($x$032$lcssa * 12 | 0) >> 2];
 HEAP32[$rgb + 4 >> 2] = HEAP32[216844 + ($x$032$lcssa * 12 | 0) + 4 >> 2];
 HEAP32[$rgb + 8 >> 2] = HEAP32[216844 + ($x$032$lcssa * 12 | 0) + 8 >> 2];
 $$0 = 1;
 return $$0 | 0;
}

function _prvTidySwitchInline($doc, $element, $node) {
 $doc = $doc | 0;
 $element = $element | 0;
 $node = $node | 0;
 var $$4 = 0, $$lcssa51 = 0, $$lcssa52 = 0, $1 = 0, $12 = 0, $13 = 0, $15 = 0, $25 = 0, $32 = 0, $37 = 0, $39 = 0, $41 = 0, $5 = 0, $9 = 0, $i$0$in$be = 0, $i$0$in$i = 0, $i$0$in$i7 = 0, $i$0$in22 = 0, $i$021 = 0, $i$023 = 0, $i$023$lcssa = 0, $i$120 = 0, $i$120$lcssa = 0, $tmp_istack = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $tmp_istack = sp;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 if (!(($element | 0) != 0 & ($1 | 0) != 0)) {
  $$4 = 0;
  STACKTOP = sp;
  return $$4 | 0;
 }
 $5 = HEAP32[$element + 28 >> 2] | 0;
 if (!(($node | 0) != 0 & ($5 | 0) != 0)) {
  $$4 = 0;
  STACKTOP = sp;
  return $$4 | 0;
 }
 $9 = HEAP32[$node + 28 >> 2] | 0;
 if (!$9) {
  $$4 = 0;
  STACKTOP = sp;
  return $$4 | 0;
 }
 $12 = HEAP32[$1 + 112 >> 2] | 0;
 $13 = $1 + 104 | 0;
 $i$0$in$i = $12;
 while (1) {
  $i$0$in$i = $i$0$in$i + -1 | 0;
  if (($i$0$in$i | 0) <= -1) {
   $$4 = 0;
   label = 19;
   break;
  }
  $15 = HEAP32[$13 >> 2] | 0;
  if ((HEAP32[$15 + ($i$0$in$i << 4) + 4 >> 2] | 0) == ($5 | 0)) {
   $$lcssa52 = $15;
   break;
  }
 }
 if ((label | 0) == 19) {
  STACKTOP = sp;
  return $$4 | 0;
 }
 $i$0$in$i7 = $12;
 do {
  $i$0$in$i7 = $i$0$in$i7 + -1 | 0;
  if (($i$0$in$i7 | 0) <= -1) {
   $$4 = 0;
   label = 19;
   break;
  }
 } while ((HEAP32[$$lcssa52 + ($i$0$in$i7 << 4) + 4 >> 2] | 0) != ($9 | 0));
 if ((label | 0) == 19) {
  STACKTOP = sp;
  return $$4 | 0;
 }
 $25 = $12 - (HEAP32[$1 + 116 >> 2] | 0) | 0;
 if ($25 >>> 0 <= 1) {
  $$4 = 0;
  STACKTOP = sp;
  return $$4 | 0;
 }
 $i$021 = $25 + -1 | 0;
 if (($i$021 | 0) > -1) {
  $i$0$in22 = $25;
  $i$023 = $i$021;
 } else {
  $$4 = 0;
  STACKTOP = sp;
  return $$4 | 0;
 }
 L27 : while (1) {
  L29 : do if ((HEAP32[$$lcssa52 + ($i$023 << 4) + 4 >> 2] | 0) == ($5 | 0)) {
   $32 = $i$0$in22 + -2 | 0;
   if (($32 | 0) > -1) {
    $i$120 = $32;
    while (1) {
     if ((HEAP32[$$lcssa52 + ($i$120 << 4) + 4 >> 2] | 0) == ($9 | 0)) {
      $i$120$lcssa = $i$120;
      break;
     }
     $37 = $i$120 + -1 | 0;
     if (($i$120 | 0) > 0) $i$120 = $37; else {
      $i$0$in$be = $37;
      break L29;
     }
    }
    $39 = $$lcssa52 + ($i$120$lcssa << 4) | 0;
    if (!$39) $i$0$in$be = $i$120$lcssa; else {
     $$lcssa51 = $39;
     $i$023$lcssa = $i$023;
     break L27;
    }
   } else $i$0$in$be = $32;
  } else $i$0$in$be = $i$023; while (0);
  $i$023 = $i$0$in$be + -1 | 0;
  if (($i$023 | 0) <= -1) {
   $$4 = 0;
   label = 19;
   break;
  } else $i$0$in22 = $i$0$in$be;
 }
 if ((label | 0) == 19) {
  STACKTOP = sp;
  return $$4 | 0;
 }
 $41 = $$lcssa52 + ($i$023$lcssa << 4) | 0;
 HEAP32[$tmp_istack >> 2] = HEAP32[$$lcssa51 >> 2];
 HEAP32[$tmp_istack + 4 >> 2] = HEAP32[$$lcssa51 + 4 >> 2];
 HEAP32[$tmp_istack + 8 >> 2] = HEAP32[$$lcssa51 + 8 >> 2];
 HEAP32[$tmp_istack + 12 >> 2] = HEAP32[$$lcssa51 + 12 >> 2];
 HEAP32[$$lcssa51 >> 2] = HEAP32[$41 >> 2];
 HEAP32[$$lcssa51 + 4 >> 2] = HEAP32[$41 + 4 >> 2];
 HEAP32[$$lcssa51 + 8 >> 2] = HEAP32[$41 + 8 >> 2];
 HEAP32[$$lcssa51 + 12 >> 2] = HEAP32[$41 + 12 >> 2];
 HEAP32[$41 >> 2] = HEAP32[$tmp_istack >> 2];
 HEAP32[$41 + 4 >> 2] = HEAP32[$tmp_istack + 4 >> 2];
 HEAP32[$41 + 8 >> 2] = HEAP32[$tmp_istack + 8 >> 2];
 HEAP32[$41 + 12 >> 2] = HEAP32[$tmp_istack + 12 >> 2];
 $$4 = 1;
 STACKTOP = sp;
 return $$4 | 0;
}

function _prvTidyFreeAttrTable($doc) {
 $doc = $doc | 0;
 var $$01$i$i$i = 0, $$lcssa = 0, $$lcssa23 = 0, $0 = 0, $1 = 0, $12 = 0, $13 = 0, $16 = 0, $17 = 0, $2 = 0, $23 = 0, $30 = 0, $31 = 0, $34 = 0, $36 = 0, $37 = 0, $38 = 0, $41 = 0, $43 = 0, $47 = 0, $49 = 0, $55 = 0, $56 = 0, $59 = 0, $6 = 0, $63 = 0, $68 = 0, $dict$01$i = 0, $h$01$i = 0, $hashval$0$lcssa$i$i$i = 0, $hashval$02$i$i$i = 0, $i$02$i = 0, $p$0$i$i = 0, $p$0$i$i$lcssa22 = 0, $p$0$in$i$i = 0, $prev$0$i$i = 0, $prev$0$i$i$lcssa21 = 0, label = 0, $dict$01$i$looptemp = 0;
 $0 = $doc + 6856 | 0;
 $i$02$i = 0;
 do {
  $1 = $doc + 5684 + ($i$02$i << 2) | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  if ($2 | 0) {
   $dict$01$i = $2;
   do {
    $dict$01$i$looptemp = $dict$01$i;
    $dict$01$i = HEAP32[$dict$01$i + 4 >> 2] | 0;
    $6 = HEAP32[$0 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$6 >> 2] | 0) + 8 >> 2] & 15]($6, $dict$01$i$looptemp);
   } while (($dict$01$i | 0) != 0);
  }
  HEAP32[$1 >> 2] = 0;
  $i$02$i = $i$02$i + 1 | 0;
 } while (($i$02$i | 0) != 178);
 $h$01$i = 0;
 do {
  $12 = $doc + 1596 + ($h$01$i << 2) | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  if ($13 | 0) {
   $16 = $13;
   do {
    HEAP32[$12 >> 2] = HEAP32[$16 >> 2];
    $17 = HEAP32[$0 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$17 >> 2] | 0) + 8 >> 2] & 15]($17, HEAP32[$16 + 8 >> 2] | 0);
    $23 = HEAP32[$0 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$23 >> 2] | 0) + 8 >> 2] & 15]($23, $16);
    $16 = HEAP32[$12 >> 2] | 0;
   } while (($16 | 0) != 0);
  }
  $h$01$i = $h$01$i + 1 | 0;
 } while (($h$01$i | 0) != 1021);
 $30 = $doc + 5680 | 0;
 $31 = HEAP32[$30 >> 2] | 0;
 if (!$31) return;
 $34 = $31;
 do {
  HEAP32[$30 >> 2] = HEAP32[$34 + 12 >> 2];
  $36 = $34 + 4 | 0;
  $37 = HEAP32[$36 >> 2] | 0;
  $38 = HEAP8[$37 >> 0] | 0;
  if (!($38 << 24 >> 24)) $hashval$0$lcssa$i$i$i = 0; else {
   $$01$i$i$i = $37;
   $41 = $38;
   $hashval$02$i$i$i = 0;
   while (1) {
    $43 = ($hashval$02$i$i$i * 31 | 0) + ($41 << 24 >> 24) | 0;
    $$01$i$i$i = $$01$i$i$i + 1 | 0;
    $41 = HEAP8[$$01$i$i$i >> 0] | 0;
    if (!($41 << 24 >> 24)) {
     $$lcssa = $43;
     break;
    } else $hashval$02$i$i$i = $43;
   }
   $hashval$0$lcssa$i$i$i = ($$lcssa >>> 0) % 178 | 0;
  }
  $47 = $doc + 5684 + ($hashval$0$lcssa$i$i$i << 2) | 0;
  $p$0$in$i$i = $47;
  $prev$0$i$i = 0;
  while (1) {
   $p$0$i$i = HEAP32[$p$0$in$i$i >> 2] | 0;
   if (!$p$0$i$i) break;
   $49 = HEAP32[$p$0$i$i >> 2] | 0;
   if (!$49) break;
   $55 = $p$0$i$i + 4 | 0;
   if (!(_prvTidytmbstrcmp($37, HEAP32[$49 + 4 >> 2] | 0) | 0)) {
    $$lcssa23 = $55;
    $p$0$i$i$lcssa22 = $p$0$i$i;
    $prev$0$i$i$lcssa21 = $prev$0$i$i;
    label = 18;
    break;
   } else {
    $p$0$in$i$i = $55;
    $prev$0$i$i = $p$0$i$i;
   }
  }
  if ((label | 0) == 18) {
   label = 0;
   $56 = HEAP32[$$lcssa23 >> 2] | 0;
   if (!$prev$0$i$i$lcssa21) HEAP32[$47 >> 2] = $56; else HEAP32[$prev$0$i$i$lcssa21 + 4 >> 2] = $56;
   $59 = HEAP32[$0 >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$59 >> 2] | 0) + 8 >> 2] & 15]($59, $p$0$i$i$lcssa22);
  }
  $63 = HEAP32[$0 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$63 >> 2] | 0) + 8 >> 2] & 15]($63, HEAP32[$36 >> 2] | 0);
  $68 = HEAP32[$0 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$68 >> 2] | 0) + 8 >> 2] & 15]($68, $34);
  $34 = HEAP32[$30 >> 2] | 0;
 } while (($34 | 0) != 0);
 return;
}

function _prvTidyParseText($doc, $field, $mode) {
 $doc = $doc | 0;
 $field = $field | 0;
 $mode = $mode | 0;
 var $$0$ph = 0, $$lcssa4 = 0, $$lcssa5 = 0, $$pre = 0, $11 = 0, $14 = 0, $15 = 0, $16 = 0, $34 = 0, $39 = 0, $47 = 0, $48 = 0, $5 = 0, $67 = 0, $72 = 0, $9 = 0, label = 0;
 HEAP32[(HEAP32[$doc + 68 >> 2] | 0) + 100 >> 2] = 0;
 if (!$field) label = 4; else {
  $5 = HEAP32[$field + 28 >> 2] | 0;
  if (!$5) label = 4; else if ((HEAP32[$5 >> 2] | 0) == 110) $$0$ph = 2; else label = 4;
 }
 if ((label | 0) == 4) $$0$ph = 1;
 $9 = _prvTidyGetToken($doc, $$0$ph) | 0;
 $$pre = $field + 28 | 0;
 L7 : do if ($9 | 0) {
  $11 = $field + 12 | 0;
  $14 = $field + 16 | 0;
  L9 : do if (!($$0$ph & 2)) {
   $16 = $9;
   while (1) {
    $15 = $16 + 28 | 0;
    if ((HEAP32[$15 >> 2] | 0) == (HEAP32[$$pre >> 2] | 0)) if ((HEAP32[$16 + 44 >> 2] | 0) == 6) {
     $$lcssa4 = $16;
     label = 25;
     break L9;
    }
    do if (!(_InsertMisc($field, $16) | 0)) {
     if (!(_prvTidynodeIsText($16) | 0)) {
      $39 = HEAP32[$15 >> 2] | 0;
      if (!$39) {
       $$lcssa5 = $16;
       break L9;
      }
      if ((HEAP32[$39 + 16 >> 2] & 1040 | 0) != 16) {
       $$lcssa5 = $16;
       break L9;
      }
      _prvTidyReportError($doc, $field, $16, 208);
      _prvTidyFreeNode($doc, $16);
      break;
     }
     if (!(HEAP32[$11 >> 2] | 0)) _TrimSpaces($doc, $field);
     if ((HEAP32[$16 + 36 >> 2] | 0) >>> 0 >= (HEAP32[$16 + 40 >> 2] | 0) >>> 0) {
      _prvTidyFreeNode($doc, $16);
      break;
     }
     HEAP32[$16 >> 2] = $field;
     $34 = HEAP32[$14 >> 2] | 0;
     HEAP32[$16 + 4 >> 2] = $34;
     if (!$34) HEAP32[$11 >> 2] = $16; else HEAP32[$34 + 8 >> 2] = $16;
     HEAP32[$14 >> 2] = $16;
    } while (0);
    $16 = _prvTidyGetToken($doc, $$0$ph) | 0;
    if (!$16) break L7;
   }
  } else {
   $48 = $9;
   while (1) {
    $47 = $48 + 28 | 0;
    if ((HEAP32[$47 >> 2] | 0) == (HEAP32[$$pre >> 2] | 0)) if ((HEAP32[$48 + 44 >> 2] | 0) == 6) {
     $$lcssa4 = $48;
     label = 25;
     break L9;
    }
    do if (!(_InsertMisc($field, $48) | 0)) {
     if (!(_prvTidynodeIsText($48) | 0)) {
      $72 = HEAP32[$47 >> 2] | 0;
      if (!$72) {
       $$lcssa5 = $48;
       break L9;
      }
      if ((HEAP32[$72 + 16 >> 2] & 1040 | 0) != 16) {
       $$lcssa5 = $48;
       break L9;
      }
      _prvTidyReportError($doc, $field, $48, 208);
      _prvTidyFreeNode($doc, $48);
      break;
     }
     if ((HEAP32[$48 + 36 >> 2] | 0) >>> 0 >= (HEAP32[$48 + 40 >> 2] | 0) >>> 0) {
      _prvTidyFreeNode($doc, $48);
      break;
     }
     HEAP32[$48 >> 2] = $field;
     $67 = HEAP32[$14 >> 2] | 0;
     HEAP32[$48 + 4 >> 2] = $67;
     if (!$67) HEAP32[$11 >> 2] = $48; else HEAP32[$67 + 8 >> 2] = $48;
     HEAP32[$14 >> 2] = $48;
    } while (0);
    $48 = _prvTidyGetToken($doc, $$0$ph) | 0;
    if (!$48) break L7;
   }
  } while (0);
  if ((label | 0) == 25) {
   _prvTidyFreeNode($doc, $$lcssa4);
   HEAP32[$field + 56 >> 2] = 1;
   _TrimSpaces($doc, $field);
   return;
  }
  if (!(HEAP32[(HEAP32[$$pre >> 2] | 0) + 16 >> 2] & 32768)) _prvTidyReportError($doc, $field, $$lcssa5, 207);
  _prvTidyUngetToken($doc);
  _TrimSpaces($doc, $field);
  return;
 } while (0);
 if (HEAP32[(HEAP32[$$pre >> 2] | 0) + 16 >> 2] & 32768 | 0) return;
 _prvTidyReportError($doc, $field, 0, 206);
 return;
}

function _scanexp($f, $pok) {
 $f = $f | 0;
 $pok = $pok | 0;
 var $$lcssa22 = 0, $0 = 0, $1 = 0, $11 = 0, $12 = 0, $2 = 0, $20 = 0, $35 = 0, $36 = 0, $48 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $59 = 0, $61 = 0, $62 = 0, $63 = 0, $78 = 0, $9 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $98 = 0, $99 = 0, $c$0 = 0, $c$1$be = 0, $c$1$be$lcssa = 0, $c$112 = 0, $c$2$be = 0, $c$2$lcssa = 0, $c$27 = 0, $c$3$be = 0, $neg$0 = 0, $x$013 = 0;
 $0 = $f + 4 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $f + 100 | 0;
 if ($1 >>> 0 < (HEAP32[$2 >> 2] | 0) >>> 0) {
  HEAP32[$0 >> 2] = $1 + 1;
  $9 = HEAPU8[$1 >> 0] | 0;
 } else $9 = ___shgetc($f) | 0;
 switch ($9 | 0) {
 case 43:
 case 45:
  {
   $11 = ($9 | 0) == 45 & 1;
   $12 = HEAP32[$0 >> 2] | 0;
   if ($12 >>> 0 < (HEAP32[$2 >> 2] | 0) >>> 0) {
    HEAP32[$0 >> 2] = $12 + 1;
    $20 = HEAPU8[$12 >> 0] | 0;
   } else $20 = ___shgetc($f) | 0;
   if (($pok | 0) != 0 & ($20 + -48 | 0) >>> 0 > 9) if (!(HEAP32[$2 >> 2] | 0)) {
    $c$0 = $20;
    $neg$0 = $11;
   } else {
    HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
    $c$0 = $20;
    $neg$0 = $11;
   } else {
    $c$0 = $20;
    $neg$0 = $11;
   }
   break;
  }
 default:
  {
   $c$0 = $9;
   $neg$0 = 0;
  }
 }
 if (($c$0 + -48 | 0) >>> 0 > 9) if (!(HEAP32[$2 >> 2] | 0)) {
  $98 = -2147483648;
  $99 = 0;
 } else {
  HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
  $98 = -2147483648;
  $99 = 0;
 } else {
  $c$112 = $c$0;
  $x$013 = 0;
  while (1) {
   $35 = $c$112 + -48 + ($x$013 * 10 | 0) | 0;
   $36 = HEAP32[$0 >> 2] | 0;
   if ($36 >>> 0 < (HEAP32[$2 >> 2] | 0) >>> 0) {
    HEAP32[$0 >> 2] = $36 + 1;
    $c$1$be = HEAPU8[$36 >> 0] | 0;
   } else $c$1$be = ___shgetc($f) | 0;
   if (($c$1$be + -48 | 0) >>> 0 < 10 & ($35 | 0) < 214748364) {
    $c$112 = $c$1$be;
    $x$013 = $35;
   } else {
    $$lcssa22 = $35;
    $c$1$be$lcssa = $c$1$be;
    break;
   }
  }
  $48 = (($$lcssa22 | 0) < 0) << 31 >> 31;
  if (($c$1$be$lcssa + -48 | 0) >>> 0 < 10) {
   $53 = $$lcssa22;
   $54 = $48;
   $c$27 = $c$1$be$lcssa;
   while (1) {
    $55 = ___muldi3($53 | 0, $54 | 0, 10, 0) | 0;
    $56 = tempRet0;
    $59 = _i64Add($c$27 | 0, (($c$27 | 0) < 0) << 31 >> 31 | 0, -48, -1) | 0;
    $61 = _i64Add($59 | 0, tempRet0 | 0, $55 | 0, $56 | 0) | 0;
    $62 = tempRet0;
    $63 = HEAP32[$0 >> 2] | 0;
    if ($63 >>> 0 < (HEAP32[$2 >> 2] | 0) >>> 0) {
     HEAP32[$0 >> 2] = $63 + 1;
     $c$2$be = HEAPU8[$63 >> 0] | 0;
    } else $c$2$be = ___shgetc($f) | 0;
    if (($c$2$be + -48 | 0) >>> 0 < 10 & (($62 | 0) < 21474836 | ($62 | 0) == 21474836 & $61 >>> 0 < 2061584302)) {
     $53 = $61;
     $54 = $62;
     $c$27 = $c$2$be;
    } else {
     $92 = $61;
     $93 = $62;
     $c$2$lcssa = $c$2$be;
     break;
    }
   }
  } else {
   $92 = $$lcssa22;
   $93 = $48;
   $c$2$lcssa = $c$1$be$lcssa;
  }
  if (($c$2$lcssa + -48 | 0) >>> 0 < 10) do {
   $78 = HEAP32[$0 >> 2] | 0;
   if ($78 >>> 0 < (HEAP32[$2 >> 2] | 0) >>> 0) {
    HEAP32[$0 >> 2] = $78 + 1;
    $c$3$be = HEAPU8[$78 >> 0] | 0;
   } else $c$3$be = ___shgetc($f) | 0;
  } while (($c$3$be + -48 | 0) >>> 0 < 10);
  if (HEAP32[$2 >> 2] | 0) HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
  $91 = ($neg$0 | 0) != 0;
  $94 = _i64Subtract(0, 0, $92 | 0, $93 | 0) | 0;
  $98 = $91 ? tempRet0 : $93;
  $99 = $91 ? $94 : $92;
 }
 tempRet0 = $98;
 return $99 | 0;
}

function _EncloseBlockText($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0$be = 0, $$08 = 0, $1 = 0, $11 = 0, $15 = 0, $19 = 0, $21 = 0, $3 = 0, $36 = 0, $37 = 0, $39 = 0, $4 = 0, $41 = 0, $42 = 0, $45 = 0, $48 = 0, $49 = 0, $5 = 0, $56 = 0, $58 = 0, $59 = 0, $64 = 0, $66 = 0, $68 = 0, $70 = 0, $73 = 0, $77 = 0, $8 = 0, $block$07 = 0, label = 0, $block$07$looptemp = 0;
 if (!$node) return;
 $1 = $doc + 68 | 0;
 $$08 = $node;
 while (1) {
  $3 = HEAP32[$$08 + 8 >> 2] | 0;
  $4 = $$08 + 12 | 0;
  $5 = HEAP32[$4 >> 2] | 0;
  if ($5 | 0) _EncloseBlockText($doc, $5);
  $8 = HEAP32[$$08 + 28 >> 2] | 0;
  L9 : do if (!$8) $$0$be = $3; else {
   switch (HEAP32[$8 >> 2] | 0) {
   case 15:
   case 75:
   case 37:
    break;
   default:
    {
     $$0$be = $3;
     break L9;
    }
   }
   $11 = HEAP32[$4 >> 2] | 0;
   if (!$11) $$0$be = $3; else {
    if (!(_prvTidynodeIsText($11) | 0)) label = 13; else {
     $15 = HEAP32[$1 >> 2] | 0;
     if (_prvTidynodeIsText($11) | 0) {
      $19 = HEAP32[$11 + 40 >> 2] | 0;
      $21 = HEAP32[$11 + 36 >> 2] | 0;
      if (($19 | 0) == ($21 | 0)) label = 13; else if (($19 | 0) == ($21 + 1 | 0)) if ((HEAP8[(HEAP32[$15 + 84 >> 2] | 0) + $21 >> 0] | 0) == 32) label = 13;
     }
    }
    if ((label | 0) == 13) {
     label = 0;
     if (!(_prvTidynodeIsElement($11) | 0)) {
      $$0$be = $3;
      break;
     }
     if (!(_prvTidynodeHasCM($11, 16) | 0)) {
      $$0$be = $3;
      break;
     }
     if (_prvTidynodeHasCM($11, 8) | 0) {
      $$0$be = $3;
      break;
     }
    }
    $36 = _prvTidyInferredTag($doc, 80) | 0;
    $37 = HEAP32[$11 >> 2] | 0;
    HEAP32[$36 >> 2] = $37;
    HEAP32[$36 + 8 >> 2] = $11;
    $39 = $11 + 4 | 0;
    $41 = $36 + 4 | 0;
    HEAP32[$41 >> 2] = HEAP32[$39 >> 2];
    HEAP32[$39 >> 2] = $36;
    $42 = HEAP32[$41 >> 2] | 0;
    if ($42 | 0) HEAP32[$42 + 8 >> 2] = $36;
    $45 = $37 + 12 | 0;
    if ((HEAP32[$45 >> 2] | 0) == ($11 | 0)) HEAP32[$45 >> 2] = $36;
    $48 = $36 + 16 | 0;
    $49 = $36 + 12 | 0;
    $block$07 = $11;
    do {
     if (_prvTidynodeIsElement($block$07) | 0) {
      if (!(_prvTidynodeHasCM($block$07, 16) | 0)) break;
      if (_prvTidynodeHasCM($block$07, 8) | 0) break;
     }
     $56 = $block$07 + 8 | 0;
     $block$07$looptemp = $block$07;
     $block$07 = HEAP32[$56 >> 2] | 0;
     $58 = $block$07$looptemp + 4 | 0;
     $59 = HEAP32[$58 >> 2] | 0;
     if (!$59) $64 = $block$07; else {
      HEAP32[$59 + 8 >> 2] = $block$07;
      $64 = HEAP32[$56 >> 2] | 0;
     }
     $66 = $64;
     if ($64 | 0) HEAP32[$64 + 4 >> 2] = $59;
     $68 = HEAP32[$block$07$looptemp >> 2] | 0;
     if ($68 | 0) {
      $70 = $68 + 12 | 0;
      if ((HEAP32[$70 >> 2] | 0) == ($block$07$looptemp | 0)) HEAP32[$70 >> 2] = $66;
      $73 = $68 + 16 | 0;
      if ((HEAP32[$73 >> 2] | 0) == ($block$07$looptemp | 0)) HEAP32[$73 >> 2] = HEAP32[$58 >> 2];
     }
     HEAP32[$56 >> 2] = 0;
     HEAP32[$block$07$looptemp >> 2] = $36;
     $77 = HEAP32[$48 >> 2] | 0;
     HEAP32[$58 >> 2] = $77;
     if (!$77) HEAP32[$49 >> 2] = $block$07$looptemp; else HEAP32[$77 + 8 >> 2] = $block$07$looptemp;
     HEAP32[$48 >> 2] = $block$07$looptemp;
    } while (($block$07 | 0) != 0);
    _TrimSpaces($doc, $36);
    $$0$be = $$08;
   }
  } while (0);
  if (!$$0$be) break; else $$08 = $$0$be;
 }
 return;
}

function _CheckRows($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$05 = 0, $$lcssa = 0, $0 = 0, $12 = 0, $22 = 0, $25 = 0, $26 = 0, $37 = 0, $4 = 0, $41 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cp$03$i = 0, $i$02$i = 0, $isWht$0$lcssa$i = 0, $isWht$02$i = 0, $numTR$0$lcssa10 = 0, $numTR$0$lcssa9 = 0, $numTR$03 = 0, $numValidTH$0$lcssa7 = 0, $numValidTH$0$lcssa8 = 0, $numValidTH$04 = 0, $numValidTH$2 = 0, $numValidTH$2$lcssa = 0, $x$01$i = 0, $x$1$i = 0, label = 0;
 $0 = $doc + 6668 | 0;
 HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + 1;
 if (!$node) {
  $numTR$0$lcssa10 = 0;
  $numValidTH$0$lcssa8 = 0;
  label = 17;
 } else {
  $4 = $doc + 6692 | 0;
  $5 = $doc + 6532 | 0;
  $6 = $doc + 68 | 0;
  $$05 = $node;
  $numTR$03 = 0;
  $numValidTH$04 = 0;
  while (1) {
   $7 = $numTR$03 + 1 | 0;
   $8 = $$05 + 12 | 0;
   $9 = HEAP32[$8 >> 2] | 0;
   if (!$9) $numValidTH$2 = $numValidTH$04; else {
    $12 = HEAP32[$9 + 28 >> 2] | 0;
    if (!$12) $numValidTH$2 = $numValidTH$04; else if ((HEAP32[$12 >> 2] | 0) == 112) {
     HEAP32[$4 >> 2] = 1;
     if (!(_prvTidynodeIsText(HEAP32[$9 + 12 >> 2] | 0) | 0)) $numValidTH$2 = $numValidTH$04; else {
      $22 = HEAP32[(HEAP32[$8 >> 2] | 0) + 12 >> 2] | 0;
      L10 : do if (!$22) $x$1$i = 0; else {
       $25 = HEAP32[$22 + 36 >> 2] | 0;
       $26 = $22 + 40 | 0;
       if ($25 >>> 0 < (HEAP32[$26 >> 2] | 0) >>> 0) {
        $i$02$i = $25;
        $x$01$i = 0;
        while (1) {
         HEAP8[$doc + 6532 + $x$01$i >> 0] = HEAP8[(HEAP32[(HEAP32[$6 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i >> 0] | 0;
         if ($x$01$i >>> 0 > 126) {
          $x$1$i = $x$01$i;
          break L10;
         }
         $i$02$i = $i$02$i + 1 | 0;
         $37 = $x$01$i + 1 | 0;
         if ($i$02$i >>> 0 >= (HEAP32[$26 >> 2] | 0) >>> 0) {
          $x$1$i = $37;
          break;
         } else $x$01$i = $37;
        }
       } else $x$1$i = 0;
      } while (0);
      HEAP8[$doc + 6532 + $x$1$i >> 0] = 0;
      $cp$03$i = $5;
      $isWht$02$i = 1;
      while (1) {
       $41 = HEAP8[$cp$03$i >> 0] | 0;
       if (!($41 << 24 >> 24)) {
        $isWht$0$lcssa$i = $isWht$02$i;
        break;
       }
       $isWht$02$i = _prvTidyIsWhite($41 << 24 >> 24) | 0;
       if (!$isWht$02$i) {
        $isWht$0$lcssa$i = 0;
        break;
       } else $cp$03$i = $cp$03$i + 1 | 0;
      }
      $numValidTH$2 = (($isWht$0$lcssa$i | 0) == 0 & 1) + $numValidTH$04 | 0;
     }
    } else $numValidTH$2 = $numValidTH$04;
   }
   $$05 = HEAP32[$$05 + 8 >> 2] | 0;
   if (!$$05) {
    $$lcssa = $7;
    $numValidTH$2$lcssa = $numValidTH$2;
    break;
   } else {
    $numTR$03 = $7;
    $numValidTH$04 = $numValidTH$2;
   }
  }
  if (($$lcssa | 0) == ($numValidTH$2$lcssa | 0)) {
   $numTR$0$lcssa10 = $$lcssa;
   $numValidTH$0$lcssa8 = $numValidTH$2$lcssa;
   label = 17;
  } else {
   $numTR$0$lcssa9 = $$lcssa;
   $numValidTH$0$lcssa7 = $numValidTH$2$lcssa;
  }
 }
 if ((label | 0) == 17) {
  HEAP32[$doc + 6704 >> 2] = 1;
  $numTR$0$lcssa9 = $numTR$0$lcssa10;
  $numValidTH$0$lcssa7 = $numValidTH$0$lcssa8;
 }
 if (($numTR$0$lcssa9 | 0) <= 1) return;
 if (!(($numTR$0$lcssa9 | 0) > ($numValidTH$0$lcssa7 | 0) & ($numValidTH$0$lcssa7 | 0) > 1)) return;
 if ((HEAP32[$doc + 6692 >> 2] | 0) != 1) return;
 HEAP32[$doc + 6712 >> 2] = 1;
 return;
}

function _ParseName($doc, $option) {
 $doc = $doc | 0;
 $option = $option | 0;
 var $$0$i$i = 0, $$lcssa27 = 0, $0 = 0, $11 = 0, $16 = 0, $25 = 0, $30 = 0, $38 = 0, $39 = 0, $45 = 0, $54 = 0, $55 = 0, $buf = 0, $c$07 = 0, $config$idx$i = 0, $config$idx$i2 = 0, $config$idx$val$i = 0, $config$idx$val$i3 = 0, $i$0$lcssa12 = 0, $i$0$lcssa13 = 0, $i$06 = 0, $i$06$lcssa = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1024 | 0;
 $buf = sp;
 _memset($buf | 0, 0, 1024) | 0;
 $0 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$0 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$0 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$0 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $11 = HEAP32[$0 >> 2] | 0;
 do if (($11 | 0) == -1) HEAP8[$buf >> 0] = 0; else {
  $config$idx$i2 = $doc + 872 | 0;
  $c$07 = $11;
  $i$06 = 0;
  while (1) {
   if (_prvTidyIsWhite($c$07) | 0) {
    $i$06$lcssa = $i$06;
    label = 16;
    break;
   }
   $16 = $i$06 + 1 | 0;
   HEAP8[$buf + $i$06 >> 0] = $c$07;
   if ((HEAP32[$0 >> 2] | 0) == -1) {
    $25 = $16;
    label = 15;
    break;
   }
   $config$idx$val$i3 = HEAP32[$config$idx$i2 >> 2] | 0;
   if (!$config$idx$val$i3) {
    $$lcssa27 = $16;
    label = 14;
    break;
   }
   $c$07 = _prvTidyReadChar($config$idx$val$i3) | 0;
   HEAP32[$0 >> 2] = $c$07;
   if (!($16 >>> 0 < 1022 & ($c$07 | 0) != -1)) {
    $25 = $16;
    label = 15;
    break;
   } else $i$06 = $16;
  }
  if ((label | 0) == 14) {
   HEAP32[$0 >> 2] = -1;
   $25 = $$lcssa27;
   label = 15;
  } else if ((label | 0) == 16) {
   HEAP8[$buf + $i$06$lcssa >> 0] = 0;
   if (!$i$06$lcssa) break; else $i$0$lcssa13 = $i$06$lcssa;
  }
  if ((label | 0) == 15) {
   HEAP8[$buf + $25 >> 0] = 0;
   $i$0$lcssa13 = $25;
  }
  $30 = HEAP32[$option >> 2] | 0;
  if ($30 >>> 0 >= 98) {
   $i$0$lcssa12 = $i$0$lcssa13;
   $54 = ($i$0$lcssa12 | 0) != 0;
   $55 = $54 & 1;
   STACKTOP = sp;
   return $55 | 0;
  }
  if ((HEAP32[1892 + ($30 << 5) >> 2] | 0) != ($30 | 0)) ___assert_fail(224036, 223800, 383, 224086);
  if (HEAP32[1892 + ($30 << 5) + 12 >> 2] | 0) ___assert_fail(224036, 223800, 383, 224086);
  $38 = $doc + 72 + ($30 << 2) | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  if ($39 | 0) if (($39 | 0) != (HEAP32[1892 + ($30 << 5) + 28 >> 2] | 0)) {
   $45 = HEAP32[$doc + 6856 >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$45 >> 2] | 0) + 8 >> 2] & 15]($45, $39);
  }
  if (!(_prvTidytmbstrlen($buf) | 0)) {
   HEAP32[$38 >> 2] = 0;
   $i$0$lcssa12 = $i$0$lcssa13;
   $54 = ($i$0$lcssa12 | 0) != 0;
   $55 = $54 & 1;
   STACKTOP = sp;
   return $55 | 0;
  } else {
   HEAP32[$38 >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, $buf) | 0;
   $i$0$lcssa12 = $i$0$lcssa13;
   $54 = ($i$0$lcssa12 | 0) != 0;
   $55 = $54 & 1;
   STACKTOP = sp;
   return $55 | 0;
  }
 } while (0);
 _prvTidyReportBadArgument($doc, HEAP32[$option + 8 >> 2] | 0);
 $i$0$lcssa12 = 0;
 $54 = ($i$0$lcssa12 | 0) != 0;
 $55 = $54 & 1;
 STACKTOP = sp;
 return $55 | 0;
}

function ___stpncpy($d, $s, $n) {
 $d = $d | 0;
 $s = $s | 0;
 $n = $n | 0;
 var $$0$lcssa = 0, $$0$lcssa42 = 0, $$031 = 0, $$04$lcssa = 0, $$04$lcssa43 = 0, $$0430 = 0, $$06$lcssa = 0, $$06$lcssa44 = 0, $$0629 = 0, $$1$lcssa = 0, $$117 = 0, $$15$ph = 0, $$1511 = 0, $$17$ph = 0, $$1710 = 0, $$2$ph = 0, $$212 = 0, $$28 = 0, $$3 = 0, $$lcssa = 0, $0 = 0, $10 = 0, $11 = 0, $12 = 0, $16 = 0, $20 = 0, $26 = 0, $27 = 0, $28 = 0, $31 = 0, $35 = 0, $7 = 0, $8 = 0, $wd$0$lcssa = 0, $wd$018 = 0, $ws$0$lcssa = 0, $ws$019 = 0, label = 0;
 $0 = $s;
 do if (!(($0 ^ $d) & 3)) {
  $7 = ($n | 0) != 0;
  L3 : do if ($7 & ($0 & 3 | 0) != 0) {
   $$031 = $n;
   $$0430 = $s;
   $$0629 = $d;
   while (1) {
    $8 = HEAP8[$$0430 >> 0] | 0;
    HEAP8[$$0629 >> 0] = $8;
    if (!($8 << 24 >> 24)) {
     $$0$lcssa42 = $$031;
     $$04$lcssa43 = $$0430;
     $$06$lcssa44 = $$0629;
     break L3;
    }
    $10 = $$031 + -1 | 0;
    $11 = $$0430 + 1 | 0;
    $12 = $$0629 + 1 | 0;
    $16 = ($10 | 0) != 0;
    if ($16 & ($11 & 3 | 0) != 0) {
     $$031 = $10;
     $$0430 = $11;
     $$0629 = $12;
    } else {
     $$0$lcssa = $10;
     $$04$lcssa = $11;
     $$06$lcssa = $12;
     $$lcssa = $16;
     label = 5;
     break;
    }
   }
  } else {
   $$0$lcssa = $n;
   $$04$lcssa = $s;
   $$06$lcssa = $d;
   $$lcssa = $7;
   label = 5;
  } while (0);
  if ((label | 0) == 5) if ($$lcssa) {
   $$0$lcssa42 = $$0$lcssa;
   $$04$lcssa43 = $$04$lcssa;
   $$06$lcssa44 = $$06$lcssa;
  } else {
   $$28 = $$06$lcssa;
   $$3 = 0;
   break;
  }
  if (!(HEAP8[$$04$lcssa43 >> 0] | 0)) {
   $$28 = $$06$lcssa44;
   $$3 = $$0$lcssa42;
  } else {
   L11 : do if ($$0$lcssa42 >>> 0 > 3) {
    $$117 = $$0$lcssa42;
    $wd$018 = $$06$lcssa44;
    $ws$019 = $$04$lcssa43;
    while (1) {
     $20 = HEAP32[$ws$019 >> 2] | 0;
     if (($20 & -2139062144 ^ -2139062144) & $20 + -16843009 | 0) {
      $$1$lcssa = $$117;
      $wd$0$lcssa = $wd$018;
      $ws$0$lcssa = $ws$019;
      break L11;
     }
     HEAP32[$wd$018 >> 2] = $20;
     $26 = $$117 + -4 | 0;
     $27 = $ws$019 + 4 | 0;
     $28 = $wd$018 + 4 | 0;
     if ($26 >>> 0 > 3) {
      $$117 = $26;
      $wd$018 = $28;
      $ws$019 = $27;
     } else {
      $$1$lcssa = $26;
      $wd$0$lcssa = $28;
      $ws$0$lcssa = $27;
      break;
     }
    }
   } else {
    $$1$lcssa = $$0$lcssa42;
    $wd$0$lcssa = $$06$lcssa44;
    $ws$0$lcssa = $$04$lcssa43;
   } while (0);
   $$15$ph = $ws$0$lcssa;
   $$17$ph = $wd$0$lcssa;
   $$2$ph = $$1$lcssa;
   label = 11;
  }
 } else {
  $$15$ph = $s;
  $$17$ph = $d;
  $$2$ph = $n;
  label = 11;
 } while (0);
 L16 : do if ((label | 0) == 11) if (!$$2$ph) {
  $$28 = $$17$ph;
  $$3 = 0;
 } else {
  $$1511 = $$15$ph;
  $$1710 = $$17$ph;
  $$212 = $$2$ph;
  while (1) {
   $31 = HEAP8[$$1511 >> 0] | 0;
   HEAP8[$$1710 >> 0] = $31;
   if (!($31 << 24 >> 24)) {
    $$28 = $$1710;
    $$3 = $$212;
    break L16;
   }
   $$212 = $$212 + -1 | 0;
   $35 = $$1710 + 1 | 0;
   if (!$$212) {
    $$28 = $35;
    $$3 = 0;
    break;
   } else {
    $$1511 = $$1511 + 1 | 0;
    $$1710 = $35;
   }
  }
 } while (0);
 _memset($$28 | 0, 0, $$3 | 0) | 0;
 return $$28 | 0;
}

function _ParseCSS1Selector($doc, $option) {
 $doc = $doc | 0;
 $option = $option | 0;
 var $$0 = 0, $$0$i$i = 0, $$lcssa25 = 0, $0 = 0, $11 = 0, $16 = 0, $24 = 0, $25 = 0, $26 = 0, $33 = 0, $35 = 0, $43 = 0, $44 = 0, $50 = 0, $buf = 0, $c$07 = 0, $config$idx$i = 0, $config$idx$i2 = 0, $config$idx$val$i = 0, $config$idx$val$i3 = 0, $i$0$lcssa12 = 0, $i$06 = 0, $i$06$lcssa = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 256 | 0;
 $buf = sp;
 _memset($buf | 0, 0, 256) | 0;
 $0 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$0 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$0 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$0 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $11 = HEAP32[$0 >> 2] | 0;
 if (($11 | 0) == -1) {
  HEAP8[$buf >> 0] = 0;
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $config$idx$i2 = $doc + 872 | 0;
 $c$07 = $11;
 $i$06 = 0;
 while (1) {
  if (_prvTidyIsWhite($c$07) | 0) {
   $i$06$lcssa = $i$06;
   label = 16;
   break;
  }
  $16 = $i$06 + 1 | 0;
  HEAP8[$buf + $i$06 >> 0] = $c$07;
  if ((HEAP32[$0 >> 2] | 0) == -1) {
   $25 = $16;
   label = 15;
   break;
  }
  $config$idx$val$i3 = HEAP32[$config$idx$i2 >> 2] | 0;
  if (!$config$idx$val$i3) {
   $$lcssa25 = $16;
   label = 14;
   break;
  }
  $c$07 = _prvTidyReadChar($config$idx$val$i3) | 0;
  HEAP32[$0 >> 2] = $c$07;
  if (!($16 >>> 0 < 254 & ($c$07 | 0) != -1)) {
   $25 = $16;
   label = 15;
   break;
  } else $i$06 = $16;
 }
 if ((label | 0) == 14) {
  HEAP32[$0 >> 2] = -1;
  $25 = $$lcssa25;
  label = 15;
 } else if ((label | 0) == 16) {
  $26 = $buf + $i$06$lcssa | 0;
  HEAP8[$26 >> 0] = 0;
  if (!$i$06$lcssa) {
   $$0 = 0;
   STACKTOP = sp;
   return $$0 | 0;
  } else {
   $33 = $26;
   $i$0$lcssa12 = $i$06$lcssa;
  }
 }
 if ((label | 0) == 15) {
  $24 = $buf + $25 | 0;
  HEAP8[$24 >> 0] = 0;
  $33 = $24;
  $i$0$lcssa12 = $25;
 }
 if (!(_prvTidyIsCSS1Selector($buf) | 0)) {
  _prvTidyReportBadArgument($doc, HEAP32[$option + 8 >> 2] | 0);
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 HEAP8[$33 >> 0] = 45;
 HEAP8[$buf + ($i$0$lcssa12 + 1) >> 0] = 0;
 $35 = HEAP32[$option >> 2] | 0;
 if ($35 >>> 0 >= 98) {
  $$0 = 1;
  STACKTOP = sp;
  return $$0 | 0;
 }
 if ((HEAP32[1892 + ($35 << 5) >> 2] | 0) != ($35 | 0)) ___assert_fail(224036, 223800, 383, 224086);
 if (HEAP32[1892 + ($35 << 5) + 12 >> 2] | 0) ___assert_fail(224036, 223800, 383, 224086);
 $43 = $doc + 72 + ($35 << 2) | 0;
 $44 = HEAP32[$43 >> 2] | 0;
 if ($44 | 0) if (($44 | 0) != (HEAP32[1892 + ($35 << 5) + 28 >> 2] | 0)) {
  $50 = HEAP32[$doc + 6856 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$50 >> 2] | 0) + 8 >> 2] & 15]($50, $44);
 }
 if (!(_prvTidytmbstrlen($buf) | 0)) {
  HEAP32[$43 >> 2] = 0;
  $$0 = 1;
  STACKTOP = sp;
  return $$0 | 0;
 } else {
  HEAP32[$43 >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, $buf) | 0;
  $$0 = 1;
  STACKTOP = sp;
  return $$0 | 0;
 }
 return 0;
}

function _prvTidyCheckHTMLTagsAttribsVersions($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$05 = 0, $$not = 0, $$pre = 0, $1 = 0, $10 = 0, $11 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $22 = 0, $23 = 0, $3 = 0, $37 = 0, $49 = 0, $58 = 0, $59 = 0, $68 = 0, $7 = 0, $9 = 0, $attval$04 = 0, $attval$04$us = 0, $attval$04$us$looptemp = 0, $attval$04$looptemp = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $3 = HEAP32[$1 + 40 >> 2] | 0;
 $7 = ($3 | 0) == 0 ? HEAP32[$1 + 36 >> 2] | 0 : $3;
 $9 = ($7 & 393508 | 0) != 0;
 $10 = $9 ? 700 : 701;
 $11 = $9 ? 703 : 704;
 if (!$node) return;
 $15 = (HEAP32[$doc + 456 >> 2] | 0) == 0;
 $16 = $doc + 212 | 0;
 $17 = $doc + 168 | 0;
 $18 = $doc + 200 | 0;
 $19 = $doc + 6840 | 0;
 $$not = $15 ^ 1;
 $$05 = $node;
 do {
  L6 : do if (_prvTidynodeIsElement($$05) | 0) {
   $22 = $$05 + 28 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   if ($23 | 0) if (!(HEAP32[$17 >> 2] | 0)) {
    $$pre = HEAP32[$23 + 8 >> 2] | 0;
    if (($$pre & $7 | 0) == 0 & $$not) {
     _prvTidyReportError($doc, 0, $$05, $10);
     break;
    }
    if ($$pre & 57344 | 0) {
     if (HEAP32[$18 >> 2] | 0) {
      if ((HEAP32[$23 >> 2] | 0) == 70) break;
      if ((HEAP32[$23 >> 2] | 0) == 120) break;
     }
     _prvTidyReportError($doc, 0, $$05, 221);
     $37 = HEAP32[$22 >> 2] | 0;
     if ($37 | 0) switch (HEAP32[$37 >> 2] | 0) {
     case 59:
      {
       HEAP32[$19 >> 2] = HEAP32[$19 >> 2] | 2;
       break L6;
       break;
      }
     case 99:
      {
       HEAP32[$19 >> 2] = HEAP32[$19 >> 2] | 1;
       break L6;
       break;
      }
     case 70:
      {
       HEAP32[$19 >> 2] = HEAP32[$19 >> 2] | 4;
       break L6;
       break;
      }
     default:
      break L6;
     }
    }
   }
  } while (0);
  L24 : do if (_prvTidynodeIsElement($$05) | 0) {
   $49 = HEAP32[$$05 + 20 >> 2] | 0;
   if ($49 | 0) {
    if ($15) {
     $attval$04$us = $49;
     while (1) {
      $attval$04$us$looptemp = $attval$04$us;
      $attval$04$us = HEAP32[$attval$04$us >> 2] | 0;
      if (_prvTidyAttributeIsProprietary($$05, $attval$04$us$looptemp) | 0) {
       _prvTidyReportAttrError($doc, $$05, $attval$04$us$looptemp, 253);
       if (HEAP32[$16 >> 2] | 0) _prvTidyRemoveAttribute($doc, $$05, $attval$04$us$looptemp);
      }
      if (!$attval$04$us) break L24;
     }
    } else $attval$04 = $49;
    do {
     $attval$04$looptemp = $attval$04;
     $attval$04 = HEAP32[$attval$04 >> 2] | 0;
     $58 = _prvTidyAttributeIsProprietary($$05, $attval$04$looptemp) | 0;
     $59 = _prvTidyAttributeIsMismatched($$05, $attval$04$looptemp, $doc) | 0;
     if (!$58) {
      if ($59 | 0) _prvTidyReportAttrError($doc, $$05, $attval$04$looptemp, $11);
     } else _prvTidyReportAttrError($doc, $$05, $attval$04$looptemp, 253);
     if ($59 | $58 | 0) if (HEAP32[$16 >> 2] | 0) _prvTidyRemoveAttribute($doc, $$05, $attval$04$looptemp);
    } while (($attval$04 | 0) != 0);
   }
  } while (0);
  $68 = HEAP32[$$05 + 12 >> 2] | 0;
  if ($68 | 0) _prvTidyCheckHTMLTagsAttribsVersions($doc, $68);
  $$05 = HEAP32[$$05 + 8 >> 2] | 0;
 } while (($$05 | 0) != 0);
 return;
}

function _prvTidyFixAnchors($doc, $node, $wantName, $wantId) {
 $doc = $doc | 0;
 $node = $node | 0;
 $wantName = $wantName | 0;
 $wantId = $wantId | 0;
 var $$029 = 0, $$not = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $16 = 0, $18 = 0, $19 = 0, $25 = 0, $3 = 0, $31 = 0, $36 = 0, $4 = 0, $49 = 0, $5 = 0, $54 = 0, $IdEmitted$0 = 0, $NameEmitted$0 = 0, $$029$looptemp = 0;
 if (!$node) return;
 $1 = ($wantId | 0) != 0;
 $$not = ($wantName | 0) == 0;
 $3 = ($wantId | $wantName | 0) == 0;
 $4 = ($wantName | 0) != 0;
 $5 = $doc + 68 | 0;
 $$029 = $node;
 do {
  $$029$looptemp = $$029;
  $$029 = HEAP32[$$029 + 8 >> 2] | 0;
  if (_prvTidyIsAnchorElement($doc, $$029$looptemp) | 0) {
   $10 = _prvTidyAttrGetById($$029$looptemp, 85) | 0;
   $11 = _prvTidyAttrGetById($$029$looptemp, 63) | 0;
   $12 = ($10 | 0) != 0;
   $13 = ($11 | 0) != 0;
   do if ($12 & $13) {
    $16 = (HEAP32[$10 + 24 >> 2] | 0) != 0;
    $18 = HEAP32[$11 + 24 >> 2] | 0;
    $19 = ($18 | 0) != 0;
    if (!($16 ^ $19)) {
     if (!($16 & $19)) {
      $IdEmitted$0 = 0;
      $NameEmitted$0 = 0;
      break;
     }
     if (!(_prvTidytmbstrcmp(HEAP32[$10 + 24 >> 2] | 0, $18) | 0)) {
      $IdEmitted$0 = 0;
      $NameEmitted$0 = 0;
      break;
     }
    }
    _prvTidyReportAttrError($doc, $$029$looptemp, $10, 260);
    $IdEmitted$0 = 0;
    $NameEmitted$0 = 0;
   } else {
    if (!($1 & $12)) {
     if (!($4 & $13)) {
      $IdEmitted$0 = 0;
      $NameEmitted$0 = 0;
      break;
     }
     $36 = _prvTidyNodeAttributeVersions($$029$looptemp, 85) | 0;
     if (!(HEAP32[(HEAP32[$5 >> 2] | 0) + 40 >> 2] & $36)) {
      $IdEmitted$0 = 0;
      $NameEmitted$0 = 0;
      break;
     }
     _prvTidyRepairAttrValue($doc, $$029$looptemp, 311658, HEAP32[$11 + 24 >> 2] | 0) | 0;
     $IdEmitted$0 = 0;
     $NameEmitted$0 = 1;
     break;
    }
    $25 = _prvTidyNodeAttributeVersions($$029$looptemp, 63) | 0;
    if (!(HEAP32[(HEAP32[$5 >> 2] | 0) + 40 >> 2] & $25)) {
     $IdEmitted$0 = 0;
     $NameEmitted$0 = 0;
    } else {
     $31 = $10 + 24 | 0;
     if (!(_prvTidyIsValidHTMLID(HEAP32[$31 >> 2] | 0) | 0)) {
      _prvTidyReportAttrError($doc, $$029$looptemp, $10, 273);
      $IdEmitted$0 = 0;
      $NameEmitted$0 = 0;
      break;
     } else {
      _prvTidyRepairAttrValue($doc, $$029$looptemp, 311655, HEAP32[$31 >> 2] | 0) | 0;
      $IdEmitted$0 = 1;
      $NameEmitted$0 = 0;
      break;
     }
    }
   } while (0);
   if ($1 | ($11 | 0) == 0) $49 = $1; else if ($$not | $12 | ($NameEmitted$0 | 0) != 0) {
    if ($3) _prvTidyRemoveAnchorByNode($doc, HEAP32[$11 + 24 >> 2] | 0, $$029$looptemp);
    _prvTidyRemoveAttribute($doc, $$029$looptemp, $11);
    $49 = 0;
   } else $49 = 0;
   if (!($4 | ($10 | 0) == 0)) if ($13 | $49 ^ 1 | ($IdEmitted$0 | 0) != 0) {
    if ($3) _prvTidyRemoveAnchorByNode($doc, HEAP32[$10 + 24 >> 2] | 0, $$029$looptemp);
    _prvTidyRemoveAttribute($doc, $$029$looptemp, $10);
   }
  }
  $54 = HEAP32[$$029$looptemp + 12 >> 2] | 0;
  if ($54 | 0) _prvTidyFixAnchors($doc, $54, $wantName, $wantId);
 } while (($$029 | 0) != 0);
 return;
}

function _prvTidyParseXMLDocument($doc) {
 $doc = $doc | 0;
 var $$lcssa = 0, $0 = 0, $12 = 0, $17 = 0, $2 = 0, $24 = 0, $25 = 0, $3 = 0, $33 = 0, $38 = 0, $40 = 0, $45 = 0, $5 = 0, $53 = 0, $6 = 0, $doctype$0$ph4 = 0;
 _prvTidySetOptionBool($doc, 24, 1) | 0;
 $0 = _prvTidyGetToken($doc, 0) | 0;
 L1 : do if ($0 | 0) {
  $2 = $doc + 16 | 0;
  $3 = $doc + 12 | 0;
  $53 = $0;
  $doctype$0$ph4 = 0;
  while (1) {
   if (!$doctype$0$ph4) $6 = $53; else {
    $25 = $53;
    break;
   }
   L5 : while (1) {
    $5 = $6 + 44 | 0;
    L7 : do if ((HEAP32[$5 >> 2] | 0) == 6) {
     _prvTidyReportError($doc, 0, $6, 213);
     _prvTidyFreeNode($doc, $6);
    } else if (!(_InsertMisc($doc, $6) | 0)) switch (HEAP32[$5 >> 2] | 0) {
    case 1:
     {
      $$lcssa = $6;
      break L5;
      break;
     }
    case 7:
     {
      HEAP32[$6 >> 2] = $doc;
      $17 = HEAP32[$2 >> 2] | 0;
      HEAP32[$6 + 4 >> 2] = $17;
      if (!$17) HEAP32[$3 >> 2] = $6; else HEAP32[$17 + 8 >> 2] = $6;
      HEAP32[$2 >> 2] = $6;
      break L7;
      break;
     }
    case 5:
     {
      HEAP32[$6 >> 2] = $doc;
      $12 = HEAP32[$2 >> 2] | 0;
      HEAP32[$6 + 4 >> 2] = $12;
      if (!$12) HEAP32[$3 >> 2] = $6; else HEAP32[$12 + 8 >> 2] = $6;
      HEAP32[$2 >> 2] = $6;
      _ParseXMLElement($doc, $6, 0);
      break L7;
      break;
     }
    default:
     {
      _prvTidyReportError($doc, $doc, $6, 208);
      _prvTidyFreeNode($doc, $6);
      break L7;
     }
    } while (0);
    $6 = _prvTidyGetToken($doc, 0) | 0;
    if (!$6) break L1;
   }
   HEAP32[$$lcssa >> 2] = $doc;
   $33 = HEAP32[$2 >> 2] | 0;
   HEAP32[$$lcssa + 4 >> 2] = $33;
   if (!$33) HEAP32[$3 >> 2] = $$lcssa; else HEAP32[$33 + 8 >> 2] = $$lcssa;
   HEAP32[$2 >> 2] = $$lcssa;
   $38 = _prvTidyGetToken($doc, 0) | 0;
   if (!$38) break L1; else {
    $53 = $38;
    $doctype$0$ph4 = $$lcssa;
   }
  }
  do {
   $24 = $25 + 44 | 0;
   L31 : do if ((HEAP32[$24 >> 2] | 0) == 6) {
    _prvTidyReportError($doc, 0, $25, 213);
    _prvTidyFreeNode($doc, $25);
   } else if (!(_InsertMisc($doc, $25) | 0)) switch (HEAP32[$24 >> 2] | 0) {
   case 1:
    {
     _prvTidyReportError($doc, $doc, $25, 208);
     _prvTidyFreeNode($doc, $25);
     break L31;
     break;
    }
   case 7:
    {
     HEAP32[$25 >> 2] = $doc;
     $40 = HEAP32[$2 >> 2] | 0;
     HEAP32[$25 + 4 >> 2] = $40;
     if (!$40) HEAP32[$3 >> 2] = $25; else HEAP32[$40 + 8 >> 2] = $25;
     HEAP32[$2 >> 2] = $25;
     break L31;
     break;
    }
   case 5:
    {
     HEAP32[$25 >> 2] = $doc;
     $45 = HEAP32[$2 >> 2] | 0;
     HEAP32[$25 + 4 >> 2] = $45;
     if (!$45) HEAP32[$3 >> 2] = $25; else HEAP32[$45 + 8 >> 2] = $25;
     HEAP32[$2 >> 2] = $25;
     _ParseXMLElement($doc, $25, 0);
     break L31;
     break;
    }
   default:
    {
     _prvTidyReportError($doc, $doc, $25, 208);
     _prvTidyFreeNode($doc, $25);
     break L31;
    }
   } while (0);
   $25 = _prvTidyGetToken($doc, 0) | 0;
  } while (($25 | 0) != 0);
 } while (0);
 if (!(HEAP32[$doc + 184 >> 2] | 0)) return;
 _prvTidyFixXmlDecl($doc) | 0;
 return;
}

function _CheckType($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $$pre = 0, $$pre34 = 0, $11 = 0, $14 = 0, $15 = 0, $18 = 0, $19 = 0, $2 = 0, $23 = 0, $25 = 0, $27 = 0, $33 = 0, $38 = 0, $47 = 0, $58 = 0, $6 = 0, $7 = 0, $9 = 0, $p$01$i = 0, $v$01$i = 0, label = 0;
 if (!$node) return;
 $2 = HEAP32[$node + 28 >> 2] | 0;
 if (!$2) return;
 switch (HEAP32[$2 >> 2] | 0) {
 case 53:
  {
   _CheckAttrValidity($doc, $node, $attval, 58632);
   return;
  }
 case 18:
  {
   _CheckAttrValidity($doc, $node, $attval, 58728);
   return;
  }
 case 118:
  {
   _CheckAttrValidity($doc, $node, $attval, 58744);
   return;
  }
 case 77:
  {
   if ($attval | 0) {
    $6 = $attval + 24 | 0;
    $7 = HEAP32[$6 >> 2] | 0;
    if ($7 | 0) {
     $11 = 308546;
     $9 = $7;
     $v$01$i = 58760;
     while (1) {
      if ($9 | 0) if (!(_prvTidytmbstrcasecmp($9, $11) | 0)) {
       label = 30;
       break;
      }
      $14 = $v$01$i + 4 | 0;
      $15 = HEAP32[$14 >> 2] | 0;
      if (!$15) break;
      $11 = $15;
      $9 = HEAP32[$6 >> 2] | 0;
      $v$01$i = $14;
     }
     if ((label | 0) == 30) return;
     _prvTidyReportAttrError($doc, $node, $attval, 251);
     return;
    }
   }
   _prvTidyReportAttrError($doc, $node, $attval, 702);
   return;
  }
 case 61:
  {
   if ($attval | 0) {
    $18 = $attval + 24 | 0;
    $19 = HEAP32[$18 >> 2] | 0;
    if ($19 | 0) {
     do if (_prvTidytmbstrcasecmp($19, 306015) | 0) {
      $23 = HEAP32[$18 >> 2] | 0;
      if ($23 | 0) if (!(_prvTidytmbstrcasecmp($23, 306020) | 0)) break;
      $58 = HEAP32[$18 >> 2] | 0;
      if ($58 | 0) if (!(_prvTidytmbstrcasecmp($58, 305783) | 0)) break;
      $47 = HEAP32[$18 >> 2] | 0;
      if ($47 | 0) {
       if (!(_prvTidytmbstrcasecmp($47, 308546) | 0)) return;
       $$pre = HEAP32[$18 >> 2] | 0;
       if ($$pre | 0) {
        if (!(_prvTidytmbstrcasecmp($$pre, 308094) | 0)) return;
        $$pre34 = HEAP32[$18 >> 2] | 0;
        if ($$pre34 | 0) if (!(_prvTidytmbstrcasecmp($$pre34, 308319) | 0)) return;
       }
      }
      _prvTidyReportAttrError($doc, $node, $attval, 251);
      return;
     } while (0);
     $25 = HEAP32[$18 >> 2] | 0;
     if (!$25) return;
     $27 = HEAP8[$25 >> 0] | 0;
     if (!($27 << 24 >> 24)) return; else {
      $33 = $27;
      $p$01$i = $25;
     }
     while (1) {
      $p$01$i = $p$01$i + 1 | 0;
      if (_prvTidyIsUpper($33 << 24 >> 24) | 0) break;
      $33 = HEAP8[$p$01$i >> 0] | 0;
      if (!($33 << 24 >> 24)) {
       label = 30;
       break;
      }
     }
     if ((label | 0) == 30) return;
     $38 = (HEAP32[$doc + 68 >> 2] | 0) + 28 | 0;
     if (!(HEAP32[$38 >> 2] | 0)) label = 26; else {
      _prvTidyReportAttrError($doc, $node, $attval, 269);
      if (!(HEAP32[$38 >> 2] | 0)) label = 26;
     }
     if ((label | 0) == 26) if (!(HEAP32[$doc + 336 >> 2] | 0)) return;
     HEAP32[$18 >> 2] = _prvTidytmbstrtolower(HEAP32[$18 >> 2] | 0) | 0;
     return;
    }
   }
   _prvTidyReportAttrError($doc, $node, $attval, 702);
   return;
  }
 default:
  return;
 }
}

function _AddFontStyles($doc, $node, $av) {
 $doc = $doc | 0;
 $node = $node | 0;
 $av = $av | 0;
 var $$0$i$i = 0, $$0$i$in$i = 0, $$0$i2$i = 0, $$05 = 0, $1 = 0, $12 = 0, $2 = 0, $22 = 0, $29 = 0, $3 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $6 = 0, $9 = 0, $buf$i2 = 0, $value$0$ph$i = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 288 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $buf$i2 = sp + 24 | 0;
 if (!$av) {
  STACKTOP = sp;
  return;
 }
 $1 = ($node | 0) == 0;
 $2 = $node + 28 | 0;
 $3 = $doc + 6856 | 0;
 $4 = $node + 32 | 0;
 $$05 = $av;
 do {
  $6 = HEAP32[$$05 + 24 >> 2] | 0;
  L6 : do if ($6 | 0) {
   $9 = HEAP32[$$05 + 4 >> 2] | 0;
   if ($9 | 0) switch (HEAP32[$9 >> 2] | 0) {
   case 50:
    {
     HEAP32[$vararg_buffer >> 2] = $6;
     _prvTidytmbsnprintf($buf$i2, 256, 311125, $vararg_buffer) | 0;
     _prvTidyAddStyleProperty($doc, $node, $buf$i2);
     break L6;
     break;
    }
   case 137:
    {
     do if (!$1) {
      $12 = HEAP32[$2 >> 2] | 0;
      if ($12 | 0) if ((HEAP32[$12 >> 2] | 0) == 80) {
       if (!(_prvTidytmbstrcmp($6, 311141) | 0)) $value$0$ph$i = 311150; else if (!(_prvTidytmbstrcmp($6, 311143) | 0)) $value$0$ph$i = 311147; else if (!(_prvTidytmbstrcmp($6, 311145) | 0)) $value$0$ph$i = 311153; else break;
       $22 = HEAP32[$3 >> 2] | 0;
       FUNCTION_TABLE_vii[HEAP32[(HEAP32[$22 >> 2] | 0) + 8 >> 2] & 15]($22, HEAP32[$4 >> 2] | 0);
       HEAP32[$4 >> 2] = _prvTidytmbstrdup(HEAP32[$3 >> 2] | 0, $value$0$ph$i) | 0;
       _prvTidyFindTag($doc, $node) | 0;
       break L6;
      }
     } while (0);
     $29 = HEAP8[$6 >> 0] | 0;
     if (!($29 << 24 >> 24)) break L6;
     do if (($29 + -48 & 255) < 7) {
      $$0$i$in$i = 66120 + (($29 << 24 >> 24) + -48 << 2) | 0;
      label = 22;
     } else {
      $37 = HEAP8[$6 + 1 >> 0] | 0;
      $38 = $37 << 24 >> 24;
      $39 = ($37 + -48 & 255) < 7;
      if ($29 << 24 >> 24 == 45) {
       if (!$39) {
        $$0$i2$i = 311240;
        break;
       }
       $$0$i$in$i = 66148 + ($38 + -48 << 2) | 0;
       label = 22;
       break;
      } else {
       if (!$39) {
        $$0$i2$i = 311233;
        break;
       }
       $$0$i$in$i = 66176 + ($38 + -48 << 2) | 0;
       label = 22;
       break;
      }
     } while (0);
     if ((label | 0) == 22) {
      label = 0;
      $$0$i$i = HEAP32[$$0$i$in$i >> 2] | 0;
      if (!$$0$i$i) break L6; else $$0$i2$i = $$0$i$i;
     }
     HEAP32[$vararg_buffer1 >> 2] = $$0$i2$i;
     _prvTidytmbsnprintf($buf$i2, 64, 311248, $vararg_buffer1) | 0;
     _prvTidyAddStyleProperty($doc, $node, $buf$i2);
     break L6;
     break;
    }
   case 32:
    {
     HEAP32[$vararg_buffer4 >> 2] = $6;
     _prvTidytmbsnprintf($buf$i2, 128, 311262, $vararg_buffer4) | 0;
     _prvTidyAddStyleProperty($doc, $node, $buf$i2);
     break L6;
     break;
    }
   default:
    break L6;
   }
  } while (0);
  $$05 = HEAP32[$$05 >> 2] | 0;
 } while (($$05 | 0) != 0);
 STACKTOP = sp;
 return;
}

function _prvTidyAdjustTags($doc) {
 $doc = $doc | 0;
 var $12 = 0, $23 = 0, $24 = 0, $25 = 0, $29 = 0, $39 = 0, $42 = 0, $43 = 0, $44 = 0, $48 = 0, $6 = 0, $7 = 0, $8 = 0, $i$02$i = 0, $i$02$i1 = 0, $i$02$i13 = 0, $next$01$i = 0, $next$01$i14 = 0, $next$01$i2 = 0, $np$01$i = 0, $np$01$i$lcssa = 0, $np$01$i10 = 0, $np$01$i10$lcssa = 0, $np$01$i7 = 0, $np$01$i7$lcssa = 0, label = 0, $next$01$i2$looptemp = 0, $next$01$i14$looptemp = 0, $next$01$i$looptemp = 0;
 $np$01$i = 58824;
 while (1) {
  if ((HEAP32[$np$01$i >> 2] | 0) == 1) {
   $np$01$i$lcssa = $np$01$i;
   label = 4;
   break;
  }
  $np$01$i = $np$01$i + 32 | 0;
  if ($np$01$i >>> 0 >= 63624 >>> 0) {
   $np$01$i7 = 58824;
   break;
  }
 }
 if ((label | 0) == 4) {
  HEAP32[$np$01$i$lcssa + 20 >> 2] = 26;
  HEAP32[$np$01$i$lcssa + 16 >> 2] = 16;
  $6 = $doc + 6856 | 0;
  $i$02$i1 = 0;
  do {
   $7 = $doc + 884 + ($i$02$i1 << 2) | 0;
   $8 = HEAP32[$7 >> 2] | 0;
   if ($8 | 0) {
    $next$01$i2 = $8;
    do {
     $next$01$i2$looptemp = $next$01$i2;
     $next$01$i2 = HEAP32[$next$01$i2 + 4 >> 2] | 0;
     $12 = HEAP32[$6 >> 2] | 0;
     FUNCTION_TABLE_vii[HEAP32[(HEAP32[$12 >> 2] | 0) + 8 >> 2] & 15]($12, $next$01$i2$looptemp);
    } while (($next$01$i2 | 0) != 0);
   }
   HEAP32[$7 >> 2] = 0;
   $i$02$i1 = $i$02$i1 + 1 | 0;
  } while (($i$02$i1 | 0) != 178);
  $np$01$i7 = 58824;
 }
 while (1) {
  if ((HEAP32[$np$01$i7 >> 2] | 0) == 19) {
   $np$01$i7$lcssa = $np$01$i7;
   label = 10;
   break;
  }
  $np$01$i7 = $np$01$i7 + 32 | 0;
  if ($np$01$i7 >>> 0 >= 63624 >>> 0) {
   $np$01$i10 = 58824;
   break;
  }
 }
 if ((label | 0) == 10) {
  HEAP32[$np$01$i7$lcssa + 20 >> 2] = 26;
  $23 = $doc + 6856 | 0;
  $i$02$i13 = 0;
  do {
   $24 = $doc + 884 + ($i$02$i13 << 2) | 0;
   $25 = HEAP32[$24 >> 2] | 0;
   if ($25 | 0) {
    $next$01$i14 = $25;
    do {
     $next$01$i14$looptemp = $next$01$i14;
     $next$01$i14 = HEAP32[$next$01$i14 + 4 >> 2] | 0;
     $29 = HEAP32[$23 >> 2] | 0;
     FUNCTION_TABLE_vii[HEAP32[(HEAP32[$29 >> 2] | 0) + 8 >> 2] & 15]($29, $next$01$i14$looptemp);
    } while (($next$01$i14 | 0) != 0);
   }
   HEAP32[$24 >> 2] = 0;
   $i$02$i13 = $i$02$i13 + 1 | 0;
  } while (($i$02$i13 | 0) != 178);
  $np$01$i10 = 58824;
 }
 while (1) {
  if ((HEAP32[$np$01$i10 >> 2] | 0) == 76) {
   $np$01$i10$lcssa = $np$01$i10;
   break;
  }
  $np$01$i10 = $np$01$i10 + 32 | 0;
  if ($np$01$i10 >>> 0 >= 63624 >>> 0) {
   label = 20;
   break;
  }
 }
 if ((label | 0) == 20) return;
 $39 = $np$01$i10$lcssa + 16 | 0;
 HEAP32[$39 >> 2] = HEAP32[$39 >> 2] | 4;
 $42 = $doc + 6856 | 0;
 $i$02$i = 0;
 do {
  $43 = $doc + 884 + ($i$02$i << 2) | 0;
  $44 = HEAP32[$43 >> 2] | 0;
  if ($44 | 0) {
   $next$01$i = $44;
   do {
    $next$01$i$looptemp = $next$01$i;
    $next$01$i = HEAP32[$next$01$i + 4 >> 2] | 0;
    $48 = HEAP32[$42 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$48 >> 2] | 0) + 8 >> 2] & 15]($48, $next$01$i$looptemp);
   } while (($next$01$i | 0) != 0);
  }
  HEAP32[$43 >> 2] = 0;
  $i$02$i = $i$02$i + 1 | 0;
 } while (($i$02$i | 0) != 178);
 return;
}

function _ParseCharEnc($doc, $option) {
 $doc = $doc | 0;
 $option = $option | 0;
 var $$0$i$i = 0, $$lcssa = 0, $0 = 0, $11 = 0, $17 = 0, $26 = 0, $28 = 0, $buf = 0, $c$09 = 0, $config$idx$i = 0, $config$idx$i2 = 0, $config$idx$val$i = 0, $config$idx$val$i3 = 0, $i$0$lcssa = 0, $i$08 = 0, $inenc$0$ph$i = 0, $outenc$0$ph$i = 0, $validEncoding$07 = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $buf = sp;
 dest = $buf;
 stop = dest + 64 | 0;
 do {
  HEAP8[dest >> 0] = 0;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 $0 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$0 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$0 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$0 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $11 = HEAP32[$0 >> 2] | 0;
 L10 : do if (($11 | 0) == -1) $i$0$lcssa = 0; else {
  $config$idx$i2 = $doc + 872 | 0;
  $c$09 = $11;
  $i$08 = 0;
  while (1) {
   if (_prvTidyIsWhite($c$09) | 0) {
    $i$0$lcssa = $i$08;
    break L10;
   }
   $17 = $i$08 + 1 | 0;
   HEAP8[$buf + $i$08 >> 0] = _prvTidyToLower($c$09) | 0;
   if ((HEAP32[$0 >> 2] | 0) == -1) {
    $i$0$lcssa = $17;
    break L10;
   }
   $config$idx$val$i3 = HEAP32[$config$idx$i2 >> 2] | 0;
   if (!$config$idx$val$i3) {
    $$lcssa = $17;
    break;
   }
   $c$09 = _prvTidyReadChar($config$idx$val$i3) | 0;
   HEAP32[$0 >> 2] = $c$09;
   if (!($17 >>> 0 < 62 & ($c$09 | 0) != -1)) {
    $i$0$lcssa = $17;
    break L10;
   } else $i$08 = $17;
  }
  HEAP32[$0 >> 2] = -1;
  $i$0$lcssa = $$lcssa;
 } while (0);
 HEAP8[$buf + $i$0$lcssa >> 0] = 0;
 $26 = _prvTidyGetCharEncodingFromOptName($buf) | 0;
 if (($26 | 0) < 0) {
  _prvTidyReportBadArgument($doc, HEAP32[$option + 8 >> 2] | 0);
  $validEncoding$07 = 0;
  STACKTOP = sp;
  return $validEncoding$07 | 0;
 }
 $28 = HEAP32[$option >> 2] | 0;
 if ($28 >>> 0 >= 98) {
  $validEncoding$07 = 1;
  STACKTOP = sp;
  return $validEncoding$07 | 0;
 }
 if ((HEAP32[1892 + ($28 << 5) + 12 >> 2] | 0) != 1) ___assert_fail(223759, 223800, 398, 223889);
 HEAP32[$doc + 72 + ($28 << 2) >> 2] = $26;
 if (($28 | 0) != 4) {
  $validEncoding$07 = 1;
  STACKTOP = sp;
  return $validEncoding$07 | 0;
 }
 switch ($26 | 0) {
 case 2:
 case 8:
 case 7:
 case 6:
  {
   $inenc$0$ph$i = $26;
   $outenc$0$ph$i = 1;
   break;
  }
 case 1:
  {
   $inenc$0$ph$i = 3;
   $outenc$0$ph$i = 1;
   break;
  }
 case 12:
 case 13:
 case 11:
 case 10:
 case 9:
 case 5:
 case 4:
 case 3:
 case 0:
  {
   $inenc$0$ph$i = $26;
   $outenc$0$ph$i = $26;
   break;
  }
 default:
  {
   $validEncoding$07 = 1;
   STACKTOP = sp;
   return $validEncoding$07 | 0;
  }
 }
 HEAP32[$doc + 88 >> 2] = $26;
 HEAP32[$doc + 92 >> 2] = $inenc$0$ph$i;
 HEAP32[$doc + 96 >> 2] = $outenc$0$ph$i;
 $validEncoding$07 = 1;
 STACKTOP = sp;
 return $validEncoding$07 | 0;
}

function _PFlushLineImpl($doc) {
 $doc = $doc | 0;
 var $$idx$i = 0, $$idx$val = 0, $$idx$val$i = 0, $$idx2$i = 0, $$idx3$val$i = 0, $$idx5$val$i = 0, $14 = 0, $17 = 0, $2 = 0, $21 = 0, $22 = 0, $23 = 0, $32 = 0, $34 = 0, $35 = 0, $38 = 0, $41 = 0, $44 = 0, $45 = 0, $48 = 0, $49 = 0, $51 = 0, $54 = 0, $55 = 0, $59 = 0, $8 = 0, $9 = 0, $i$04 = 0, $i$13 = 0, $wantIt$0$i = 0;
 $$idx$i = $doc + 6752 | 0;
 $$idx$val$i = HEAP32[$$idx$i >> 2] | 0;
 $2 = $doc + 6736 | 0;
 if (((($$idx$val$i | 0) < 0 ? 0 : $$idx$val$i) + (HEAP32[$2 >> 2] | 0) | 0) >>> 0 < (HEAP32[$doc + 80 >> 2] | 0) >>> 0) $$idx$val = $$idx$val$i; else {
  _WrapLine($doc);
  $$idx$val = HEAP32[$$idx$i >> 2] | 0;
 }
 $8 = ($$idx$val | 0) > 0;
 $9 = $8 & 1;
 if ($8) {
  $$idx2$i = $doc + 6740 | 0;
  $$idx3$val$i = HEAP32[$doc + 6756 >> 2] | 0;
  if (!$$idx3$val$i) $14 = 0; else $14 = ($$idx3$val$i | 0) < 1 ? 1 : ($$idx3$val$i | 0) >= (HEAP32[$$idx2$i >> 2] | 0);
  if ((HEAP32[$doc + 284 >> 2] | 0) != 0 | $14) {
   $$idx5$val$i = HEAP32[$doc + 6760 >> 2] | 0;
   if (!$$idx5$val$i) $17 = 0; else $17 = ($$idx5$val$i | 0) < 1 ? 1 : ($$idx5$val$i | 0) >= (HEAP32[$$idx2$i >> 2] | 0);
  } else $17 = 0;
  $wantIt$0$i = $17 & 1;
 } else $wantIt$0$i = $9;
 if (!(($wantIt$0$i | 0) == 0 | $8 ^ 1)) {
  $23 = $doc + 6780 | 0;
  $i$04 = 0;
  do {
   _prvTidyWriteChar(HEAP32[16017] | 0, HEAP32[$23 >> 2] | 0);
   $i$04 = $i$04 + 1 | 0;
  } while (($i$04 | 0) != ($$idx$val | 0));
 }
 if (!(HEAP32[$2 >> 2] | 0)) $38 = 0; else {
  $21 = $doc + 6728 | 0;
  $22 = $doc + 6780 | 0;
  $i$13 = 0;
  do {
   _prvTidyWriteChar(HEAP32[(HEAP32[$21 >> 2] | 0) + ($i$13 << 2) >> 2] | 0, HEAP32[$22 >> 2] | 0);
   $i$13 = $i$13 + 1 | 0;
   $32 = HEAP32[$2 >> 2] | 0;
  } while ($i$13 >>> 0 < $32 >>> 0);
  $38 = $32;
 }
 $34 = $doc + 6760 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 if (($35 | 0) > -1 & ($35 | 0) < ($38 | 0)) _prvTidyWriteChar(92, HEAP32[$doc + 6780 >> 2] | 0);
 $41 = $doc + 6748 | 0;
 if (HEAP32[$41 >> 2] | 0) {
  $44 = $doc + 6752 | 0;
  $45 = $doc + 6764 | 0;
  HEAP32[$44 >> 2] = HEAP32[$45 >> 2];
  HEAP32[$44 + 4 >> 2] = HEAP32[$45 + 4 >> 2];
  HEAP32[$44 + 8 >> 2] = HEAP32[$45 + 8 >> 2];
  HEAP32[$45 >> 2] = -1;
  HEAP32[$doc + 6768 >> 2] = -1;
  HEAP32[$doc + 6772 >> 2] = -1;
 }
 $48 = $doc + 6740 | 0;
 $49 = HEAP32[$48 >> 2] | 0;
 $51 = HEAP32[$34 >> 2] | 0;
 if (!$49) {
  if (($51 | 0) > 0) HEAP32[$34 >> 2] = 0;
  $59 = $doc + 6756 | 0;
  if ((HEAP32[$59 >> 2] | 0) <= 0) {
   HEAP32[$41 >> 2] = 0;
   HEAP32[$48 >> 2] = 0;
   HEAP32[$2 >> 2] = 0;
   return;
  }
  HEAP32[$59 >> 2] = 0;
  HEAP32[$41 >> 2] = 0;
  HEAP32[$48 >> 2] = 0;
  HEAP32[$2 >> 2] = 0;
  return;
 } else {
  if (($51 | 0) > ($49 | 0)) HEAP32[$34 >> 2] = $51 - $49;
  $54 = $doc + 6756 | 0;
  $55 = HEAP32[$54 >> 2] | 0;
  if (($55 | 0) <= ($49 | 0)) {
   HEAP32[$41 >> 2] = 0;
   HEAP32[$48 >> 2] = 0;
   HEAP32[$2 >> 2] = 0;
   return;
  }
  HEAP32[$54 >> 2] = $55 - $49;
  HEAP32[$41 >> 2] = 0;
  HEAP32[$48 >> 2] = 0;
  HEAP32[$2 >> 2] = 0;
  return;
 }
}

function _prvTidyParseColGroup($doc, $colgroup, $mode) {
 $doc = $doc | 0;
 $colgroup = $colgroup | 0;
 $mode = $mode | 0;
 var $$lcssa23 = 0, $0 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $17 = 0, $19 = 0, $36 = 0, $40 = 0, $42 = 0, $47 = 0, $49 = 0, $6 = 0, $60 = 0, $8 = 0, $9 = 0, $colgroup$pn = 0, label = 0;
 $0 = $colgroup + 28 | 0;
 if (HEAP32[(HEAP32[$0 >> 2] | 0) + 16 >> 2] & 1 | 0) return;
 $6 = _prvTidyGetToken($doc, 0) | 0;
 if (!$6) return;
 $8 = $doc + 6848 | 0;
 $9 = $colgroup + 16 | 0;
 $10 = $colgroup + 12 | 0;
 $11 = $doc + 68 | 0;
 $13 = $6;
 L7 : while (1) {
  $12 = $13 + 28 | 0;
  $14 = HEAP32[$12 >> 2] | 0;
  $17 = $13 + 44 | 0;
  $19 = (HEAP32[$17 >> 2] | 0) == 6;
  L9 : do if (($14 | 0) == (HEAP32[$0 >> 2] | 0)) if ($19) {
   $$lcssa23 = $13;
   label = 6;
   break L7;
  } else label = 15; else if ($19) {
   if (!$14) $colgroup$pn = $colgroup; else if ((HEAP32[$14 >> 2] | 0) == 37) {
    HEAP32[$8 >> 2] = HEAP32[$8 >> 2] | 1;
    _prvTidyReportError($doc, $colgroup, $13, 208);
    _prvTidyFreeNode($doc, $13);
    break;
   } else $colgroup$pn = $colgroup;
   while (1) {
    $colgroup$pn = HEAP32[$colgroup$pn >> 2] | 0;
    if (!$colgroup$pn) {
     label = 15;
     break L9;
    }
    if (($14 | 0) == (HEAP32[$colgroup$pn + 28 >> 2] | 0)) {
     label = 14;
     break L7;
    }
   }
  } else label = 15; while (0);
  do if ((label | 0) == 15) {
   label = 0;
   if (_prvTidynodeIsText($13) | 0) {
    label = 16;
    break L7;
   }
   if (!(_InsertMisc($colgroup, $13) | 0)) {
    $36 = HEAP32[$12 >> 2] | 0;
    if (!$36) {
     _prvTidyReportError($doc, $colgroup, $13, 208);
     _prvTidyFreeNode($doc, $13);
     break;
    }
    if ((HEAP32[$36 >> 2] | 0) != 23) {
     label = 21;
     break L7;
    }
    $40 = HEAP32[$17 >> 2] | 0;
    if (($40 | 0) == 6) {
     _prvTidyReportError($doc, $colgroup, $13, 208);
     _prvTidyFreeNode($doc, $13);
     break;
    }
    HEAP32[$13 >> 2] = $colgroup;
    $42 = HEAP32[$9 >> 2] | 0;
    HEAP32[$13 + 4 >> 2] = $42;
    if (!$42) HEAP32[$10 >> 2] = $13; else HEAP32[$42 + 8 >> 2] = $13;
    HEAP32[$9 >> 2] = $13;
    $47 = HEAP32[$11 >> 2] | 0;
    $49 = HEAP32[$36 + 16 >> 2] | 0;
    if (!($49 & 1)) {
     if (!($49 & 16)) HEAP32[$47 + 16 >> 2] = 0;
    } else {
     HEAP32[$47 + 8 >> 2] = 0;
     if (!(HEAP32[$36 + 20 >> 2] | 0)) break;
    }
    $60 = HEAP32[$36 + 20 >> 2] | 0;
    if (!(($60 | 0) == 0 | ($40 | 0) == 7)) {
     HEAP32[$47 + 72 >> 2] = $13;
     FUNCTION_TABLE_viii[$60 & 63]($doc, $13, 0);
    }
   }
  } while (0);
  $13 = _prvTidyGetToken($doc, 0) | 0;
  if (!$13) {
   label = 33;
   break;
  }
 }
 if ((label | 0) == 6) {
  _prvTidyFreeNode($doc, $$lcssa23);
  HEAP32[$colgroup + 56 >> 2] = 1;
  return;
 } else if ((label | 0) == 14) {
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 16) {
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 21) {
  _prvTidyUngetToken($doc);
  return;
 } else if ((label | 0) == 33) return;
}

function _prvTidyBQ2Div($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0$idx$val4 = 0, $$015 = 0, $$lcssa = 0, $1 = 0, $10 = 0, $12 = 0, $14 = 0, $18 = 0, $2 = 0, $24 = 0, $25 = 0, $29 = 0, $3 = 0, $33 = 0, $34 = 0, $38 = 0, $45 = 0, $7 = 0, $child$02$i = 0, $indent$0$lcssa18 = 0, $indent$05 = 0, $indent$05$lcssa = 0, $indent_buf = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer = sp;
 $indent_buf = sp + 8 | 0;
 if (!$node) {
  STACKTOP = sp;
  return;
 }
 $1 = $doc + 6856 | 0;
 $$015 = $node;
 do {
  $2 = $$015 + 28 | 0;
  $3 = HEAP32[$2 >> 2] | 0;
  if (!$3) label = 17; else if ((HEAP32[$3 >> 2] | 0) == 15) {
   $7 = $$015 + 60 | 0;
   if (!(HEAP32[$7 >> 2] | 0)) label = 17; else {
    $10 = $$015 + 12 | 0;
    $$0$idx$val4 = HEAP32[$10 >> 2] | 0;
    L10 : do if (!$$0$idx$val4) $indent$0$lcssa18 = 1; else {
     $12 = $$015 + 16 | 0;
     $14 = $$0$idx$val4;
     $indent$05 = 1;
     while (1) {
      if (HEAP32[$14 + 8 >> 2] | 0) {
       $$lcssa = $14;
       $indent$05$lcssa = $indent$05;
       break;
      }
      $18 = HEAP32[$14 + 28 >> 2] | 0;
      if (!$18) {
       $$lcssa = $14;
       $indent$05$lcssa = $indent$05;
       break;
      }
      if ((HEAP32[$18 >> 2] | 0) != 15) {
       $$lcssa = $14;
       $indent$05$lcssa = $indent$05;
       break;
      }
      if (!(HEAP32[$7 >> 2] | 0)) {
       $$lcssa = $14;
       $indent$05$lcssa = $indent$05;
       break;
      }
      $24 = $indent$05 + 1 | 0;
      $25 = $14 + 12 | 0;
      HEAP32[$10 >> 2] = HEAP32[$25 >> 2];
      HEAP32[$12 >> 2] = HEAP32[$14 + 16 >> 2];
      HEAP32[$25 >> 2] = 0;
      _prvTidyFreeNode($doc, $14);
      $14 = HEAP32[$10 >> 2] | 0;
      $29 = ($14 | 0) == 0;
      if ($29) {
       $indent$0$lcssa18 = $24;
       break L10;
      } else $child$02$i = $14;
      do {
       HEAP32[$child$02$i >> 2] = $$015;
       $child$02$i = HEAP32[$child$02$i + 8 >> 2] | 0;
      } while (($child$02$i | 0) != 0);
      if ($29) {
       $indent$0$lcssa18 = $24;
       break L10;
      } else $indent$05 = $24;
     }
     _prvTidyBQ2Div($doc, $$lcssa);
     $indent$0$lcssa18 = $indent$05$lcssa;
    } while (0);
    HEAP32[$vararg_buffer >> 2] = $indent$0$lcssa18 << 1;
    _prvTidytmbsnprintf($indent_buf, 32, 311399, $vararg_buffer) | 0;
    $33 = _prvTidyLookupTagDef(30) | 0;
    $34 = HEAP32[$1 >> 2] | 0;
    $38 = $$015 + 32 | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$34 >> 2] | 0) + 8 >> 2] & 15]($34, HEAP32[$38 >> 2] | 0);
    HEAP32[$38 >> 2] = _prvTidytmbstrdup(HEAP32[$1 >> 2] | 0, HEAP32[$33 + 4 >> 2] | 0) | 0;
    HEAP32[$2 >> 2] = $33;
    _prvTidyAddStyleProperty($doc, $$015, $indent_buf);
   }
  } else label = 17;
  if ((label | 0) == 17) {
   label = 0;
   $45 = HEAP32[$$015 + 12 >> 2] | 0;
   if ($45 | 0) _prvTidyBQ2Div($doc, $45);
  }
  $$015 = HEAP32[$$015 + 8 >> 2] | 0;
 } while (($$015 | 0) != 0);
 STACKTOP = sp;
 return;
}

function _CheckValign($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $$ph = 0, $$pre = 0, $$pre21 = 0, $$pre22 = 0, $$pre23 = 0, $$pre24 = 0, $1 = 0, $10 = 0, $15 = 0, $2 = 0, $23 = 0, $24 = 0, $26 = 0, $32 = 0, $38 = 0, $4 = 0, $p$01$i = 0, $v$01$i = 0, $v$01$i$ph = 0, label = 0;
 if ($attval | 0) {
  $1 = $attval + 24 | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  if ($2 | 0) {
   $4 = HEAP8[$2 >> 0] | 0;
   L4 : do if (!($4 << 24 >> 24)) {
    $$ph = 308203;
    $v$01$i$ph = 58376;
    label = 11;
   } else {
    $10 = $4;
    $p$01$i = $2;
    while (1) {
     $p$01$i = $p$01$i + 1 | 0;
     if (_prvTidyIsUpper($10 << 24 >> 24) | 0) break;
     $10 = HEAP8[$p$01$i >> 0] | 0;
     if (!($10 << 24 >> 24)) {
      $$ph = 308203;
      $v$01$i$ph = 58376;
      label = 11;
      break L4;
     }
    }
    $15 = (HEAP32[$doc + 68 >> 2] | 0) + 28 | 0;
    if (!(HEAP32[$15 >> 2] | 0)) label = 9; else {
     _prvTidyReportAttrError($doc, $node, $attval, 269);
     if (!(HEAP32[$15 >> 2] | 0)) label = 9;
    }
    if ((label | 0) == 9) if (!(HEAP32[$doc + 336 >> 2] | 0)) {
     $$ph = 308203;
     $v$01$i$ph = 58376;
     label = 11;
     break;
    }
    $23 = _prvTidytmbstrtolower(HEAP32[$1 >> 2] | 0) | 0;
    HEAP32[$1 >> 2] = $23;
    $24 = $23;
    $26 = 308203;
    $v$01$i = 58376;
   } while (0);
   while (1) {
    if ((label | 0) == 11) {
     label = 0;
     $24 = HEAP32[$1 >> 2] | 0;
     $26 = $$ph;
     $v$01$i = $v$01$i$ph;
    }
    if ($24 | 0) if (!(_prvTidytmbstrcasecmp($24, $26) | 0)) {
     label = 24;
     break;
    }
    $v$01$i$ph = $v$01$i + 4 | 0;
    $$ph = HEAP32[$v$01$i$ph >> 2] | 0;
    if (!$$ph) break; else label = 11;
   }
   if ((label | 0) == 24) return;
   $32 = HEAP32[$1 >> 2] | 0;
   do if ($32 | 0) {
    if (_prvTidytmbstrcasecmp($32, 308192) | 0) {
     $$pre = HEAP32[$1 >> 2] | 0;
     if (!$$pre) break;
     if (_prvTidytmbstrcasecmp($$pre, 308197) | 0) {
      $$pre21 = HEAP32[$1 >> 2] | 0;
      if (!$$pre21) break;
      if (_prvTidytmbstrcasecmp($$pre21, 304537) | 0) {
       $$pre22 = HEAP32[$1 >> 2] | 0;
       if (!$$pre22) break;
       if (_prvTidytmbstrcasecmp($$pre22, 304545) | 0) {
        $$pre23 = HEAP32[$1 >> 2] | 0;
        if (!$$pre23) break;
        if (_prvTidytmbstrcasecmp($$pre23, 304555) | 0) {
         $$pre24 = HEAP32[$1 >> 2] | 0;
         if (!$$pre24) break;
         if (_prvTidytmbstrcasecmp($$pre24, 304565) | 0) break;
        }
       }
      }
      _prvTidyConstrainVersion($doc, 57344);
      _prvTidyReportAttrError($doc, $node, $attval, 254);
      return;
     }
    }
    $38 = HEAP32[$node + 28 >> 2] | 0;
    if ($38 | 0) if (HEAP32[$38 + 16 >> 2] & 65536 | 0) return;
    _prvTidyReportAttrError($doc, $node, $attval, 251);
    return;
   } while (0);
   _prvTidyReportAttrError($doc, $node, $attval, 251);
   return;
  }
 }
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 return;
}

function _prvTidyTrimEmptyElement($doc, $element) {
 $doc = $doc | 0;
 $element = $element | 0;
 var $$0 = 0, $$pr32$pr$pre$i = 0, $12 = 0, $18 = 0, $30 = 0, $37 = 0, $38 = 0, $40 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $57 = 0, $59 = 0, $61 = 0, $63 = 0, $66 = 0, $8 = 0, $9 = 0;
 L1 : do if (HEAP32[$doc + 220 >> 2] | 0) {
  L3 : do if (!(_prvTidynodeIsText($element) | 0)) {
   if (HEAP32[$element + 12 >> 2] | 0) break L1;
   $8 = $element + 28 | 0;
   $9 = HEAP32[$8 >> 2] | 0;
   if (!$9) break L1;
   $12 = HEAP32[$9 + 16 >> 2] | 0;
   if ($12 & 8 | 0) if (HEAP32[$element + 20 >> 2] | 0) break L1;
   $18 = HEAP32[$9 >> 2] | 0;
   L10 : do switch ($18 | 0) {
   case 1:
    {
     if (!(($12 & 513 | 0) == 0 & (HEAP32[$element + 20 >> 2] | 0) == 0)) break L1;
     break;
    }
   case 80:
    {
     if (!(($12 & 513 | 0) == 0 & (HEAP32[$doc + 224 >> 2] | 0) != 0)) break L1;
     break;
    }
   default:
    {
     if ($12 & 513 | 0) break L1;
     switch ($18 | 0) {
     case 76:
     case 6:
      {
       break L1;
       break;
      }
     case 94:
      {
       if (_prvTidyAttrGetById($element, 139) | 0) break L1;
       $$pr32$pr$pre$i = HEAP32[$8 >> 2] | 0;
       if (!$$pr32$pr$pre$i) break L10;
       $30 = HEAP32[$$pr32$pr$pre$i >> 2] | 0;
       break;
      }
     default:
      $30 = $18;
     }
     switch ($30 | 0) {
     case 143:
     case 127:
     case 110:
     case 50:
     case 114:
      {
       break L1;
       break;
      }
     default:
      {}
     }
    }
   } while (0);
   if (_prvTidyAttrGetById($element, 63) | 0) break L1;
   if (_prvTidyAttrGetById($element, 85) | 0) break L1;
   if (_prvTidyAttrGetById($element, 39) | 0) break L1;
   $37 = HEAP32[$8 >> 2] | 0;
   $38 = HEAP32[$37 >> 2] | 0;
   if (!$38) break L1;
   $40 = ($37 | 0) == 0;
   if (($38 | 8 | 0) == 24 & ($40 ^ 1)) break L1;
   if (!$40) {
    switch ($38 | 0) {
    case 26:
     {
      break L1;
      break;
     }
    case 79:
     break;
    default:
     break L3;
    }
    if (HEAP32[$element + 20 >> 2] | 0) break L1;
   }
  } while (0);
  if ((HEAP32[$element + 44 >> 2] | 0) != 4) _prvTidyReportNotice($doc, $element, 0, 223);
  $49 = $element + 8 | 0;
  $50 = HEAP32[$49 >> 2] | 0;
  $51 = $element + 4 | 0;
  $52 = HEAP32[$51 >> 2] | 0;
  if (!$52) $57 = $50; else {
   HEAP32[$52 + 8 >> 2] = $50;
   $57 = HEAP32[$49 >> 2] | 0;
  }
  $59 = $57;
  if ($57 | 0) HEAP32[$57 + 4 >> 2] = $52;
  $61 = HEAP32[$element >> 2] | 0;
  if ($61 | 0) {
   $63 = $61 + 12 | 0;
   if ((HEAP32[$63 >> 2] | 0) == ($element | 0)) HEAP32[$63 >> 2] = $59;
   $66 = $61 + 16 | 0;
   if ((HEAP32[$66 >> 2] | 0) == ($element | 0)) HEAP32[$66 >> 2] = HEAP32[$51 >> 2];
  }
  HEAP32[$49 >> 2] = 0;
  HEAP32[$51 >> 2] = 0;
  HEAP32[$element >> 2] = 0;
  _prvTidyFreeNode($doc, $element);
  $$0 = $50;
  return $$0 | 0;
 } while (0);
 $$0 = HEAP32[$element + 8 >> 2] | 0;
 return $$0 | 0;
}

function _CheckColumns($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $0 = 0, $12 = 0, $13 = 0, $14 = 0, $18 = 0, $22 = 0, $25 = 0, $26 = 0, $37 = 0, $4 = 0, $41 = 0, $7 = 0, $cp$03$i = 0, $i$02$i = 0, $isMissingHeader$012 = 0, $isMissingHeader$1 = 0, $isMissingHeader$1$lcssa = 0, $isWht$0$lcssa$i = 0, $isWht$02$i = 0, $numTH$011 = 0, $numTH$2 = 0, $numTH$2$lcssa = 0, $tnode$0 = 0, $tnode$013 = 0, $x$01$i = 0, $x$1$i = 0;
 $0 = $doc + 6668 | 0;
 HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + 1;
 $4 = HEAP32[$node + 12 >> 2] | 0;
 if (!$4) return;
 $7 = HEAP32[$4 + 28 >> 2] | 0;
 if (!$7) return;
 if ((HEAP32[$7 >> 2] | 0) != 112) return;
 HEAP32[$doc + 6692 >> 2] = 1;
 $12 = $doc + 6532 | 0;
 $13 = $doc + 68 | 0;
 $14 = $7;
 $isMissingHeader$012 = 0;
 $numTH$011 = 0;
 $tnode$013 = $4;
 while (1) {
  if (!$14) {
   $isMissingHeader$1 = 1;
   $numTH$2 = $numTH$011;
  } else if ((HEAP32[$14 >> 2] | 0) == 112) {
   $18 = $tnode$013 + 12 | 0;
   if (!(_prvTidynodeIsText(HEAP32[$18 >> 2] | 0) | 0)) {
    $isMissingHeader$1 = $isMissingHeader$012;
    $numTH$2 = $numTH$011;
   } else {
    $22 = HEAP32[$18 >> 2] | 0;
    L16 : do if (!$22) $x$1$i = 0; else {
     $25 = HEAP32[$22 + 36 >> 2] | 0;
     $26 = $22 + 40 | 0;
     if ($25 >>> 0 < (HEAP32[$26 >> 2] | 0) >>> 0) {
      $i$02$i = $25;
      $x$01$i = 0;
      while (1) {
       HEAP8[$doc + 6532 + $x$01$i >> 0] = HEAP8[(HEAP32[(HEAP32[$13 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i >> 0] | 0;
       if ($x$01$i >>> 0 > 126) {
        $x$1$i = $x$01$i;
        break L16;
       }
       $i$02$i = $i$02$i + 1 | 0;
       $37 = $x$01$i + 1 | 0;
       if ($i$02$i >>> 0 >= (HEAP32[$26 >> 2] | 0) >>> 0) {
        $x$1$i = $37;
        break;
       } else $x$01$i = $37;
      }
     } else $x$1$i = 0;
    } while (0);
    HEAP8[$doc + 6532 + $x$1$i >> 0] = 0;
    $cp$03$i = $12;
    $isWht$02$i = 1;
    while (1) {
     $41 = HEAP8[$cp$03$i >> 0] | 0;
     if (!($41 << 24 >> 24)) {
      $isWht$0$lcssa$i = $isWht$02$i;
      break;
     }
     $isWht$02$i = _prvTidyIsWhite($41 << 24 >> 24) | 0;
     if (!$isWht$02$i) {
      $isWht$0$lcssa$i = 0;
      break;
     } else $cp$03$i = $cp$03$i + 1 | 0;
    }
    $isMissingHeader$1 = $isMissingHeader$012;
    $numTH$2 = (($isWht$0$lcssa$i | 0) == 0 & 1) + $numTH$011 | 0;
   }
  } else {
   $isMissingHeader$1 = 1;
   $numTH$2 = $numTH$011;
  }
  $tnode$0 = HEAP32[$tnode$013 + 8 >> 2] | 0;
  if (!$tnode$0) {
   $isMissingHeader$1$lcssa = $isMissingHeader$1;
   $numTH$2$lcssa = $numTH$2;
   break;
  }
  $14 = HEAP32[$tnode$0 + 28 >> 2] | 0;
  $isMissingHeader$012 = $isMissingHeader$1;
  $numTH$011 = $numTH$2;
  $tnode$013 = $tnode$0;
 }
 if (($numTH$2$lcssa | 0) > 0 & ($isMissingHeader$1$lcssa | 0) == 0) HEAP32[$doc + 6708 >> 2] = 1;
 if (!(($numTH$2$lcssa | 0) > 1 & ($isMissingHeader$1$lcssa | 0) != 0)) return;
 HEAP32[$doc + 6716 >> 2] = 1;
 return;
}

function _ParseNewline($doc, $entry) {
 $doc = $doc | 0;
 $entry = $entry | 0;
 var $$0$i$i = 0, $$lcssa = 0, $0 = 0, $1 = 0, $12 = 0, $17 = 0, $32 = 0, $c$016 = 0, $config$idx$i = 0, $config$idx$i9 = 0, $config$idx$val$i = 0, $config$idx$val$i10 = 0, $cp$0$lcssa = 0, $cp$015 = 0, $nl$0$lobit = 0, $nl$0$lobit$not = 0, $nl$0$ph = 0, $nl$013 = 0, $work = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $work = sp;
 dest = $work;
 stop = dest + 16 | 0;
 do {
  HEAP8[dest >> 0] = 0;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 $0 = $work + 16 | 0;
 $1 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$1 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$1 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$1 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $12 = HEAP32[$1 >> 2] | 0;
 L10 : do if (($12 | 0) == -1) $cp$0$lcssa = $work; else {
  $config$idx$i9 = $doc + 872 | 0;
  $c$016 = $12;
  $cp$015 = $work;
  while (1) {
   if (_prvTidyIsWhite($c$016) | 0) {
    $cp$0$lcssa = $cp$015;
    break L10;
   }
   switch ($c$016 | 0) {
   case 10:
   case 13:
    {
     $cp$0$lcssa = $cp$015;
     break L10;
     break;
    }
   default:
    {}
   }
   $17 = $cp$015 + 1 | 0;
   HEAP8[$cp$015 >> 0] = $c$016;
   if ((HEAP32[$1 >> 2] | 0) == -1) {
    $cp$0$lcssa = $17;
    break L10;
   }
   $config$idx$val$i10 = HEAP32[$config$idx$i9 >> 2] | 0;
   if (!$config$idx$val$i10) {
    $$lcssa = $17;
    break;
   }
   $c$016 = _prvTidyReadChar($config$idx$val$i10) | 0;
   HEAP32[$1 >> 2] = $c$016;
   if (!($17 >>> 0 < $0 >>> 0 & ($c$016 | 0) != -1)) {
    $cp$0$lcssa = $17;
    break L10;
   } else $cp$015 = $17;
  }
  HEAP32[$1 >> 2] = -1;
  $cp$0$lcssa = $$lcssa;
 } while (0);
 HEAP8[$cp$0$lcssa >> 0] = 0;
 if (!(_prvTidytmbstrcasecmp($work, 223957) | 0)) $nl$0$ph = 0; else if (!(_prvTidytmbstrcasecmp($work, 223960) | 0)) $nl$0$ph = 1; else if (!(_prvTidytmbstrcasecmp($work, 223965) | 0)) $nl$0$ph = 2; else {
  _prvTidyReportBadArgument($doc, HEAP32[$entry + 8 >> 2] | 0);
  $nl$013 = -1;
  $nl$0$lobit = $nl$013 >>> 31;
  $nl$0$lobit$not = $nl$0$lobit ^ 1;
  STACKTOP = sp;
  return $nl$0$lobit$not | 0;
 }
 $32 = HEAP32[$entry >> 2] | 0;
 if ($32 >>> 0 >= 98) {
  $nl$013 = $nl$0$ph;
  $nl$0$lobit = $nl$013 >>> 31;
  $nl$0$lobit$not = $nl$0$lobit ^ 1;
  STACKTOP = sp;
  return $nl$0$lobit$not | 0;
 }
 if ((HEAP32[1892 + ($32 << 5) + 12 >> 2] | 0) != 1) ___assert_fail(223759, 223800, 398, 223889);
 HEAP32[$doc + 72 + ($32 << 2) >> 2] = $nl$0$ph;
 $nl$013 = $nl$0$ph;
 $nl$0$lobit = $nl$013 >>> 31;
 $nl$0$lobit$not = $nl$0$lobit ^ 1;
 STACKTOP = sp;
 return $nl$0$lobit$not | 0;
}

function _pop_arg($arg, $type, $ap) {
 $arg = $arg | 0;
 $type = $type | 0;
 $ap = $ap | 0;
 var $105 = 0, $106 = 0.0, $112 = 0, $113 = 0.0, $13 = 0, $14 = 0, $17 = 0, $26 = 0, $27 = 0, $28 = 0, $37 = 0, $38 = 0, $40 = 0, $43 = 0, $44 = 0, $53 = 0, $54 = 0, $56 = 0, $59 = 0, $6 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $79 = 0, $80 = 0, $82 = 0, $85 = 0, $94 = 0, $95 = 0, $96 = 0;
 L1 : do if ($type >>> 0 <= 20) do switch ($type | 0) {
 case 9:
  {
   $6 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $7 = HEAP32[$6 >> 2] | 0;
   HEAP32[$ap >> 2] = $6 + 4;
   HEAP32[$arg >> 2] = $7;
   break L1;
   break;
  }
 case 10:
  {
   $13 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $14 = HEAP32[$13 >> 2] | 0;
   HEAP32[$ap >> 2] = $13 + 4;
   $17 = $arg;
   HEAP32[$17 >> 2] = $14;
   HEAP32[$17 + 4 >> 2] = (($14 | 0) < 0) << 31 >> 31;
   break L1;
   break;
  }
 case 11:
  {
   $26 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $27 = HEAP32[$26 >> 2] | 0;
   HEAP32[$ap >> 2] = $26 + 4;
   $28 = $arg;
   HEAP32[$28 >> 2] = $27;
   HEAP32[$28 + 4 >> 2] = 0;
   break L1;
   break;
  }
 case 12:
  {
   $37 = (HEAP32[$ap >> 2] | 0) + (8 - 1) & ~(8 - 1);
   $38 = $37;
   $40 = HEAP32[$38 >> 2] | 0;
   $43 = HEAP32[$38 + 4 >> 2] | 0;
   HEAP32[$ap >> 2] = $37 + 8;
   $44 = $arg;
   HEAP32[$44 >> 2] = $40;
   HEAP32[$44 + 4 >> 2] = $43;
   break L1;
   break;
  }
 case 13:
  {
   $53 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $54 = HEAP32[$53 >> 2] | 0;
   HEAP32[$ap >> 2] = $53 + 4;
   $56 = ($54 & 65535) << 16 >> 16;
   $59 = $arg;
   HEAP32[$59 >> 2] = $56;
   HEAP32[$59 + 4 >> 2] = (($56 | 0) < 0) << 31 >> 31;
   break L1;
   break;
  }
 case 14:
  {
   $68 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $69 = HEAP32[$68 >> 2] | 0;
   HEAP32[$ap >> 2] = $68 + 4;
   $70 = $arg;
   HEAP32[$70 >> 2] = $69 & 65535;
   HEAP32[$70 + 4 >> 2] = 0;
   break L1;
   break;
  }
 case 15:
  {
   $79 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $80 = HEAP32[$79 >> 2] | 0;
   HEAP32[$ap >> 2] = $79 + 4;
   $82 = ($80 & 255) << 24 >> 24;
   $85 = $arg;
   HEAP32[$85 >> 2] = $82;
   HEAP32[$85 + 4 >> 2] = (($82 | 0) < 0) << 31 >> 31;
   break L1;
   break;
  }
 case 16:
  {
   $94 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $95 = HEAP32[$94 >> 2] | 0;
   HEAP32[$ap >> 2] = $94 + 4;
   $96 = $arg;
   HEAP32[$96 >> 2] = $95 & 255;
   HEAP32[$96 + 4 >> 2] = 0;
   break L1;
   break;
  }
 case 17:
  {
   $105 = (HEAP32[$ap >> 2] | 0) + (8 - 1) & ~(8 - 1);
   $106 = +HEAPF64[$105 >> 3];
   HEAP32[$ap >> 2] = $105 + 8;
   HEAPF64[$arg >> 3] = $106;
   break L1;
   break;
  }
 case 18:
  {
   $112 = (HEAP32[$ap >> 2] | 0) + (8 - 1) & ~(8 - 1);
   $113 = +HEAPF64[$112 >> 3];
   HEAP32[$ap >> 2] = $112 + 8;
   HEAPF64[$arg >> 3] = $113;
   break L1;
   break;
  }
 default:
  break L1;
 } while (0); while (0);
 return;
}

function ___stdio_write($f, $buf, $len) {
 $f = $f | 0;
 $buf = $buf | 0;
 $len = $len | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $15 = 0, $20 = 0, $25 = 0, $3 = 0, $34 = 0, $36 = 0, $38 = 0, $49 = 0, $5 = 0, $9 = 0, $cnt$0 = 0, $cnt$1 = 0, $iov$0 = 0, $iov$0$lcssa11 = 0, $iov$1 = 0, $iovcnt$0 = 0, $iovcnt$0$lcssa12 = 0, $iovcnt$1 = 0, $iovs = 0, $rem$0 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $iovs = sp + 32 | 0;
 $0 = $f + 28 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 HEAP32[$iovs >> 2] = $1;
 $3 = $f + 20 | 0;
 $5 = (HEAP32[$3 >> 2] | 0) - $1 | 0;
 HEAP32[$iovs + 4 >> 2] = $5;
 HEAP32[$iovs + 8 >> 2] = $buf;
 HEAP32[$iovs + 12 >> 2] = $len;
 $9 = $f + 60 | 0;
 $10 = $f + 44 | 0;
 $iov$0 = $iovs;
 $iovcnt$0 = 2;
 $rem$0 = $5 + $len | 0;
 while (1) {
  if (!(HEAP32[79254] | 0)) {
   HEAP32[$vararg_buffer3 >> 2] = HEAP32[$9 >> 2];
   HEAP32[$vararg_buffer3 + 4 >> 2] = $iov$0;
   HEAP32[$vararg_buffer3 + 8 >> 2] = $iovcnt$0;
   $cnt$0 = ___syscall_ret(___syscall146(146, $vararg_buffer3 | 0) | 0) | 0;
  } else {
   _pthread_cleanup_push(1, $f | 0);
   HEAP32[$vararg_buffer >> 2] = HEAP32[$9 >> 2];
   HEAP32[$vararg_buffer + 4 >> 2] = $iov$0;
   HEAP32[$vararg_buffer + 8 >> 2] = $iovcnt$0;
   $15 = ___syscall_ret(___syscall146(146, $vararg_buffer | 0) | 0) | 0;
   _pthread_cleanup_pop(0);
   $cnt$0 = $15;
  }
  if (($rem$0 | 0) == ($cnt$0 | 0)) {
   label = 6;
   break;
  }
  if (($cnt$0 | 0) < 0) {
   $iov$0$lcssa11 = $iov$0;
   $iovcnt$0$lcssa12 = $iovcnt$0;
   label = 8;
   break;
  }
  $34 = $rem$0 - $cnt$0 | 0;
  $36 = HEAP32[$iov$0 + 4 >> 2] | 0;
  if ($cnt$0 >>> 0 > $36 >>> 0) {
   $38 = HEAP32[$10 >> 2] | 0;
   HEAP32[$0 >> 2] = $38;
   HEAP32[$3 >> 2] = $38;
   $49 = HEAP32[$iov$0 + 12 >> 2] | 0;
   $cnt$1 = $cnt$0 - $36 | 0;
   $iov$1 = $iov$0 + 8 | 0;
   $iovcnt$1 = $iovcnt$0 + -1 | 0;
  } else if (($iovcnt$0 | 0) == 2) {
   HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + $cnt$0;
   $49 = $36;
   $cnt$1 = $cnt$0;
   $iov$1 = $iov$0;
   $iovcnt$1 = 2;
  } else {
   $49 = $36;
   $cnt$1 = $cnt$0;
   $iov$1 = $iov$0;
   $iovcnt$1 = $iovcnt$0;
  }
  HEAP32[$iov$1 >> 2] = (HEAP32[$iov$1 >> 2] | 0) + $cnt$1;
  HEAP32[$iov$1 + 4 >> 2] = $49 - $cnt$1;
  $iov$0 = $iov$1;
  $iovcnt$0 = $iovcnt$1;
  $rem$0 = $34;
 }
 if ((label | 0) == 6) {
  $20 = HEAP32[$10 >> 2] | 0;
  HEAP32[$f + 16 >> 2] = $20 + (HEAP32[$f + 48 >> 2] | 0);
  $25 = $20;
  HEAP32[$0 >> 2] = $25;
  HEAP32[$3 >> 2] = $25;
  $$0 = $len;
 } else if ((label | 0) == 8) {
  HEAP32[$f + 16 >> 2] = 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$3 >> 2] = 0;
  HEAP32[$f >> 2] = HEAP32[$f >> 2] | 32;
  if (($iovcnt$0$lcssa12 | 0) == 2) $$0 = 0; else $$0 = $len - (HEAP32[$iov$0$lcssa11 + 4 >> 2] | 0) | 0;
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _CleanNode($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$pr$pre = 0, $$pr3$pr9 = 0, $1 = 0, $17 = 0, $18 = 0, $20 = 0, $21 = 0, $24 = 0, $26 = 0, $28 = 0, $3 = 0, $31 = 0, $32 = 0, $39 = 0, $4 = 0, $47 = 0, $7 = 0, $8 = 0, $child$05 = 0, $next$sroa$0$1 = 0, $node$01$i = 0, $node$02$i = 0;
 $1 = HEAP32[$node + 12 >> 2] | 0;
 if (!$1) return; else $child$05 = $1;
 while (1) {
  $3 = $child$05 + 8 | 0;
  $4 = HEAP32[$3 >> 2] | 0;
  L5 : do if (!(_prvTidynodeIsElement($child$05) | 0)) $next$sroa$0$1 = $4; else {
   $7 = $child$05 + 28 | 0;
   $8 = HEAP32[$7 >> 2] | 0;
   L7 : do if ($8 | 0) {
    if ((HEAP32[$8 >> 2] | 0) == 103) {
     _prvTidyDiscardElement($doc, $child$05) | 0;
     $$pr$pre = HEAP32[$7 >> 2] | 0;
     if (!$$pr$pre) break; else $$pr3$pr9 = $$pr$pre;
    } else $$pr3$pr9 = $8;
    switch (HEAP32[$$pr3$pr9 >> 2] | 0) {
    case 80:
     {
      if (HEAP32[$child$05 + 12 >> 2] | 0) break L7;
      _prvTidyDiscardElement($doc, $child$05) | 0;
      $next$sroa$0$1 = $4;
      break L5;
      break;
     }
    case 100:
     {
      $17 = $child$05 + 12 | 0;
      $18 = HEAP32[$17 >> 2] | 0;
      $20 = $18;
      if (!$18) {
       $next$sroa$0$1 = _prvTidyDiscardElement($doc, $child$05) | 0;
       break L5;
      }
      $21 = HEAP32[$child$05 >> 2] | 0;
      $24 = HEAP32[$child$05 + 16 >> 2] | 0;
      HEAP32[$24 + 8 >> 2] = HEAP32[$3 >> 2];
      $26 = HEAP32[$3 >> 2] | 0;
      $28 = $24;
      if (!$26) HEAP32[$21 + 16 >> 2] = $28; else HEAP32[$26 + 4 >> 2] = $28;
      $31 = $child$05 + 4 | 0;
      $32 = HEAP32[$31 >> 2] | 0;
      if (!$32) HEAP32[$21 + 12 >> 2] = $20; else {
       HEAP32[$18 + 4 >> 2] = $32;
       HEAP32[(HEAP32[$31 >> 2] | 0) + 8 >> 2] = $20;
      }
      $node$01$i = HEAP32[$17 >> 2] | 0;
      $39 = $node$01$i;
      if ($node$01$i | 0) {
       $node$02$i = $node$01$i;
       do {
        HEAP32[$node$02$i >> 2] = $21;
        $node$02$i = HEAP32[$node$02$i + 8 >> 2] | 0;
       } while (($node$02$i | 0) != 0);
      }
      HEAP32[$17 >> 2] = 0;
      HEAP32[$3 >> 2] = 0;
      _prvTidyFreeNode($doc, $child$05);
      $next$sroa$0$1 = $39;
      break L5;
      break;
     }
    case 1:
     {
      if (HEAP32[$child$05 + 12 >> 2] | 0) break L7;
      $47 = _prvTidyGetAttrByName($child$05, 311658) | 0;
      if ($47 | 0) _prvTidyRepairAttrValue($doc, HEAP32[$child$05 >> 2] | 0, 311655, HEAP32[$47 + 24 >> 2] | 0) | 0;
      _prvTidyDiscardElement($doc, $child$05) | 0;
      $next$sroa$0$1 = $4;
      break L5;
      break;
     }
    default:
     break L7;
    }
   } while (0);
   if (HEAP32[$child$05 + 20 >> 2] | 0) _prvTidyDropAttrByName($doc, $child$05, 310945);
   _CleanNode($doc, $child$05);
   $next$sroa$0$1 = $4;
  } while (0);
  if (!$next$sroa$0$1) break; else $child$05 = $next$sroa$0$1;
 }
 return;
}

function _prvTidyEncodeCharToUTF8Bytes($c, $encodebuf, $outp, $count) {
 $c = $c | 0;
 $encodebuf = $encodebuf | 0;
 $outp = $outp | 0;
 $count = $count | 0;
 var $$encodebuf = 0, $104 = 0, $14 = 0, $2 = 0, $28 = 0, $6 = 0, $94 = 0, $97 = 0, $99 = 0, $bytes$0 = 0, $bytes$0$ph = 0, $hasError$0 = 0, $tempbuf = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $tempbuf = sp;
 dest = $tempbuf;
 stop = dest + 10 | 0;
 do {
  HEAP8[dest >> 0] = 0;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 $$encodebuf = ($encodebuf | 0) == 0 ? $tempbuf : $encodebuf;
 do if ($c >>> 0 < 128) {
  $2 = $c & 255;
  HEAP8[$$encodebuf >> 0] = $2;
  $97 = $2;
  $bytes$0 = 1;
  $hasError$0 = 1;
 } else {
  if ($c >>> 0 < 2048) {
   $6 = ($c >>> 6 | 192) & 255;
   HEAP8[$$encodebuf >> 0] = $6;
   HEAP8[$$encodebuf + 1 >> 0] = $c & 63 | 128;
   $97 = $6;
   $bytes$0 = 2;
   $hasError$0 = 1;
   break;
  }
  if ($c >>> 0 < 65536) {
   $14 = ($c >>> 12 | 224) & 255;
   HEAP8[$$encodebuf >> 0] = $14;
   HEAP8[$$encodebuf + 1 >> 0] = $c >>> 6 & 63 | 128;
   HEAP8[$$encodebuf + 2 >> 0] = $c & 63 | 128;
   $97 = $14;
   $bytes$0 = 3;
   $hasError$0 = ($c | 1 | 0) != 65535;
   break;
  }
  if ($c >>> 0 < 2097152) {
   $28 = ($c >>> 18 | 240) & 255;
   HEAP8[$$encodebuf >> 0] = $28;
   HEAP8[$$encodebuf + 1 >> 0] = $c >>> 12 & 63 | 128;
   HEAP8[$$encodebuf + 2 >> 0] = $c >>> 6 & 63 | 128;
   HEAP8[$$encodebuf + 3 >> 0] = $c & 63 | 128;
   $97 = $28;
   $bytes$0 = 4;
   $hasError$0 = $c >>> 0 < 1114112;
   break;
  }
  if ($c >>> 0 < 67108864) {
   HEAP8[$$encodebuf >> 0] = $c >>> 24 | 248;
   HEAP8[$$encodebuf + 1 >> 0] = $c >>> 18 | 128;
   HEAP8[$$encodebuf + 2 >> 0] = $c >>> 12 & 63 | 128;
   HEAP8[$$encodebuf + 3 >> 0] = $c >>> 6 & 63 | 128;
   HEAP8[$$encodebuf + 4 >> 0] = $c & 63 | 128;
   $bytes$0$ph = 5;
  } else if (($c | 0) > -1) {
   HEAP8[$$encodebuf >> 0] = $c >>> 30 | 252;
   HEAP8[$$encodebuf + 1 >> 0] = $c >>> 24 & 63 | 128;
   HEAP8[$$encodebuf + 2 >> 0] = $c >>> 18 & 63 | 128;
   HEAP8[$$encodebuf + 3 >> 0] = $c >>> 12 & 63 | 128;
   HEAP8[$$encodebuf + 4 >> 0] = $c >>> 6 & 63 | 128;
   HEAP8[$$encodebuf + 5 >> 0] = $c & 63 | 128;
   $bytes$0$ph = 6;
  } else $bytes$0$ph = 0;
  HEAP32[$count >> 2] = $bytes$0$ph;
  $104 = -1;
  STACKTOP = sp;
  return $104 | 0;
 } while (0);
 if (($outp | 0) != 0 & $hasError$0) {
  $94 = $outp + 4 | 0;
  FUNCTION_TABLE_vii[HEAP32[$94 >> 2] & 15](HEAP32[$outp >> 2] | 0, $97);
  if ($bytes$0 >>> 0 > 1) {
   $99 = 1;
   do {
    FUNCTION_TABLE_vii[HEAP32[$94 >> 2] & 15](HEAP32[$outp >> 2] | 0, HEAP8[$$encodebuf + $99 >> 0] | 0);
    $99 = $99 + 1 | 0;
   } while (($99 | 0) < ($bytes$0 | 0));
  }
 }
 HEAP32[$count >> 2] = $bytes$0;
 $104 = ($hasError$0 ^ 1) << 31 >> 31;
 STACKTOP = sp;
 return $104 | 0;
}

function _print_xml_help_option_element($element, $name) {
 $element = $element | 0;
 $name = $name | 0;
 var $1 = 0, $12 = 0, $16 = 0, $2 = 0, $4 = 0, $aux$i = 0, $c$07$i = 0, $c$15$i = 0, $endptr$i = 0, $endptr2$i = 0, $endptr4$i = 0, $len$0$lcssa$i = 0, $len$06$i = 0, $len$1$i = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $aux$i = sp + 12 | 0;
 if (!$name) {
  STACKTOP = sp;
  return;
 }
 $1 = HEAP8[$name >> 0] | 0;
 $2 = $1 << 24 >> 24 == 0;
 L4 : do if ($2) $len$0$lcssa$i = 0; else {
  $4 = $1;
  $c$07$i = $name;
  $len$06$i = 0;
  while (1) {
   switch ($4 << 24 >> 24 | 0) {
   case 62:
   case 60:
    {
     $len$1$i = $len$06$i + 4 | 0;
     break;
    }
   case 34:
    {
     $len$1$i = $len$06$i + 6 | 0;
     break;
    }
   default:
    $len$1$i = $len$06$i + 1 | 0;
   }
   $c$07$i = $c$07$i + 1 | 0;
   $4 = HEAP8[$c$07$i >> 0] | 0;
   if (!($4 << 24 >> 24)) {
    $len$0$lcssa$i = $len$1$i;
    break L4;
   } else $len$06$i = $len$1$i;
  }
 } while (0);
 $12 = _malloc($len$0$lcssa$i + 1 | 0) | 0;
 if (!$12) _outOfMemory();
 HEAP8[$12 >> 0] = 0;
 HEAP8[$aux$i + 1 >> 0] = 0;
 L16 : do if (!$2) {
  $16 = $1;
  $c$15$i = $name;
  while (1) {
   switch ($16 << 24 >> 24 | 0) {
   case 60:
    {
     $endptr4$i = $12 + (_strlen($12) | 0) | 0;
     HEAP8[$endptr4$i >> 0] = HEAP8[310722] | 0;
     HEAP8[$endptr4$i + 1 >> 0] = HEAP8[310723] | 0;
     HEAP8[$endptr4$i + 2 >> 0] = HEAP8[310724] | 0;
     HEAP8[$endptr4$i + 3 >> 0] = HEAP8[310725] | 0;
     HEAP8[$endptr4$i + 4 >> 0] = HEAP8[310726] | 0;
     break;
    }
   case 62:
    {
     $endptr2$i = $12 + (_strlen($12) | 0) | 0;
     HEAP8[$endptr2$i >> 0] = HEAP8[310727] | 0;
     HEAP8[$endptr2$i + 1 >> 0] = HEAP8[310728] | 0;
     HEAP8[$endptr2$i + 2 >> 0] = HEAP8[310729] | 0;
     HEAP8[$endptr2$i + 3 >> 0] = HEAP8[310730] | 0;
     HEAP8[$endptr2$i + 4 >> 0] = HEAP8[310731] | 0;
     break;
    }
   case 34:
    {
     $endptr$i = $12 + (_strlen($12) | 0) | 0;
     HEAP8[$endptr$i >> 0] = HEAP8[310738] | 0;
     HEAP8[$endptr$i + 1 >> 0] = HEAP8[310739] | 0;
     HEAP8[$endptr$i + 2 >> 0] = HEAP8[310740] | 0;
     HEAP8[$endptr$i + 3 >> 0] = HEAP8[310741] | 0;
     HEAP8[$endptr$i + 4 >> 0] = HEAP8[310742] | 0;
     HEAP8[$endptr$i + 5 >> 0] = HEAP8[310743] | 0;
     HEAP8[$endptr$i + 6 >> 0] = HEAP8[310744] | 0;
     break;
    }
   default:
    {
     HEAP8[$aux$i >> 0] = $16;
     _strcat($12, $aux$i) | 0;
    }
   }
   $c$15$i = $c$15$i + 1 | 0;
   $16 = HEAP8[$c$15$i >> 0] | 0;
   if (!($16 << 24 >> 24)) break L16;
  }
 } while (0);
 HEAP32[$vararg_buffer >> 2] = $element;
 HEAP32[$vararg_buffer + 4 >> 2] = $12;
 HEAP32[$vararg_buffer + 8 >> 2] = $element;
 _printf(222101, $vararg_buffer) | 0;
 _free($12);
 STACKTOP = sp;
 return;
}

function _tidyLocalizedStringN($messageType, $quantity) {
 $messageType = $messageType | 0;
 $quantity = $quantity | 0;
 var $$lcssa = 0, $$lcssa51 = 0, $$lcssa53 = 0, $$lcssa55 = 0, $0 = 0, $16 = 0, $19 = 0, $2 = 0, $21 = 0, $34 = 0, $35 = 0, $4 = 0, $48 = 0, $49 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $i$02$i = 0, $i$02$i10 = 0, $i$02$i2 = 0, $i$02$i6 = 0, $result$2 = 0, label = 0;
 $0 = HEAP32[1691] | 0;
 $2 = FUNCTION_TABLE_ii[HEAP32[$0 >> 2] & 31]($quantity) | 0;
 $4 = HEAP32[$0 + 12 >> 2] | 0;
 L1 : do if ($4 | 0) {
  $61 = $4;
  $i$02$i = 0;
  while (1) {
   if ((HEAP32[$0 + 4 + ($i$02$i * 12 | 0) >> 2] | 0) == ($messageType | 0)) if ((HEAP32[$0 + 4 + ($i$02$i * 12 | 0) + 4 >> 2] | 0) == ($2 | 0)) {
    $$lcssa55 = $61;
    break;
   }
   $i$02$i = $i$02$i + 1 | 0;
   $61 = HEAP32[$0 + 4 + ($i$02$i * 12 | 0) + 8 >> 2] | 0;
   if (!$61) break L1;
  }
  HEAP32[79117] = $messageType;
  $result$2 = $$lcssa55;
  return $result$2 | 0;
 } while (0);
 $16 = HEAP32[1692] | 0;
 L10 : do if ($16 | 0) {
  $19 = FUNCTION_TABLE_ii[HEAP32[$16 >> 2] & 31]($quantity) | 0;
  $21 = HEAP32[$16 + 12 >> 2] | 0;
  if ($21 | 0) {
   $62 = $21;
   $i$02$i2 = 0;
   while (1) {
    if ((HEAP32[$16 + 4 + ($i$02$i2 * 12 | 0) >> 2] | 0) == ($messageType | 0)) if ((HEAP32[$16 + 4 + ($i$02$i2 * 12 | 0) + 4 >> 2] | 0) == ($19 | 0)) {
     $$lcssa53 = $62;
     break;
    }
    $i$02$i2 = $i$02$i2 + 1 | 0;
    $62 = HEAP32[$16 + 4 + ($i$02$i2 * 12 | 0) + 8 >> 2] | 0;
    if (!$62) break L10;
   }
   HEAP32[79117] = $messageType;
   $result$2 = $$lcssa53;
   return $result$2 | 0;
  }
 } while (0);
 $34 = FUNCTION_TABLE_ii[HEAP32[1700] & 31]($quantity) | 0;
 $35 = HEAP32[1703] | 0;
 L20 : do if ($35 | 0) {
  $63 = $35;
  $i$02$i6 = 0;
  while (1) {
   if ((HEAP32[6804 + ($i$02$i6 * 12 | 0) >> 2] | 0) == ($messageType | 0)) if ((HEAP32[6804 + ($i$02$i6 * 12 | 0) + 4 >> 2] | 0) == ($34 | 0)) {
    $$lcssa51 = $63;
    break;
   }
   $i$02$i6 = $i$02$i6 + 1 | 0;
   $63 = HEAP32[6804 + ($i$02$i6 * 12 | 0) + 8 >> 2] | 0;
   if (!$63) break L20;
  }
  HEAP32[79117] = $messageType;
  $result$2 = $$lcssa51;
  return $result$2 | 0;
 } while (0);
 $48 = FUNCTION_TABLE_ii[HEAP32[1700] & 31](1) | 0;
 $49 = HEAP32[1703] | 0;
 if (!$49) {
  $result$2 = 0;
  return $result$2 | 0;
 } else {
  $64 = $49;
  $i$02$i10 = 0;
 }
 while (1) {
  if ((HEAP32[6804 + ($i$02$i10 * 12 | 0) >> 2] | 0) == ($messageType | 0)) if ((HEAP32[6804 + ($i$02$i10 * 12 | 0) + 4 >> 2] | 0) == ($48 | 0)) {
   $$lcssa = $64;
   break;
  }
  $i$02$i10 = $i$02$i10 + 1 | 0;
  $64 = HEAP32[6804 + ($i$02$i10 * 12 | 0) + 8 >> 2] | 0;
  if (!$64) {
   $result$2 = 0;
   label = 22;
   break;
  }
 }
 if ((label | 0) == 22) return $result$2 | 0;
 HEAP32[79117] = $messageType;
 $result$2 = $$lcssa;
 return $result$2 | 0;
}

function _prvTidyRemoveAnchorByNode($doc, $name, $node) {
 $doc = $doc | 0;
 $name = $name | 0;
 $node = $node | 0;
 var $$02$i = 0, $$02$i2 = 0, $$lcssa = 0, $$lcssa33 = 0, $$pre$i12 = 0, $$pre$i8 = 0, $12 = 0, $15 = 0, $19 = 0, $2 = 0, $23 = 0, $29 = 0, $3 = 0, $31 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $6 = 0, $8 = 0, $curr$0 = 0, $curr$016 = 0, $curr$018 = 0, $curr$018$lcssa = 0, $delme$010 = 0, $h$0 = 0, $hashval$01$i = 0, $hashval$01$i3 = 0, $prev$017 = 0, $prev$017$lcssa = 0, $prev$017$phi = 0;
 $2 = ($name | 0) == 0;
 if ((_prvTidyHTMLVersion($doc) | 0) == 131072) if ($2) $h$0 = 0; else {
  $3 = HEAP8[$name >> 0] | 0;
  if (!($3 << 24 >> 24)) $h$0 = 0; else {
   $$02$i = $name;
   $6 = $3;
   $hashval$01$i = 0;
   while (1) {
    $8 = ($hashval$01$i * 31 | 0) + ($6 << 24 >> 24) | 0;
    $$02$i = $$02$i + 1 | 0;
    $6 = HEAP8[$$02$i >> 0] | 0;
    if (!($6 << 24 >> 24)) {
     $$lcssa = $8;
     break;
    } else $hashval$01$i = $8;
   }
   $h$0 = ($$lcssa >>> 0) % 1021 | 0;
  }
 } else if ($2) $h$0 = 0; else {
  $12 = HEAP8[$name >> 0] | 0;
  if (!($12 << 24 >> 24)) $h$0 = 0; else {
   $$02$i2 = $name;
   $15 = $12;
   $hashval$01$i3 = 0;
   while (1) {
    $19 = ((_prvTidyToLower($15 << 24 >> 24) | 0) << 24 >> 24) + ($hashval$01$i3 * 31 | 0) | 0;
    $$02$i2 = $$02$i2 + 1 | 0;
    $15 = HEAP8[$$02$i2 >> 0] | 0;
    if (!($15 << 24 >> 24)) {
     $$lcssa33 = $19;
     break;
    } else $hashval$01$i3 = $19;
   }
   $h$0 = ($$lcssa33 >>> 0) % 1021 | 0;
  }
 }
 $23 = $doc + 1596 + ($h$0 << 2) | 0;
 $curr$016 = HEAP32[$23 >> 2] | 0;
 L13 : do if ($curr$016 | 0) {
  $curr$018 = $curr$016;
  $prev$017 = 0;
  while (1) {
   if ((HEAP32[$curr$018 + 4 >> 2] | 0) == ($node | 0)) {
    $curr$018$lcssa = $curr$018;
    $prev$017$lcssa = $prev$017;
    break;
   }
   $curr$0 = HEAP32[$curr$018 >> 2] | 0;
   if (!$curr$0) break L13; else {
    $prev$017$phi = $curr$018;
    $curr$018 = $curr$0;
    $prev$017 = $prev$017$phi;
   }
  }
  $29 = HEAP32[$curr$018$lcssa >> 2] | 0;
  if (!$prev$017$lcssa) HEAP32[$23 >> 2] = $29; else HEAP32[$prev$017$lcssa >> 2] = $29;
  $$pre$i8 = $doc + 6856 | 0;
  $31 = HEAP32[$$pre$i8 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$31 >> 2] | 0) + 8 >> 2] & 15]($31, HEAP32[$curr$018$lcssa + 8 >> 2] | 0);
  $$pre$i12 = $$pre$i8;
  $delme$010 = $curr$018$lcssa;
  $37 = HEAP32[$$pre$i12 >> 2] | 0;
  $38 = HEAP32[$37 >> 2] | 0;
  $39 = $38 + 8 | 0;
  $40 = HEAP32[$39 >> 2] | 0;
  FUNCTION_TABLE_vii[$40 & 15]($37, $delme$010);
  return;
 } while (0);
 $$pre$i12 = $doc + 6856 | 0;
 $delme$010 = 0;
 $37 = HEAP32[$$pre$i12 >> 2] | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = $38 + 8 | 0;
 $40 = HEAP32[$39 >> 2] | 0;
 FUNCTION_TABLE_vii[$40 & 15]($37, $delme$010);
 return;
}

function _printOptionValues($tdoc, $topt, $d) {
 $tdoc = $tdoc | 0;
 $topt = $topt | 0;
 $d = $d | 0;
 var $0 = 0, $11 = 0, $14 = 0, $18 = 0, $19 = 0, $2 = 0, $26 = 0, $3 = 0, $30 = 0, $31 = 0, $33 = 0, $36 = 0, $37 = 0, $4 = 0, $6 = 0, $7 = 0, $8 = 0, $pos = 0, $vararg_buffer = 0, $vararg_buffer15 = 0, $vararg_buffer4 = 0, $vararg_buffer9 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $vararg_buffer15 = sp + 48 | 0;
 $vararg_buffer9 = sp + 32 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer = sp;
 $pos = sp + 60 | 0;
 $0 = _tidyOptGetId($topt) | 0;
 $2 = (_tidyOptIsReadOnly($topt) | 0) != 0;
 $3 = $2 ? 223004 : 317568;
 switch ($0 | 0) {
 case 83:
 case 82:
 case 81:
 case 80:
  {
   $4 = _tidyOptGetDeclTagList($tdoc) | 0;
   HEAP32[$pos >> 2] = $4;
   L3 : do if ($4 | 0) {
    $6 = $d + 16 | 0;
    $7 = $d + 8 | 0;
    do {
     $8 = _tidyOptGetNextDeclTag($tdoc, $0, $pos) | 0;
     HEAP32[$6 >> 2] = $8;
     if (!(HEAP32[$pos >> 2] | 0)) break L3;
     $11 = HEAP32[$d >> 2] | 0;
     $14 = HEAP32[$7 >> 2] | 0;
     if (!(HEAP8[$11 >> 0] | 0)) {
      HEAP32[$vararg_buffer4 >> 2] = $11;
      HEAP32[$vararg_buffer4 + 4 >> 2] = $14;
      HEAP32[$vararg_buffer4 + 8 >> 2] = $8;
      _printf(222779, $vararg_buffer4) | 0;
     } else {
      HEAP32[$vararg_buffer >> 2] = $11;
      HEAP32[$vararg_buffer + 4 >> 2] = $14;
      HEAP32[$vararg_buffer + 8 >> 2] = $3;
      HEAP32[$vararg_buffer + 12 >> 2] = $8;
      _printf(223006, $vararg_buffer) | 0;
     }
     HEAP32[$d >> 2] = 317568;
     HEAP32[$7 >> 2] = 317568;
    } while ((HEAP32[$pos >> 2] | 0) != 0);
   } while (0);
   break;
  }
 case 7:
  {
   HEAP32[$d + 16 >> 2] = _tidyOptGetCurrPick($tdoc, 7) | 0;
   break;
  }
 default:
  {}
 }
 $18 = HEAP32[$d >> 2] | 0;
 $19 = HEAP8[$18 >> 0] | 0;
 if (!($19 << 24 >> 24)) if (!(HEAP8[HEAP32[$d + 8 >> 2] >> 0] | 0)) {
  $26 = HEAP32[$d + 16 >> 2] | 0;
  if (!$26) {
   STACKTOP = sp;
   return;
  }
  if (!(HEAP8[$26 >> 0] | 0)) {
   STACKTOP = sp;
   return;
  }
 }
 $30 = $d + 16 | 0;
 $31 = HEAP32[$30 >> 2] | 0;
 if (!$31) {
  HEAP32[$30 >> 2] = 317568;
  $33 = HEAP8[$18 >> 0] | 0;
  $37 = 317568;
 } else {
  $33 = $19;
  $37 = $31;
 }
 $36 = HEAP32[$d + 8 >> 2] | 0;
 if (!($33 << 24 >> 24)) {
  HEAP32[$vararg_buffer15 >> 2] = $18;
  HEAP32[$vararg_buffer15 + 4 >> 2] = $36;
  HEAP32[$vararg_buffer15 + 8 >> 2] = $37;
  _printf(222779, $vararg_buffer15) | 0;
  STACKTOP = sp;
  return;
 } else {
  HEAP32[$vararg_buffer9 >> 2] = $18;
  HEAP32[$vararg_buffer9 + 4 >> 2] = $36;
  HEAP32[$vararg_buffer9 + 8 >> 2] = $3;
  HEAP32[$vararg_buffer9 + 12 >> 2] = $37;
  _printf(223006, $vararg_buffer9) | 0;
  STACKTOP = sp;
  return;
 }
}

function _attrsLookup($doc, $attribs, $atnam) {
 $doc = $doc | 0;
 $attribs = $attribs | 0;
 $atnam = $atnam | 0;
 var $$0 = 0, $$01$i = 0, $$01$i$i = 0, $$lcssa = 0, $$lcssa35 = 0, $$lcssa39 = 0, $$lcssa40 = 0, $1 = 0, $14 = 0, $21 = 0, $25 = 0, $28 = 0, $29 = 0, $30 = 0, $33 = 0, $35 = 0, $39 = 0, $4 = 0, $46 = 0, $6 = 0, $hashval$0$lcssa$i = 0, $hashval$0$lcssa$i$i = 0, $hashval$02$i = 0, $hashval$02$i$i = 0, $np$07 = 0, $np$07$lcssa = 0, $p$08 = 0, $p$09 = 0, label = 0;
 if (!$atnam) {
  $$0 = 0;
  return $$0 | 0;
 }
 $1 = HEAP8[$atnam >> 0] | 0;
 if (!($1 << 24 >> 24)) $hashval$0$lcssa$i = 0; else {
  $$01$i = $atnam;
  $4 = $1;
  $hashval$02$i = 0;
  while (1) {
   $6 = ($hashval$02$i * 31 | 0) + ($4 << 24 >> 24) | 0;
   $$01$i = $$01$i + 1 | 0;
   $4 = HEAP8[$$01$i >> 0] | 0;
   if (!($4 << 24 >> 24)) {
    $$lcssa40 = $6;
    break;
   } else $hashval$02$i = $6;
  }
  $hashval$0$lcssa$i = ($$lcssa40 >>> 0) % 178 | 0;
 }
 $p$08 = HEAP32[$attribs + 4088 + ($hashval$0$lcssa$i << 2) >> 2] | 0;
 L9 : do if (!$p$08) {
  $21 = 308085;
  $46 = 53196;
  $np$07 = 53192;
 } else {
  $p$09 = $p$08;
  while (1) {
   $14 = HEAP32[$p$09 >> 2] | 0;
   if (!$14) {
    $21 = 308085;
    $46 = 53196;
    $np$07 = 53192;
    break L9;
   }
   if (!(_prvTidytmbstrcmp($atnam, HEAP32[$14 + 4 >> 2] | 0) | 0)) {
    $$lcssa39 = $p$09;
    break;
   }
   $p$09 = HEAP32[$p$09 + 4 >> 2] | 0;
   if (!$p$09) {
    $21 = 308085;
    $46 = 53196;
    $np$07 = 53192;
    break L9;
   }
  }
  $$0 = HEAP32[$$lcssa39 >> 2] | 0;
  return $$0 | 0;
 } while (0);
 while (1) {
  if (!(_prvTidytmbstrcmp($atnam, $21) | 0)) {
   $$lcssa35 = $46;
   $np$07$lcssa = $np$07;
   break;
  }
  $46 = $np$07 + 20 | 0;
  $21 = HEAP32[$46 >> 2] | 0;
  if (!$21) {
   $$0 = 0;
   label = 16;
   break;
  } else $np$07 = $np$07 + 16 | 0;
 }
 if ((label | 0) == 16) return $$0 | 0;
 $25 = HEAP32[$doc + 6856 >> 2] | 0;
 $28 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$25 >> 2] >> 2] & 31]($25, 8) | 0;
 HEAP32[$28 >> 2] = $np$07$lcssa;
 $29 = HEAP32[$$lcssa35 >> 2] | 0;
 $30 = HEAP8[$29 >> 0] | 0;
 if (!($30 << 24 >> 24)) $hashval$0$lcssa$i$i = 0; else {
  $$01$i$i = $29;
  $33 = $30;
  $hashval$02$i$i = 0;
  while (1) {
   $35 = ($hashval$02$i$i * 31 | 0) + ($33 << 24 >> 24) | 0;
   $$01$i$i = $$01$i$i + 1 | 0;
   $33 = HEAP8[$$01$i$i >> 0] | 0;
   if (!($33 << 24 >> 24)) {
    $$lcssa = $35;
    break;
   } else $hashval$02$i$i = $35;
  }
  $hashval$0$lcssa$i$i = ($$lcssa >>> 0) % 178 | 0;
 }
 $39 = $attribs + 4088 + ($hashval$0$lcssa$i$i << 2) | 0;
 HEAP32[$28 + 4 >> 2] = HEAP32[$39 >> 2];
 HEAP32[$39 >> 2] = $28;
 $$0 = $np$07$lcssa;
 return $$0 | 0;
}

function _PurgeWord2000Attributes($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$lcssa = 0, $$pr$us$pre = 0, $$pr9$pr$pr$us43 = 0, $0 = 0, $1 = 0, $12 = 0, $13 = 0, $17 = 0, $22 = 0, $26 = 0, $3 = 0, $5 = 0, $7 = 0, $8 = 0, $attr$0$ph19 = 0, $attr$015$us = 0, $attr$015$us$lcssa = 0, $prev$0$ph20 = 0, label = 0, $attr$015$us$looptemp = 0;
 $0 = $node + 20 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) return;
 $3 = $node + 28 | 0;
 $attr$0$ph19 = $1;
 $prev$0$ph20 = 0;
 L4 : while (1) {
  $5 = ($prev$0$ph20 | 0) == 0;
  $attr$015$us = $attr$0$ph19;
  L6 : while (1) {
   $attr$015$us$looptemp = $attr$015$us;
   $attr$015$us = HEAP32[$attr$015$us >> 2] | 0;
   $7 = $attr$015$us$looptemp + 4 | 0;
   $8 = HEAP32[$7 >> 2] | 0;
   L8 : do if (!$8) label = 15; else {
    if ((HEAP32[$8 >> 2] | 0) == 26) {
     $12 = $attr$015$us$looptemp + 24 | 0;
     $13 = HEAP32[$12 >> 2] | 0;
     if (!$13) $17 = 0; else {
      if (!(_prvTidytmbstrcasecmp($13, 311503) | 0)) {
       $$lcssa = $attr$015$us;
       $attr$015$us$lcssa = $attr$015$us$looptemp;
       break L6;
      }
      $17 = HEAP32[$12 >> 2] | 0;
     }
     if (_prvTidytmbstrncmp($17, 311508, 3) | 0) {
      $$lcssa = $attr$015$us;
      $attr$015$us$lcssa = $attr$015$us$looptemp;
      break L6;
     }
     $$pr$us$pre = HEAP32[$7 >> 2] | 0;
     if (!$$pr$us$pre) {
      label = 15;
      break;
     } else $$pr9$pr$pr$us43 = $$pr$us$pre;
    } else $$pr9$pr$pr$us43 = $8;
    switch (HEAP32[$$pr9$pr$pr$us43 >> 2] | 0) {
    case 71:
    case 143:
    case 26:
     {
      break L8;
      break;
     }
    case 159:
    case 58:
     break;
    default:
     {
      label = 15;
      break L8;
     }
    }
    $22 = HEAP32[$3 >> 2] | 0;
    if (!$22) label = 15; else switch (HEAP32[$22 >> 2] | 0) {
    case 112:
    case 115:
    case 109:
     break;
    default:
     label = 15;
    }
   } while (0);
   if ((label | 0) == 15) {
    label = 0;
    $26 = HEAP32[$attr$015$us$looptemp + 20 >> 2] | 0;
    if (!$26) {
     $$lcssa = $attr$015$us;
     $attr$015$us$lcssa = $attr$015$us$looptemp;
     break;
    }
    if (_prvTidytmbstrncmp($26, 311512, 2) | 0) {
     $$lcssa = $attr$015$us;
     $attr$015$us$lcssa = $attr$015$us$looptemp;
     break;
    }
   }
   if ($5) HEAP32[$0 >> 2] = $attr$015$us; else HEAP32[$prev$0$ph20 >> 2] = $attr$015$us;
   _prvTidyFreeAttribute($doc, $attr$015$us$looptemp);
   if (!$attr$015$us) {
    label = 21;
    break L4;
   }
  }
  if (!$$lcssa) {
   label = 21;
   break;
  } else {
   $attr$0$ph19 = $$lcssa;
   $prev$0$ph20 = $attr$015$us$lcssa;
  }
 }
 if ((label | 0) == 21) return;
}

function _ParseDocType($doc, $option) {
 $doc = $doc | 0;
 $option = $option | 0;
 var $$0 = 0, $$0$i$i = 0, $$lcssa = 0, $0 = 0, $11 = 0, $16 = 0, $buf = 0, $c$011 = 0, $config$idx$i = 0, $config$idx$i4 = 0, $config$idx$val$i = 0, $config$idx$val$i5 = 0, $dtmode$0$ph = 0, $i$0$lcssa = 0, $i$010 = 0, dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $buf = sp;
 dest = $buf;
 stop = dest + 32 | 0;
 do {
  HEAP8[dest >> 0] = 0;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 $0 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$0 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$0 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$0 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $11 = HEAP32[$0 >> 2] | 0;
 switch ($11 | 0) {
 case 34:
 case 39:
  {
   _ParseString($doc, $option) | 0;
   HEAP32[$doc + 104 >> 2] = 5;
   $$0 = 1;
   STACKTOP = sp;
   return $$0 | 0;
  }
 case -1:
  {
   $i$0$lcssa = 0;
   break;
  }
 default:
  label = 8;
 }
 L13 : do if ((label | 0) == 8) {
  $config$idx$i4 = $doc + 872 | 0;
  $c$011 = $11;
  $i$010 = 0;
  while (1) {
   if (_prvTidyIsWhite($c$011) | 0) {
    $i$0$lcssa = $i$010;
    break L13;
   }
   $16 = $i$010 + 1 | 0;
   HEAP8[$buf + $i$010 >> 0] = $c$011;
   if ((HEAP32[$0 >> 2] | 0) == -1) {
    $i$0$lcssa = $16;
    break L13;
   }
   $config$idx$val$i5 = HEAP32[$config$idx$i4 >> 2] | 0;
   if (!$config$idx$val$i5) {
    $$lcssa = $16;
    break;
   }
   $c$011 = _prvTidyReadChar($config$idx$val$i5) | 0;
   HEAP32[$0 >> 2] = $c$011;
   if (!($16 >>> 0 < 31 & ($c$011 | 0) != -1)) {
    $i$0$lcssa = $16;
    break L13;
   } else $i$010 = $16;
  }
  HEAP32[$0 >> 2] = -1;
  $i$0$lcssa = $$lcssa;
 } while (0);
 HEAP8[$buf + $i$0$lcssa >> 0] = 0;
 if (!(_prvTidytmbstrcasecmp($buf, 305746) | 0)) $dtmode$0$ph = 2; else if (!(_prvTidytmbstrcasecmp($buf, 223992) | 0)) $dtmode$0$ph = 0; else if (!(_prvTidytmbstrcasecmp($buf, 223998) | 0)) $dtmode$0$ph = 1; else if (!(_prvTidytmbstrcasecmp($buf, 224003) | 0)) $dtmode$0$ph = 3; else if (!(_prvTidytmbstrcasecmp($buf, 224101) | 0)) $dtmode$0$ph = 4; else if (!(_prvTidytmbstrcasecmp($buf, 224010) | 0)) $dtmode$0$ph = 4; else {
  _prvTidyReportBadArgument($doc, HEAP32[$option + 8 >> 2] | 0);
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 HEAP32[$doc + 104 >> 2] = $dtmode$0$ph;
 $$0 = 1;
 STACKTOP = sp;
 return $$0 | 0;
}

function _ReplaceObsoleteElements($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$05 = 0, $$pr$pre = 0, $$pr3$pr9 = 0, $1 = 0, $11 = 0, $12 = 0, $18 = 0, $26 = 0, $30 = 0, $38 = 0, $4 = 0, $40 = 0, $41 = 0, $47 = 0, $5 = 0, $55 = 0, $59 = 0, $66 = 0, $9 = 0, $$05$looptemp = 0;
 if (!$node) return;
 $1 = $doc + 6856 | 0;
 $$05 = $node;
 do {
  $$05$looptemp = $$05;
  $$05 = HEAP32[$$05 + 8 >> 2] | 0;
  $4 = $$05$looptemp + 28 | 0;
  $5 = HEAP32[$4 >> 2] | 0;
  L6 : do if ($5 | 0) {
   if ((HEAP32[$5 >> 2] | 0) == 29) {
    $9 = _prvTidyLookupTagDef(118) | 0;
    $11 = _prvTidyInferredTag($doc, HEAP32[$9 >> 2] | 0) | 0;
    _prvTidyReportWarning($doc, $$05$looptemp, $11, 220);
    $12 = HEAP32[$1 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$12 >> 2] | 0) + 8 >> 2] & 15]($12, HEAP32[$11 + 32 >> 2] | 0);
    $18 = HEAP32[$1 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$18 >> 2] | 0) + 8 >> 2] & 15]($18, $11);
    HEAP32[$$05$looptemp + 24 >> 2] = HEAP32[$4 >> 2];
    HEAP32[$4 >> 2] = $9;
    HEAP32[$$05$looptemp + 44 >> 2] = 5;
    HEAP32[$$05$looptemp + 60 >> 2] = 1;
    $26 = HEAP32[$1 >> 2] | 0;
    $30 = $$05$looptemp + 32 | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$26 >> 2] | 0) + 8 >> 2] & 15]($26, HEAP32[$30 >> 2] | 0);
    HEAP32[$30 >> 2] = _prvTidytmbstrdup(HEAP32[$1 >> 2] | 0, HEAP32[$9 + 4 >> 2] | 0) | 0;
    $$pr$pre = HEAP32[$4 >> 2] | 0;
    if (!$$pr$pre) break; else $$pr3$pr9 = $$pr$pre;
   } else $$pr3$pr9 = $5;
   switch (HEAP32[$$pr3$pr9 >> 2] | 0) {
   case 83:
   case 63:
   case 121:
    break;
   default:
    break L6;
   }
   $38 = _prvTidyLookupTagDef(84) | 0;
   $40 = _prvTidyInferredTag($doc, HEAP32[$38 >> 2] | 0) | 0;
   _prvTidyReportWarning($doc, $$05$looptemp, $40, 220);
   $41 = HEAP32[$1 >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$41 >> 2] | 0) + 8 >> 2] & 15]($41, HEAP32[$40 + 32 >> 2] | 0);
   $47 = HEAP32[$1 >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$47 >> 2] | 0) + 8 >> 2] & 15]($47, $40);
   HEAP32[$$05$looptemp + 24 >> 2] = HEAP32[$4 >> 2];
   HEAP32[$4 >> 2] = $38;
   HEAP32[$$05$looptemp + 44 >> 2] = 5;
   HEAP32[$$05$looptemp + 60 >> 2] = 1;
   $55 = HEAP32[$1 >> 2] | 0;
   $59 = $$05$looptemp + 32 | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$55 >> 2] | 0) + 8 >> 2] & 15]($55, HEAP32[$59 >> 2] | 0);
   HEAP32[$59 >> 2] = _prvTidytmbstrdup(HEAP32[$1 >> 2] | 0, HEAP32[$38 + 4 >> 2] | 0) | 0;
  } while (0);
  $66 = HEAP32[$$05$looptemp + 12 >> 2] | 0;
  if ($66 | 0) _ReplaceObsoleteElements($doc, $66);
 } while (($$05 | 0) != 0);
 return;
}

function _memchr($src, $c, $n) {
 $src = $src | 0;
 $c = $c | 0;
 $n = $n | 0;
 var $$0$lcssa = 0, $$0$lcssa30 = 0, $$019 = 0, $$1$lcssa = 0, $$110 = 0, $$110$lcssa = 0, $$24 = 0, $$3 = 0, $$lcssa = 0, $0 = 0, $13 = 0, $15 = 0, $17 = 0, $20 = 0, $26 = 0, $27 = 0, $32 = 0, $4 = 0, $5 = 0, $8 = 0, $9 = 0, $s$0$lcssa = 0, $s$0$lcssa29 = 0, $s$020 = 0, $s$15 = 0, $s$2 = 0, $w$0$lcssa = 0, $w$011 = 0, $w$011$lcssa = 0, label = 0;
 $0 = $c & 255;
 $4 = ($n | 0) != 0;
 L1 : do if ($4 & ($src & 3 | 0) != 0) {
  $5 = $c & 255;
  $$019 = $n;
  $s$020 = $src;
  while (1) {
   if ((HEAP8[$s$020 >> 0] | 0) == $5 << 24 >> 24) {
    $$0$lcssa30 = $$019;
    $s$0$lcssa29 = $s$020;
    label = 6;
    break L1;
   }
   $8 = $s$020 + 1 | 0;
   $9 = $$019 + -1 | 0;
   $13 = ($9 | 0) != 0;
   if ($13 & ($8 & 3 | 0) != 0) {
    $$019 = $9;
    $s$020 = $8;
   } else {
    $$0$lcssa = $9;
    $$lcssa = $13;
    $s$0$lcssa = $8;
    label = 5;
    break;
   }
  }
 } else {
  $$0$lcssa = $n;
  $$lcssa = $4;
  $s$0$lcssa = $src;
  label = 5;
 } while (0);
 if ((label | 0) == 5) if ($$lcssa) {
  $$0$lcssa30 = $$0$lcssa;
  $s$0$lcssa29 = $s$0$lcssa;
  label = 6;
 } else {
  $$3 = 0;
  $s$2 = $s$0$lcssa;
 }
 L8 : do if ((label | 0) == 6) {
  $15 = $c & 255;
  if ((HEAP8[$s$0$lcssa29 >> 0] | 0) == $15 << 24 >> 24) {
   $$3 = $$0$lcssa30;
   $s$2 = $s$0$lcssa29;
  } else {
   $17 = Math_imul($0, 16843009) | 0;
   L11 : do if ($$0$lcssa30 >>> 0 > 3) {
    $$110 = $$0$lcssa30;
    $w$011 = $s$0$lcssa29;
    while (1) {
     $20 = HEAP32[$w$011 >> 2] ^ $17;
     if (($20 & -2139062144 ^ -2139062144) & $20 + -16843009 | 0) {
      $$110$lcssa = $$110;
      $w$011$lcssa = $w$011;
      break;
     }
     $26 = $w$011 + 4 | 0;
     $27 = $$110 + -4 | 0;
     if ($27 >>> 0 > 3) {
      $$110 = $27;
      $w$011 = $26;
     } else {
      $$1$lcssa = $27;
      $w$0$lcssa = $26;
      label = 11;
      break L11;
     }
    }
    $$24 = $$110$lcssa;
    $s$15 = $w$011$lcssa;
   } else {
    $$1$lcssa = $$0$lcssa30;
    $w$0$lcssa = $s$0$lcssa29;
    label = 11;
   } while (0);
   if ((label | 0) == 11) if (!$$1$lcssa) {
    $$3 = 0;
    $s$2 = $w$0$lcssa;
    break;
   } else {
    $$24 = $$1$lcssa;
    $s$15 = $w$0$lcssa;
   }
   while (1) {
    if ((HEAP8[$s$15 >> 0] | 0) == $15 << 24 >> 24) {
     $$3 = $$24;
     $s$2 = $s$15;
     break L8;
    }
    $32 = $s$15 + 1 | 0;
    $$24 = $$24 + -1 | 0;
    if (!$$24) {
     $$3 = 0;
     $s$2 = $32;
     break;
    } else $s$15 = $32;
   }
  }
 } while (0);
 return ($$3 | 0 ? $s$2 : 0) | 0;
}

function _prvTidyFixLanguageInformation($doc, $node, $wantXmlLang, $wantLang) {
 $doc = $doc | 0;
 $node = $node | 0;
 $wantXmlLang = $wantXmlLang | 0;
 $wantLang = $wantLang | 0;
 var $$010 = 0, $$010$us = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $20 = 0, $3 = 0, $30 = 0, $37 = 0, $38 = 0, $40 = 0, $41 = 0, $52 = 0, $8 = 0, $9 = 0, $$010$looptemp = 0, $$010$us$looptemp = 0;
 if (!$node) return;
 $1 = ($wantLang | 0) != 0;
 $3 = $doc + 68 | 0;
 if (!$wantXmlLang) {
  $$010 = $node;
  do {
   $$010$looptemp = $$010;
   $$010 = HEAP32[$$010 + 8 >> 2] | 0;
   if (_prvTidynodeIsElement($$010$looptemp) | 0) {
    $37 = _prvTidyAttrGetById($$010$looptemp, 71) | 0;
    $38 = _prvTidyAttrGetById($$010$looptemp, 161) | 0;
    $40 = ($38 | 0) != 0;
    if ($1 & $40 & (($37 | 0) != 0 & $40 ^ 1)) {
     $41 = _prvTidyNodeAttributeVersions($$010$looptemp, 71) | 0;
     if (HEAP32[(HEAP32[$3 >> 2] | 0) + 40 >> 2] & $41 | 0) _prvTidyRepairAttrValue($doc, $$010$looptemp, 313532, HEAP32[$38 + 24 >> 2] | 0) | 0;
    }
    if (!($1 | ($37 | 0) == 0)) _prvTidyRemoveAttribute($doc, $$010$looptemp, $37);
    if ($38 | 0) _prvTidyRemoveAttribute($doc, $$010$looptemp, $38);
   }
   $52 = HEAP32[$$010$looptemp + 12 >> 2] | 0;
   if ($52 | 0) _prvTidyFixLanguageInformation($doc, $52, 0, $wantLang);
  } while (($$010 | 0) != 0);
  return;
 } else $$010$us = $node;
 do {
  $$010$us$looptemp = $$010$us;
  $$010$us = HEAP32[$$010$us + 8 >> 2] | 0;
  L24 : do if (_prvTidynodeIsElement($$010$us$looptemp) | 0) {
   $8 = _prvTidyAttrGetById($$010$us$looptemp, 71) | 0;
   $9 = _prvTidyAttrGetById($$010$us$looptemp, 161) | 0;
   $10 = ($8 | 0) != 0;
   $11 = ($9 | 0) != 0;
   do if (!($10 & $11)) {
    if ($10) {
     $20 = _prvTidyNodeAttributeVersions($$010$us$looptemp, 161) | 0;
     if (!(HEAP32[(HEAP32[$3 >> 2] | 0) + 40 >> 2] & $20)) break;
     _prvTidyRepairAttrValue($doc, $$010$us$looptemp, 311617, HEAP32[$8 + 24 >> 2] | 0) | 0;
     break;
    }
    if (!($1 & $11)) break L24;
    $12 = _prvTidyNodeAttributeVersions($$010$us$looptemp, 71) | 0;
    if (!(HEAP32[(HEAP32[$3 >> 2] | 0) + 40 >> 2] & $12)) break L24;
    _prvTidyRepairAttrValue($doc, $$010$us$looptemp, 313532, HEAP32[$9 + 24 >> 2] | 0) | 0;
    break L24;
   } while (0);
   if (!($1 | ($8 | 0) == 0)) _prvTidyRemoveAttribute($doc, $$010$us$looptemp, $8);
  } while (0);
  $30 = HEAP32[$$010$us$looptemp + 12 >> 2] | 0;
  if ($30 | 0) _prvTidyFixLanguageInformation($doc, $30, $wantXmlLang, $wantLang);
 } while (($$010$us | 0) != 0);
 return;
}

function _prvTidyTakeConfigSnapshot($doc) {
 $doc = $doc | 0;
 var $$phi$trans$insert$i = 0, $14 = 0, $26 = 0, $38 = 0, $41 = 0, $42 = 0, $43 = 0, $46 = 0, $51 = 0, $55 = 0, $57 = 0, $8 = 0, $ixVal$04 = 0, $option$02 = 0, label = 0;
 if (HEAP32[$doc + 300 >> 2] | 0) HEAP32[$doc + 296 >> 2] = 1;
 if (!(HEAP32[$doc + 152 >> 2] | 0)) HEAP32[$doc + 76 >> 2] = 0;
 $8 = $doc + 80 | 0;
 if (!(HEAP32[$8 >> 2] | 0)) HEAP32[$8 >> 2] = 2147483647;
 if (HEAP32[$doc + 308 >> 2] | 0) {
  $14 = $doc + 864 | 0;
  HEAP32[$14 >> 2] = HEAP32[$14 >> 2] | 2;
  _prvTidyDefineTag($doc, 2, 311525);
 }
 $$phi$trans$insert$i = $doc + 176 | 0;
 if (!(HEAP32[$doc + 168 >> 2] | 0)) {
  if (HEAP32[$$phi$trans$insert$i >> 2] | 0) {
   HEAP32[$doc + 172 >> 2] = 1;
   HEAP32[$doc + 188 >> 2] = 0;
   HEAP32[$doc + 192 >> 2] = 0;
  }
 } else {
  HEAP32[$$phi$trans$insert$i >> 2] = 0;
  HEAP32[$doc + 172 >> 2] = 1;
  HEAP32[$doc + 288 >> 2] = 1;
 }
 $26 = HEAP32[$doc + 96 >> 2] | 0;
 switch ($26 | 0) {
 case 0:
 case 9:
 case 10:
 case 11:
 case 4:
 case 1:
  break;
 default:
  if (HEAP32[$doc + 172 >> 2] | 0) HEAP32[$doc + 184 >> 2] = 1;
 }
 if (HEAP32[$doc + 172 >> 2] | 0) {
  if (($26 + -9 | 0) >>> 0 < 3) HEAP32[$doc + 380 >> 2] = 1;
  HEAP32[$doc + 252 >> 2] = 1;
  HEAP32[$doc + 164 >> 2] = 0;
 }
 $38 = $doc + 6856 | 0;
 $ixVal$04 = 0;
 $option$02 = 1892;
 while (1) {
  if (($ixVal$04 | 0) != (HEAP32[$option$02 >> 2] | 0)) {
   label = 22;
   break;
  }
  $41 = $doc + 468 + ($ixVal$04 << 2) | 0;
  $42 = $doc + 72 + ($ixVal$04 << 2) | 0;
  $43 = $option$02 + 12 | 0;
  do if (!(HEAP32[$43 >> 2] | 0)) {
   $46 = HEAP32[$41 >> 2] | 0;
   if ($46 | 0) if (($46 | 0) != (HEAP32[$option$02 + 28 >> 2] | 0)) {
    $51 = HEAP32[$38 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$51 >> 2] | 0) + 8 >> 2] & 15]($51, $46);
    if (HEAP32[$43 >> 2] | 0) {
     label = 31;
     break;
    }
   }
   $55 = HEAP32[$42 >> 2] | 0;
   $57 = $55;
   if ($55 | 0) if (($55 | 0) != (HEAP32[$option$02 + 28 >> 2] | 0)) {
    HEAP32[$41 >> 2] = _prvTidytmbstrdup(HEAP32[$38 >> 2] | 0, $55) | 0;
    break;
   }
   HEAP32[$41 >> 2] = $57;
  } else label = 31; while (0);
  if ((label | 0) == 31) {
   label = 0;
   HEAP32[$41 >> 2] = HEAP32[$42 >> 2];
  }
  $ixVal$04 = $ixVal$04 + 1 | 0;
  if ($ixVal$04 >>> 0 >= 98) {
   label = 33;
   break;
  } else $option$02 = $option$02 + 32 | 0;
 }
 if ((label | 0) == 22) ___assert_fail(225459, 223800, 543, 225514); else if ((label | 0) == 33) return;
}

function _MergeNestedElements($doc, $Id, $state, $node) {
 $doc = $doc | 0;
 $Id = $Id | 0;
 $state = $state | 0;
 $node = $node | 0;
 var $$0 = 0, $14 = 0, $24 = 0, $27 = 0, $29 = 0, $3 = 0, $32 = 0, $34 = 0, $35 = 0, $36 = 0, $7 = 0, $8 = 0, $av2$0$be$i = 0, $av2$04$i = 0, $child$01$i = 0, $child$02$i = 0, label = 0;
 if (!(($state | 0) != 0 & ($node | 0) != 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $3 = HEAP32[$node + 28 >> 2] | 0;
 if (!$3) {
  $$0 = 0;
  return $$0 | 0;
 }
 if ((HEAP32[$3 >> 2] | 0) != ($Id | 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $7 = $node + 12 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 if (!$8) {
  $$0 = 0;
  return $$0 | 0;
 }
 if (HEAP32[$8 + 8 >> 2] | 0) {
  $$0 = 0;
  return $$0 | 0;
 }
 $14 = HEAP32[$8 + 28 >> 2] | 0;
 if (!$14) {
  $$0 = 0;
  return $$0 | 0;
 }
 if ((HEAP32[$14 >> 2] | 0) != ($Id | 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 if (($state | 0) == 2) {
  if (_prvTidyAttrGetById($8, 63) | 0) if (_prvTidyAttrGetById($node, 63) | 0) {
   $$0 = 0;
   return $$0 | 0;
  }
  $24 = HEAP32[$8 + 20 >> 2] | 0;
  if ($24 | 0) {
   $av2$04$i = $24;
   while (1) {
    $27 = HEAP32[$av2$04$i + 4 >> 2] | 0;
    L30 : do if (!$27) label = 18; else {
     $29 = HEAP32[$27 >> 2] | 0;
     switch ($29 | 0) {
     case 0:
      {
       label = 18;
       break L30;
       break;
      }
     case 26:
     case 143:
      {
       $av2$0$be$i = HEAP32[$av2$04$i >> 2] | 0;
       break L30;
       break;
      }
     default:
      {}
     }
     $32 = _prvTidyAttrGetById($node, $29) | 0;
     if (!$32) label = 18; else {
      _prvTidyRemoveAttribute($doc, $node, $32);
      label = 18;
     }
    } while (0);
    if ((label | 0) == 18) {
     label = 0;
     _prvTidyDetachAttribute($8, $av2$04$i);
     $34 = HEAP32[$av2$04$i >> 2] | 0;
     HEAP32[$av2$04$i >> 2] = 0;
     _prvTidyInsertAttributeAtEnd($node, $av2$04$i);
     $av2$0$be$i = $34;
    }
    if (!$av2$0$be$i) break; else $av2$04$i = $av2$0$be$i;
   }
  }
 }
 _MergeStyles($doc, $node, $8);
 $35 = HEAP32[$7 >> 2] | 0;
 $36 = $35 + 12 | 0;
 HEAP32[$7 >> 2] = HEAP32[$36 >> 2];
 HEAP32[$node + 16 >> 2] = HEAP32[$35 + 16 >> 2];
 HEAP32[$36 >> 2] = 0;
 _prvTidyFreeNode($doc, $35);
 $child$01$i = HEAP32[$7 >> 2] | 0;
 if (!$child$01$i) {
  $$0 = 1;
  return $$0 | 0;
 } else $child$02$i = $child$01$i;
 do {
  HEAP32[$child$02$i >> 2] = $node;
  $child$02$i = HEAP32[$child$02$i + 8 >> 2] | 0;
 } while (($child$02$i | 0) != 0);
 $$0 = 1;
 return $$0 | 0;
}

function _CheckId($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $1 = 0, $15 = 0, $17 = 0, $18 = 0, $19 = 0, $22 = 0, $23 = 0, $27 = 0, $29 = 0, $3 = 0, $32 = 0, $34 = 0, $38 = 0, $4 = 0, $6 = 0, $c$i = 0, $s$0$i = 0, $s$0$i1 = 0, $s$1$i = 0, $s$2$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c$i = sp;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 if ($attval | 0) {
  $3 = $attval + 24 | 0;
  $4 = HEAP32[$3 >> 2] | 0;
  if ($4 | 0) {
   $s$0$i = $4;
   while (1) {
    $6 = HEAP8[$s$0$i >> 0] | 0;
    if (!($6 << 24 >> 24)) break;
    if (!(_prvTidyIsHTMLSpace($6 << 24 >> 24) | 0)) $s$0$i = $s$0$i + 1 | 0; else {
     label = 6;
     break;
    }
   }
   L6 : do if ((label | 0) == 6) {
    if (HEAP32[$1 + 28 >> 2] | 0) {
     $15 = HEAP32[$3 >> 2] | 0;
     L10 : do if ($15 | 0) {
      $17 = $15 + 1 | 0;
      $18 = HEAP8[$15 >> 0] | 0;
      $19 = $18 << 24 >> 24;
      HEAP32[$c$i >> 2] = $19;
      if ($18 << 24 >> 24 < 0) {
       $22 = $17 + (_prvTidyGetUTF8($17, $c$i) | 0) | 0;
       $23 = HEAP32[$c$i >> 2] | 0;
       $s$0$i1 = $22;
      } else {
       $23 = $19;
       $s$0$i1 = $17;
      }
      if (!(_prvTidyIsXMLLetter($23) | 0)) switch (HEAP32[$c$i >> 2] | 0) {
      case 58:
      case 95:
       {
        $s$1$i = $s$0$i1;
        break;
       }
      default:
       break L10;
      } else $s$1$i = $s$0$i1;
      while (1) {
       $27 = HEAP8[$s$1$i >> 0] | 0;
       if (!($27 << 24 >> 24)) break;
       $29 = $27 & 255;
       HEAP32[$c$i >> 2] = $29;
       if ($27 << 24 >> 24 < 0) {
        $32 = $s$1$i + (_prvTidyGetUTF8($s$1$i, $c$i) | 0) | 0;
        $34 = HEAP32[$c$i >> 2] | 0;
        $s$2$i = $32;
       } else {
        $34 = $29;
        $s$2$i = $s$1$i;
       }
       if (!(_prvTidyIsXMLNamechar($34) | 0)) break L10; else $s$1$i = $s$2$i + 1 | 0;
      }
      _prvTidyReportAttrError($doc, $node, $attval, 270);
      break L6;
     } while (0);
    }
    _prvTidyReportAttrError($doc, $node, $attval, 251);
   } while (0);
   $38 = _GetNodeByAnchor($doc, HEAP32[$3 >> 2] | 0) | 0;
   if (($38 | 0) == 0 | ($38 | 0) == ($node | 0)) {
    _AddAnchor($doc, HEAP32[$3 >> 2] | 0, $node);
    STACKTOP = sp;
    return;
   } else {
    _prvTidyReportAttrError($doc, $node, $attval, 266);
    STACKTOP = sp;
    return;
   }
  }
 }
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 STACKTOP = sp;
 return;
}

function ___fdopen($fd, $mode) {
 $fd = $fd | 0;
 $mode = $mode | 0;
 var $$0 = 0, $0 = 0, $12 = 0, $14 = 0, $19 = 0, $24 = 0, $26 = 0, $37 = 0, $4 = 0, $tio = 0, $vararg_buffer = 0, $vararg_buffer12 = 0, $vararg_buffer3 = 0, $vararg_buffer7 = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $vararg_buffer12 = sp + 40 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $tio = sp + 52 | 0;
 $0 = HEAP8[$mode >> 0] | 0;
 if (!(_memchr(316173, $0 << 24 >> 24, 4) | 0)) {
  HEAP32[(___errno_location() | 0) >> 2] = 22;
  $$0 = 0;
 } else {
  $4 = _malloc(1144) | 0;
  if (!$4) $$0 = 0; else {
   dest = $4;
   stop = dest + 112 | 0;
   do {
    HEAP32[dest >> 2] = 0;
    dest = dest + 4 | 0;
   } while ((dest | 0) < (stop | 0));
   if (!(_strchr($mode, 43) | 0)) HEAP32[$4 >> 2] = $0 << 24 >> 24 == 114 ? 8 : 4;
   if (!(_strchr($mode, 101) | 0)) $12 = $0; else {
    HEAP32[$vararg_buffer >> 2] = $fd;
    HEAP32[$vararg_buffer + 4 >> 2] = 2;
    HEAP32[$vararg_buffer + 8 >> 2] = 1;
    ___syscall221(221, $vararg_buffer | 0) | 0;
    $12 = HEAP8[$mode >> 0] | 0;
   }
   if ($12 << 24 >> 24 == 97) {
    HEAP32[$vararg_buffer3 >> 2] = $fd;
    HEAP32[$vararg_buffer3 + 4 >> 2] = 3;
    $14 = ___syscall221(221, $vararg_buffer3 | 0) | 0;
    if (!($14 & 1024)) {
     HEAP32[$vararg_buffer7 >> 2] = $fd;
     HEAP32[$vararg_buffer7 + 4 >> 2] = 4;
     HEAP32[$vararg_buffer7 + 8 >> 2] = $14 | 1024;
     ___syscall221(221, $vararg_buffer7 | 0) | 0;
    }
    $19 = HEAP32[$4 >> 2] | 128;
    HEAP32[$4 >> 2] = $19;
    $26 = $19;
   } else $26 = HEAP32[$4 >> 2] | 0;
   HEAP32[$4 + 60 >> 2] = $fd;
   HEAP32[$4 + 44 >> 2] = $4 + 120;
   HEAP32[$4 + 48 >> 2] = 1024;
   $24 = $4 + 75 | 0;
   HEAP8[$24 >> 0] = -1;
   if (!($26 & 8)) {
    HEAP32[$vararg_buffer12 >> 2] = $fd;
    HEAP32[$vararg_buffer12 + 4 >> 2] = 21505;
    HEAP32[$vararg_buffer12 + 8 >> 2] = $tio;
    if (!(___syscall54(54, $vararg_buffer12 | 0) | 0)) HEAP8[$24 >> 0] = 10;
   }
   HEAP32[$4 + 32 >> 2] = 5;
   HEAP32[$4 + 36 >> 2] = 2;
   HEAP32[$4 + 40 >> 2] = 3;
   HEAP32[$4 + 12 >> 2] = 10;
   if (!(HEAP32[79255] | 0)) HEAP32[$4 + 76 >> 2] = -1;
   ___lock(317044);
   $37 = HEAP32[79260] | 0;
   HEAP32[$4 + 56 >> 2] = $37;
   if ($37 | 0) HEAP32[$37 + 52 >> 2] = $4;
   HEAP32[79260] = $4;
   ___unlock(317044);
   $$0 = $4;
  }
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _prvTidyPopInline($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $0 = 0, $1 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $16 = 0, $17 = 0, $19 = 0, $21 = 0, $22 = 0, $23 = 0, $26 = 0, $29 = 0, $33 = 0, $4 = 0, $41 = 0, $42 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $51 = 0, $55 = 0, $59 = 0, $61 = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 L1 : do if ($node | 0) {
  $4 = HEAP32[$node + 28 >> 2] | 0;
  if (!$4) return;
  if ((HEAP32[$4 + 16 >> 2] & 2064 | 0) != 16) return;
  switch (HEAP32[$4 >> 2] | 0) {
  case 1:
   break;
  case 27:
  case 54:
   return;
  default:
   break L1;
  }
  $11 = $1 + 112 | 0;
  $12 = $doc + 6856 | 0;
  $13 = $1 + 104 | 0;
  $14 = HEAP32[$11 >> 2] | 0;
  while (1) {
   if (!$14) {
    label = 17;
    break;
   }
   $16 = HEAP32[$0 >> 2] | 0;
   $17 = $16 + 112 | 0;
   $19 = (HEAP32[$17 >> 2] | 0) + -1 | 0;
   HEAP32[$17 >> 2] = $19;
   $21 = HEAP32[$16 + 104 >> 2] | 0;
   $22 = $21 + ($19 << 4) + 12 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   if ($23 | 0) {
    $26 = $23;
    do {
     HEAP32[$22 >> 2] = HEAP32[$26 >> 2];
     _prvTidyFreeAttribute($doc, $26);
     $26 = HEAP32[$22 >> 2] | 0;
    } while (($26 | 0) != 0);
   }
   $29 = HEAP32[$12 >> 2] | 0;
   $33 = $21 + ($19 << 4) + 8 | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$29 >> 2] | 0) + 8 >> 2] & 15]($29, HEAP32[$33 >> 2] | 0);
   HEAP32[$33 >> 2] = 0;
   $14 = HEAP32[$11 >> 2] | 0;
   if ((HEAP32[HEAP32[(HEAP32[$13 >> 2] | 0) + ($14 << 4) + 4 >> 2] >> 2] | 0) == 1) {
    label = 17;
    break;
   }
  }
  if ((label | 0) == 17) return;
 } while (0);
 $41 = $1 + 112 | 0;
 $42 = HEAP32[$41 >> 2] | 0;
 if (!$42) return;
 $44 = $42 + -1 | 0;
 HEAP32[$41 >> 2] = $44;
 $45 = $1 + 104 | 0;
 $46 = HEAP32[$45 >> 2] | 0;
 $47 = $46 + ($44 << 4) + 12 | 0;
 $48 = HEAP32[$47 >> 2] | 0;
 if ($48 | 0) {
  $51 = $48;
  do {
   HEAP32[$47 >> 2] = HEAP32[$51 >> 2];
   _prvTidyFreeAttribute($doc, $51);
   $51 = HEAP32[$47 >> 2] | 0;
  } while (($51 | 0) != 0);
 }
 $55 = HEAP32[$doc + 6856 >> 2] | 0;
 $59 = $46 + ($44 << 4) + 8 | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$55 >> 2] | 0) + 8 >> 2] & 15]($55, HEAP32[$59 >> 2] | 0);
 HEAP32[$59 >> 2] = 0;
 $61 = $1 + 100 | 0;
 if ((HEAP32[$61 >> 2] | 0) >>> 0 < ((HEAP32[$45 >> 2] | 0) + (HEAP32[$41 >> 2] << 4) | 0) >>> 0) return;
 HEAP32[$61 >> 2] = 0;
 return;
}

function _prvTidyDowngradeTypography($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$05 = 0, $$lcssa = 0, $10 = 0, $11 = 0, $12 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $22 = 0, $23 = 0, $25 = 0, $26 = 0, $27 = 0, $3 = 0, $32 = 0, $34 = 0, $8 = 0, $c = 0, $i$02 = 0, $i$1 = 0, $p$0$lcssa = 0, $p$03 = 0, sp = 0, $$05$looptemp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 if (!$node) {
  STACKTOP = sp;
  return;
 }
 $3 = (HEAP32[$doc + 68 >> 2] | 0) + 84 | 0;
 $$05 = $node;
 do {
  $$05$looptemp = $$05;
  $$05 = HEAP32[$$05 + 8 >> 2] | 0;
  if (_prvTidynodeIsText($$05$looptemp) | 0) {
   $8 = HEAP32[$3 >> 2] | 0;
   $10 = HEAP32[$$05$looptemp + 36 >> 2] | 0;
   $11 = $8 + $10 | 0;
   $12 = $$05$looptemp + 40 | 0;
   $15 = $8;
   if ($10 >>> 0 < (HEAP32[$12 >> 2] | 0) >>> 0) {
    $17 = $8;
    $i$02 = $10;
    $p$03 = $11;
    while (1) {
     $16 = $17 + $i$02 | 0;
     $18 = HEAP8[$16 >> 0] | 0;
     $19 = $18 & 255;
     HEAP32[$c >> 2] = $19;
     if ($18 << 24 >> 24 < 0) {
      $22 = (_prvTidyGetUTF8($16, $c) | 0) + $i$02 | 0;
      $23 = HEAP32[$c >> 2] | 0;
      $i$1 = $22;
     } else {
      $23 = $19;
      $i$1 = $i$02;
     }
     L14 : do if (($23 + -8211 | 0) >>> 0 < 12) switch ($23 | 0) {
     case 8212:
     case 8211:
      {
       HEAP32[$c >> 2] = 45;
       $25 = 45;
       break L14;
       break;
      }
     case 8218:
     case 8217:
     case 8216:
      {
       HEAP32[$c >> 2] = 39;
       $25 = 39;
       break L14;
       break;
      }
     case 8222:
     case 8221:
     case 8220:
      {
       HEAP32[$c >> 2] = 34;
       $25 = 34;
       break L14;
       break;
      }
     default:
      {
       $25 = $23;
       break L14;
      }
     } else $25 = $23; while (0);
     $26 = _prvTidyPutUTF8($p$03, $25) | 0;
     $27 = $i$1 + 1 | 0;
     if ($27 >>> 0 >= (HEAP32[$12 >> 2] | 0) >>> 0) {
      $$lcssa = $26;
      break;
     }
     $17 = HEAP32[$3 >> 2] | 0;
     $i$02 = $27;
     $p$03 = $26;
    }
    $32 = HEAP32[$3 >> 2] | 0;
    $p$0$lcssa = $$lcssa;
   } else {
    $32 = $15;
    $p$0$lcssa = $11;
   }
   HEAP32[$12 >> 2] = $p$0$lcssa - $32;
  }
  $34 = HEAP32[$$05$looptemp + 12 >> 2] | 0;
  if ($34 | 0) _prvTidyDowngradeTypography($doc, $34);
 } while (($$05 | 0) != 0);
 STACKTOP = sp;
 return;
}

function _tidyDocSaveStream($doc, $out) {
 $doc = $doc | 0;
 $out = $out | 0;
 var $$pre = 0, $1 = 0, $11 = 0, $13 = 0, $15 = 0, $17 = 0, $19 = 0, $21 = 0, $23 = 0, $27 = 0, $3 = 0, $31 = 0, $33 = 0, $44 = 0, $47 = 0, $5 = 0, $6 = 0, $60 = 0, $7 = 0, $9 = 0, label = 0;
 $1 = HEAP32[$doc + 136 >> 2] | 0;
 $3 = HEAP32[$doc + 348 >> 2] | 0;
 $5 = HEAP32[$doc + 380 >> 2] | 0;
 $6 = ($5 | 0) == 1;
 $7 = ($5 | 0) == 2;
 $9 = HEAP32[$doc + 172 >> 2] | 0;
 $11 = HEAP32[$doc + 176 >> 2] | 0;
 $13 = HEAP32[$doc + 328 >> 2] | 0;
 $15 = HEAP32[$doc + 340 >> 2] | 0;
 $17 = HEAP32[$doc + 200 >> 2] | 0;
 $19 = HEAP32[$doc + 356 >> 2] | 0;
 $21 = HEAP32[$doc + 196 >> 2] | 0;
 $23 = HEAP32[$doc + 368 >> 2] | 0;
 $27 = HEAP32[$doc + 436 >> 2] | 0;
 if (!(HEAP32[$doc + 448 >> 2] | 0)) _prvTidyPPrintSpaces(); else _prvTidyPPrintTabs();
 if ($23 | 0) _prvTidyConvertCDATANodes($doc, $doc);
 if ($15 | 0) _prvTidyDropComments($doc, $doc);
 $31 = ($17 | 0) != 0;
 if ($31) _prvTidyDropFontElements($doc, $doc, 0);
 $33 = ($21 | 0) != 0;
 if ($31 & ($19 | 0) != 0 | $33) _prvTidyDowngradeTypography($doc, $doc);
 if ($33) _prvTidyNormalizeSpaces(HEAP32[$doc + 68 >> 2] | 0, $doc); else _prvTidyReplacePreformattedSpaces($doc, $doc);
 if ($27 | 0) _prvTidySortAttributes($doc, $27);
 $$pre = $doc + 6812 | 0;
 if ($1 | 0) if (($3 | 0) != 0 | (HEAP32[$$pre >> 2] | 0) == 0) {
  if ($6) label = 21; else if ($7 & (HEAP32[$doc + 6868 >> 2] | 0) != 0) label = 21;
  if ((label | 0) == 21) _prvTidyoutBOM($out);
  $44 = $doc + 6780 | 0;
  HEAP32[$44 >> 2] = $out;
  do if (($9 | 0) == 0 | ($11 | 0) != 0) {
   if ($13 >>> 0 < 2) if (!$13) label = 29; else label = 28; else {
    $47 = _prvTidyFindBody($doc) | 0;
    if (!$47) label = 29; else if (!(HEAP32[$47 + 60 >> 2] | 0)) label = 29; else label = 28;
   }
   if ((label | 0) == 28) {
    _prvTidyPrintBody($doc);
    break;
   } else if ((label | 0) == 29) {
    _prvTidyPPrintTree($doc, 0, 0, $doc);
    break;
   }
  } else _prvTidyPPrintXMLTree($doc, 0, 0, $doc); while (0);
  _prvTidyPFlushLine($doc, 0);
  HEAP32[$44 >> 2] = 0;
 }
 _prvTidyResetConfigToSnapshot($doc);
 if (HEAP32[$$pre >> 2] | 0) {
  $60 = 2;
  return $60 | 0;
 }
 if (HEAP32[$doc + 6816 >> 2] | 0) {
  $60 = 1;
  return $60 | 0;
 }
 $60 = (HEAP32[$doc + 6820 >> 2] | 0) != 0 & 1;
 return $60 | 0;
}

function _GetNodeByAnchor($doc, $name) {
 $doc = $doc | 0;
 $name = $name | 0;
 var $$0 = 0, $$02$i = 0, $$02$i2 = 0, $$lcssa = 0, $$lcssa21 = 0, $0 = 0, $11 = 0, $15 = 0, $18 = 0, $2 = 0, $22 = 0, $34 = 0, $40 = 0, $5 = 0, $6 = 0, $9 = 0, $found$010 = 0, $found$011 = 0, $found$011$lcssa = 0, $h$0 = 0, $hashval$01$i = 0, $hashval$01$i3 = 0, $hashval$1$i7 = 0, $lname$0 = 0;
 $0 = $doc + 6856 | 0;
 $2 = _prvTidytmbstrdup(HEAP32[$0 >> 2] | 0, $name) | 0;
 $5 = ($name | 0) == 0;
 if ((_prvTidyHTMLVersion($doc) | 0) == 131072) if ($5) {
  $h$0 = 0;
  $lname$0 = $2;
 } else {
  $6 = HEAP8[$name >> 0] | 0;
  if (!($6 << 24 >> 24)) {
   $h$0 = 0;
   $lname$0 = $2;
  } else {
   $$02$i = $name;
   $9 = $6;
   $hashval$01$i = 0;
   while (1) {
    $11 = ($hashval$01$i * 31 | 0) + ($9 << 24 >> 24) | 0;
    $$02$i = $$02$i + 1 | 0;
    $9 = HEAP8[$$02$i >> 0] | 0;
    if (!($9 << 24 >> 24)) {
     $$lcssa = $11;
     break;
    } else $hashval$01$i = $11;
   }
   $h$0 = ($$lcssa >>> 0) % 1021 | 0;
   $lname$0 = $2;
  }
 } else {
  if ($5) $hashval$1$i7 = 0; else {
   $15 = HEAP8[$name >> 0] | 0;
   if (!($15 << 24 >> 24)) $hashval$1$i7 = 0; else {
    $$02$i2 = $name;
    $18 = $15;
    $hashval$01$i3 = 0;
    while (1) {
     $22 = ((_prvTidyToLower($18 << 24 >> 24) | 0) << 24 >> 24) + ($hashval$01$i3 * 31 | 0) | 0;
     $$02$i2 = $$02$i2 + 1 | 0;
     $18 = HEAP8[$$02$i2 >> 0] | 0;
     if (!($18 << 24 >> 24)) {
      $$lcssa21 = $22;
      break;
     } else $hashval$01$i3 = $22;
    }
    $hashval$1$i7 = ($$lcssa21 >>> 0) % 1021 | 0;
   }
  }
  $h$0 = $hashval$1$i7;
  $lname$0 = _prvTidytmbstrtolower($2) | 0;
 }
 $found$010 = HEAP32[$doc + 1596 + ($h$0 << 2) >> 2] | 0;
 L15 : do if ($found$010 | 0) {
  $found$011 = $found$010;
  while (1) {
   if (!(_prvTidytmbstrcmp(HEAP32[$found$011 + 8 >> 2] | 0, $lname$0) | 0)) {
    $found$011$lcssa = $found$011;
    break;
   }
   $found$011 = HEAP32[$found$011 >> 2] | 0;
   if (!$found$011) break L15;
  }
  $34 = HEAP32[$0 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$34 >> 2] | 0) + 8 >> 2] & 15]($34, $lname$0);
  $$0 = HEAP32[$found$011$lcssa + 4 >> 2] | 0;
  return $$0 | 0;
 } while (0);
 $40 = HEAP32[$0 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$40 >> 2] | 0) + 8 >> 2] & 15]($40, $lname$0);
 $$0 = 0;
 return $$0 | 0;
}

function _prvTidyGetNextDeclaredTag($doc, $tagType, $iter) {
 $doc = $doc | 0;
 $tagType = $tagType | 0;
 $iter = $iter | 0;
 var $curr$0 = 0, $curr$0$lcssa = 0, $curr$0$us = 0, $curr$0$us8 = 0, $curr$01 = 0, $curr$03 = 0, $curr$03$us = 0, $curr$03$us5 = 0, $name$0$lcssa = 0, $name$1 = 0, $name$1$us = 0, $name$1$us7 = 0;
 $curr$01 = HEAP32[$iter >> 2] | 0;
 if (!$curr$01) {
  $curr$0$lcssa = 0;
  $name$0$lcssa = 0;
  HEAP32[$iter >> 2] = $curr$0$lcssa;
  return $name$0$lcssa | 0;
 }
 switch ($tagType | 0) {
 case 1:
  {
   $curr$03$us = $curr$01;
   while (1) {
    if (!(HEAP32[$curr$03$us + 16 >> 2] & 1)) $name$1$us = 0; else $name$1$us = HEAP32[$curr$03$us + 4 >> 2] | 0;
    $curr$0$us = HEAP32[$curr$03$us + 28 >> 2] | 0;
    if (($name$1$us | 0) == 0 & ($curr$0$us | 0) != 0) $curr$03$us = $curr$0$us; else {
     $curr$0$lcssa = $curr$0$us;
     $name$0$lcssa = $name$1$us;
     break;
    }
   }
   HEAP32[$iter >> 2] = $curr$0$lcssa;
   return $name$0$lcssa | 0;
  }
 case 2:
  {
   $curr$03$us5 = $curr$01;
   while (1) {
    if (!(HEAP32[$curr$03$us5 + 16 >> 2] & 16)) $name$1$us7 = 0; else $name$1$us7 = HEAP32[$curr$03$us5 + 4 >> 2] | 0;
    $curr$0$us8 = HEAP32[$curr$03$us5 + 28 >> 2] | 0;
    if (($name$1$us7 | 0) == 0 & ($curr$0$us8 | 0) != 0) $curr$03$us5 = $curr$0$us8; else {
     $curr$0$lcssa = $curr$0$us8;
     $name$0$lcssa = $name$1$us7;
     break;
    }
   }
   HEAP32[$iter >> 2] = $curr$0$lcssa;
   return $name$0$lcssa | 0;
  }
 default:
  {
   $curr$03 = $curr$01;
   while (1) {
    switch ($tagType | 0) {
    case 8:
     {
      if (!(HEAP32[$curr$03 + 16 >> 2] & 8)) $name$1 = 0; else if ((HEAP32[$curr$03 + 20 >> 2] | 0) == 35) $name$1 = HEAP32[$curr$03 + 4 >> 2] | 0; else $name$1 = 0;
      break;
     }
    case 4:
     {
      if (!(HEAP32[$curr$03 + 16 >> 2] & 8)) $name$1 = 0; else if ((HEAP32[$curr$03 + 20 >> 2] | 0) == 25) $name$1 = HEAP32[$curr$03 + 4 >> 2] | 0; else $name$1 = 0;
      break;
     }
    default:
     $name$1 = 0;
    }
    $curr$0 = HEAP32[$curr$03 + 28 >> 2] | 0;
    if (($name$1 | 0) == 0 & ($curr$0 | 0) != 0) $curr$03 = $curr$0; else {
     $curr$0$lcssa = $curr$0;
     $name$0$lcssa = $name$1;
     break;
    }
   }
   HEAP32[$iter >> 2] = $curr$0$lcssa;
   return $name$0$lcssa | 0;
  }
 }
 return 0;
}

function _prvTidyFindBody($doc) {
 $doc = $doc | 0;
 var $$0 = 0, $13 = 0, $2 = 0, $21 = 0, $30 = 0, $4 = 0, $node$028 = 0, $node$028$lcssa = 0, $node$124 = 0, $node$125 = 0, $node$125$lcssa60 = 0, $node$221 = 0, $node$222 = 0, $node$222$lcssa = 0, $node$317 = 0, $node$318 = 0, label = 0;
 if (!$doc) {
  $$0 = 0;
  return $$0 | 0;
 }
 $2 = HEAP32[$doc + 12 >> 2] | 0;
 if (!$2) {
  $$0 = 0;
  return $$0 | 0;
 } else $node$028 = $2;
 while (1) {
  $4 = HEAP32[$node$028 + 28 >> 2] | 0;
  if ($4 | 0) if ((HEAP32[$4 >> 2] | 0) == 48) {
   $node$028$lcssa = $node$028;
   break;
  }
  $node$028 = HEAP32[$node$028 + 8 >> 2] | 0;
  if (!$node$028) {
   $$0 = 0;
   label = 18;
   break;
  }
 }
 if ((label | 0) == 18) return $$0 | 0;
 $node$124 = HEAP32[$node$028$lcssa + 12 >> 2] | 0;
 if (!$node$124) {
  $$0 = 0;
  return $$0 | 0;
 } else $node$125 = $node$124;
 L16 : while (1) {
  $13 = HEAP32[$node$125 + 28 >> 2] | 0;
  if ($13 | 0) switch (HEAP32[$13 >> 2] | 0) {
  case 39:
   {
    $node$125$lcssa60 = $node$125;
    label = 10;
    break L16;
    break;
   }
  case 16:
   {
    $$0 = $node$125;
    label = 18;
    break L16;
    break;
   }
  default:
   {}
  }
  $node$125 = HEAP32[$node$125 + 8 >> 2] | 0;
  if (!$node$125) {
   $$0 = 0;
   label = 18;
   break;
  }
 }
 if ((label | 0) == 10) {
  $node$221 = HEAP32[$node$125$lcssa60 + 12 >> 2] | 0;
  if (!$node$221) {
   $$0 = 0;
   return $$0 | 0;
  } else $node$222 = $node$221;
  while (1) {
   $21 = HEAP32[$node$222 + 28 >> 2] | 0;
   if ($21 | 0) if ((HEAP32[$21 >> 2] | 0) == 72) {
    $node$222$lcssa = $node$222;
    break;
   }
   $node$222 = HEAP32[$node$222 + 8 >> 2] | 0;
   if (!$node$222) {
    $$0 = 0;
    label = 18;
    break;
   }
  }
  if ((label | 0) == 18) return $$0 | 0;
  $node$317 = HEAP32[$node$222$lcssa + 12 >> 2] | 0;
  if (!$node$317) {
   $$0 = 0;
   return $$0 | 0;
  } else $node$318 = $node$317;
  while (1) {
   $30 = HEAP32[$node$318 + 28 >> 2] | 0;
   if ($30 | 0) if ((HEAP32[$30 >> 2] | 0) == 16) {
    $$0 = $node$318;
    label = 18;
    break;
   }
   $node$318 = HEAP32[$node$318 + 8 >> 2] | 0;
   if (!$node$318) {
    $$0 = 0;
    label = 18;
    break;
   }
  }
  if ((label | 0) == 18) return $$0 | 0;
 } else if ((label | 0) == 18) return $$0 | 0;
 return 0;
}

function _CheckMissingStyleSheets($node) {
 $node = $node | 0;
 var $$lcssa = 0, $12 = 0, $14 = 0, $15 = 0, $16 = 0, $20 = 0, $25 = 0, $26 = 0, $3 = 0, $6 = 0, $7 = 0, $av$043 = 0, $av$045 = 0, $content$048 = 0, $content$049 = 0, $sspresent$0$lcssa = 0, $sspresent$1$lcssa = 0, $sspresent$2 = 0, $sspresent$3 = 0, label = 0;
 $content$048 = HEAP32[$node + 12 >> 2] | 0;
 if (!$content$048) {
  $sspresent$0$lcssa = 0;
  return $sspresent$0$lcssa | 0;
 } else $content$049 = $content$048;
 L3 : while (1) {
  $3 = HEAP32[$content$049 + 28 >> 2] | 0;
  L5 : do if (!$3) $7 = 0; else {
   switch (HEAP32[$3 >> 2] | 0) {
   case 36:
   case 103:
   case 62:
    {
     $sspresent$0$lcssa = 1;
     label = 17;
     break L3;
     break;
    }
   case 10:
    {
     $7 = 1;
     break L5;
     break;
    }
   default:
    {}
   }
   $7 = 0;
  } while (0);
  $6 = $7 & 1;
  $av$043 = HEAP32[$content$049 + 20 >> 2] | 0;
  if (($av$043 | 0) != 0 & ($7 ^ 1)) {
   $av$045 = $av$043;
   while (1) {
    $12 = HEAP32[$av$045 + 4 >> 2] | 0;
    if (!$12) $sspresent$2 = 0; else {
     $14 = HEAP32[$12 >> 2] | 0;
     switch ($14 | 0) {
     case 8:
     case 157:
     case 147:
     case 143:
      {
       $sspresent$0$lcssa = 1;
       label = 17;
       break L3;
       break;
      }
     default:
      {}
     }
     $15 = ($14 | 0) == 76;
     $16 = $15 & 1;
     if ($15) $sspresent$2 = $16; else if ((HEAP32[$12 >> 2] | 0) == 122) {
      $20 = HEAP32[$av$045 + 24 >> 2] | 0;
      if (!$20) $25 = 0; else $25 = (_prvTidytmbstrcasecmp($20, 311719) | 0) == 0;
      $sspresent$2 = $25 & 1;
     } else $sspresent$2 = $16;
    }
    $av$045 = HEAP32[$av$045 >> 2] | 0;
    $26 = ($sspresent$2 | 0) != 0;
    if (!(($av$045 | 0) != 0 & ($26 ^ 1))) {
     $$lcssa = $26;
     $sspresent$1$lcssa = $sspresent$2;
     break;
    }
   }
  } else {
   $$lcssa = $7;
   $sspresent$1$lcssa = $6;
  }
  if ($$lcssa) $sspresent$3 = $sspresent$1$lcssa; else $sspresent$3 = _CheckMissingStyleSheets($content$049) | 0;
  $content$049 = HEAP32[$content$049 + 8 >> 2] | 0;
  if (!(($sspresent$3 | 0) == 0 & ($content$049 | 0) != 0)) {
   $sspresent$0$lcssa = $sspresent$3;
   label = 17;
   break;
  }
 }
 if ((label | 0) == 17) return $sspresent$0$lcssa | 0;
 return 0;
}

function _prvTidyEntityInfo($name, $isXml, $code, $versions) {
 $name = $name | 0;
 $isXml = $isXml | 0;
 $code = $code | 0;
 $versions = $versions | 0;
 var $$0 = 0, $$1 = 0, $20 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $c = 0, $np$02$i4 = 0, $np$02$i4$lcssa = 0, $res$0 = 0, $storemerge = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $c = sp + 12 | 0;
 if (!$name) ___assert_fail(312147, 312170, 356, 312261);
 if ((HEAP8[$name >> 0] | 0) != 38) ___assert_fail(312147, 312170, 356, 312261);
 if (!$code) ___assert_fail(312279, 312170, 357, 312261);
 if (!$versions) ___assert_fail(312292, 312170, 358, 312261);
 $5 = $name + 1 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 L13 : do switch ($6 << 24 >> 24) {
 case 35:
  {
   HEAP32[$c >> 2] = 0;
   $7 = $name + 2 | 0;
   $8 = HEAP8[$7 >> 0] | 0;
   if ($8 << 24 >> 24 == 120) label = 11; else if (($isXml | 0) == 0 & $8 << 24 >> 24 == 88) label = 11; else {
    HEAP32[$vararg_buffer1 >> 2] = $c;
    $res$0 = _sscanf($7, 312312, $vararg_buffer1) | 0;
   }
   if ((label | 0) == 11) {
    HEAP32[$vararg_buffer >> 2] = $c;
    $res$0 = _sscanf($name + 3 | 0, 312309, $vararg_buffer) | 0;
   }
   if (($res$0 | 0) == 1) {
    HEAP32[$code >> 2] = HEAP32[$c >> 2];
    $$0 = 1;
    $storemerge = 401407;
   } else {
    HEAP32[$code >> 2] = 0;
    $$0 = 0;
    $storemerge = $isXml | 0 ? 65536 : 57344;
   }
   HEAP32[$versions >> 2] = $storemerge;
   $$1 = $$0;
   STACKTOP = sp;
   return $$1 | 0;
  }
 case 0:
  break;
 default:
  {
   $20 = 312315;
   $np$02$i4 = 217060;
   while (1) {
    if ($6 << 24 >> 24 == (HEAP8[$20 >> 0] | 0)) if (!(_prvTidytmbstrcmp($5, $20) | 0)) {
     $np$02$i4$lcssa = $np$02$i4;
     break;
    }
    $np$02$i4 = $np$02$i4 + 12 | 0;
    $20 = HEAP32[$np$02$i4 >> 2] | 0;
    if (!$20) break L13;
   }
   HEAP32[$code >> 2] = HEAP32[$np$02$i4$lcssa + 8 >> 2];
   HEAP32[$versions >> 2] = HEAP32[$np$02$i4$lcssa + 4 >> 2];
   $$1 = 1;
   STACKTOP = sp;
   return $$1 | 0;
  }
 } while (0);
 HEAP32[$code >> 2] = 0;
 HEAP32[$versions >> 2] = $isXml | 0 ? 65536 : 57344;
 $$1 = 0;
 STACKTOP = sp;
 return $$1 | 0;
}

function _CheckAlign($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $$pre5 = 0, $$pre6 = 0, $$pre7 = 0, $$pre8 = 0, $0 = 0, $1 = 0, $11 = 0, $17 = 0, $22 = 0, $32 = 0, $36 = 0, $8 = 0, $9 = 0, $p$01$i = 0, label = 0;
 $0 = $node + 28 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if ($1 | 0) if (HEAP32[$1 + 16 >> 2] & 65536 | 0) {
  _CheckValign($doc, $node, $attval);
  return;
 }
 if ($attval | 0) {
  $8 = $attval + 24 | 0;
  $9 = HEAP32[$8 >> 2] | 0;
  if ($9 | 0) {
   $11 = HEAP8[$9 >> 0] | 0;
   if (!($11 << 24 >> 24)) {
    $32 = $1;
    label = 16;
   } else {
    $17 = $11;
    $p$01$i = $9;
    do {
     $p$01$i = $p$01$i + 1 | 0;
     if (_prvTidyIsUpper($17 << 24 >> 24) | 0) {
      label = 10;
      break;
     }
     $17 = HEAP8[$p$01$i >> 0] | 0;
    } while ($17 << 24 >> 24 != 0);
    do if ((label | 0) == 10) {
     $22 = (HEAP32[$doc + 68 >> 2] | 0) + 28 | 0;
     if (!(HEAP32[$22 >> 2] | 0)) label = 12; else {
      _prvTidyReportAttrError($doc, $node, $attval, 269);
      if (!(HEAP32[$22 >> 2] | 0)) label = 12;
     }
     if ((label | 0) == 12) if (!(HEAP32[$doc + 336 >> 2] | 0)) break;
     HEAP32[$8 >> 2] = _prvTidytmbstrtolower(HEAP32[$8 >> 2] | 0) | 0;
    } while (0);
    if ($node | 0) {
     $32 = HEAP32[$0 >> 2] | 0;
     label = 16;
    }
   }
   if ((label | 0) == 16) if ($32 | 0) if ((HEAP32[$32 >> 2] | 0) == 19) return;
   $36 = HEAP32[$8 >> 2] | 0;
   if ($36 | 0) {
    if (!(_prvTidytmbstrcasecmp($36, 308192) | 0)) return;
    $$pre5 = HEAP32[$8 >> 2] | 0;
    if ($$pre5 | 0) {
     if (!(_prvTidytmbstrcasecmp($$pre5, 308197) | 0)) return;
     $$pre6 = HEAP32[$8 >> 2] | 0;
     if ($$pre6 | 0) {
      if (!(_prvTidytmbstrcasecmp($$pre6, 308214) | 0)) return;
      $$pre7 = HEAP32[$8 >> 2] | 0;
      if ($$pre7 | 0) {
       if (!(_prvTidytmbstrcasecmp($$pre7, 304581) | 0)) return;
       $$pre8 = HEAP32[$8 >> 2] | 0;
       if ($$pre8 | 0) if (!(_prvTidytmbstrcasecmp($$pre8, 304576) | 0)) if (_prvTidynodeHasCM($node, 640) | 0) return;
      }
     }
    }
   }
   _prvTidyReportAttrError($doc, $node, $attval, 251);
   return;
  }
 }
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 return;
}

function _ParseRepeatAttr($doc, $option) {
 $doc = $doc | 0;
 $option = $option | 0;
 var $$0$i$i = 0, $$lcssa = 0, $0 = 0, $11 = 0, $16 = 0, $buf = 0, $c$07 = 0, $config$idx$i = 0, $config$idx$i2 = 0, $config$idx$val$i = 0, $config$idx$val$i3 = 0, $i$0$lcssa = 0, $i$06 = 0, $status$0 = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $buf = sp;
 dest = $buf;
 stop = dest + 64 | 0;
 do {
  HEAP8[dest >> 0] = 0;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 $0 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$0 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$0 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$0 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $11 = HEAP32[$0 >> 2] | 0;
 L10 : do if (($11 | 0) == -1) $i$0$lcssa = 0; else {
  $config$idx$i2 = $doc + 872 | 0;
  $c$07 = $11;
  $i$06 = 0;
  while (1) {
   if (_prvTidyIsWhite($c$07) | 0) {
    $i$0$lcssa = $i$06;
    break L10;
   }
   $16 = $i$06 + 1 | 0;
   HEAP8[$buf + $i$06 >> 0] = $c$07;
   if ((HEAP32[$0 >> 2] | 0) == -1) {
    $i$0$lcssa = $16;
    break L10;
   }
   $config$idx$val$i3 = HEAP32[$config$idx$i2 >> 2] | 0;
   if (!$config$idx$val$i3) {
    $$lcssa = $16;
    break;
   }
   $c$07 = _prvTidyReadChar($config$idx$val$i3) | 0;
   HEAP32[$0 >> 2] = $c$07;
   if (!($16 >>> 0 < 63 & ($c$07 | 0) != -1)) {
    $i$0$lcssa = $16;
    break L10;
   } else $i$06 = $16;
  }
  HEAP32[$0 >> 2] = -1;
  $i$0$lcssa = $$lcssa;
 } while (0);
 HEAP8[$buf + $i$0$lcssa >> 0] = 0;
 if (!(_prvTidytmbstrcasecmp($buf, 224127) | 0)) {
  HEAP32[$doc + 112 >> 2] = 0;
  $status$0 = 1;
  STACKTOP = sp;
  return $status$0 | 0;
 }
 if (!(_prvTidytmbstrcasecmp($buf, 224138) | 0)) {
  HEAP32[$doc + 112 >> 2] = 1;
  $status$0 = 1;
  STACKTOP = sp;
  return $status$0 | 0;
 } else {
  _prvTidyReportBadArgument($doc, HEAP32[$option + 8 >> 2] | 0);
  $status$0 = 0;
  STACKTOP = sp;
  return $status$0 | 0;
 }
 return 0;
}

function _mbrtowc($wc, $src, $n, $st) {
 $wc = $wc | 0;
 $src = $src | 0;
 $n = $n | 0;
 $st = $st | 0;
 var $$0 = 0, $$024 = 0, $$1 = 0, $$lcssa = 0, $$lcssa35 = 0, $$st = 0, $1 = 0, $12 = 0, $16 = 0, $17 = 0, $19 = 0, $21 = 0, $30 = 0, $7 = 0, $8 = 0, $c$05 = 0, $c$1 = 0, $c$2 = 0, $dummy = 0, $dummy$wc = 0, $s$06 = 0, $s$1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $dummy = sp;
 $$st = ($st | 0) == 0 ? 317064 : $st;
 $1 = HEAP32[$$st >> 2] | 0;
 L1 : do if (!$src) if (!$1) $$0 = 0; else label = 15; else {
  $dummy$wc = ($wc | 0) == 0 ? $dummy : $wc;
  if (!$n) $$0 = -2; else {
   if (!$1) {
    $7 = HEAP8[$src >> 0] | 0;
    $8 = $7 & 255;
    if ($7 << 24 >> 24 > -1) {
     HEAP32[$dummy$wc >> 2] = $8;
     $$0 = $7 << 24 >> 24 != 0 & 1;
     break;
    }
    $12 = $8 + -194 | 0;
    if ($12 >>> 0 > 50) {
     label = 15;
     break;
    }
    $16 = HEAP32[220460 + ($12 << 2) >> 2] | 0;
    $17 = $n + -1 | 0;
    if (!$17) $c$2 = $16; else {
     $$024 = $17;
     $c$05 = $16;
     $s$06 = $src + 1 | 0;
     label = 9;
    }
   } else {
    $$024 = $n;
    $c$05 = $1;
    $s$06 = $src;
    label = 9;
   }
   L11 : do if ((label | 0) == 9) {
    $19 = HEAP8[$s$06 >> 0] | 0;
    $21 = ($19 & 255) >>> 3;
    if (($21 + -16 | $21 + ($c$05 >> 26)) >>> 0 > 7) {
     label = 15;
     break L1;
    } else {
     $$1 = $$024;
     $30 = $19;
     $c$1 = $c$05;
     $s$1 = $s$06;
    }
    while (1) {
     $s$1 = $s$1 + 1 | 0;
     $c$1 = ($30 & 255) + -128 | $c$1 << 6;
     $$1 = $$1 + -1 | 0;
     if (($c$1 | 0) >= 0) {
      $$lcssa = $c$1;
      $$lcssa35 = $$1;
      break;
     }
     if (!$$1) {
      $c$2 = $c$1;
      break L11;
     }
     $30 = HEAP8[$s$1 >> 0] | 0;
     if (($30 & -64) << 24 >> 24 != -128) {
      label = 15;
      break L1;
     }
    }
    HEAP32[$$st >> 2] = 0;
    HEAP32[$dummy$wc >> 2] = $$lcssa;
    $$0 = $n - $$lcssa35 | 0;
    break L1;
   } while (0);
   HEAP32[$$st >> 2] = $c$2;
   $$0 = -2;
  }
 } while (0);
 if ((label | 0) == 15) {
  HEAP32[$$st >> 2] = 0;
  HEAP32[(___errno_location() | 0) >> 2] = 84;
  $$0 = -1;
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _ParseSorter($doc, $option) {
 $doc = $doc | 0;
 $option = $option | 0;
 var $$0$i$i = 0, $$lcssa = 0, $0 = 0, $11 = 0, $16 = 0, $buf = 0, $c$07 = 0, $config$idx$i = 0, $config$idx$i2 = 0, $config$idx$val$i = 0, $config$idx$val$i3 = 0, $i$0$lcssa = 0, $i$06 = 0, $status$0 = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $buf = sp;
 dest = $buf;
 stop = dest + 64 | 0;
 do {
  HEAP8[dest >> 0] = 0;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 $0 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$0 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$0 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$0 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $11 = HEAP32[$0 >> 2] | 0;
 L10 : do if (($11 | 0) == -1) $i$0$lcssa = 0; else {
  $config$idx$i2 = $doc + 872 | 0;
  $c$07 = $11;
  $i$06 = 0;
  while (1) {
   if (_prvTidyIsWhite($c$07) | 0) {
    $i$0$lcssa = $i$06;
    break L10;
   }
   $16 = $i$06 + 1 | 0;
   HEAP8[$buf + $i$06 >> 0] = $c$07;
   if ((HEAP32[$0 >> 2] | 0) == -1) {
    $i$0$lcssa = $16;
    break L10;
   }
   $config$idx$val$i3 = HEAP32[$config$idx$i2 >> 2] | 0;
   if (!$config$idx$val$i3) {
    $$lcssa = $16;
    break;
   }
   $c$07 = _prvTidyReadChar($config$idx$val$i3) | 0;
   HEAP32[$0 >> 2] = $c$07;
   if (!($16 >>> 0 < 63 & ($c$07 | 0) != -1)) {
    $i$0$lcssa = $16;
    break L10;
   } else $i$06 = $16;
  }
  HEAP32[$0 >> 2] = -1;
  $i$0$lcssa = $$lcssa;
 } while (0);
 HEAP8[$buf + $i$0$lcssa >> 0] = 0;
 if (!(_prvTidytmbstrcasecmp($buf, 313043) | 0)) {
  HEAP32[$doc + 436 >> 2] = 1;
  $status$0 = 1;
  STACKTOP = sp;
  return $status$0 | 0;
 }
 if (!(_prvTidytmbstrcasecmp($buf, 304891) | 0)) {
  HEAP32[$doc + 436 >> 2] = 0;
  $status$0 = 1;
  STACKTOP = sp;
  return $status$0 | 0;
 } else {
  _prvTidyReportBadArgument($doc, HEAP32[$option + 8 >> 2] | 0);
  $status$0 = 0;
  STACKTOP = sp;
  return $status$0 | 0;
 }
 return 0;
}

function _prvTidyPushInline($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$phi$trans$insert = 0, $$pre$phi11Z2D = 0, $$pre$phiZ2D = 0, $1 = 0, $14 = 0, $15 = 0, $16 = 0, $23 = 0, $24 = 0, $25 = 0, $29 = 0, $30 = 0, $31 = 0, $35 = 0, $38 = 0, $40 = 0, $41 = 0, $42 = 0, $5 = 0, $6 = 0, $8 = 0, $i$0$in$i = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 if (HEAP32[$node + 60 >> 2] | 0) return;
 $5 = $node + 28 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $8 = $6;
 if (!$6) return;
 if ((HEAP32[$6 + 16 >> 2] & 2064 | 0) != 16) return;
 L10 : do switch (HEAP32[$6 >> 2] | 0) {
 case 36:
  {
   $$phi$trans$insert = $1 + 112 | 0;
   $$pre$phiZ2D = $$phi$trans$insert;
   $23 = HEAP32[$$phi$trans$insert >> 2] | 0;
   break;
  }
 case 27:
 case 54:
  return;
 default:
  {
   $14 = $1 + 112 | 0;
   $15 = HEAP32[$14 >> 2] | 0;
   $16 = $1 + 104 | 0;
   $i$0$in$i = $15;
   do {
    $i$0$in$i = $i$0$in$i + -1 | 0;
    if (($i$0$in$i | 0) <= -1) {
     $$pre$phiZ2D = $14;
     $23 = $15;
     break L10;
    }
   } while ((HEAP32[(HEAP32[$16 >> 2] | 0) + ($i$0$in$i << 4) + 4 >> 2] | 0) != ($6 | 0));
   return;
  }
 } while (0);
 $24 = $1 + 108 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 if (($23 + 1 | 0) >>> 0 > $25 >>> 0) {
  if (!$25) {
   HEAP32[$24 >> 2] = 6;
   $29 = 6;
  } else $29 = $25;
  HEAP32[$24 >> 2] = $29 << 1;
  $30 = $doc + 6856 | 0;
  $31 = HEAP32[$30 >> 2] | 0;
  $35 = $1 + 104 | 0;
  $38 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$31 >> 2] | 0) + 4 >> 2] & 15]($31, HEAP32[$35 >> 2] | 0, $29 << 5) | 0;
  HEAP32[$35 >> 2] = $38;
  $$pre$phi11Z2D = $30;
  $40 = $38;
  $41 = HEAP32[$$pre$phiZ2D >> 2] | 0;
  $42 = HEAP32[$5 >> 2] | 0;
 } else {
  $$pre$phi11Z2D = $doc + 6856 | 0;
  $40 = HEAP32[$1 + 104 >> 2] | 0;
  $41 = $23;
  $42 = $8;
 }
 HEAP32[$40 + ($41 << 4) + 4 >> 2] = $42;
 HEAP32[$40 + ($41 << 4) + 8 >> 2] = _prvTidytmbstrdup(HEAP32[$$pre$phi11Z2D >> 2] | 0, HEAP32[$node + 32 >> 2] | 0) | 0;
 HEAP32[$40 + ($41 << 4) + 12 >> 2] = _prvTidyDupAttrs($doc, HEAP32[$node + 20 >> 2] | 0) | 0;
 HEAP32[$$pre$phiZ2D >> 2] = (HEAP32[$$pre$phiZ2D >> 2] | 0) + 1;
 return;
}

function _prvTidyParseTitle($doc, $title, $mode) {
 $doc = $doc | 0;
 $title = $title | 0;
 $mode = $mode | 0;
 var $$lcssa = 0, $$lcssa14 = 0, $0 = 0, $11 = 0, $2 = 0, $3 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $doc$idx = 0, label = 0;
 $0 = _prvTidyGetToken($doc, 1) | 0;
 L1 : do if ($0 | 0) {
  $2 = $title + 28 | 0;
  $3 = $doc + 156 | 0;
  $4 = $title + 12 | 0;
  $doc$idx = $doc + 68 | 0;
  $5 = $title + 16 | 0;
  $7 = $0;
  L3 : while (1) {
   $6 = $7 + 28 | 0;
   do if ((HEAP32[$6 >> 2] | 0) == (HEAP32[$2 >> 2] | 0)) {
    $11 = $7 + 44 | 0;
    if ((HEAP32[$11 >> 2] | 0) == 5) if (HEAP32[$3 >> 2] | 0) {
     _prvTidyReportError($doc, $title, $7, 224);
     HEAP32[$11 >> 2] = 6;
     _prvTidyUngetToken($doc);
     break;
    }
    if ((HEAP32[$7 + 44 >> 2] | 0) == 6) {
     $$lcssa = $7;
     label = 9;
     break L3;
    } else label = 10;
   } else label = 10; while (0);
   do if ((label | 0) == 10) {
    label = 0;
    if (!(_prvTidynodeIsText($7) | 0)) {
     if (_InsertMisc($title, $7) | 0) break;
     if (HEAP32[$6 >> 2] | 0) {
      $$lcssa14 = $7;
      label = 22;
      break L3;
     }
     _prvTidyReportError($doc, $title, $7, 208);
     _prvTidyFreeNode($doc, $7);
     break;
    }
    if (!(HEAP32[$4 >> 2] | 0)) _TrimInitialSpace(HEAP32[$doc$idx >> 2] | 0, $title, $7);
    if ((HEAP32[$7 + 36 >> 2] | 0) >>> 0 >= (HEAP32[$7 + 40 >> 2] | 0) >>> 0) {
     _prvTidyFreeNode($doc, $7);
     break;
    }
    HEAP32[$7 >> 2] = $title;
    $31 = HEAP32[$5 >> 2] | 0;
    HEAP32[$7 + 4 >> 2] = $31;
    if (!$31) HEAP32[$4 >> 2] = $7; else HEAP32[$31 + 8 >> 2] = $7;
    HEAP32[$5 >> 2] = $7;
   } while (0);
   $7 = _prvTidyGetToken($doc, 1) | 0;
   if (!$7) break L1;
  }
  if ((label | 0) == 9) {
   _prvTidyFreeNode($doc, $$lcssa);
   HEAP32[$title + 56 >> 2] = 1;
   _TrimSpaces($doc, $title);
   return;
  } else if ((label | 0) == 22) {
   _prvTidyReportError($doc, $title, $$lcssa14, 207);
   _prvTidyUngetToken($doc);
   _TrimSpaces($doc, $title);
   return;
  }
 } while (0);
 _prvTidyReportError($doc, $title, 0, 206);
 return;
}

function _CreatePropString($doc, $props) {
 $doc = $doc | 0;
 $props = $props | 0;
 var $$lcssa = 0, $0 = 0, $15 = 0, $19 = 0, $22 = 0, $23 = 0, $25 = 0, $31 = 0, $34 = 0, $37 = 0, $4 = 0, $6 = 0, $len$0$lcssa = 0, $len$04 = 0, $len$1 = 0, $p$01 = 0, $p$1 = 0, $p$1$lcssa = 0, $p$2 = 0, $prop$05 = 0, $prop$12 = 0, $s$0 = 0, $s$1 = 0, label = 0;
 $0 = ($props | 0) == 0;
 if ($0) $len$0$lcssa = 0; else {
  $len$04 = 0;
  $prop$05 = $props;
  while (1) {
   $4 = $len$04 + 2 + (_prvTidytmbstrlen(HEAP32[$prop$05 >> 2] | 0) | 0) | 0;
   $6 = HEAP32[$prop$05 + 4 >> 2] | 0;
   if (!$6) $len$1 = $4; else $len$1 = $4 + 2 + (_prvTidytmbstrlen($6) | 0) | 0;
   $prop$05 = HEAP32[$prop$05 + 8 >> 2] | 0;
   if (!$prop$05) {
    $len$0$lcssa = $len$1;
    break;
   } else $len$04 = $len$1;
  }
 }
 $15 = HEAP32[$doc + 6856 >> 2] | 0;
 $19 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$15 >> 2] >> 2] & 31]($15, $len$0$lcssa + 1 | 0) | 0;
 HEAP8[$19 >> 0] = 0;
 if ($0) return $19 | 0; else {
  $p$01 = $19;
  $prop$12 = $props;
 }
 while (1) {
  $p$1 = $p$01;
  $s$0 = HEAP32[$prop$12 >> 2] | 0;
  while (1) {
   $22 = HEAP8[$s$0 >> 0] | 0;
   $23 = $p$1 + 1 | 0;
   HEAP8[$p$1 >> 0] = $22;
   if (!($22 << 24 >> 24)) {
    $$lcssa = $23;
    $p$1$lcssa = $p$1;
    break;
   } else {
    $p$1 = $23;
    $s$0 = $s$0 + 1 | 0;
   }
  }
  $25 = $prop$12 + 4 | 0;
  if (!(HEAP32[$25 >> 2] | 0)) $37 = $p$1$lcssa; else {
   HEAP8[$p$1$lcssa >> 0] = 58;
   HEAP8[$$lcssa >> 0] = 32;
   $p$2 = $p$1$lcssa + 2 | 0;
   $s$1 = HEAP32[$25 >> 2] | 0;
   while (1) {
    $31 = HEAP8[$s$1 >> 0] | 0;
    HEAP8[$p$2 >> 0] = $31;
    if (!($31 << 24 >> 24)) {
     $37 = $p$2;
     break;
    } else {
     $p$2 = $p$2 + 1 | 0;
     $s$1 = $s$1 + 1 | 0;
    }
   }
  }
  $34 = $prop$12 + 8 | 0;
  if (!(HEAP32[$34 >> 2] | 0)) {
   label = 13;
   break;
  }
  HEAP8[$37 >> 0] = 59;
  HEAP8[$37 + 1 >> 0] = 32;
  $prop$12 = HEAP32[$34 >> 2] | 0;
  if (!$prop$12) {
   label = 13;
   break;
  } else $p$01 = $37 + 2 | 0;
 }
 if ((label | 0) == 13) return $19 | 0;
 return 0;
}

function _CheckFlicker($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$lcssa29 = 0, $11 = 0, $12 = 0, $14 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $5 = 0, $9 = 0, $cp$03$i$i = 0, $ext = 0, $i$0$in$i = 0, $msgcode$223 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $ext = sp;
 if (!($node | 0 ? ((HEAP32[$doc + 6396 >> 2] | 0) + -1 | 0) >>> 0 < 3 : 0)) {
  STACKTOP = sp;
  return;
 }
 $3 = HEAP32[$node + 28 >> 2] | 0;
 if (!$3) {
  STACKTOP = sp;
  return;
 }
 $5 = HEAP32[$3 >> 2] | 0;
 L7 : do if (($5 | 0) == 94) $msgcode$223 = 379; else if (($5 | 0) == 76) $msgcode$223 = 380; else if (($5 | 0) == 34) $msgcode$223 = 381; else {
  switch ($5 | 0) {
  case 6:
   {
    $msgcode$223 = 382;
    break L7;
    break;
   }
  case 52:
   break;
  default:
   {
    STACKTOP = sp;
    return;
   }
  }
  $9 = _prvTidyAttrGetById($node, 139) | 0;
  if (!$9) {
   STACKTOP = sp;
   return;
  }
  $11 = $9 + 24 | 0;
  $12 = HEAP32[$11 >> 2] | 0;
  if (!$12) {
   STACKTOP = sp;
   return;
  } else $cp$03$i$i = $12;
  while (1) {
   $14 = HEAP8[$cp$03$i$i >> 0] | 0;
   if (!($14 << 24 >> 24)) {
    label = 17;
    break;
   }
   if (!(_prvTidyIsWhite($14 << 24 >> 24) | 0)) break; else $cp$03$i$i = $cp$03$i$i + 1 | 0;
  }
  if ((label | 0) == 17) {
   STACKTOP = sp;
   return;
  }
  $20 = HEAP32[$11 >> 2] | 0;
  $21 = _prvTidytmbstrlen($20) | 0;
  HEAP8[$ext >> 0] = 0;
  $i$0$in$i = $21;
  L25 : do {
   $i$0$in$i = $i$0$in$i + -1 | 0;
   $22 = $20 + $i$0$in$i | 0;
   switch (HEAP8[$22 >> 0] | 0) {
   case 92:
   case 47:
    {
     break L25;
     break;
    }
   case 46:
    {
     $$lcssa29 = $22;
     label = 13;
     break L25;
     break;
    }
   default:
    {}
   }
  } while (($i$0$in$i | 0) > 1);
  if ((label | 0) == 13) _prvTidytmbstrncpy($ext, $$lcssa29, 20) | 0;
  if (!(_prvTidytmbstrcasecmp($ext, 311986) | 0)) $msgcode$223 = 383; else {
   STACKTOP = sp;
   return;
  }
 } while (0);
 _prvTidyReportAccessWarning($doc, $node, $msgcode$223);
 STACKTOP = sp;
 return;
}

function _InsertMisc($element, $node) {
 $element = $element | 0;
 $node = $node | 0;
 var $$1 = 0, $10 = 0, $12 = 0, $13 = 0, $2 = 0, $23 = 0, $3 = 0, $30 = 0, $37 = 0, $38 = 0, $root$0 = 0, $root$0$lcssa12 = 0, label = 0;
 switch (HEAP32[$node + 44 >> 2] | 0) {
 case 12:
 case 11:
 case 10:
 case 9:
 case 8:
 case 3:
 case 2:
  {
   HEAP32[$node >> 2] = $element;
   $2 = $element + 16 | 0;
   $3 = HEAP32[$2 >> 2] | 0;
   HEAP32[$node + 4 >> 2] = $3;
   if (!$3) HEAP32[$element + 12 >> 2] = $node; else HEAP32[$3 + 8 >> 2] = $node;
   HEAP32[$2 >> 2] = $node;
   $$1 = 1;
   return $$1 | 0;
  }
 case 13:
  {
   $root$0 = $element;
   label = 6;
   break;
  }
 default:
  {}
 }
 L8 : do if ((label | 0) == 6) {
  while (1) {
   label = 0;
   if (!$root$0) break L8;
   $10 = HEAP32[$root$0 >> 2] | 0;
   if (!$10) {
    $root$0$lcssa12 = $root$0;
    break;
   } else {
    $root$0 = $10;
    label = 6;
   }
  }
  $12 = $root$0$lcssa12 + 12 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  if (!$13) {
   HEAP32[$node >> 2] = $root$0$lcssa12;
   HEAP32[$root$0$lcssa12 + 16 >> 2] = $node;
  } else {
   if ((HEAP32[$13 + 44 >> 2] | 0) == 13) break;
   HEAP32[$node >> 2] = $root$0$lcssa12;
   HEAP32[$13 + 4 >> 2] = $node;
  }
  HEAP32[$node + 8 >> 2] = $13;
  HEAP32[$node + 4 >> 2] = 0;
  HEAP32[$12 >> 2] = $node;
  $$1 = 1;
  return $$1 | 0;
 } while (0);
 $23 = $node + 28 | 0;
 if (!(HEAP32[$23 >> 2] | 0)) {
  $$1 = 0;
  return $$1 | 0;
 }
 if (!(_prvTidynodeIsElement($node) | 0)) {
  $$1 = 0;
  return $$1 | 0;
 }
 if (!(_prvTidynodeCMIsEmpty($node) | 0)) {
  $$1 = 0;
  return $$1 | 0;
 }
 $30 = HEAP32[$23 >> 2] | 0;
 if ($30 | 0) if (HEAP32[$30 >> 2] | 0) {
  $$1 = 0;
  return $$1 | 0;
 }
 if (!(HEAP32[$30 + 8 >> 2] & 57344)) {
  $$1 = 0;
  return $$1 | 0;
 }
 HEAP32[$node >> 2] = $element;
 $37 = $element + 16 | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 HEAP32[$node + 4 >> 2] = $38;
 if (!$38) HEAP32[$element + 12 >> 2] = $node; else HEAP32[$38 + 8 >> 2] = $node;
 HEAP32[$37 >> 2] = $node;
 $$1 = 1;
 return $$1 | 0;
}

function _prvTidyParseOptGroup($doc, $field, $mode) {
 $doc = $doc | 0;
 $field = $field | 0;
 $mode = $mode | 0;
 var $$lcssa = 0, $0 = 0, $19 = 0, $22 = 0, $25 = 0, $3 = 0, $30 = 0, $31 = 0, $34 = 0, $45 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0;
 $0 = $doc + 68 | 0;
 HEAP32[(HEAP32[$0 >> 2] | 0) + 100 >> 2] = 0;
 $3 = _prvTidyGetToken($doc, 0) | 0;
 if (!$3) return;
 $5 = $field + 28 | 0;
 $6 = $field + 16 | 0;
 $7 = $field + 12 | 0;
 $9 = $3;
 while (1) {
  $8 = $9 + 28 | 0;
  if ((HEAP32[$8 >> 2] | 0) == (HEAP32[$5 >> 2] | 0)) if ((HEAP32[$9 + 44 >> 2] | 0) == 6) {
   $$lcssa = $9;
   break;
  }
  L9 : do if (!(_InsertMisc($field, $9) | 0)) {
   $19 = $9 + 44 | 0;
   L11 : do if ((HEAP32[$19 >> 2] | 0) == 5) {
    $22 = HEAP32[$8 >> 2] | 0;
    if ($22 | 0) {
     switch (HEAP32[$22 >> 2] | 0) {
     case 79:
      break;
     case 78:
      {
       _prvTidyReportError($doc, $field, $9, 219);
       break;
      }
     default:
      break L11;
     }
     HEAP32[$9 >> 2] = $field;
     $25 = HEAP32[$6 >> 2] | 0;
     HEAP32[$9 + 4 >> 2] = $25;
     if (!$25) HEAP32[$7 >> 2] = $9; else HEAP32[$25 + 8 >> 2] = $9;
     HEAP32[$6 >> 2] = $9;
     $30 = HEAP32[$0 >> 2] | 0;
     $31 = HEAP32[$8 >> 2] | 0;
     if (!$31) break L9;
     $34 = HEAP32[$31 + 16 >> 2] | 0;
     if (!($34 & 1)) {
      if (!($34 & 16)) HEAP32[$30 + 16 >> 2] = 0;
     } else {
      HEAP32[$30 + 8 >> 2] = 0;
      if (!(HEAP32[$31 + 20 >> 2] | 0)) break L9;
     }
     $45 = HEAP32[$31 + 20 >> 2] | 0;
     if (!$45) break L9;
     if ((HEAP32[$19 >> 2] | 0) == 7) break L9;
     HEAP32[$30 + 72 >> 2] = $9;
     FUNCTION_TABLE_viii[$45 & 63]($doc, $9, 1);
     break L9;
    }
   } while (0);
   _prvTidyReportError($doc, $field, $9, 208);
   _prvTidyFreeNode($doc, $9);
  } while (0);
  $9 = _prvTidyGetToken($doc, 0) | 0;
  if (!$9) {
   label = 24;
   break;
  }
 }
 if ((label | 0) == 24) return;
 _prvTidyFreeNode($doc, $$lcssa);
 HEAP32[$field + 56 >> 2] = 1;
 _TrimSpaces($doc, $field);
 return;
}

function _AddAnchor($doc, $name, $node) {
 $doc = $doc | 0;
 $name = $name | 0;
 $node = $node | 0;
 var $$02$i = 0, $$02$i2 = 0, $$lcssa = 0, $$lcssa13 = 0, $0 = 0, $1 = 0, $12 = 0, $13 = 0, $16 = 0, $18 = 0, $22 = 0, $25 = 0, $29 = 0, $33 = 0, $34 = 0, $36 = 0, $4 = 0, $6 = 0, $7 = 0, $h$0 = 0, $hashval$01$i = 0, $hashval$01$i3 = 0, $here$0 = 0, $here$0$lcssa = 0;
 $0 = $doc + 6856 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $4 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1 >> 2] >> 2] & 31]($1, 12) | 0;
 $6 = _prvTidytmbstrdup(HEAP32[$0 >> 2] | 0, $name) | 0;
 $7 = $4 + 8 | 0;
 HEAP32[$7 >> 2] = $6;
 HEAP32[$7 >> 2] = _prvTidytmbstrtolower($6) | 0;
 HEAP32[$4 + 4 >> 2] = $node;
 HEAP32[$4 >> 2] = 0;
 $12 = ($name | 0) == 0;
 if ((_prvTidyHTMLVersion($doc) | 0) == 131072) if ($12) $h$0 = 0; else {
  $13 = HEAP8[$name >> 0] | 0;
  if (!($13 << 24 >> 24)) $h$0 = 0; else {
   $$02$i = $name;
   $16 = $13;
   $hashval$01$i = 0;
   while (1) {
    $18 = ($hashval$01$i * 31 | 0) + ($16 << 24 >> 24) | 0;
    $$02$i = $$02$i + 1 | 0;
    $16 = HEAP8[$$02$i >> 0] | 0;
    if (!($16 << 24 >> 24)) {
     $$lcssa = $18;
     break;
    } else $hashval$01$i = $18;
   }
   $h$0 = ($$lcssa >>> 0) % 1021 | 0;
  }
 } else if ($12) $h$0 = 0; else {
  $22 = HEAP8[$name >> 0] | 0;
  if (!($22 << 24 >> 24)) $h$0 = 0; else {
   $$02$i2 = $name;
   $25 = $22;
   $hashval$01$i3 = 0;
   while (1) {
    $29 = ((_prvTidyToLower($25 << 24 >> 24) | 0) << 24 >> 24) + ($hashval$01$i3 * 31 | 0) | 0;
    $$02$i2 = $$02$i2 + 1 | 0;
    $25 = HEAP8[$$02$i2 >> 0] | 0;
    if (!($25 << 24 >> 24)) {
     $$lcssa13 = $29;
     break;
    } else $hashval$01$i3 = $29;
   }
   $h$0 = ($$lcssa13 >>> 0) % 1021 | 0;
  }
 }
 $33 = $doc + 1596 + ($h$0 << 2) | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 if (!$34) {
  HEAP32[$33 >> 2] = $4;
  return;
 } else $here$0 = $34;
 while (1) {
  $36 = HEAP32[$here$0 >> 2] | 0;
  if (!$36) {
   $here$0$lcssa = $here$0;
   break;
  } else $here$0 = $36;
 }
 HEAP32[$here$0$lcssa >> 2] = $4;
 return;
}

function _prvTidytmbsubstr($s1, $s2) {
 $s1 = $s1 | 0;
 $s2 = $s2 | 0;
 var $$0 = 0, $$01$i = 0, $$01$i4 = 0, $$01$lcssa$i = 0, $$019$i = 0, $$028$i = 0, $$037$i = 0, $11 = 0, $14 = 0, $18 = 0, $19 = 0, $21 = 0, $26 = 0, $31 = 0, $34 = 0, $4 = 0, $ix$012 = 0, $len$02$i = 0, $len$02$i3 = 0, $len$1$i = 0, $len$1$i6 = 0, label = 0;
 if (!$s1) $len$1$i = 0; else if (!(HEAP8[$s1 >> 0] | 0)) $len$1$i = 0; else {
  $$01$i = $s1;
  $len$02$i = 0;
  while (1) {
   $$01$i = $$01$i + 1 | 0;
   $4 = $len$02$i + 1 | 0;
   if (!(HEAP8[$$01$i >> 0] | 0)) {
    $len$1$i = $4;
    break;
   } else $len$02$i = $4;
  }
 }
 if (!$s2) $len$1$i6 = 0; else if (!(HEAP8[$s2 >> 0] | 0)) $len$1$i6 = 0; else {
  $$01$i4 = $s2;
  $len$02$i3 = 0;
  while (1) {
   $$01$i4 = $$01$i4 + 1 | 0;
   $11 = $len$02$i3 + 1 | 0;
   if (!(HEAP8[$$01$i4 >> 0] | 0)) {
    $len$1$i6 = $11;
    break;
   } else $len$02$i3 = $11;
  }
 }
 $14 = $len$1$i - $len$1$i6 | 0;
 if (($14 | 0) < 0) {
  $$0 = 0;
  return $$0 | 0;
 } else $ix$012 = 0;
 L13 : while (1) {
  $18 = $s1 + $ix$012 | 0;
  $19 = HEAP8[$18 >> 0] | 0;
  $21 = _prvTidyToLower($19 << 24 >> 24) | 0;
  if (($21 | 0) == (_prvTidyToLower(HEAP8[$s2 >> 0] | 0) | 0)) {
   $$019$i = $len$1$i6;
   $$028$i = $s2;
   $$037$i = $18;
   $26 = $19;
   while (1) {
    if ($26 << 24 >> 24 == 0 | ($$019$i | 0) == 0) {
     $$0 = $18;
     label = 13;
     break L13;
    }
    $$037$i = $$037$i + 1 | 0;
    $$028$i = $$028$i + 1 | 0;
    $31 = $$019$i + -1 | 0;
    $26 = HEAP8[$$037$i >> 0] | 0;
    $34 = _prvTidyToLower($26 << 24 >> 24) | 0;
    if (($34 | 0) != (_prvTidyToLower(HEAP8[$$028$i >> 0] | 0) | 0)) {
     $$01$lcssa$i = $31;
     break;
    } else $$019$i = $31;
   }
  } else $$01$lcssa$i = $len$1$i6;
  if (!$$01$lcssa$i) {
   $$0 = $18;
   label = 13;
   break;
  }
  if (($ix$012 | 0) < ($14 | 0)) $ix$012 = $ix$012 + 1 | 0; else {
   $$0 = 0;
   label = 13;
   break;
  }
 }
 if ((label | 0) == 13) return $$0 | 0;
 return 0;
}

function _prvTidyDocParseStream($doc, $in) {
 $doc = $doc | 0;
 $in = $in | 0;
 var $1 = 0, $11 = 0, $15 = 0, $23 = 0, $30 = 0, $38 = 0, $4 = 0, $50 = 0, $7 = 0, $8 = 0, dest = 0, stop = 0;
 $1 = HEAP32[$doc + 168 >> 2] | 0;
 if (!(($doc | 0) != 0 & ($in | 0) != 0)) ___assert_fail(226577, 226435, 1217, 226603);
 $4 = $doc + 6776 | 0;
 if (HEAP32[$4 >> 2] | 0) ___assert_fail(226416, 226435, 1218, 226603);
 HEAP32[$4 >> 2] = $in;
 _prvTidyResetTags($doc);
 _prvTidyTakeConfigSnapshot($doc);
 _prvTidyFreeAnchors($doc);
 _prvTidyFreeNode($doc, $doc);
 dest = $doc;
 stop = dest + 68 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 $7 = $doc + 6872 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 if ($8 | 0) {
  $11 = HEAP32[$doc + 6856 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$11 >> 2] | 0) + 8 >> 2] & 15]($11, $8);
 }
 _prvTidyFreeLexer($doc);
 HEAP32[$7 >> 2] = 0;
 $15 = _prvTidyNewLexer($doc) | 0;
 HEAP32[$doc + 68 >> 2] = $15;
 HEAP32[$doc + 48 >> 2] = HEAP32[$15 >> 2];
 HEAP32[$doc + 52 >> 2] = HEAP32[$15 + 4 >> 2];
 HEAP32[$doc + 6868 >> 2] = 0;
 $23 = _prvTidyReadBOMEncoding($in) | 0;
 if (($23 | 0) != -1) {
  HEAP32[$in + 296 >> 2] = $23;
  _prvTidySetOptionInt($doc, 5, $23) | 0;
 }
 if (!$1) {
  HEAP32[$doc + 6816 >> 2] = 0;
  _prvTidyParseDocument($doc);
  if (!(_prvTidyCheckNodeIntegrity($doc) | 0)) {
   $38 = HEAP32[$doc + 6856 >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$38 >> 2] | 0) + 12 >> 2] & 15]($38, 226625);
  }
 } else {
  _prvTidyParseXMLDocument($doc);
  if (!(_prvTidyCheckNodeIntegrity($doc) | 0)) {
   $30 = HEAP32[$doc + 6856 >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$30 >> 2] | 0) + 12 >> 2] & 15]($30, 226625);
  }
 }
 HEAP32[$4 >> 2] = 0;
 if (HEAP32[$doc + 6812 >> 2] | 0) {
  $50 = 2;
  return $50 | 0;
 }
 if (HEAP32[$doc + 6816 >> 2] | 0) {
  $50 = 1;
  return $50 | 0;
 }
 $50 = (HEAP32[$doc + 6820 >> 2] | 0) != 0 & 1;
 return $50 | 0;
}

function _CheckClear($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $$ph = 0, $$pre = 0, $1 = 0, $14 = 0, $19 = 0, $27 = 0, $28 = 0, $30 = 0, $8 = 0, $p$01$i = 0, $v$01$i = 0, $v$01$i$ph = 0, label = 0;
 $$pre = $attval + 24 | 0;
 if ($attval | 0) {
  $1 = HEAP32[$$pre >> 2] | 0;
  if ($1 | 0) {
   $8 = HEAP8[$1 >> 0] | 0;
   L4 : do if (!($8 << 24 >> 24)) {
    $$ph = 304891;
    $v$01$i$ph = 58532;
    label = 12;
   } else {
    $14 = $8;
    $p$01$i = $1;
    while (1) {
     $p$01$i = $p$01$i + 1 | 0;
     if (_prvTidyIsUpper($14 << 24 >> 24) | 0) break;
     $14 = HEAP8[$p$01$i >> 0] | 0;
     if (!($14 << 24 >> 24)) {
      $$ph = 304891;
      $v$01$i$ph = 58532;
      label = 12;
      break L4;
     }
    }
    $19 = (HEAP32[$doc + 68 >> 2] | 0) + 28 | 0;
    if (!(HEAP32[$19 >> 2] | 0)) label = 10; else {
     _prvTidyReportAttrError($doc, $node, $attval, 269);
     if (!(HEAP32[$19 >> 2] | 0)) label = 10;
    }
    if ((label | 0) == 10) if (!(HEAP32[$doc + 336 >> 2] | 0)) {
     $$ph = 304891;
     $v$01$i$ph = 58532;
     label = 12;
     break;
    }
    $27 = _prvTidytmbstrtolower(HEAP32[$$pre >> 2] | 0) | 0;
    HEAP32[$$pre >> 2] = $27;
    $28 = $27;
    $30 = 304891;
    $v$01$i = 58532;
   } while (0);
   while (1) {
    if ((label | 0) == 12) {
     label = 0;
     $28 = HEAP32[$$pre >> 2] | 0;
     $30 = $$ph;
     $v$01$i = $v$01$i$ph;
    }
    if ($28 | 0) if (!(_prvTidytmbstrcasecmp($28, $30) | 0)) {
     label = 17;
     break;
    }
    $v$01$i$ph = $v$01$i + 4 | 0;
    $$ph = HEAP32[$v$01$i$ph >> 2] | 0;
    if (!$$ph) break; else label = 12;
   }
   if ((label | 0) == 17) return;
   _prvTidyReportAttrError($doc, $node, $attval, 251);
   return;
  }
 }
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 if (HEAP32[$$pre >> 2] | 0) return;
 HEAP32[$$pre >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, 304891) | 0;
 return;
}

function _prvTidyBumpObject($doc, $html) {
 $doc = $doc | 0;
 $html = $html | 0;
 var $14 = 0, $16 = 0, $20 = 0, $34 = 0, $4 = 0, $6 = 0, $body$011 = 0, $body$1 = 0, $body$1$lcssa = 0, $child$05 = 0, $child$06 = 0, $head$010 = 0, $head$14 = 0, $head$14$lcssa = 0, $node$012 = 0, $node$09 = 0, $node$17 = 0, $node$17$looptemp = 0;
 if (!$html) return;
 $node$09 = HEAP32[$html + 12 >> 2] | 0;
 if (!$node$09) return; else {
  $body$011 = 0;
  $head$010 = 0;
  $node$012 = $node$09;
 }
 while (1) {
  $4 = HEAP32[$node$012 + 28 >> 2] | 0;
  if (!$4) {
   $body$1 = $body$011;
   $head$14 = $head$010;
  } else {
   $6 = HEAP32[$4 >> 2] | 0;
   $body$1 = ($6 | 0) == 16 ? $node$012 : $body$011;
   $head$14 = ($6 | 0) == 46 ? $node$012 : $head$010;
  }
  $node$012 = HEAP32[$node$012 + 8 >> 2] | 0;
  if (!$node$012) {
   $body$1$lcssa = $body$1;
   $head$14$lcssa = $head$14;
   break;
  } else {
   $body$011 = $body$1;
   $head$010 = $head$14;
  }
 }
 if (!(($head$14$lcssa | 0) != 0 & ($body$1$lcssa | 0) != 0)) return;
 $14 = HEAP32[$head$14$lcssa + 12 >> 2] | 0;
 if (!$14) return;
 $16 = $doc + 68 | 0;
 $node$17 = $14;
 do {
  $node$17$looptemp = $node$17;
  $node$17 = HEAP32[$node$17 + 8 >> 2] | 0;
  $20 = HEAP32[$node$17$looptemp + 28 >> 2] | 0;
  L20 : do if ($20 | 0) if ((HEAP32[$20 >> 2] | 0) == 76) {
   $child$05 = HEAP32[$node$17$looptemp + 12 >> 2] | 0;
   if ($child$05 | 0) {
    $child$06 = $child$05;
    while (1) {
     if (_prvTidynodeIsText($child$06) | 0) if (!(_prvTidyIsBlank(HEAP32[$16 >> 2] | 0, $node$17$looptemp) | 0)) break;
     $34 = HEAP32[$child$06 + 28 >> 2] | 0;
     if (!$34) break;
     if ((HEAP32[$34 >> 2] | 0) != 81) break;
     $child$06 = HEAP32[$child$06 + 8 >> 2] | 0;
     if (!$child$06) break L20;
    }
    _prvTidyRemoveNode($node$17$looptemp) | 0;
    _prvTidyInsertNodeAtStart($body$1$lcssa, $node$17$looptemp);
   }
  } while (0);
 } while (($node$17 | 0) != 0);
 return;
}

function ___stpcpy($d, $s) {
 $d = $d | 0;
 $s = $s | 0;
 var $$0$lcssa = 0, $$01$lcssa = 0, $$0115 = 0, $$016 = 0, $$03 = 0, $$1$ph = 0, $$12$ph = 0, $$128 = 0, $$19 = 0, $0 = 0, $10 = 0, $14 = 0, $20 = 0, $21 = 0, $22 = 0, $29 = 0, $32 = 0, $33 = 0, $7 = 0, $9 = 0, $wd$0$lcssa = 0, $wd$010 = 0, $ws$0$lcssa = 0, $ws$011 = 0, label = 0;
 $0 = $s;
 L1 : do if (!(($0 ^ $d) & 3)) {
  if (!($0 & 3)) {
   $$0$lcssa = $s;
   $$01$lcssa = $d;
  } else {
   $$0115 = $d;
   $$016 = $s;
   while (1) {
    $7 = HEAP8[$$016 >> 0] | 0;
    HEAP8[$$0115 >> 0] = $7;
    if (!($7 << 24 >> 24)) {
     $$03 = $$0115;
     break L1;
    }
    $9 = $$016 + 1 | 0;
    $10 = $$0115 + 1 | 0;
    if (!($9 & 3)) {
     $$0$lcssa = $9;
     $$01$lcssa = $10;
     break;
    } else {
     $$0115 = $10;
     $$016 = $9;
    }
   }
  }
  $14 = HEAP32[$$0$lcssa >> 2] | 0;
  if (!(($14 & -2139062144 ^ -2139062144) & $14 + -16843009)) {
   $22 = $14;
   $wd$010 = $$01$lcssa;
   $ws$011 = $$0$lcssa;
   while (1) {
    $20 = $ws$011 + 4 | 0;
    $21 = $wd$010 + 4 | 0;
    HEAP32[$wd$010 >> 2] = $22;
    $22 = HEAP32[$20 >> 2] | 0;
    if (($22 & -2139062144 ^ -2139062144) & $22 + -16843009 | 0) {
     $wd$0$lcssa = $21;
     $ws$0$lcssa = $20;
     break;
    } else {
     $wd$010 = $21;
     $ws$011 = $20;
    }
   }
  } else {
   $wd$0$lcssa = $$01$lcssa;
   $ws$0$lcssa = $$0$lcssa;
  }
  $$1$ph = $ws$0$lcssa;
  $$12$ph = $wd$0$lcssa;
  label = 8;
 } else {
  $$1$ph = $s;
  $$12$ph = $d;
  label = 8;
 } while (0);
 if ((label | 0) == 8) {
  $29 = HEAP8[$$1$ph >> 0] | 0;
  HEAP8[$$12$ph >> 0] = $29;
  if (!($29 << 24 >> 24)) $$03 = $$12$ph; else {
   $$128 = $$12$ph;
   $$19 = $$1$ph;
   while (1) {
    $$19 = $$19 + 1 | 0;
    $32 = $$128 + 1 | 0;
    $33 = HEAP8[$$19 >> 0] | 0;
    HEAP8[$32 >> 0] = $33;
    if (!($33 << 24 >> 24)) {
     $$03 = $32;
     break;
    } else $$128 = $32;
   }
  }
 }
 return $$03 | 0;
}

function _prvTidyReadBOMEncoding($in) {
 $in = $in | 0;
 var $$1 = 0, $0 = 0, $2 = 0, $27 = 0, $29 = 0, $4 = 0, $46 = 0, $8 = 0;
 $0 = $in + 308 | 0;
 $2 = $in + 304 | 0;
 $4 = FUNCTION_TABLE_ii[HEAP32[$0 >> 2] & 31](HEAP32[$2 >> 2] | 0) | 0;
 if (($4 | 0) == -1) {
  $$1 = -1;
  return $$1 | 0;
 }
 $8 = FUNCTION_TABLE_ii[HEAP32[$0 >> 2] & 31](HEAP32[$2 >> 2] | 0) | 0;
 if (($8 | 0) == -1) {
  FUNCTION_TABLE_vii[HEAP32[$in + 312 >> 2] & 15](HEAP32[$2 >> 2] | 0, $4 & 255);
  $$1 = -1;
  return $$1 | 0;
 }
 switch ($8 + ($4 << 8) | 0) {
 case 65279:
  {
   if ((HEAP32[$in + 296 >> 2] & -2 | 0) == 10) {
    $$1 = 10;
    return $$1 | 0;
   }
   _prvTidyReportEncodingWarning(HEAP32[$in + 320 >> 2] | 0, 295, 10);
   $$1 = 10;
   return $$1 | 0;
  }
 case 65534:
  {
   switch (HEAP32[$in + 296 >> 2] | 0) {
   case 9:
   case 11:
    {
     $$1 = 9;
     return $$1 | 0;
    }
   default:
    {}
   }
   _prvTidyReportEncodingWarning(HEAP32[$in + 320 >> 2] | 0, 295, 9);
   $$1 = 9;
   return $$1 | 0;
  }
 default:
  {
   $27 = FUNCTION_TABLE_ii[HEAP32[$0 >> 2] & 31](HEAP32[$2 >> 2] | 0) | 0;
   if (($27 | 0) == -1) {
    $29 = $in + 312 | 0;
    FUNCTION_TABLE_vii[HEAP32[$29 >> 2] & 15](HEAP32[$2 >> 2] | 0, $8 & 255);
    FUNCTION_TABLE_vii[HEAP32[$29 >> 2] & 15](HEAP32[$2 >> 2] | 0, $4 & 255);
    $$1 = -1;
    return $$1 | 0;
   }
   if ((($8 << 8) + ($4 << 16) + $27 | 0) != 15711167) {
    $46 = $in + 312 | 0;
    FUNCTION_TABLE_vii[HEAP32[$46 >> 2] & 15](HEAP32[$2 >> 2] | 0, $27 & 255);
    FUNCTION_TABLE_vii[HEAP32[$46 >> 2] & 15](HEAP32[$2 >> 2] | 0, $8 & 255);
    FUNCTION_TABLE_vii[HEAP32[$46 >> 2] & 15](HEAP32[$2 >> 2] | 0, $4 & 255);
    $$1 = -1;
    return $$1 | 0;
   }
   if ((HEAP32[$in + 296 >> 2] | 0) == 4) {
    $$1 = 4;
    return $$1 | 0;
   }
   _prvTidyReportEncodingWarning(HEAP32[$in + 320 >> 2] | 0, 295, 4);
   $$1 = 4;
   return $$1 | 0;
  }
 }
 return 0;
}

function _TrimInitialSpace($doc$0$1$val, $element, $text) {
 $doc$0$1$val = $doc$0$1$val | 0;
 $element = $element | 0;
 $text = $text | 0;
 var $18 = 0, $19 = 0, $2 = 0, $22 = 0, $23 = 0, $26 = 0, $3 = 0, $32 = 0, $33 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $47 = 0, $50 = 0, $51 = 0, $54 = 0, label = 0;
 if (!(_prvTidynodeIsText($text) | 0)) return;
 $2 = $text + 36 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = $doc$0$1$val + 84 | 0;
 if ((HEAP8[(HEAP32[$4 >> 2] | 0) + $3 >> 0] | 0) != 32) return;
 if ($3 >>> 0 >= (HEAP32[$text + 40 >> 2] | 0) >>> 0) return;
 do if ((HEAP32[(HEAP32[$element + 28 >> 2] | 0) + 16 >> 2] & 1040 | 0) == 16) {
  $18 = $element + 4 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  if (!(_prvTidynodeIsText($19) | 0)) {
   $38 = _prvTidyNewNode(HEAP32[$doc$0$1$val + 124 >> 2] | 0, $doc$0$1$val) | 0;
   $39 = $element + 36 | 0;
   $40 = HEAP32[$39 >> 2] | 0;
   HEAP32[$39 >> 2] = $40 + 1;
   HEAP32[$38 + 36 >> 2] = $40;
   HEAP32[$38 + 40 >> 2] = HEAP32[$39 >> 2];
   HEAP8[(HEAP32[$4 >> 2] | 0) + $40 >> 0] = 32;
   $47 = HEAP32[$element >> 2] | 0;
   HEAP32[$38 >> 2] = $47;
   HEAP32[$38 + 8 >> 2] = $element;
   $50 = $38 + 4 | 0;
   HEAP32[$50 >> 2] = HEAP32[$18 >> 2];
   HEAP32[$18 >> 2] = $38;
   $51 = HEAP32[$50 >> 2] | 0;
   if ($51 | 0) HEAP32[$51 + 8 >> 2] = $38;
   $54 = $47 + 12 | 0;
   if ((HEAP32[$54 >> 2] | 0) != ($element | 0)) break;
   HEAP32[$54 >> 2] = $38;
   break;
  }
  $22 = $19 + 40 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  if (!$23) {
   $32 = HEAP32[$4 >> 2] | 0;
   label = 9;
  } else {
   $26 = HEAP32[$4 >> 2] | 0;
   if ((HEAP8[$26 + ($23 + -1) >> 0] | 0) != 32) {
    $32 = $26;
    label = 9;
   }
  }
  if ((label | 0) == 9) {
   HEAP32[$22 >> 2] = $23 + 1;
   HEAP8[$32 + $23 >> 0] = 32;
  }
  $33 = $element + 36 | 0;
  HEAP32[$33 >> 2] = (HEAP32[$33 >> 2] | 0) + 1;
 } while (0);
 HEAP32[$2 >> 2] = (HEAP32[$2 >> 2] | 0) + 1;
 return;
}

function _prvTidyParseDatalist($doc, $field, $mode) {
 $doc = $doc | 0;
 $field = $field | 0;
 $mode = $mode | 0;
 var $$lcssa = 0, $0 = 0, $22 = 0, $25 = 0, $3 = 0, $30 = 0, $32 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $0 = $doc + 68 | 0;
 HEAP32[(HEAP32[$0 >> 2] | 0) + 100 >> 2] = 0;
 $3 = _prvTidyGetToken($doc, 0) | 0;
 L1 : do if ($3 | 0) {
  $5 = $field + 28 | 0;
  $6 = $field + 16 | 0;
  $7 = $field + 12 | 0;
  $9 = $3;
  while (1) {
   $8 = $9 + 28 | 0;
   if ((HEAP32[$8 >> 2] | 0) == (HEAP32[$5 >> 2] | 0)) if ((HEAP32[$9 + 44 >> 2] | 0) == 6) {
    $$lcssa = $9;
    break;
   }
   L8 : do if (!(_InsertMisc($field, $9) | 0)) {
    L10 : do if ((HEAP32[$9 + 44 >> 2] | 0) == 5) {
     $22 = HEAP32[$8 >> 2] | 0;
     if ($22 | 0) {
      switch (HEAP32[$22 >> 2] | 0) {
      case 94:
      case 129:
      case 78:
      case 79:
       break;
      default:
       break L10;
      }
      HEAP32[$9 >> 2] = $field;
      $25 = HEAP32[$6 >> 2] | 0;
      HEAP32[$9 + 4 >> 2] = $25;
      if (!$25) HEAP32[$7 >> 2] = $9; else HEAP32[$25 + 8 >> 2] = $9;
      HEAP32[$6 >> 2] = $9;
      $30 = HEAP32[$0 >> 2] | 0;
      $32 = HEAP32[$22 + 16 >> 2] | 0;
      if (!($32 & 1)) {
       if (!($32 & 16)) HEAP32[$30 + 16 >> 2] = 0;
      } else {
       HEAP32[$30 + 8 >> 2] = 0;
       if (!(HEAP32[$22 + 20 >> 2] | 0)) break L8;
      }
      $43 = HEAP32[$22 + 20 >> 2] | 0;
      if (!$43) break L8;
      HEAP32[$30 + 72 >> 2] = $9;
      FUNCTION_TABLE_viii[$43 & 63]($doc, $9, 0);
      break L8;
     }
    } while (0);
    _prvTidyReportError($doc, $field, $9, 208);
    _prvTidyFreeNode($doc, $9);
   } while (0);
   $9 = _prvTidyGetToken($doc, 0) | 0;
   if (!$9) break L1;
  }
  _prvTidyFreeNode($doc, $$lcssa);
  HEAP32[$field + 56 >> 2] = 1;
  _TrimSpaces($doc, $field);
  return;
 } while (0);
 _prvTidyReportError($doc, $field, 0, 206);
 return;
}

function _prvTidyParseSelect($doc, $field, $mode) {
 $doc = $doc | 0;
 $field = $field | 0;
 $mode = $mode | 0;
 var $$lcssa = 0, $0 = 0, $22 = 0, $25 = 0, $3 = 0, $30 = 0, $32 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $0 = $doc + 68 | 0;
 HEAP32[(HEAP32[$0 >> 2] | 0) + 100 >> 2] = 0;
 $3 = _prvTidyGetToken($doc, 0) | 0;
 L1 : do if ($3 | 0) {
  $5 = $field + 28 | 0;
  $6 = $field + 16 | 0;
  $7 = $field + 12 | 0;
  $9 = $3;
  while (1) {
   $8 = $9 + 28 | 0;
   if ((HEAP32[$8 >> 2] | 0) == (HEAP32[$5 >> 2] | 0)) if ((HEAP32[$9 + 44 >> 2] | 0) == 6) {
    $$lcssa = $9;
    break;
   }
   L8 : do if (!(_InsertMisc($field, $9) | 0)) {
    L10 : do if ((HEAP32[$9 + 44 >> 2] | 0) == 5) {
     $22 = HEAP32[$8 >> 2] | 0;
     if ($22 | 0) {
      switch (HEAP32[$22 >> 2] | 0) {
      case 94:
      case 129:
      case 78:
      case 79:
       break;
      default:
       break L10;
      }
      HEAP32[$9 >> 2] = $field;
      $25 = HEAP32[$6 >> 2] | 0;
      HEAP32[$9 + 4 >> 2] = $25;
      if (!$25) HEAP32[$7 >> 2] = $9; else HEAP32[$25 + 8 >> 2] = $9;
      HEAP32[$6 >> 2] = $9;
      $30 = HEAP32[$0 >> 2] | 0;
      $32 = HEAP32[$22 + 16 >> 2] | 0;
      if (!($32 & 1)) {
       if (!($32 & 16)) HEAP32[$30 + 16 >> 2] = 0;
      } else {
       HEAP32[$30 + 8 >> 2] = 0;
       if (!(HEAP32[$22 + 20 >> 2] | 0)) break L8;
      }
      $43 = HEAP32[$22 + 20 >> 2] | 0;
      if (!$43) break L8;
      HEAP32[$30 + 72 >> 2] = $9;
      FUNCTION_TABLE_viii[$43 & 63]($doc, $9, 0);
      break L8;
     }
    } while (0);
    _prvTidyReportError($doc, $field, $9, 208);
    _prvTidyFreeNode($doc, $9);
   } while (0);
   $9 = _prvTidyGetToken($doc, 0) | 0;
   if (!$9) break L1;
  }
  _prvTidyFreeNode($doc, $$lcssa);
  HEAP32[$field + 56 >> 2] = 1;
  _TrimSpaces($doc, $field);
  return;
 } while (0);
 _prvTidyReportError($doc, $field, 0, 206);
 return;
}

function _FindStyle($doc, $tag, $properties) {
 $doc = $doc | 0;
 $tag = $tag | 0;
 $properties = $properties | 0;
 var $$0 = 0, $$0$in = 0, $14 = 0, $15 = 0, $18 = 0, $2 = 0, $22 = 0, $26 = 0, $28 = 0, $31 = 0, $buf$i = 0, $pfx$0$i = 0, $style$02 = 0, $style$03 = 0, $style$03$lcssa = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 528 | 0;
 $vararg_buffer = sp;
 $buf$i = sp + 8 | 0;
 $2 = (HEAP32[$doc + 68 >> 2] | 0) + 120 | 0;
 $style$02 = HEAP32[$2 >> 2] | 0;
 L1 : do if ($style$02 | 0) {
  $style$03 = $style$02;
  while (1) {
   if (!(_prvTidytmbstrcmp(HEAP32[$style$03 >> 2] | 0, $tag) | 0)) if (!(_prvTidytmbstrcmp(HEAP32[$style$03 + 8 >> 2] | 0, $properties) | 0)) {
    $style$03$lcssa = $style$03;
    break;
   }
   $style$03 = HEAP32[$style$03 + 12 >> 2] | 0;
   if (!$style$03) break L1;
  }
  $$0$in = $style$03$lcssa + 4 | 0;
  $$0 = HEAP32[$$0$in >> 2] | 0;
  STACKTOP = sp;
  return $$0 | 0;
 } while (0);
 $14 = $doc + 6856 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $18 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$15 >> 2] >> 2] & 31]($15, 16) | 0;
 HEAP32[$18 >> 2] = _prvTidytmbstrdup(HEAP32[$14 >> 2] | 0, $tag) | 0;
 $22 = HEAP32[$doc + 388 >> 2] | 0;
 if (!$22) label = 8; else if (!(HEAP8[$22 >> 0] | 0)) label = 8; else $pfx$0$i = $22;
 if ((label | 0) == 8) $pfx$0$i = 310938;
 $26 = $doc + 6864 | 0;
 $28 = (HEAP32[$26 >> 2] | 0) + 1 | 0;
 HEAP32[$26 >> 2] = $28;
 HEAP32[$vararg_buffer >> 2] = $pfx$0$i;
 HEAP32[$vararg_buffer + 4 >> 2] = $28;
 _prvTidytmbsnprintf($buf$i, 512, 310940, $vararg_buffer) | 0;
 $31 = $18 + 4 | 0;
 HEAP32[$31 >> 2] = _prvTidytmbstrdup(HEAP32[$14 >> 2] | 0, $buf$i) | 0;
 HEAP32[$18 + 8 >> 2] = _prvTidytmbstrdup(HEAP32[$14 >> 2] | 0, $properties) | 0;
 HEAP32[$18 + 12 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$2 >> 2] = $18;
 $$0$in = $31;
 $$0 = HEAP32[$$0$in >> 2] | 0;
 STACKTOP = sp;
 return $$0 | 0;
}

function _prvTidyAddCharToLexer($lexer, $c) {
 $lexer = $lexer | 0;
 $c = $c | 0;
 var $$$i = 0, $$$i$lcssa = 0, $$pre$i = 0, $10 = 0, $11 = 0, $16 = 0, $21 = 0, $23 = 0, $26 = 0, $4 = 0, $5 = 0, $6 = 0, $8 = 0, $allocAmt$01$i = 0, $buf = 0, $count = 0, $i$01 = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $count = sp;
 $buf = sp + 4 | 0;
 HEAP32[$count >> 2] = 0;
 dest = $buf;
 stop = dest + 10 | 0;
 do {
  HEAP8[dest >> 0] = 0;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 if (!(_prvTidyEncodeCharToUTF8Bytes($c, $buf, 0, $count) | 0)) {
  if ((HEAP32[$count >> 2] | 0) <= 0) {
   STACKTOP = sp;
   return;
  }
 } else {
  HEAP8[$buf >> 0] = -17;
  HEAP8[$buf + 1 >> 0] = -65;
  HEAP8[$buf + 2 >> 0] = -67;
  HEAP32[$count >> 2] = 3;
 }
 $4 = $lexer + 92 | 0;
 $5 = $lexer + 88 | 0;
 $$pre$i = $lexer + 84 | 0;
 $6 = $lexer + 124 | 0;
 $i$01 = 0;
 do {
  $8 = HEAP8[$buf + $i$01 >> 0] | 0;
  $10 = (HEAP32[$4 >> 2] | 0) + 2 | 0;
  $11 = HEAP32[$5 >> 2] | 0;
  if ($10 >>> 0 >= $11 >>> 0) {
   $allocAmt$01$i = $11;
   while (1) {
    $$$i = ($allocAmt$01$i | 0) == 0 ? 8192 : $allocAmt$01$i << 1;
    if ($10 >>> 0 < $$$i >>> 0) {
     $$$i$lcssa = $$$i;
     break;
    } else $allocAmt$01$i = $$$i;
   }
   $16 = HEAP32[$6 >> 2] | 0;
   $21 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$16 >> 2] | 0) + 4 >> 2] & 15]($16, HEAP32[$$pre$i >> 2] | 0, $$$i$lcssa) | 0;
   if ($21 | 0) {
    $23 = HEAP32[$5 >> 2] | 0;
    _memset($21 + $23 | 0, 0, $$$i$lcssa - $23 | 0) | 0;
    HEAP32[$$pre$i >> 2] = $21;
    HEAP32[$5 >> 2] = $$$i$lcssa;
   }
  }
  $26 = HEAP32[$4 >> 2] | 0;
  HEAP32[$4 >> 2] = $26 + 1;
  HEAP8[(HEAP32[$$pre$i >> 2] | 0) + $26 >> 0] = $8;
  HEAP8[(HEAP32[$$pre$i >> 2] | 0) + (HEAP32[$4 >> 2] | 0) >> 0] = 0;
  $i$01 = $i$01 + 1 | 0;
 } while (($i$01 | 0) < (HEAP32[$count >> 2] | 0));
 STACKTOP = sp;
 return;
}
function _prvTidyWarnMissingSIInEmittedDocType($doc) {
 $doc = $doc | 0;
 var $$0 = 0, $1 = 0, $6 = 0, $8 = 0, $node$01$i = 0, $node$01$i$lcssa = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 L1 : do if (!(HEAP32[$1 + 28 >> 2] | 0)) {
  $6 = HEAP32[$1 + 40 >> 2] | 0;
  L3 : do if (($6 | 0) < 128) switch ($6 | 0) {
  case 64:
  case 32:
  case 16:
  case 8:
  case 4:
  case 2:
  case 1:
   break;
  default:
   {
    $$0 = 0;
    break L1;
   }
  } else {
   if (($6 | 0) < 2048) switch ($6 | 0) {
   case 1024:
   case 512:
   case 256:
   case 128:
    {
     break L3;
     break;
    }
   default:
    {
     $$0 = 0;
     break L1;
    }
   }
   if (($6 | 0) < 131072) switch ($6 | 0) {
   case 4096:
   case 2048:
    {
     break L3;
     break;
    }
   default:
    {
     $$0 = 0;
     break L1;
    }
   }
   if (($6 | 0) < 262144) switch ($6 | 0) {
   case 131072:
    {
     break L3;
     break;
    }
   default:
    {
     $$0 = 0;
     break L1;
    }
   } else switch ($6 | 0) {
   case 262144:
    {
     break L3;
     break;
    }
   default:
    {
     $$0 = 0;
     break L1;
    }
   }
  } while (0);
  if (($6 + -1 | 0) >>> 0 < 2) $$0 = 0; else {
   switch ($6 | 0) {
   case 4096:
   case 2048:
   case 1024:
   case 512:
   case 256:
   case 128:
   case 64:
   case 32:
   case 16:
   case 8:
   case 4:
    break;
   default:
    {
     $$0 = 0;
     break L1;
    }
   }
   $8 = HEAP32[$doc + 12 >> 2] | 0;
   L18 : do if ($8 | 0) {
    $node$01$i = $8;
    while (1) {
     if ((HEAP32[$node$01$i + 44 >> 2] | 0) == 1) {
      $node$01$i$lcssa = $node$01$i;
      break;
     }
     $node$01$i = HEAP32[$node$01$i + 8 >> 2] | 0;
     if (!$node$01$i) break L18;
    }
    if (!(_prvTidyGetAttrByName($node$01$i$lcssa, 310777) | 0)) {
     $$0 = 1;
     break L1;
    }
   } while (0);
   $$0 = 0;
  }
 } else $$0 = 0; while (0);
 return $$0 | 0;
}

function _prvTidyFreeNode($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$01 = 0, $1 = 0, $12 = 0, $24 = 0, $29 = 0, $35 = 0, $4 = 0, $41 = 0, $43 = 0, $5 = 0, $52 = 0, $7 = 0, $8 = 0, $$01$looptemp = 0;
 if (!$node) return;
 $1 = $doc + 6856 | 0;
 $$01 = $node;
 do {
  $$01$looptemp = $$01;
  $$01 = HEAP32[$$01 + 8 >> 2] | 0;
  $4 = $$01$looptemp + 20 | 0;
  $5 = HEAP32[$4 >> 2] | 0;
  if ($5 | 0) {
   $8 = $5;
   do {
    $7 = $8 + 20 | 0;
    L10 : do if (HEAP32[$7 >> 2] | 0) {
     $12 = HEAP32[$8 + 4 >> 2] | 0;
     if ($12 | 0) {
      switch (HEAP32[$12 >> 2] | 0) {
      case 85:
      case 63:
       break;
      default:
       break L10;
      }
      if (_prvTidyIsAnchorElement($doc, $$01$looptemp) | 0) _prvTidyRemoveAnchorByNode($doc, HEAP32[$8 + 24 >> 2] | 0, $$01$looptemp);
     }
    } while (0);
    HEAP32[$4 >> 2] = HEAP32[$8 >> 2];
    _prvTidyFreeNode($doc, HEAP32[$8 + 8 >> 2] | 0);
    _prvTidyFreeNode($doc, HEAP32[$8 + 12 >> 2] | 0);
    $24 = HEAP32[$1 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$24 >> 2] | 0) + 8 >> 2] & 15]($24, HEAP32[$7 >> 2] | 0);
    $29 = HEAP32[$1 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$29 >> 2] | 0) + 8 >> 2] & 15]($29, HEAP32[$8 + 24 >> 2] | 0);
    $35 = HEAP32[$1 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$35 >> 2] | 0) + 8 >> 2] & 15]($35, $8);
    $8 = HEAP32[$4 >> 2] | 0;
   } while (($8 | 0) != 0);
  }
  $41 = $$01$looptemp + 12 | 0;
  _prvTidyFreeNode($doc, HEAP32[$41 >> 2] | 0);
  $43 = HEAP32[$1 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$43 >> 2] | 0) + 8 >> 2] & 15]($43, HEAP32[$$01$looptemp + 32 >> 2] | 0);
  if (!(HEAP32[$$01$looptemp + 44 >> 2] | 0)) HEAP32[$41 >> 2] = 0; else {
   $52 = HEAP32[$1 >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$52 >> 2] | 0) + 8 >> 2] & 15]($52, $$01$looptemp);
  }
 } while (($$01 | 0) != 0);
 return;
}

function _prvTidyNestedEmphasis($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0$be = 0, $$01 = 0, $1 = 0, $13 = 0, $14 = 0, $16 = 0, $18 = 0, $2 = 0, $20 = 0, $22 = 0, $25 = 0, $26 = 0, $38 = 0, $4 = 0, $6 = 0, $8 = 0, $node$01$i = 0, $node$02$i = 0, label = 0;
 if (!$node) return; else $$01 = $node;
 while (1) {
  $1 = $$01 + 8 | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  $4 = HEAP32[$$01 + 28 >> 2] | 0;
  $6 = $2;
  L5 : do if (!$4) label = 18; else {
   switch (HEAP32[$4 >> 2] | 0) {
   case 49:
   case 8:
    break;
   default:
    {
     label = 18;
     break L5;
    }
   }
   $8 = HEAP32[$$01 >> 2] | 0;
   if (!$8) label = 18; else if ((HEAP32[$8 + 28 >> 2] | 0) == ($4 | 0)) {
    $13 = $$01 + 12 | 0;
    $14 = HEAP32[$13 >> 2] | 0;
    $16 = $14;
    if (!$14) {
     $$0$be = _prvTidyDiscardElement($doc, $$01) | 0;
     break;
    }
    $18 = HEAP32[$$01 + 16 >> 2] | 0;
    HEAP32[$18 + 8 >> 2] = $6;
    $20 = HEAP32[$1 >> 2] | 0;
    $22 = $18;
    if (!$20) HEAP32[$8 + 16 >> 2] = $22; else HEAP32[$20 + 4 >> 2] = $22;
    $25 = $$01 + 4 | 0;
    $26 = HEAP32[$25 >> 2] | 0;
    if (!$26) HEAP32[$8 + 12 >> 2] = $16; else {
     HEAP32[$14 + 4 >> 2] = $26;
     HEAP32[(HEAP32[$25 >> 2] | 0) + 8 >> 2] = $16;
    }
    $node$01$i = HEAP32[$13 >> 2] | 0;
    if ($node$01$i | 0) {
     $node$02$i = $node$01$i;
     do {
      HEAP32[$node$02$i >> 2] = $8;
      $node$02$i = HEAP32[$node$02$i + 8 >> 2] | 0;
     } while (($node$02$i | 0) != 0);
    }
    HEAP32[$13 >> 2] = 0;
    HEAP32[$1 >> 2] = 0;
    _prvTidyFreeNode($doc, $$01);
    $$0$be = $node$01$i;
   } else label = 18;
  } while (0);
  if ((label | 0) == 18) {
   label = 0;
   $38 = HEAP32[$$01 + 12 >> 2] | 0;
   if (!$38) $$0$be = $2; else {
    _prvTidyNestedEmphasis($doc, $38);
    $$0$be = $2;
   }
  }
  if (!$$0$be) break; else $$01 = $$0$be;
 }
 return;
}

function _prvTidyAccessibilityChecks($doc) {
 $doc = $doc | 0;
 var $1 = 0, $10 = 0, $12 = 0, $13 = 0, $2 = 0, $23 = 0, $5 = 0, $7 = 0, $8 = 0, $doc$idx$i = 0, $i$02$i$i = 0, $x$01$i$i = 0, $x$1$i$i = 0;
 $1 = HEAP32[$doc + 408 >> 2] | 0;
 $2 = $doc + 6396 | 0;
 _memset($2 | 0, 0, 328) | 0;
 HEAP32[$2 >> 2] = $1;
 _prvTidyAccessibilityHelloMessage($doc);
 _CheckScriptKeyboardAccessible($doc, $doc);
 _CheckForStyleAttribute($doc, $doc);
 $doc$idx$i = $doc + 6396 | 0;
 do if ((HEAP32[$doc$idx$i >> 2] | 1 | 0) == 3) {
  $5 = _prvTidyFindDocType($doc) | 0;
  if ($5 | 0) {
   $7 = $5 + 40 | 0;
   $8 = HEAP32[$7 >> 2] | 0;
   if (!$8) break;
   $10 = $doc + 6532 | 0;
   $12 = HEAP32[$5 + 36 >> 2] | 0;
   $13 = $doc + 68 | 0;
   L6 : do if ($12 >>> 0 < $8 >>> 0) {
    $i$02$i$i = $12;
    $x$01$i$i = 0;
    while (1) {
     HEAP8[$doc + 6532 + $x$01$i$i >> 0] = HEAP8[(HEAP32[(HEAP32[$13 >> 2] | 0) + 84 >> 2] | 0) + $i$02$i$i >> 0] | 0;
     if ($x$01$i$i >>> 0 > 126) {
      $x$1$i$i = $x$01$i$i;
      break L6;
     }
     $i$02$i$i = $i$02$i$i + 1 | 0;
     $23 = $x$01$i$i + 1 | 0;
     if ($i$02$i$i >>> 0 >= (HEAP32[$7 >> 2] | 0) >>> 0) {
      $x$1$i$i = $23;
      break;
     } else $x$01$i$i = $23;
    }
   } else $x$1$i$i = 0; while (0);
   HEAP8[$doc + 6532 + $x$1$i$i >> 0] = 0;
   if (_strstr($10, 311695) | 0) break;
   if (_strstr($10, 311707) | 0) break;
  }
  _prvTidyReportAccessError($doc, $doc, 336);
 } while (0);
 if ((HEAP32[$doc$idx$i >> 2] | 1 | 0) != 3) {
  _CheckForListElements($doc, $doc);
  _AccessibilityCheckNode($doc, $doc);
  return;
 }
 if (_CheckMissingStyleSheets($doc) | 0) {
  _CheckForListElements($doc, $doc);
  _AccessibilityCheckNode($doc, $doc);
  return;
 }
 _prvTidyReportAccessWarning($doc, $doc, 337);
 _CheckForListElements($doc, $doc);
 _AccessibilityCheckNode($doc, $doc);
 return;
}

function _vfprintf($f, $fmt, $ap) {
 $f = $f | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 var $$ = 0, $$0 = 0, $12 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $21 = 0, $22 = 0, $28 = 0, $32 = 0, $6 = 0, $7 = 0, $ap2 = 0, $internal_buf = 0, $nl_arg = 0, $nl_type = 0, $ret$1 = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 $ap2 = sp + 120 | 0;
 $nl_type = sp + 80 | 0;
 $nl_arg = sp;
 $internal_buf = sp + 136 | 0;
 dest = $nl_type;
 stop = dest + 40 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 HEAP32[$ap2 >> 2] = HEAP32[$ap >> 2];
 if ((_printf_core(0, $fmt, $ap2, $nl_arg, $nl_type) | 0) < 0) $$0 = -1; else {
  if ((HEAP32[$f + 76 >> 2] | 0) > -1) $32 = ___lockfile($f) | 0; else $32 = 0;
  $6 = HEAP32[$f >> 2] | 0;
  $7 = $6 & 32;
  if ((HEAP8[$f + 74 >> 0] | 0) < 1) HEAP32[$f >> 2] = $6 & -33;
  $12 = $f + 48 | 0;
  if (!(HEAP32[$12 >> 2] | 0)) {
   $16 = $f + 44 | 0;
   $17 = HEAP32[$16 >> 2] | 0;
   HEAP32[$16 >> 2] = $internal_buf;
   $18 = $f + 28 | 0;
   HEAP32[$18 >> 2] = $internal_buf;
   $19 = $f + 20 | 0;
   HEAP32[$19 >> 2] = $internal_buf;
   HEAP32[$12 >> 2] = 80;
   $21 = $f + 16 | 0;
   HEAP32[$21 >> 2] = $internal_buf + 80;
   $22 = _printf_core($f, $fmt, $ap2, $nl_arg, $nl_type) | 0;
   if (!$17) $ret$1 = $22; else {
    FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 15]($f, 0, 0) | 0;
    $$ = (HEAP32[$19 >> 2] | 0) == 0 ? -1 : $22;
    HEAP32[$16 >> 2] = $17;
    HEAP32[$12 >> 2] = 0;
    HEAP32[$21 >> 2] = 0;
    HEAP32[$18 >> 2] = 0;
    HEAP32[$19 >> 2] = 0;
    $ret$1 = $$;
   }
  } else $ret$1 = _printf_core($f, $fmt, $ap2, $nl_arg, $nl_type) | 0;
  $28 = HEAP32[$f >> 2] | 0;
  HEAP32[$f >> 2] = $28 | $7;
  if ($32 | 0) ___unlockfile($f);
  $$0 = ($28 & 32 | 0) == 0 ? $ret$1 : -1;
 }
 STACKTOP = sp;
 return $$0 | 0;
}
function _prvTidyIsCSS1Selector($buf) {
 $buf = $buf | 0;
 var $$03 = 0, $$03$ph = 0, $$lcssa = 0, $$lcssa33 = 0, $$sink = 0, $0 = 0, $1 = 0, $3 = 0, $4 = 0, $5 = 0, $esclen$02 = 0, $esclen$02$lcssa = 0, $esclen$02$ph = 0, $esclen$1 = 0, $esclen$2 = 0, $pos$04 = 0, $pos$04$lcssa = 0, $pos$04$ph = 0, $valid$0$lcssa = 0, $valid$01$ph = 0, label = 0;
 $$03$ph = $buf;
 $esclen$02$ph = 0;
 $pos$04$ph = 0;
 $valid$01$ph = 1;
 L1 : while (1) {
  $$03 = $$03$ph;
  $esclen$02 = $esclen$02$ph;
  $pos$04 = $pos$04$ph;
  L3 : while (1) {
   $0 = $$03 + 1 | 0;
   $1 = HEAP8[$$03 >> 0] | 0;
   switch ($1 << 24 >> 24) {
   case 0:
    {
     $valid$0$lcssa = $valid$01$ph;
     label = 12;
     break L1;
     break;
    }
   case 92:
    break;
   default:
    {
     $$lcssa = $0;
     $$lcssa33 = $1;
     $esclen$02$lcssa = $esclen$02;
     $pos$04$lcssa = $pos$04;
     break L3;
    }
   }
   $$03 = $0;
   $esclen$02 = 1;
   $pos$04 = $pos$04 + 1 | 0;
  }
  $3 = $$lcssa33 & 255;
  $4 = ($esclen$02$lcssa | 0) > 0;
  if (($3 + -48 | 0) >>> 0 < 10) {
   $5 = $esclen$02$lcssa + 1 | 0;
   $esclen$1 = $4 ? $5 : $esclen$02$lcssa;
   if (!(($4 ? ($5 | 0) < 6 & 1 : $valid$01$ph) | 0)) {
    $valid$0$lcssa = 0;
    label = 12;
    break;
   }
   $$sink = ($pos$04$lcssa | 0) > 0 | ($esclen$1 | 0) > 0;
   $esclen$2 = $esclen$1;
  } else if ($4) {
   $$sink = 1;
   $esclen$2 = 0;
  } else if (($pos$04$lcssa | 0) > 0 & $$lcssa33 << 24 >> 24 == 45) {
   $$sink = 1;
   $esclen$2 = 0;
  } else {
   $$sink = ($$lcssa33 & 255) > 160 | (_isalpha($3) | 0) != 0;
   $esclen$2 = 0;
  }
  if ($$sink) {
   $$03$ph = $$lcssa;
   $esclen$02$ph = $esclen$2;
   $pos$04$ph = $pos$04$lcssa + 1 | 0;
   $valid$01$ph = $$sink & 1;
  } else {
   $valid$0$lcssa = 0;
   label = 12;
   break;
  }
 }
 if ((label | 0) == 12) return $valid$0$lcssa | 0;
 return 0;
}

function _ShouldIndent($doc$0$2$0$20$0$val, $node) {
 $doc$0$2$0$20$0$val = $doc$0$2$0$20$0$val | 0;
 $node = $node | 0;
 var $$0 = 0, $$013 = 0, $$014 = 0, $1 = 0, $21 = 0, $25 = 0, $28 = 0, $3 = 0, $35 = 0, $45 = 0, $8 = 0, label = 0;
 if (!$doc$0$2$0$20$0$val) {
  $$0 = 0;
  return $$0 | 0;
 }
 $1 = ($node | 0) != 0;
 if ($1) {
  $3 = HEAP32[$node + 28 >> 2] | 0;
  if ($3 | 0) if ((HEAP32[$3 >> 2] | 0) == 110) {
   $$0 = 0;
   return $$0 | 0;
  }
 }
 L9 : do if (($doc$0$2$0$20$0$val | 0) == 2) {
  $8 = $node + 12 | 0;
  if (HEAP32[$8 >> 2] | 0) if (_prvTidynodeHasCM($node, 262144) | 0) {
   $$013 = HEAP32[$8 >> 2] | 0;
   if (!$$013) {
    $$0 = 0;
    return $$0 | 0;
   } else $$014 = $$013;
   while (1) {
    if (_prvTidynodeHasCM($$014, 8) | 0) {
     $$0 = 1;
     label = 24;
     break;
    }
    $$014 = HEAP32[$$014 + 8 >> 2] | 0;
    if (!$$014) {
     $$0 = 0;
     label = 24;
     break;
    }
   }
   if ((label | 0) == 24) return $$0 | 0;
  }
  if (_prvTidynodeHasCM($node, 16384) | 0) {
   $$0 = 0;
   return $$0 | 0;
  }
  $21 = HEAP32[$node + 28 >> 2] | 0;
  if ($21 | 0) {
   switch (HEAP32[$21 >> 2] | 0) {
   case 30:
    break;
   case 114:
   case 80:
   case 48:
    {
     $$0 = 0;
     return $$0 | 0;
    }
   default:
    break L9;
   }
   $25 = HEAP32[$node + 16 >> 2] | 0;
   if ($25 | 0) {
    $28 = HEAP32[$25 + 28 >> 2] | 0;
    if ($28 | 0) if ((HEAP32[$28 >> 2] | 0) == 52) {
     $$0 = 0;
     return $$0 | 0;
    }
   }
  }
 } while (0);
 if (_prvTidynodeHasCM($node, 3072) | 0) {
  $$0 = 1;
  return $$0 | 0;
 }
 if ($1) {
  $35 = HEAP32[$node + 28 >> 2] | 0;
  if ($35 | 0) if ((HEAP32[$35 >> 2] | 0) == 64) {
   $$0 = 1;
   return $$0 | 0;
  }
 }
 if (!(_prvTidynodeHasCM($node, 16) | 0)) $45 = (HEAP32[$node + 12 >> 2] | 0) != 0; else $45 = 0;
 $$0 = $45 & 1;
 return $$0 | 0;
}

function _CheckName($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $1 = 0, $12 = 0, $14 = 0, $17 = 0, $19 = 0, $2 = 0, $23 = 0, $6 = 0, $c$i = 0, $s$0$i = 0, $s$1$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c$i = sp;
 if ($attval | 0) {
  $1 = $attval + 24 | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  if ($2 | 0) {
   if (!$node) {
    STACKTOP = sp;
    return;
   }
   $6 = HEAP32[$node + 28 >> 2] | 0;
   if (!$6) {
    STACKTOP = sp;
    return;
   }
   switch (HEAP32[$6 >> 2] | 0) {
   case 1:
   case 6:
   case 37:
   case 38:
   case 50:
   case 52:
   case 64:
    break;
   default:
    {
     STACKTOP = sp;
     return;
    }
   }
   do if (HEAP32[$doc + 172 >> 2] | 0) {
    $s$0$i = $2;
    while (1) {
     $12 = HEAP8[$s$0$i >> 0] | 0;
     if (!($12 << 24 >> 24)) {
      label = 13;
      break;
     }
     $14 = $12 & 255;
     HEAP32[$c$i >> 2] = $14;
     if ($12 << 24 >> 24 < 0) {
      $17 = $s$0$i + (_prvTidyGetUTF8($s$0$i, $c$i) | 0) | 0;
      $19 = HEAP32[$c$i >> 2] | 0;
      $s$1$i = $17;
     } else {
      $19 = $14;
      $s$1$i = $s$0$i;
     }
     if (!(_prvTidyIsXMLNamechar($19) | 0)) {
      label = 14;
      break;
     } else $s$0$i = $s$1$i + 1 | 0;
    }
    if ((label | 0) == 13) break; else if ((label | 0) == 14) {
     _prvTidyReportAttrError($doc, $node, $attval, 251);
     break;
    }
   } while (0);
   $23 = _GetNodeByAnchor($doc, HEAP32[$1 >> 2] | 0) | 0;
   if (($23 | 0) == 0 | ($23 | 0) == ($node | 0)) {
    _AddAnchor($doc, HEAP32[$1 >> 2] | 0, $node);
    STACKTOP = sp;
    return;
   } else {
    _prvTidyReportAttrError($doc, $node, $attval, 266);
    STACKTOP = sp;
    return;
   }
  }
 }
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 STACKTOP = sp;
 return;
}

function _IsValidMediaExtension($sType) {
 $sType = $sType | 0;
 var $$0 = 0, $$lcssa7 = 0, $0 = 0, $1 = 0, $ext = 0, $i$0$in$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $ext = sp;
 $0 = _prvTidytmbstrlen($sType) | 0;
 HEAP8[$ext >> 0] = 0;
 $i$0$in$i = $0;
 L1 : do {
  $i$0$in$i = $i$0$in$i + -1 | 0;
  $1 = $sType + $i$0$in$i | 0;
  switch (HEAP8[$1 >> 0] | 0) {
  case 92:
  case 47:
   {
    break L1;
    break;
   }
  case 46:
   {
    $$lcssa7 = $1;
    label = 3;
    break L1;
    break;
   }
  default:
   {}
  }
 } while (($i$0$in$i | 0) > 1);
 if ((label | 0) == 3) _prvTidytmbstrncpy($ext, $$lcssa7, 20) | 0;
 if (!(_prvTidytmbstrcasecmp($ext, 311838) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311843) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311848) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311853) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311858) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311863) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311868) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311873) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311879) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311884) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311889) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311895) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311900) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311905) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311911) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311916) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311920) | 0)) $$0 = 1; else $$0 = (_prvTidytmbstrcasecmp($ext, 311925) | 0) == 0 & 1;
 STACKTOP = sp;
 return $$0 | 0;
}

function _prvTidyInitMap() {
 var $$01$i4 = 0, $$01$i7 = 0, $38 = 0, $40 = 0, $41 = 0, $45 = 0, $47 = 0, $48 = 0;
 HEAP32[79135] = HEAP32[79135] | 24;
 HEAP32[79132] = HEAP32[79132] | 24;
 HEAP32[79134] = HEAP32[79134] | 24;
 HEAP32[79154] = HEAP32[79154] | 8;
 HEAP32[79131] = HEAP32[79131] | 8;
 HEAP32[79167] = HEAP32[79167] | 4;
 HEAP32[79168] = HEAP32[79168] | 4;
 HEAP32[79180] = HEAP32[79180] | 4;
 HEAP32[79217] = HEAP32[79217] | 4;
 HEAP32[79170] = HEAP32[79170] | 133;
 HEAP32[79171] = HEAP32[79171] | 133;
 HEAP32[79172] = HEAP32[79172] | 133;
 HEAP32[79173] = HEAP32[79173] | 133;
 HEAP32[79174] = HEAP32[79174] | 133;
 HEAP32[79175] = HEAP32[79175] | 133;
 HEAP32[79176] = HEAP32[79176] | 133;
 HEAP32[79177] = HEAP32[79177] | 133;
 HEAP32[79178] = HEAP32[79178] | 133;
 HEAP32[79179] = HEAP32[79179] | 133;
 $$01$i7 = 310527;
 $40 = 97;
 while (1) {
  $38 = $$01$i7 + 1 | 0;
  $41 = 316488 + (($40 & 255) << 2) | 0;
  HEAP32[$41 >> 2] = HEAP32[$41 >> 2] | 38;
  if (($38 | 0) == 310553) {
   $$01$i4 = 310554;
   $47 = 65;
   break;
  } else {
   $$01$i7 = $38;
   $40 = HEAP8[$38 >> 0] | 0;
  }
 }
 while (1) {
  $45 = $$01$i4 + 1 | 0;
  $48 = 316488 + (($47 & 255) << 2) | 0;
  HEAP32[$48 >> 2] = HEAP32[$48 >> 2] | 70;
  if (($45 | 0) == 310580) break; else {
   $$01$i4 = $45;
   $47 = HEAP8[$45 >> 0] | 0;
  }
 }
 HEAP32[79219] = HEAP32[79219] | 128;
 HEAP32[79220] = HEAP32[79220] | 128;
 HEAP32[79221] = HEAP32[79221] | 128;
 HEAP32[79222] = HEAP32[79222] | 128;
 HEAP32[79223] = HEAP32[79223] | 128;
 HEAP32[79224] = HEAP32[79224] | 128;
 HEAP32[79187] = HEAP32[79187] | 128;
 HEAP32[79188] = HEAP32[79188] | 128;
 HEAP32[79189] = HEAP32[79189] | 128;
 HEAP32[79190] = HEAP32[79190] | 128;
 HEAP32[79191] = HEAP32[79191] | 128;
 HEAP32[79192] = HEAP32[79192] | 128;
 return;
}

function _AfterSpaceImp($lexer, $node, $isEmpty) {
 $lexer = $lexer | 0;
 $node = $node | 0;
 $isEmpty = $isEmpty | 0;
 var $$0 = 0, $10 = 0, $12 = 0, $14 = 0, $16 = 0, $17 = 0, $21 = 0, $24 = 0, $26 = 0, $3 = 0, $36 = 0, $9 = 0, $c$i = 0, $i$03$i = 0, $i$1$i = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c$i = sp;
 L1 : do if (!(_prvTidynodeCMIsInline($node) | 0)) $$0 = 1; else {
  $3 = HEAP32[$node + 4 >> 2] | 0;
  if (!$3) {
   if ($isEmpty | 0) if (!(_prvTidynodeCMIsInline(HEAP32[$node >> 2] | 0) | 0)) {
    $$0 = 0;
    break;
   }
   $$0 = _AfterSpaceImp($lexer, HEAP32[$node >> 2] | 0, $isEmpty) | 0;
   break;
  }
  if (!(_prvTidynodeIsText($3) | 0)) {
   $26 = HEAP32[$3 + 28 >> 2] | 0;
   if ($26 | 0) if ((HEAP32[$26 >> 2] | 0) == 17) {
    $$0 = 1;
    break;
   }
   $$0 = 0;
   break;
  }
  if (!(_prvTidynodeIsText($3) | 0)) $$0 = 0; else {
   $9 = $3 + 40 | 0;
   $10 = HEAP32[$9 >> 2] | 0;
   $12 = HEAP32[$3 + 36 >> 2] | 0;
   if ($10 >>> 0 > $12 >>> 0) {
    HEAP32[$c$i >> 2] = 0;
    $14 = $lexer + 84 | 0;
    $36 = $10;
    $i$03$i = $12;
    while (1) {
     $16 = (HEAP32[$14 >> 2] | 0) + $i$03$i | 0;
     $17 = HEAP8[$16 >> 0] | 0;
     HEAP32[$c$i >> 2] = $17 & 255;
     if ($17 << 24 >> 24 < 0) {
      $21 = (_prvTidyGetUTF8($16, $c$i) | 0) + $i$03$i | 0;
      $24 = HEAP32[$9 >> 2] | 0;
      $i$1$i = $21;
     } else {
      $24 = $36;
      $i$1$i = $i$03$i;
     }
     $i$03$i = $i$1$i + 1 | 0;
     if ($i$03$i >>> 0 >= $24 >>> 0) break; else $36 = $24;
    }
    switch (HEAP32[$c$i >> 2] | 0) {
    case 10:
    case 32:
     {
      $$0 = 1;
      break L1;
      break;
     }
    default:
     {
      $$0 = 0;
      break L1;
     }
    }
   } else $$0 = 0;
  }
 } while (0);
 STACKTOP = sp;
 return $$0 | 0;
}

function _tidySetLanguage($languageCode) {
 $languageCode = $languageCode | 0;
 var $$0 = 0, $$0$i = 0, $$lcssa = 0, $1 = 0, $15 = 0, $22 = 0, $27 = 0, $30 = 0, $31 = 0, $8 = 0, $i$01$i = 0, $i$01$i8 = 0, $lang = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $lang = sp;
 HEAP8[$lang >> 0] = 0;
 HEAP8[$lang + 1 >> 0] = 0;
 HEAP8[$lang + 2 >> 0] = 0;
 if (!$languageCode) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 _tidyNormalizedLocaleName($languageCode) | 0;
 $1 = HEAP32[1693] | 0;
 L4 : do if (!$1) $$0$i = 0; else {
  $8 = $1;
  $i$01$i = 0;
  while (1) {
   $i$01$i = $i$01$i + 1 | 0;
   if (!(_strcmp(HEAP32[$8 + 12 >> 2] | 0, 298438) | 0)) {
    $$0$i = $8;
    break L4;
   }
   $8 = HEAP32[6772 + ($i$01$i << 2) >> 2] | 0;
   if (!$8) {
    $$0$i = 0;
    break;
   }
  }
 } while (0);
 L9 : do if ((_strlen(298438) | 0) >>> 0 > 2) {
  _strncpy($lang, 298438, 2) | 0;
  HEAP8[$lang + 2 >> 0] = 0;
  $15 = HEAP32[1693] | 0;
  if (!$15) label = 11; else {
   $22 = $15;
   $i$01$i8 = 0;
   while (1) {
    $i$01$i8 = $i$01$i8 + 1 | 0;
    if (!(_strcmp(HEAP32[$22 + 12 >> 2] | 0, $lang) | 0)) {
     $$lcssa = $22;
     break;
    }
    $22 = HEAP32[6772 + ($i$01$i8 << 2) >> 2] | 0;
    if (!$22) {
     label = 11;
     break L9;
    }
   }
   if (!$$0$i) {
    HEAP32[1691] = $$lcssa;
    HEAP32[1692] = 0;
    $30 = 0;
    $31 = 1;
    break;
   } else {
    HEAP32[1691] = $$0$i;
    HEAP32[1692] = $$lcssa;
    $30 = 1;
    $31 = 1;
    break;
   }
  }
 } else label = 11; while (0);
 if ((label | 0) == 11) {
  $27 = ($$0$i | 0) != 0;
  if (!$$0$i) {
   $30 = $27;
   $31 = 0;
  } else {
   HEAP32[1691] = $$0$i;
   HEAP32[1692] = 0;
   $30 = $27;
   $31 = 0;
  }
 }
 $$0 = ($31 | $30) & 1;
 STACKTOP = sp;
 return $$0 | 0;
}

function _prvTidyResetTags($doc) {
 $doc = $doc | 0;
 var $16 = 0, $17 = 0, $18 = 0, $22 = 0, $i$02$i = 0, $next$01$i = 0, $np$01$i = 0, $np$01$i$lcssa = 0, $np$01$i1 = 0, $np$01$i1$lcssa = 0, $np$01$i4 = 0, $np$01$i4$lcssa = 0, label = 0, $next$01$i$looptemp = 0;
 $np$01$i = 58824;
 while (1) {
  if ((HEAP32[$np$01$i >> 2] | 0) == 1) {
   $np$01$i$lcssa = $np$01$i;
   label = 4;
   break;
  }
  $np$01$i = $np$01$i + 32 | 0;
  if ($np$01$i >>> 0 >= 63624 >>> 0) {
   $np$01$i1 = 58824;
   break;
  }
 }
 if ((label | 0) == 4) {
  HEAP32[$np$01$i$lcssa + 20 >> 2] = 25;
  HEAP32[$np$01$i$lcssa + 16 >> 2] = 131096;
  $np$01$i1 = 58824;
 }
 while (1) {
  if ((HEAP32[$np$01$i1 >> 2] | 0) == 19) {
   $np$01$i1$lcssa = $np$01$i1;
   label = 7;
   break;
  }
  $np$01$i1 = $np$01$i1 + 32 | 0;
  if ($np$01$i1 >>> 0 >= 63624 >>> 0) {
   $np$01$i4 = 58824;
   break;
  }
 }
 if ((label | 0) == 7) {
  HEAP32[$np$01$i1$lcssa + 20 >> 2] = 25;
  $np$01$i4 = 58824;
 }
 do {
  if ((HEAP32[$np$01$i4 >> 2] | 0) == 76) {
   $np$01$i4$lcssa = $np$01$i4;
   label = 10;
   break;
  }
  $np$01$i4 = $np$01$i4 + 32 | 0;
 } while ($np$01$i4 >>> 0 < 63624 >>> 0);
 if ((label | 0) == 10) HEAP32[$np$01$i4$lcssa + 16 >> 2] = 71696;
 $16 = $doc + 6856 | 0;
 $i$02$i = 0;
 do {
  $17 = $doc + 884 + ($i$02$i << 2) | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  if ($18 | 0) {
   $next$01$i = $18;
   do {
    $next$01$i$looptemp = $next$01$i;
    $next$01$i = HEAP32[$next$01$i + 4 >> 2] | 0;
    $22 = HEAP32[$16 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$22 >> 2] | 0) + 8 >> 2] & 15]($22, $next$01$i$looptemp);
   } while (($next$01$i | 0) != 0);
  }
  HEAP32[$17 >> 2] = 0;
  $i$02$i = $i$02$i + 1 | 0;
 } while (($i$02$i | 0) != 178);
 HEAP32[$doc + 6852 >> 2] = 1;
 return;
}

function _ParseInt($doc, $entry) {
 $doc = $doc | 0;
 $entry = $entry | 0;
 var $$0$i$i = 0, $$0$i$i3 = 0, $$lcssa = 0, $0 = 0, $11 = 0, $16 = 0, $25 = 0, $c$0$be = 0, $c$06 = 0, $config$idx$i = 0, $config$idx$i1 = 0, $config$idx$val$i = 0, $config$idx$val$i2 = 0, $digits$0$lcssa8 = 0, $number$05 = 0;
 $0 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$0 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$0 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$0 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $11 = HEAP32[$0 >> 2] | 0;
 if (!(_prvTidyIsDigit($11) | 0)) {
  _prvTidyReportBadArgument($doc, HEAP32[$entry + 8 >> 2] | 0);
  $digits$0$lcssa8 = 0;
  return $digits$0$lcssa8 | 0;
 }
 $config$idx$i1 = $doc + 872 | 0;
 $c$06 = $11;
 $number$05 = 0;
 while (1) {
  $16 = $c$06 + -48 + ($number$05 * 10 | 0) | 0;
  if ((HEAP32[$0 >> 2] | 0) == -1) $c$0$be = -1; else {
   $config$idx$val$i2 = HEAP32[$config$idx$i1 >> 2] | 0;
   if (!$config$idx$val$i2) $$0$i$i3 = -1; else $$0$i$i3 = _prvTidyReadChar($config$idx$val$i2) | 0;
   HEAP32[$0 >> 2] = $$0$i$i3;
   $c$0$be = $$0$i$i3;
  }
  if (!(_prvTidyIsDigit($c$0$be) | 0)) {
   $$lcssa = $16;
   break;
  } else {
   $c$06 = $c$0$be;
   $number$05 = $16;
  }
 }
 $25 = HEAP32[$entry >> 2] | 0;
 if ($25 >>> 0 >= 98) {
  $digits$0$lcssa8 = 1;
  return $digits$0$lcssa8 | 0;
 }
 if ((HEAP32[1892 + ($25 << 5) + 12 >> 2] | 0) != 1) ___assert_fail(223759, 223800, 398, 223889);
 HEAP32[$doc + 72 + ($25 << 2) >> 2] = $$lcssa;
 $digits$0$lcssa8 = 1;
 return $digits$0$lcssa8 | 0;
}

function ___stdio_read($f, $buf, $len) {
 $f = $f | 0;
 $buf = $buf | 0;
 $len = $len | 0;
 var $$0 = 0, $$cast = 0, $0 = 0, $1 = 0, $15 = 0, $2 = 0, $27 = 0, $30 = 0, $31 = 0, $7 = 0, $cnt$0 = 0, $iov = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $iov = sp + 32 | 0;
 HEAP32[$iov >> 2] = $buf;
 $0 = $iov + 4 | 0;
 $1 = $f + 48 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 HEAP32[$0 >> 2] = $len - (($2 | 0) != 0 & 1);
 $7 = $f + 44 | 0;
 HEAP32[$iov + 8 >> 2] = HEAP32[$7 >> 2];
 HEAP32[$iov + 12 >> 2] = $2;
 if (!(HEAP32[79254] | 0)) {
  HEAP32[$vararg_buffer3 >> 2] = HEAP32[$f + 60 >> 2];
  HEAP32[$vararg_buffer3 + 4 >> 2] = $iov;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 2;
  $cnt$0 = ___syscall_ret(___syscall145(145, $vararg_buffer3 | 0) | 0) | 0;
 } else {
  _pthread_cleanup_push(2, $f | 0);
  HEAP32[$vararg_buffer >> 2] = HEAP32[$f + 60 >> 2];
  HEAP32[$vararg_buffer + 4 >> 2] = $iov;
  HEAP32[$vararg_buffer + 8 >> 2] = 2;
  $15 = ___syscall_ret(___syscall145(145, $vararg_buffer | 0) | 0) | 0;
  _pthread_cleanup_pop(0);
  $cnt$0 = $15;
 }
 if (($cnt$0 | 0) < 1) {
  HEAP32[$f >> 2] = HEAP32[$f >> 2] | $cnt$0 & 48 ^ 16;
  HEAP32[$f + 8 >> 2] = 0;
  HEAP32[$f + 4 >> 2] = 0;
  $$0 = $cnt$0;
 } else {
  $27 = HEAP32[$0 >> 2] | 0;
  if ($cnt$0 >>> 0 > $27 >>> 0) {
   $30 = HEAP32[$7 >> 2] | 0;
   $31 = $f + 4 | 0;
   HEAP32[$31 >> 2] = $30;
   $$cast = $30;
   HEAP32[$f + 8 >> 2] = $$cast + ($cnt$0 - $27);
   if (!(HEAP32[$1 >> 2] | 0)) $$0 = $len; else {
    HEAP32[$31 >> 2] = $$cast + 1;
    HEAP8[$buf + ($len + -1) >> 0] = HEAP8[$$cast >> 0] | 0;
    $$0 = $len;
   }
  } else $$0 = $cnt$0;
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _prvTidyNormalizeSpaces($lexer, $node) {
 $lexer = $lexer | 0;
 $node = $node | 0;
 var $$04 = 0, $$lcssa = 0, $1 = 0, $10 = 0, $11 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $21 = 0, $22 = 0, $24 = 0, $25 = 0, $26 = 0, $3 = 0, $31 = 0, $7 = 0, $9 = 0, $c = 0, $i$01 = 0, $i$1 = 0, $p$0$lcssa = 0, $p$02 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 if (!$node) {
  STACKTOP = sp;
  return;
 }
 $1 = $lexer + 84 | 0;
 $$04 = $node;
 do {
  $3 = HEAP32[$$04 + 12 >> 2] | 0;
  if ($3 | 0) _prvTidyNormalizeSpaces($lexer, $3);
  if (_prvTidynodeIsText($$04) | 0) {
   $7 = HEAP32[$1 >> 2] | 0;
   $9 = HEAP32[$$04 + 36 >> 2] | 0;
   $10 = $7 + $9 | 0;
   $11 = $$04 + 40 | 0;
   $14 = $7;
   if ($9 >>> 0 < (HEAP32[$11 >> 2] | 0) >>> 0) {
    $16 = $7;
    $i$01 = $9;
    $p$02 = $10;
    while (1) {
     $15 = $16 + $i$01 | 0;
     $17 = HEAP8[$15 >> 0] | 0;
     $18 = $17 & 255;
     HEAP32[$c >> 2] = $18;
     if ($17 << 24 >> 24 < 0) {
      $21 = (_prvTidyGetUTF8($15, $c) | 0) + $i$01 | 0;
      $22 = HEAP32[$c >> 2] | 0;
      $i$1 = $21;
     } else {
      $22 = $18;
      $i$1 = $i$01;
     }
     if (($22 | 0) == 160) {
      HEAP32[$c >> 2] = 32;
      $24 = 32;
     } else $24 = $22;
     $25 = _prvTidyPutUTF8($p$02, $24) | 0;
     $26 = $i$1 + 1 | 0;
     if ($26 >>> 0 >= (HEAP32[$11 >> 2] | 0) >>> 0) {
      $$lcssa = $25;
      break;
     }
     $16 = HEAP32[$1 >> 2] | 0;
     $i$01 = $26;
     $p$02 = $25;
    }
    $31 = HEAP32[$1 >> 2] | 0;
    $p$0$lcssa = $$lcssa;
   } else {
    $31 = $14;
    $p$0$lcssa = $10;
   }
   HEAP32[$11 >> 2] = $p$0$lcssa - $31;
  }
  $$04 = HEAP32[$$04 + 8 >> 2] | 0;
 } while (($$04 | 0) != 0);
 STACKTOP = sp;
 return;
}

function _MoveToHead($doc, $element, $node) {
 $doc = $doc | 0;
 $element = $element | 0;
 $node = $node | 0;
 var $$pre$i = 0, $0 = 0, $1 = 0, $10 = 0, $12 = 0, $15 = 0, $21 = 0, $23 = 0, $24 = 0, $30 = 0, $32 = 0, $35 = 0, $38 = 0, $6 = 0, $8 = 0;
 $0 = $node + 4 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $$pre$i = $node + 8 | 0;
 if ($1 | 0) HEAP32[$1 + 8 >> 2] = HEAP32[$$pre$i >> 2];
 $6 = HEAP32[$$pre$i >> 2] | 0;
 $8 = $6;
 if ($6 | 0) HEAP32[$6 + 4 >> 2] = $1;
 $10 = HEAP32[$node >> 2] | 0;
 if ($10 | 0) {
  $12 = $10 + 12 | 0;
  if ((HEAP32[$12 >> 2] | 0) == ($node | 0)) HEAP32[$12 >> 2] = $8;
  $15 = $10 + 16 | 0;
  if ((HEAP32[$15 >> 2] | 0) == ($node | 0)) HEAP32[$15 >> 2] = HEAP32[$0 >> 2];
 }
 HEAP32[$$pre$i >> 2] = 0;
 HEAP32[$0 >> 2] = 0;
 HEAP32[$node >> 2] = 0;
 if (!(_prvTidynodeIsElement($node) | 0)) {
  _prvTidyReportError($doc, $element, $node, 208);
  _prvTidyFreeNode($doc, $node);
  return;
 }
 _prvTidyReportError($doc, $element, $node, 211);
 $21 = _prvTidyFindHEAD($doc) | 0;
 if (!$21) ___assert_fail(307731, 307744, 813, 307833);
 HEAP32[$node >> 2] = $21;
 $23 = $21 + 16 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 HEAP32[$0 >> 2] = $24;
 if (!$24) HEAP32[$21 + 12 >> 2] = $node; else HEAP32[$24 + 8 >> 2] = $node;
 HEAP32[$23 >> 2] = $node;
 $30 = HEAP32[$node + 28 >> 2] | 0;
 $32 = HEAP32[$30 + 20 >> 2] | 0;
 if (!$32) return;
 $35 = HEAP32[$doc + 68 >> 2] | 0;
 if (!$30) return;
 $38 = HEAP32[$30 + 16 >> 2] | 0;
 if (!($38 & 1)) {
  if (!($38 & 16)) HEAP32[$35 + 16 >> 2] = 0;
 } else HEAP32[$35 + 8 >> 2] = 0;
 if ((HEAP32[$node + 44 >> 2] | 0) == 7) return;
 HEAP32[$35 + 72 >> 2] = $node;
 FUNCTION_TABLE_viii[$32 & 63]($doc, $node, 0);
 return;
}

function _prvTidyCheckAttribute($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $$0$i = 0, $0 = 0, $1 = 0, $11 = 0, $15 = 0, $19 = 0, $22 = 0, $24 = 0, $26 = 0, $27 = 0, $36 = 0, $i$03$i = 0, $i$03$i$lcssa = 0, label = 0;
 $0 = $attval + 4 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) return $1 | 0;
 if (((HEAP32[$1 >> 2] | 0) + -161 | 0) >>> 0 < 2) {
  HEAP32[(HEAP32[$doc + 68 >> 2] | 0) + 28 >> 2] = 1;
  if (!(HEAP32[$doc + 180 >> 2] | 0)) {
   _prvTidySetOptionBool($doc, 26, 1) | 0;
   _prvTidySetOptionBool($doc, 25, 1) | 0;
  }
 }
 $11 = HEAP32[$attval + 20 >> 2] | 0;
 if (!$11) label = 7; else if (!(_prvTidytmbstrncmp($11, 304457, 5) | 0)) $$0$i = 393216; else label = 7;
 L10 : do if ((label | 0) == 7) {
  $15 = HEAP32[$0 >> 2] | 0;
  if (!$15) $$0$i = 0; else if (!$node) $$0$i = 57344; else {
   $19 = HEAP32[$node + 28 >> 2] | 0;
   if (!$19) $$0$i = 57344; else {
    $22 = HEAP32[$19 + 12 >> 2] | 0;
    if (!$22) $$0$i = 57344; else {
     $24 = HEAP32[$22 >> 2] | 0;
     if (!$24) $$0$i = 57344; else {
      $26 = HEAP32[$15 >> 2] | 0;
      $27 = $24;
      $i$03$i = 0;
      while (1) {
       if (($27 | 0) == ($26 | 0)) {
        $i$03$i$lcssa = $i$03$i;
        break;
       }
       $i$03$i = $i$03$i + 1 | 0;
       $27 = HEAP32[$22 + ($i$03$i << 3) >> 2] | 0;
       if (!$27) {
        $$0$i = 57344;
        break L10;
       }
      }
      $$0$i = HEAP32[$22 + ($i$03$i$lcssa << 3) + 4 >> 2] | 0;
     }
    }
   }
  }
 } while (0);
 _prvTidyConstrainVersion($doc, $$0$i);
 $36 = HEAP32[$1 + 8 >> 2] | 0;
 if (!$36) return $1 | 0;
 FUNCTION_TABLE_viii[$36 & 63]($doc, $node, $attval);
 return $1 | 0;
}

function _prvTidyFindTITLE($doc) {
 $doc = $doc | 0;
 var $15 = 0, $2 = 0, $24 = 0, $5 = 0, $node$02$i$i = 0, $node$02$i$i$lcssa = 0, $node$04$i = 0, $node$05$i = 0, $node$05$i$lcssa = 0, $node$06 = 0, $node$07 = 0, $node$1 = 0, label = 0;
 if (!$doc) {
  $node$1 = 0;
  return $node$1 | 0;
 }
 $2 = HEAP32[$doc + 12 >> 2] | 0;
 if (!$2) {
  $node$1 = 0;
  return $node$1 | 0;
 } else $node$02$i$i = $2;
 while (1) {
  $5 = HEAP32[$node$02$i$i + 28 >> 2] | 0;
  if ($5 | 0) if ((HEAP32[$5 >> 2] | 0) == 48) {
   $node$02$i$i$lcssa = $node$02$i$i;
   break;
  }
  $node$02$i$i = HEAP32[$node$02$i$i + 8 >> 2] | 0;
  if (!$node$02$i$i) {
   $node$1 = 0;
   label = 14;
   break;
  }
 }
 if ((label | 0) == 14) return $node$1 | 0;
 $node$04$i = HEAP32[$node$02$i$i$lcssa + 12 >> 2] | 0;
 if (!$node$04$i) {
  $node$1 = 0;
  return $node$1 | 0;
 } else $node$05$i = $node$04$i;
 while (1) {
  $15 = HEAP32[$node$05$i + 28 >> 2] | 0;
  if ($15 | 0) if ((HEAP32[$15 >> 2] | 0) == 46) {
   $node$05$i$lcssa = $node$05$i;
   break;
  }
  $node$05$i = HEAP32[$node$05$i + 8 >> 2] | 0;
  if (!$node$05$i) {
   $node$1 = 0;
   label = 14;
   break;
  }
 }
 if ((label | 0) == 14) return $node$1 | 0;
 $node$06 = HEAP32[$node$05$i$lcssa + 12 >> 2] | 0;
 if (!$node$06) {
  $node$1 = 0;
  return $node$1 | 0;
 } else $node$07 = $node$06;
 while (1) {
  $24 = HEAP32[$node$07 + 28 >> 2] | 0;
  if ($24 | 0) if ((HEAP32[$24 >> 2] | 0) == 114) {
   $node$1 = $node$07;
   label = 14;
   break;
  }
  $node$07 = HEAP32[$node$07 + 8 >> 2] | 0;
  if (!$node$07) {
   $node$1 = 0;
   label = 14;
   break;
  }
 }
 if ((label | 0) == 14) return $node$1 | 0;
 return 0;
}

function _prvTidyDropFontElements($doc, $node, $pnode) {
 $doc = $doc | 0;
 $node = $node | 0;
 $pnode = $pnode | 0;
 var $$0$be = 0, $$01 = 0, $1 = 0, $11 = 0, $12 = 0, $14 = 0, $16 = 0, $18 = 0, $2 = 0, $21 = 0, $22 = 0, $33 = 0, $4 = 0, $8 = 0, $9 = 0, $node$01$i = 0, $node$02$i = 0, label = 0;
 if (!$node) return; else $$01 = $node;
 while (1) {
  $1 = $$01 + 8 | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  $4 = HEAP32[$$01 + 28 >> 2] | 0;
  do if (!$4) label = 15; else if ((HEAP32[$4 >> 2] | 0) == 36) {
   $8 = $$01 + 12 | 0;
   $9 = HEAP32[$8 >> 2] | 0;
   $11 = $9;
   if (!$9) {
    $$0$be = _prvTidyDiscardElement($doc, $$01) | 0;
    break;
   }
   $12 = HEAP32[$$01 >> 2] | 0;
   $14 = HEAP32[$$01 + 16 >> 2] | 0;
   HEAP32[$14 + 8 >> 2] = $2;
   $16 = HEAP32[$1 >> 2] | 0;
   $18 = $14;
   if (!$16) HEAP32[$12 + 16 >> 2] = $18; else HEAP32[$16 + 4 >> 2] = $18;
   $21 = $$01 + 4 | 0;
   $22 = HEAP32[$21 >> 2] | 0;
   if (!$22) HEAP32[$12 + 12 >> 2] = $11; else {
    HEAP32[$9 + 4 >> 2] = $22;
    HEAP32[(HEAP32[$21 >> 2] | 0) + 8 >> 2] = $11;
   }
   $node$01$i = HEAP32[$8 >> 2] | 0;
   if ($node$01$i | 0) {
    $node$02$i = $node$01$i;
    do {
     HEAP32[$node$02$i >> 2] = $12;
     $node$02$i = HEAP32[$node$02$i + 8 >> 2] | 0;
    } while (($node$02$i | 0) != 0);
   }
   HEAP32[$8 >> 2] = 0;
   HEAP32[$1 >> 2] = 0;
   _prvTidyFreeNode($doc, $$01);
   $$0$be = $node$01$i;
  } else label = 15; while (0);
  if ((label | 0) == 15) {
   label = 0;
   $33 = HEAP32[$$01 + 12 >> 2] | 0;
   if ($33 | 0) _prvTidyDropFontElements($doc, $33, 0);
   $$0$be = $2;
  }
  if (!$$0$be) break; else $$01 = $$0$be;
 }
 return;
}

function _prvTidyAttributeIsMismatched($node, $attval, $doc) {
 $node = $node | 0;
 $attval = $attval | 0;
 $doc = $doc | 0;
 var $$0 = 0, $$0$i = 0, $10 = 0, $12 = 0, $17 = 0, $2 = 0, $22 = 0, $24 = 0, $27 = 0, $29 = 0, $3 = 0, $31 = 0, $32 = 0, $41 = 0, $i$03$i = 0, $i$03$i$lcssa = 0, label = 0;
 if (!(($node | 0) != 0 & ($attval | 0) != 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $2 = $node + 28 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 if (!$3) {
  $$0 = 0;
  return $$0 | 0;
 }
 if (!(HEAP32[$3 + 8 >> 2] & 401407)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $10 = HEAP32[$doc + 68 >> 2] | 0;
 $12 = HEAP32[$10 + 40 >> 2] | 0;
 if (!$12) $41 = HEAP32[$10 + 36 >> 2] | 0; else $41 = $12;
 $17 = HEAP32[$attval + 20 >> 2] | 0;
 if (!$17) label = 8; else if (!(_prvTidytmbstrncmp($17, 304457, 5) | 0)) $$0$i = 393216; else label = 8;
 L15 : do if ((label | 0) == 8) {
  $22 = HEAP32[$attval + 4 >> 2] | 0;
  if (!$22) $$0$i = 0; else {
   $24 = HEAP32[$2 >> 2] | 0;
   if (!$24) $$0$i = 57344; else {
    $27 = HEAP32[$24 + 12 >> 2] | 0;
    if (!$27) $$0$i = 57344; else {
     $29 = HEAP32[$27 >> 2] | 0;
     if (!$29) $$0$i = 57344; else {
      $31 = HEAP32[$22 >> 2] | 0;
      $32 = $29;
      $i$03$i = 0;
      while (1) {
       if (($32 | 0) == ($31 | 0)) {
        $i$03$i$lcssa = $i$03$i;
        break;
       }
       $i$03$i = $i$03$i + 1 | 0;
       $32 = HEAP32[$27 + ($i$03$i << 3) >> 2] | 0;
       if (!$32) {
        $$0$i = 57344;
        break L15;
       }
      }
      $$0$i = HEAP32[$27 + ($i$03$i$lcssa << 3) + 4 >> 2] | 0;
     }
    }
   }
  }
 } while (0);
 $$0 = ($$0$i & $41 | 0) == 0 & 1;
 return $$0 | 0;
}

function _CheckNumber($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $11 = 0, $19 = 0, $2 = 0, $26 = 0, $32 = 0, $6 = 0, $p$0 = 0, $p$1$ph = 0, $p$12 = 0, label = 0;
 if ($attval | 0) {
  $2 = HEAP32[$attval + 24 >> 2] | 0;
  if ($2 | 0) {
   L4 : do if (!$node) $p$0 = $2; else {
    $6 = HEAP32[$node + 28 >> 2] | 0;
    if (!$6) $p$0 = $2; else {
     L7 : do if ((HEAP32[$6 >> 2] | 0) == 39) {
      $11 = HEAP32[$attval + 4 >> 2] | 0;
      if ($11 | 0) {
       switch (HEAP32[$11 >> 2] | 0) {
       case 126:
       case 33:
        break;
       default:
        break L7;
       }
       return;
      }
     } while (0);
     if ((HEAP32[$6 >> 2] | 0) == 36) {
      switch (HEAP8[$2 >> 0] | 0) {
      case 45:
      case 43:
       break;
      default:
       {
        $p$0 = $2;
        break L4;
       }
      }
      $p$0 = $2 + 1 | 0;
     } else $p$0 = $2;
    }
   } while (0);
   $19 = HEAP32[$attval + 20 >> 2] | 0;
   if (!$19) $p$1$ph = $p$0; else if (!(_strcmp($19, 304828) | 0)) $p$1$ph = (HEAP8[$p$0 >> 0] | 0) == 45 ? $p$0 + 1 | 0 : $p$0; else $p$1$ph = $p$0;
   $26 = HEAP8[$p$1$ph >> 0] | 0;
   if (!($26 << 24 >> 24)) return; else {
    $32 = $26;
    $p$12 = $p$1$ph;
   }
   while (1) {
    $p$12 = $p$12 + 1 | 0;
    if (!(_prvTidyIsDigit($32 << 24 >> 24) | 0)) break;
    $32 = HEAP8[$p$12 >> 0] | 0;
    if (!($32 << 24 >> 24)) {
     label = 19;
     break;
    }
   }
   if ((label | 0) == 19) return;
   _prvTidyReportAttrError($doc, $node, $attval, 251);
   return;
  }
 }
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 return;
}

function _prvTidyReportWarning($doc, $element, $node, $code) {
 $doc = $doc | 0;
 $element = $element | 0;
 $node = $node | 0;
 $code = $code | 0;
 var $1 = 0, $2 = 0, $5 = 0, $elemdesc = 0, $nodedesc = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer5 = 0, $vararg_buffer8 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 544 | 0;
 $vararg_buffer8 = sp + 24 | 0;
 $vararg_buffer5 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $nodedesc = sp + 288 | 0;
 $elemdesc = sp + 32 | 0;
 $1 = $element | 0 ? $element : $node;
 $2 = _tidyLocalizedString($code) | 0;
 _memset($nodedesc | 0, 0, 256) | 0;
 _memset($elemdesc | 0, 0, 256) | 0;
 if (!$2) ___assert_fail(223545, 223391, 689, 223630);
 _TagToString($node, $nodedesc, 256);
 switch ($code | 0) {
 case 240:
  {
   HEAP32[$vararg_buffer >> 2] = $2;
   _messageNode($doc, 1, 240, $1, 223602, $vararg_buffer);
   STACKTOP = sp;
   return;
  }
 case 220:
  {
   _TagToString($element, $elemdesc, 256);
   HEAP32[$vararg_buffer1 >> 2] = $elemdesc;
   HEAP32[$vararg_buffer1 + 4 >> 2] = $nodedesc;
   _messageNode($doc, 1, 220, $1, $2, $vararg_buffer1);
   STACKTOP = sp;
   return;
  }
 case 289:
 case 288:
 case 209:
  {
   HEAP32[$vararg_buffer5 >> 2] = $nodedesc;
   _messageNode($doc, 1, $code, $1, $2, $vararg_buffer5);
   STACKTOP = sp;
   return;
  }
 case 285:
  {
   $5 = HEAP32[$node + 32 >> 2] | 0;
   HEAP32[$vararg_buffer8 >> 2] = $5;
   HEAP32[$vararg_buffer8 + 4 >> 2] = $5;
   _messageNode($doc, 1, 285, $1, $2, $vararg_buffer8);
   STACKTOP = sp;
   return;
  }
 default:
  {
   STACKTOP = sp;
   return;
  }
 }
}

function _TagToString($tag, $buf, $count) {
 $tag = $tag | 0;
 $buf = $buf | 0;
 $count = $count | 0;
 var $12 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer12 = 0, $vararg_buffer6 = 0, $vararg_buffer9 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer12 = sp + 40 | 0;
 $vararg_buffer9 = sp + 32 | 0;
 $vararg_buffer6 = sp + 24 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 HEAP8[$buf >> 0] = 0;
 if (!$tag) {
  STACKTOP = sp;
  return;
 }
 if (_prvTidynodeIsElement($tag) | 0) {
  HEAP32[$vararg_buffer >> 2] = HEAP32[$tag + 32 >> 2];
  _prvTidytmbsnprintf($buf, $count, 223580, $vararg_buffer) | 0;
  STACKTOP = sp;
  return;
 }
 switch (HEAP32[$tag + 44 >> 2] | 0) {
 case 6:
  {
   HEAP32[$vararg_buffer1 >> 2] = HEAP32[$tag + 32 >> 2];
   _prvTidytmbsnprintf($buf, $count, 223585, $vararg_buffer1) | 0;
   STACKTOP = sp;
   return;
  }
 case 1:
  {
   _prvTidytmbsnprintf($buf, $count, 223591, sp + 16 | 0) | 0;
   STACKTOP = sp;
   return;
  }
 case 4:
  {
   HEAP32[$vararg_buffer6 >> 2] = _tidyLocalizedString(2064) | 0;
   _prvTidytmbsnprintf($buf, $count, 223602, $vararg_buffer6) | 0;
   STACKTOP = sp;
   return;
  }
 case 13:
  {
   HEAP32[$vararg_buffer9 >> 2] = _tidyLocalizedString(2070) | 0;
   _prvTidytmbsnprintf($buf, $count, 223602, $vararg_buffer9) | 0;
   STACKTOP = sp;
   return;
  }
 default:
  {
   $12 = HEAP32[$tag + 32 >> 2] | 0;
   if (!$12) {
    STACKTOP = sp;
    return;
   }
   HEAP32[$vararg_buffer12 >> 2] = $12;
   _prvTidytmbsnprintf($buf, $count, 223602, $vararg_buffer12) | 0;
   STACKTOP = sp;
   return;
  }
 }
}

function _prvTidyResetConfigToSnapshot($doc) {
 $doc = $doc | 0;
 var $11 = 0, $16 = 0, $2 = 0, $20 = 0, $22 = 0, $3 = 0, $6 = 0, $7 = 0, $8 = 0, $changedUserTags = 0, $ixVal$03 = 0, $option$01 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $changedUserTags = sp;
 $2 = _NeedReparseTagDecls($doc + 72 | 0, $doc + 468 | 0, $changedUserTags) | 0;
 $3 = $doc + 6856 | 0;
 $ixVal$03 = 0;
 $option$01 = 1892;
 while (1) {
  if (($ixVal$03 | 0) != (HEAP32[$option$01 >> 2] | 0)) {
   label = 3;
   break;
  }
  $6 = $doc + 72 + ($ixVal$03 << 2) | 0;
  $7 = $doc + 468 + ($ixVal$03 << 2) | 0;
  $8 = $option$01 + 12 | 0;
  do if (!(HEAP32[$8 >> 2] | 0)) {
   $11 = HEAP32[$6 >> 2] | 0;
   if ($11 | 0) if (($11 | 0) != (HEAP32[$option$01 + 28 >> 2] | 0)) {
    $16 = HEAP32[$3 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$16 >> 2] | 0) + 8 >> 2] & 15]($16, $11);
    if (HEAP32[$8 >> 2] | 0) {
     label = 12;
     break;
    }
   }
   $20 = HEAP32[$7 >> 2] | 0;
   $22 = $20;
   if ($20 | 0) if (($20 | 0) != (HEAP32[$option$01 + 28 >> 2] | 0)) {
    HEAP32[$6 >> 2] = _prvTidytmbstrdup(HEAP32[$3 >> 2] | 0, $20) | 0;
    break;
   }
   HEAP32[$6 >> 2] = $22;
  } else label = 12; while (0);
  if ((label | 0) == 12) {
   label = 0;
   HEAP32[$6 >> 2] = HEAP32[$7 >> 2];
  }
  $ixVal$03 = $ixVal$03 + 1 | 0;
  if ($ixVal$03 >>> 0 >= 98) break; else $option$01 = $option$01 + 32 | 0;
 }
 if ((label | 0) == 3) ___assert_fail(225459, 223800, 560, 225608);
 if (!$2) {
  STACKTOP = sp;
  return;
 }
 _ReparseTagDecls($doc, HEAP32[$changedUserTags >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _strspn($s, $c) {
 $s = $s | 0;
 $c = $c | 0;
 var $$0 = 0, $$028 = 0, $$03 = 0, $$03$lcssa = 0, $$1$lcssa = 0, $$16 = 0, $0 = 0, $11 = 0, $14 = 0, $18 = 0, $24 = 0, $33 = 0, $byteset = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $byteset = sp;
 HEAP32[$byteset >> 2] = 0;
 HEAP32[$byteset + 4 >> 2] = 0;
 HEAP32[$byteset + 8 >> 2] = 0;
 HEAP32[$byteset + 12 >> 2] = 0;
 HEAP32[$byteset + 16 >> 2] = 0;
 HEAP32[$byteset + 20 >> 2] = 0;
 HEAP32[$byteset + 24 >> 2] = 0;
 HEAP32[$byteset + 28 >> 2] = 0;
 $0 = HEAP8[$c >> 0] | 0;
 do if (!($0 << 24 >> 24)) $$0 = 0; else {
  if (!(HEAP8[$c + 1 >> 0] | 0)) {
   $$03 = $s;
   while (1) if ((HEAP8[$$03 >> 0] | 0) == $0 << 24 >> 24) $$03 = $$03 + 1 | 0; else {
    $$03$lcssa = $$03;
    break;
   }
   $$0 = $$03$lcssa - $s | 0;
   break;
  } else {
   $$028 = $c;
   $14 = $0;
  }
  do {
   $18 = $byteset + ((($14 & 255) >>> 5 & 255) << 2) | 0;
   HEAP32[$18 >> 2] = HEAP32[$18 >> 2] | 1 << ($14 & 31);
   $$028 = $$028 + 1 | 0;
   $14 = HEAP8[$$028 >> 0] | 0;
  } while ($14 << 24 >> 24 != 0);
  $11 = HEAP8[$s >> 0] | 0;
  L10 : do if (!($11 << 24 >> 24)) $$1$lcssa = $s; else {
   $$16 = $s;
   $24 = $11;
   while (1) {
    if (!(HEAP32[$byteset + ((($24 & 255) >>> 5 & 255) << 2) >> 2] & 1 << ($24 & 31))) {
     $$1$lcssa = $$16;
     break L10;
    }
    $33 = $$16 + 1 | 0;
    $24 = HEAP8[$33 >> 0] | 0;
    if (!($24 << 24 >> 24)) {
     $$1$lcssa = $33;
     break;
    } else $$16 = $33;
   }
  } while (0);
  $$0 = $$1$lcssa - $s | 0;
 } while (0);
 STACKTOP = sp;
 return $$0 | 0;
}

function _ReparseTagDecls($doc, $changedUserTags) {
 $doc = $doc | 0;
 $changedUserTags = $changedUserTags | 0;
 var $15 = 0, $17 = 0, $18 = 0, $26 = 0, $28 = 0, $29 = 0, $37 = 0, $39 = 0, $4 = 0, $40 = 0, $6 = 0, $7 = 0;
 if ($changedUserTags & 2 | 0) {
  _prvTidyFreeDeclaredTags($doc, 2);
  $4 = $doc + 6856 | 0;
  $6 = _prvTidytmbstrdup(HEAP32[$4 >> 2] | 0, HEAP32[$doc + 392 >> 2] | 0) | 0;
  _prvTidyParseConfigValue($doc, 80, $6) | 0;
  $7 = HEAP32[$4 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$7 >> 2] | 0) + 8 >> 2] & 15]($7, $6);
 }
 if ($changedUserTags & 4 | 0) {
  _prvTidyFreeDeclaredTags($doc, 4);
  $15 = $doc + 6856 | 0;
  $17 = _prvTidytmbstrdup(HEAP32[$15 >> 2] | 0, HEAP32[$doc + 396 >> 2] | 0) | 0;
  _prvTidyParseConfigValue($doc, 81, $17) | 0;
  $18 = HEAP32[$15 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$18 >> 2] | 0) + 8 >> 2] & 15]($18, $17);
 }
 if ($changedUserTags & 1 | 0) {
  _prvTidyFreeDeclaredTags($doc, 1);
  $26 = $doc + 6856 | 0;
  $28 = _prvTidytmbstrdup(HEAP32[$26 >> 2] | 0, HEAP32[$doc + 400 >> 2] | 0) | 0;
  _prvTidyParseConfigValue($doc, 82, $28) | 0;
  $29 = HEAP32[$26 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$29 >> 2] | 0) + 8 >> 2] & 15]($29, $28);
 }
 if (!($changedUserTags & 8)) return;
 _prvTidyFreeDeclaredTags($doc, 8);
 $37 = $doc + 6856 | 0;
 $39 = _prvTidytmbstrdup(HEAP32[$37 >> 2] | 0, HEAP32[$doc + 404 >> 2] | 0) | 0;
 _prvTidyParseConfigValue($doc, 83, $39) | 0;
 $40 = HEAP32[$37 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$40 >> 2] | 0) + 8 >> 2] & 15]($40, $39);
 return;
}

function _PPrintEndTag($doc, $node$0$8$val) {
 $doc = $doc | 0;
 $node$0$8$val = $node$0$8$val | 0;
 var $0 = 0, $11 = 0, $12 = 0, $16 = 0, $17 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $4 = 0, $7 = 0, $8 = 0, $c = 0, $s$01 = 0, $s$01$us = 0, $s$1 = 0, $s$1$us = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 $0 = $doc + 6724 | 0;
 $2 = HEAP32[$doc + 188 >> 2] | 0;
 _AddString($0, 310894);
 if (!$node$0$8$val) {
  _AddChar($0, 62);
  STACKTOP = sp;
  return;
 }
 $4 = HEAP8[$node$0$8$val >> 0] | 0;
 if (!($4 << 24 >> 24)) {
  _AddChar($0, 62);
  STACKTOP = sp;
  return;
 }
 if (!$2) {
  $8 = $4;
  $s$01$us = $node$0$8$val;
  do {
   $7 = $8 & 255;
   HEAP32[$c >> 2] = $7;
   if ($8 << 24 >> 24 < 0) {
    $11 = $s$01$us + (_prvTidyGetUTF8($s$01$us, $c) | 0) | 0;
    $12 = HEAP32[$c >> 2] | 0;
    $s$1$us = $11;
   } else {
    $12 = $7;
    $s$1$us = $s$01$us;
   }
   _AddChar($0, $12);
   $s$01$us = $s$1$us + 1 | 0;
   $8 = HEAP8[$s$01$us >> 0] | 0;
  } while ($8 << 24 >> 24 != 0);
  _AddChar($0, 62);
  STACKTOP = sp;
  return;
 } else {
  $17 = $4;
  $s$01 = $node$0$8$val;
 }
 do {
  $16 = $17 & 255;
  HEAP32[$c >> 2] = $16;
  if ($17 << 24 >> 24 < 0) {
   $20 = $s$01 + (_prvTidyGetUTF8($s$01, $c) | 0) | 0;
   $22 = HEAP32[$c >> 2] | 0;
   $s$1 = $20;
  } else {
   $21 = _prvTidyToUpper($16) | 0;
   HEAP32[$c >> 2] = $21;
   $22 = $21;
   $s$1 = $s$01;
  }
  _AddChar($0, $22);
  $s$01 = $s$1 + 1 | 0;
  $17 = HEAP8[$s$01 >> 0] | 0;
 } while ($17 << 24 >> 24 != 0);
 _AddChar($0, 62);
 STACKTOP = sp;
 return;
}

function _ParseTabs($doc, $entry) {
 $doc = $doc | 0;
 $entry = $entry | 0;
 var $$0$i$i = 0, $$0$i3 = 0, $0 = 0, $11 = 0, $12 = 0, $17 = 0, $18 = 0, $config$idx$i = 0, $config$idx$val$i = 0, $flag$0$ph = 0;
 $0 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$0 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$0 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$0 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $11 = HEAP32[$0 >> 2] | 0;
 $12 = $11 | 32;
 L10 : do if (($11 | 0) == 49) $flag$0$ph = 1; else {
  switch ($12 | 0) {
  case 116:
  case 121:
   {
    $flag$0$ph = 1;
    break L10;
    break;
   }
  default:
   {}
  }
  if (($11 | 0) == 48) $flag$0$ph = 0; else {
   switch ($12 | 0) {
   case 102:
   case 110:
    {
     $flag$0$ph = 0;
     break L10;
     break;
    }
   default:
    {}
   }
   _prvTidyReportBadArgument($doc, HEAP32[$entry + 8 >> 2] | 0);
   $$0$i3 = 0;
   return $$0$i3 | 0;
  }
 } while (0);
 $17 = $flag$0$ph & 1;
 $18 = HEAP32[$entry >> 2] | 0;
 do if ($18 >>> 0 < 98) if ((HEAP32[1892 + ($18 << 5) + 12 >> 2] | 0) == 2) {
  HEAP32[$doc + 72 + ($18 << 2) >> 2] = $17;
  break;
 } else ___assert_fail(224203, 223800, 409, 224244); while (0);
 if (!$flag$0$ph) {
  $$0$i3 = 1;
  return $$0$i3 | 0;
 }
 HEAP32[$doc + 76 >> 2] = 1;
 $$0$i3 = 1;
 return $$0$i3 | 0;
}

function _DeclareUserTag($doc, $optId, $tagType, $name) {
 $doc = $doc | 0;
 $optId = $optId | 0;
 $tagType = $tagType | 0;
 $name = $name | 0;
 var $0 = 0, $1 = 0, $17 = 0, $23 = 0, $3 = 0, $34 = 0, $6 = 0, $9 = 0, $catval$0 = 0, $theval$0 = 0;
 $0 = $doc + 72 + ($optId << 2) | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) {
  $catval$0 = 0;
  $theval$0 = $name;
 } else {
  $3 = _prvTidytmbstrlen($name) | 0;
  $6 = $3 + 3 + (_prvTidytmbstrlen($1) | 0) | 0;
  $9 = _prvTidytmbstrndup(HEAP32[$doc + 6856 >> 2] | 0, $1, $6) | 0;
  _prvTidytmbstrcat($9, 225098) | 0;
  _prvTidytmbstrcat($9, $name) | 0;
  $catval$0 = $9;
  $theval$0 = $9;
 }
 _prvTidyDefineTag($doc, $tagType, $name);
 do if ($optId >>> 0 < 98) {
  if ((HEAP32[1892 + ($optId << 5) >> 2] | 0) != ($optId | 0)) ___assert_fail(224036, 223800, 383, 224086);
  if (HEAP32[1892 + ($optId << 5) + 12 >> 2] | 0) ___assert_fail(224036, 223800, 383, 224086);
  $17 = HEAP32[$0 >> 2] | 0;
  if ($17 | 0) if (($17 | 0) != (HEAP32[1892 + ($optId << 5) + 28 >> 2] | 0)) {
   $23 = HEAP32[$doc + 6856 >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$23 >> 2] | 0) + 8 >> 2] & 15]($23, $17);
  }
  if (!(_prvTidytmbstrlen($theval$0) | 0)) {
   HEAP32[$0 >> 2] = 0;
   break;
  } else {
   HEAP32[$0 >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, $theval$0) | 0;
   break;
  }
 } while (0);
 if (!$catval$0) return;
 $34 = HEAP32[$doc + 6856 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$34 >> 2] | 0) + 8 >> 2] & 15]($34, $catval$0);
 return;
}

function _prvTidyList2BQ($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0$idx$val = 0, $$01 = 0, $1 = 0, $18 = 0, $2 = 0, $26 = 0, $27 = 0, $3 = 0, $31 = 0, $5 = 0, $6 = 0, $child$01$i = 0, $child$02$i = 0;
 if (!$node) return;
 $1 = $doc + 6856 | 0;
 $$01 = $node;
 do {
  $2 = $$01 + 12 | 0;
  $3 = HEAP32[$2 >> 2] | 0;
  if ($3 | 0) _prvTidyList2BQ($doc, $3);
  $5 = $$01 + 28 | 0;
  $6 = HEAP32[$5 >> 2] | 0;
  if ($6 | 0) if ((HEAP32[$6 + 20 >> 2] | 0) == 30) {
   $$0$idx$val = HEAP32[$2 >> 2] | 0;
   if ($$0$idx$val | 0) if (!(HEAP32[$$0$idx$val + 8 >> 2] | 0)) if (HEAP32[$$0$idx$val + 60 >> 2] | 0) {
    $18 = $$0$idx$val + 12 | 0;
    HEAP32[$2 >> 2] = HEAP32[$18 >> 2];
    HEAP32[$$01 + 16 >> 2] = HEAP32[$$0$idx$val + 16 >> 2];
    HEAP32[$18 >> 2] = 0;
    _prvTidyFreeNode($doc, $$0$idx$val);
    $child$01$i = HEAP32[$2 >> 2] | 0;
    if ($child$01$i | 0) {
     $child$02$i = $child$01$i;
     do {
      HEAP32[$child$02$i >> 2] = $$01;
      $child$02$i = HEAP32[$child$02$i + 8 >> 2] | 0;
     } while (($child$02$i | 0) != 0);
    }
    $26 = _prvTidyLookupTagDef(15) | 0;
    $27 = HEAP32[$1 >> 2] | 0;
    $31 = $$01 + 32 | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$27 >> 2] | 0) + 8 >> 2] & 15]($27, HEAP32[$31 >> 2] | 0);
    HEAP32[$31 >> 2] = _prvTidytmbstrdup(HEAP32[$1 >> 2] | 0, HEAP32[$26 + 4 >> 2] | 0) | 0;
    HEAP32[$5 >> 2] = $26;
    HEAP32[$$01 + 60 >> 2] = 1;
   }
  }
  $$01 = HEAP32[$$01 + 8 >> 2] | 0;
 } while (($$01 | 0) != 0);
 return;
}

function _prvTidytmbsubstrn($s1, $len1, $s2) {
 $s1 = $s1 | 0;
 $len1 = $len1 | 0;
 $s2 = $s2 | 0;
 var $$0 = 0, $$01$i = 0, $$01$lcssa$i = 0, $$0110$i = 0, $$029$i = 0, $$038$i = 0, $12 = 0, $15 = 0, $20 = 0, $4 = 0, $7 = 0, $9 = 0, $ix$05 = 0, $len$02$i = 0, $len$1$i = 0, label = 0;
 if (!$s2) $len$1$i = 0; else if (!(HEAP8[$s2 >> 0] | 0)) $len$1$i = 0; else {
  $$01$i = $s2;
  $len$02$i = 0;
  while (1) {
   $$01$i = $$01$i + 1 | 0;
   $4 = $len$02$i + 1 | 0;
   if (!(HEAP8[$$01$i >> 0] | 0)) {
    $len$1$i = $4;
    break;
   } else $len$02$i = $4;
  }
 }
 $7 = $len1 - $len$1$i | 0;
 if (($7 | 0) < 0) {
  $$0 = 0;
  return $$0 | 0;
 }
 $9 = HEAP8[$s2 >> 0] | 0;
 $ix$05 = 0;
 L9 : while (1) {
  $12 = $s1 + $ix$05 | 0;
  if ((HEAP8[$12 >> 0] | 0) == $9 << 24 >> 24) {
   $$0110$i = $len$1$i;
   $$029$i = $s2;
   $$038$i = $12;
   $15 = $9;
   while (1) {
    if ($15 << 24 >> 24 == 0 | ($$0110$i | 0) == 0) {
     $$0 = $12;
     label = 11;
     break L9;
    }
    $$038$i = $$038$i + 1 | 0;
    $$029$i = $$029$i + 1 | 0;
    $20 = $$0110$i + -1 | 0;
    $15 = HEAP8[$$038$i >> 0] | 0;
    if ($15 << 24 >> 24 != (HEAP8[$$029$i >> 0] | 0)) {
     $$01$lcssa$i = $20;
     break;
    } else $$0110$i = $20;
   }
  } else $$01$lcssa$i = $len$1$i;
  if (!$$01$lcssa$i) {
   $$0 = $12;
   label = 11;
   break;
  }
  if (($ix$05 | 0) < ($7 | 0)) $ix$05 = $ix$05 + 1 | 0; else {
   $$0 = 0;
   label = 11;
   break;
  }
 }
 if ((label | 0) == 11) return $$0 | 0;
 return 0;
}

function _prvTidyRepairAttrValue($doc, $node, $name, $value) {
 $doc = $doc | 0;
 $node = $node | 0;
 $name = $name | 0;
 $value = $value | 0;
 var $$0 = 0, $$sink$i = 0, $12 = 0, $20 = 0, $22 = 0, $3 = 0, $8 = 0, $9 = 0, $attr$01$i = 0, $attr$02$i = 0, $attr$02$i$lcssa = 0, $storemerge = 0;
 $attr$01$i = HEAP32[$node + 20 >> 2] | 0;
 L1 : do if ($attr$01$i | 0) {
  $attr$02$i = $attr$01$i;
  while (1) {
   $3 = HEAP32[$attr$02$i + 20 >> 2] | 0;
   if ($3 | 0) if (!(_prvTidytmbstrcmp($3, $name) | 0)) {
    $attr$02$i$lcssa = $attr$02$i;
    break;
   }
   $attr$02$i = HEAP32[$attr$02$i >> 2] | 0;
   if (!$attr$02$i) break L1;
  }
  $8 = $attr$02$i$lcssa + 24 | 0;
  $9 = HEAP32[$8 >> 2] | 0;
  if ($9 | 0) {
   $12 = HEAP32[$doc + 6856 >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$12 >> 2] | 0) + 8 >> 2] & 15]($12, $9);
  }
  if (!$value) $storemerge = 0; else $storemerge = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, $value) | 0;
  HEAP32[$8 >> 2] = $storemerge;
  $$0 = $attr$02$i$lcssa;
  return $$0 | 0;
 } while (0);
 $20 = _prvTidyNewAttribute($doc) | 0;
 HEAP32[$20 + 16 >> 2] = 34;
 $22 = $doc + 6856 | 0;
 HEAP32[$20 + 20 >> 2] = _prvTidytmbstrdup(HEAP32[$22 >> 2] | 0, $name) | 0;
 if (!$value) $$sink$i = 0; else $$sink$i = _prvTidytmbstrdup(HEAP32[$22 >> 2] | 0, $value) | 0;
 HEAP32[$20 + 24 >> 2] = $$sink$i;
 HEAP32[$20 + 4 >> 2] = _attrsLookup($doc, $doc + 1596 | 0, $name) | 0;
 _prvTidyInsertAttributeAtEnd($node, $20);
 $$0 = $20;
 return $$0 | 0;
}

function _ParseAutoBool($doc, $entry) {
 $doc = $doc | 0;
 $entry = $entry | 0;
 var $$0$i$i = 0, $$0$i3 = 0, $0 = 0, $11 = 0, $12 = 0, $18 = 0, $config$idx$i = 0, $config$idx$val$i = 0, $flag$0$ph = 0;
 $0 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$0 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$0 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$0 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $11 = HEAP32[$0 >> 2] | 0;
 $12 = $11 | 32;
 L10 : do if (($11 | 0) == 49) $flag$0$ph = 1; else {
  switch ($12 | 0) {
  case 116:
  case 121:
   {
    $flag$0$ph = 1;
    break L10;
    break;
   }
  default:
   {}
  }
  if (($11 | 0) == 48) $flag$0$ph = 0; else {
   switch ($12 | 0) {
   case 102:
   case 110:
    {
     $flag$0$ph = 0;
     break L10;
     break;
    }
   default:
    {}
   }
   if (($12 | 0) == 97) $flag$0$ph = 2; else {
    _prvTidyReportBadArgument($doc, HEAP32[$entry + 8 >> 2] | 0);
    $$0$i3 = 0;
    return $$0$i3 | 0;
   }
  }
 } while (0);
 $18 = HEAP32[$entry >> 2] | 0;
 if ($18 >>> 0 >= 98) {
  $$0$i3 = 1;
  return $$0$i3 | 0;
 }
 if ((HEAP32[1892 + ($18 << 5) + 12 >> 2] | 0) != 1) ___assert_fail(223759, 223800, 398, 223889);
 HEAP32[$doc + 72 + ($18 << 2) >> 2] = $flag$0$ph;
 $$0$i3 = 1;
 return $$0$i3 | 0;
}

function _IsImage($iType) {
 $iType = $iType | 0;
 var $$0 = 0, $$lcssa7 = 0, $0 = 0, $1 = 0, $ext = 0, $i$0$in$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $ext = sp;
 $0 = _prvTidytmbstrlen($iType) | 0;
 HEAP8[$ext >> 0] = 0;
 $i$0$in$i = $0;
 L1 : do {
  $i$0$in$i = $i$0$in$i + -1 | 0;
  $1 = $iType + $i$0$in$i | 0;
  switch (HEAP8[$1 >> 0] | 0) {
  case 92:
  case 47:
   {
    break L1;
    break;
   }
  case 46:
   {
    $$lcssa7 = $1;
    label = 3;
    break L1;
    break;
   }
  default:
   {}
  }
 } while (($i$0$in$i | 0) > 1);
 if ((label | 0) == 3) _prvTidytmbstrncpy($ext, $$lcssa7, 20) | 0;
 if (!(_prvTidytmbstrcasecmp($ext, 312010) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 311986) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312015) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312020) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312025) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312030) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312035) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312040) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312045) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312050) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312055) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312061) | 0)) $$0 = 1; else $$0 = (_prvTidytmbstrcasecmp($ext, 312067) | 0) == 0 & 1;
 STACKTOP = sp;
 return $$0 | 0;
}

function ___strchrnul($s, $c) {
 $s = $s | 0;
 $c = $c | 0;
 var $$0 = 0, $$02$lcssa = 0, $$0211 = 0, $$1 = 0, $0 = 0, $11 = 0, $15 = 0, $16 = 0, $22 = 0, $23 = 0, $29 = 0, $36 = 0, $37 = 0, $5 = 0, $8 = 0, $w$0$lcssa = 0, $w$08 = 0;
 $0 = $c & 255;
 L1 : do if (!$0) $$0 = $s + (_strlen($s) | 0) | 0; else {
  if (!($s & 3)) $$02$lcssa = $s; else {
   $5 = $c & 255;
   $$0211 = $s;
   while (1) {
    $8 = HEAP8[$$0211 >> 0] | 0;
    if ($8 << 24 >> 24 == 0 ? 1 : $8 << 24 >> 24 == $5 << 24 >> 24) {
     $$0 = $$0211;
     break L1;
    }
    $11 = $$0211 + 1 | 0;
    if (!($11 & 3)) {
     $$02$lcssa = $11;
     break;
    } else $$0211 = $11;
   }
  }
  $15 = Math_imul($0, 16843009) | 0;
  $16 = HEAP32[$$02$lcssa >> 2] | 0;
  L10 : do if (!(($16 & -2139062144 ^ -2139062144) & $16 + -16843009)) {
   $23 = $16;
   $w$08 = $$02$lcssa;
   while (1) {
    $22 = $23 ^ $15;
    if (($22 & -2139062144 ^ -2139062144) & $22 + -16843009 | 0) {
     $w$0$lcssa = $w$08;
     break L10;
    }
    $29 = $w$08 + 4 | 0;
    $23 = HEAP32[$29 >> 2] | 0;
    if (($23 & -2139062144 ^ -2139062144) & $23 + -16843009 | 0) {
     $w$0$lcssa = $29;
     break;
    } else $w$08 = $29;
   }
  } else $w$0$lcssa = $$02$lcssa; while (0);
  $36 = $c & 255;
  $$1 = $w$0$lcssa;
  while (1) {
   $37 = HEAP8[$$1 >> 0] | 0;
   if ($37 << 24 >> 24 == 0 ? 1 : $37 << 24 >> 24 == $36 << 24 >> 24) {
    $$0 = $$1;
    break;
   } else $$1 = $$1 + 1 | 0;
  }
 } while (0);
 return $$0 | 0;
}

function _PruneSection($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$02 = 0, $$13 = 0, $$13$lcssa11 = 0, $$2 = 0, $1 = 0, $11 = 0, $2 = 0, $29 = 0, $check$01$i = 0, label = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $2 = $1 + 84 | 0;
 $$02 = $node;
 while (1) {
  L3 : do if (!(($$02 | 0) == 0 | (_prvTidytmbstrncmp((HEAP32[$2 >> 2] | 0) + (HEAP32[$$02 + 36 >> 2] | 0) | 0, 311428, 21) | 0) != 0)) {
   $check$01$i = $$02;
   while (1) {
    $11 = HEAP32[$check$01$i + 28 >> 2] | 0;
    if ($11 | 0) if ((HEAP32[$11 >> 2] | 0) == 109) break;
    $check$01$i = HEAP32[$check$01$i >> 2] | 0;
    if (!$check$01$i) break L3;
   }
   _prvTidyInsertNodeBeforeElement($$02, _prvTidyNewLiteralTextNode($1, 311450) | 0);
  } while (0);
  if ((HEAP32[$$02 + 44 >> 2] | 0) == 4) $$13 = HEAP32[$$02 + 8 >> 2] | 0; else $$13 = _prvTidyDiscardElement($doc, $$02) | 0;
  if (!$$13) {
   $$2 = 0;
   label = 16;
   break;
  }
  if ((HEAP32[$$13 + 44 >> 2] | 0) != 9) {
   $$02 = $$13;
   continue;
  }
  $29 = $$13 + 36 | 0;
  if (!(_prvTidytmbstrncmp((HEAP32[$2 >> 2] | 0) + (HEAP32[$29 >> 2] | 0) | 0, 311417, 2) | 0)) {
   $$02 = _PruneSection($doc, $$13) | 0;
   continue;
  } else if (!(_prvTidytmbstrncmp((HEAP32[$2 >> 2] | 0) + (HEAP32[$29 >> 2] | 0) | 0, 311452, 5) | 0)) {
   $$13$lcssa11 = $$13;
   break;
  } else {
   $$02 = $$13;
   continue;
  }
 }
 if ((label | 0) == 16) return $$2 | 0;
 $$2 = _prvTidyDiscardElement($doc, $$13$lcssa11) | 0;
 return $$2 | 0;
}

function _CheckAttrValidity($doc, $node, $attval, $list) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 $list = $list | 0;
 var $1 = 0, $10 = 0, $15 = 0, $2 = 0, $24 = 0, $26 = 0, $28 = 0, $4 = 0, $p$01$i = 0, $v$01$i = 0, label = 0;
 if ($attval | 0) {
  $1 = $attval + 24 | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  if ($2 | 0) {
   $4 = HEAP8[$2 >> 0] | 0;
   L4 : do if ($4 << 24 >> 24) {
    $10 = $4;
    $p$01$i = $2;
    while (1) {
     $p$01$i = $p$01$i + 1 | 0;
     if (_prvTidyIsUpper($10 << 24 >> 24) | 0) break;
     $10 = HEAP8[$p$01$i >> 0] | 0;
     if (!($10 << 24 >> 24)) break L4;
    }
    $15 = (HEAP32[$doc + 68 >> 2] | 0) + 28 | 0;
    if (!(HEAP32[$15 >> 2] | 0)) label = 9; else {
     _prvTidyReportAttrError($doc, $node, $attval, 269);
     if (!(HEAP32[$15 >> 2] | 0)) label = 9;
    }
    if ((label | 0) == 9) if (!(HEAP32[$doc + 336 >> 2] | 0)) break;
    HEAP32[$1 >> 2] = _prvTidytmbstrtolower(HEAP32[$1 >> 2] | 0) | 0;
   } while (0);
   $24 = HEAP32[$list >> 2] | 0;
   L15 : do if ($24 | 0) {
    $28 = $24;
    $v$01$i = $list;
    while (1) {
     $26 = HEAP32[$1 >> 2] | 0;
     if ($26 | 0) if (!(_prvTidytmbstrcasecmp($26, $28) | 0)) break;
     $v$01$i = $v$01$i + 4 | 0;
     $28 = HEAP32[$v$01$i >> 2] | 0;
     if (!$28) break L15;
    }
    return;
   } while (0);
   _prvTidyReportAttrError($doc, $node, $attval, 251);
   return;
  }
 }
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 return;
}

function _strcspn($s, $c) {
 $s = $s | 0;
 $c = $c | 0;
 var $$0 = 0, $$027 = 0, $$03$lcssa = 0, $$035 = 0, $0 = 0, $10 = 0, $13 = 0, $17 = 0, $23 = 0, $32 = 0, $byteset = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $byteset = sp;
 $0 = HEAP8[$c >> 0] | 0;
 if (!($0 << 24 >> 24)) label = 3; else if (!(HEAP8[$c + 1 >> 0] | 0)) label = 3; else {
  HEAP32[$byteset >> 2] = 0;
  HEAP32[$byteset + 4 >> 2] = 0;
  HEAP32[$byteset + 8 >> 2] = 0;
  HEAP32[$byteset + 12 >> 2] = 0;
  HEAP32[$byteset + 16 >> 2] = 0;
  HEAP32[$byteset + 20 >> 2] = 0;
  HEAP32[$byteset + 24 >> 2] = 0;
  HEAP32[$byteset + 28 >> 2] = 0;
  $$027 = $c;
  $13 = $0;
  do {
   $17 = $byteset + ((($13 & 255) >>> 5 & 255) << 2) | 0;
   HEAP32[$17 >> 2] = HEAP32[$17 >> 2] | 1 << ($13 & 31);
   $$027 = $$027 + 1 | 0;
   $13 = HEAP8[$$027 >> 0] | 0;
  } while ($13 << 24 >> 24 != 0);
  $10 = HEAP8[$s >> 0] | 0;
  L7 : do if (!($10 << 24 >> 24)) $$03$lcssa = $s; else {
   $$035 = $s;
   $23 = $10;
   while (1) {
    if (HEAP32[$byteset + ((($23 & 255) >>> 5 & 255) << 2) >> 2] & 1 << ($23 & 31) | 0) {
     $$03$lcssa = $$035;
     break L7;
    }
    $32 = $$035 + 1 | 0;
    $23 = HEAP8[$32 >> 0] | 0;
    if (!($23 << 24 >> 24)) {
     $$03$lcssa = $32;
     break;
    } else $$035 = $32;
   }
  } while (0);
  $$0 = $$03$lcssa - $s | 0;
 }
 if ((label | 0) == 3) $$0 = (___strchrnul($s, $0 << 24 >> 24) | 0) - $s | 0;
 STACKTOP = sp;
 return $$0 | 0;
}

function _ParseTagName($doc) {
 $doc = $doc | 0;
 var $$lcssa = 0, $1 = 0, $11 = 0, $16 = 0, $18 = 0, $20 = 0, $26 = 0, $29 = 0, $6 = 0, $7 = 0, $8 = 0, $c$0 = 0, $phitmp$i9 = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $6 = (HEAP32[$1 + 84 >> 2] | 0) + (HEAP32[$1 + 48 >> 2] | 0) | 0;
 $7 = HEAP8[$6 >> 0] | 0;
 $8 = $7 << 24 >> 24;
 $11 = (HEAP32[$doc + 168 >> 2] | 0) != 0;
 if ($7 << 24 >> 24 > -1 & ($11 ^ 1)) if (HEAP32[316488 + ($8 << 2) >> 2] & 64 | 0) HEAP8[$6 >> 0] = $8 + 32;
 $16 = $doc + 6776 | 0;
 $18 = _prvTidyReadChar(HEAP32[$16 >> 2] | 0) | 0;
 L5 : do if (($18 | 0) == -1) $$lcssa = -1; else {
  if ($11) {
   $20 = $18;
   while (1) {
    if (!(_prvTidyIsXMLNamechar($20) | 0)) {
     $$lcssa = $20;
     break L5;
    }
    _prvTidyAddCharToLexer($1, $20);
    $20 = _prvTidyReadChar(HEAP32[$16 >> 2] | 0) | 0;
    if (($20 | 0) == -1) {
     $$lcssa = -1;
     break L5;
    }
   }
  } else $26 = $18;
  while (1) {
   if ($26 >>> 0 >= 128) {
    $$lcssa = $26;
    break L5;
   }
   $29 = HEAP32[316488 + ($26 << 2) >> 2] | 0;
   if (!($29 & 4)) {
    $$lcssa = $26;
    break L5;
   }
   $phitmp$i9 = $29 & 64;
   if (!$phitmp$i9) $c$0 = $26; else $c$0 = $phitmp$i9 | 0 ? $26 + 32 | 0 : $26;
   _prvTidyAddCharToLexer($1, $c$0);
   $26 = _prvTidyReadChar(HEAP32[$16 >> 2] | 0) | 0;
   if (($26 | 0) == -1) {
    $$lcssa = -1;
    break;
   }
  }
 } while (0);
 HEAP32[$1 + 52 >> 2] = HEAP32[$1 + 92 >> 2];
 return $$lcssa & 255 | 0;
}

function ___fwritex($s, $l, $f) {
 $s = $s | 0;
 $l = $l | 0;
 $f = $f | 0;
 var $$0 = 0, $$01 = 0, $$02 = 0, $0 = 0, $1 = 0, $11 = 0, $19 = 0, $29 = 0, $6 = 0, $7 = 0, $9 = 0, $i$0 = 0, $i$0$lcssa12 = 0, $i$1 = 0, label = 0;
 $0 = $f + 16 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) if (!(___towrite($f) | 0)) {
  $9 = HEAP32[$0 >> 2] | 0;
  label = 5;
 } else $$0 = 0; else {
  $9 = $1;
  label = 5;
 }
 L5 : do if ((label | 0) == 5) {
  $6 = $f + 20 | 0;
  $7 = HEAP32[$6 >> 2] | 0;
  $11 = $7;
  if (($9 - $7 | 0) >>> 0 < $l >>> 0) {
   $$0 = FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 15]($f, $s, $l) | 0;
   break;
  }
  L10 : do if ((HEAP8[$f + 75 >> 0] | 0) > -1) {
   $i$0 = $l;
   while (1) {
    if (!$i$0) {
     $$01 = $l;
     $$02 = $s;
     $29 = $11;
     $i$1 = 0;
     break L10;
    }
    $19 = $i$0 + -1 | 0;
    if ((HEAP8[$s + $19 >> 0] | 0) == 10) {
     $i$0$lcssa12 = $i$0;
     break;
    } else $i$0 = $19;
   }
   if ((FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 15]($f, $s, $i$0$lcssa12) | 0) >>> 0 < $i$0$lcssa12 >>> 0) {
    $$0 = $i$0$lcssa12;
    break L5;
   }
   $$01 = $l - $i$0$lcssa12 | 0;
   $$02 = $s + $i$0$lcssa12 | 0;
   $29 = HEAP32[$6 >> 2] | 0;
   $i$1 = $i$0$lcssa12;
  } else {
   $$01 = $l;
   $$02 = $s;
   $29 = $11;
   $i$1 = 0;
  } while (0);
  _memcpy($29 | 0, $$02 | 0, $$01 | 0) | 0;
  HEAP32[$6 >> 2] = (HEAP32[$6 >> 2] | 0) + $$01;
  $$0 = $i$1 + $$01 | 0;
 } while (0);
 return $$0 | 0;
}

function _prvTidyAddStyleProperty($doc, $node, $property) {
 $doc = $doc | 0;
 $node = $node | 0;
 $property = $property | 0;
 var $$01$i$i = 0, $$pre = 0, $0 = 0, $11 = 0, $16 = 0, $2 = 0, $22 = 0, $27 = 0, $3 = 0, $6 = 0, $7 = 0, $$01$i$i$looptemp = 0;
 $0 = _prvTidyAttrGetById($node, 143) | 0;
 if (!$0) {
  _prvTidyInsertAttributeAtStart($node, _prvTidyNewAttributeEx($doc, 310951, $property, 34) | 0);
  return;
 }
 $2 = $0 + 24 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 if (!$3) {
  HEAP32[$2 >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, $property) | 0;
  return;
 }
 $6 = _CreateProps($doc, _CreateProps($doc, 0, $3) | 0, $property) | 0;
 $7 = _CreatePropString($doc, $6) | 0;
 $$pre = $doc + 6856 | 0;
 if ($6 | 0) {
  $$01$i$i = $6;
  do {
   $$01$i$i$looptemp = $$01$i$i;
   $$01$i$i = HEAP32[$$01$i$i + 8 >> 2] | 0;
   $11 = HEAP32[$$pre >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$11 >> 2] | 0) + 8 >> 2] & 15]($11, HEAP32[$$01$i$i$looptemp >> 2] | 0);
   $16 = HEAP32[$$pre >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$16 >> 2] | 0) + 8 >> 2] & 15]($16, HEAP32[$$01$i$i$looptemp + 4 >> 2] | 0);
   $22 = HEAP32[$$pre >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$22 >> 2] | 0) + 8 >> 2] & 15]($22, $$01$i$i$looptemp);
  } while (($$01$i$i | 0) != 0);
 }
 $27 = HEAP32[$$pre >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$27 >> 2] | 0) + 8 >> 2] & 15]($27, HEAP32[$2 >> 2] | 0);
 HEAP32[$2 >> 2] = $7;
 return;
}

function _prvTidyAttributeIsProprietary($node, $attval) {
 $node = $node | 0;
 $attval = $attval | 0;
 var $$0 = 0, $$0$i = 0, $10 = 0, $15 = 0, $17 = 0, $2 = 0, $20 = 0, $22 = 0, $24 = 0, $25 = 0, $3 = 0, $i$03$i = 0, $i$03$i$lcssa = 0, label = 0;
 if (!(($node | 0) != 0 & ($attval | 0) != 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $2 = $node + 28 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 if (!$3) {
  $$0 = 0;
  return $$0 | 0;
 }
 if (!(HEAP32[$3 + 8 >> 2] & 401407)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $10 = HEAP32[$attval + 20 >> 2] | 0;
 if (!$10) label = 6; else if (!(_prvTidytmbstrncmp($10, 304457, 5) | 0)) $$0$i = 0; else label = 6;
 L12 : do if ((label | 0) == 6) {
  $15 = HEAP32[$attval + 4 >> 2] | 0;
  if (!$15) $$0$i = 1; else {
   $17 = HEAP32[$2 >> 2] | 0;
   if (!$17) $$0$i = 1; else {
    $20 = HEAP32[$17 + 12 >> 2] | 0;
    if (!$20) $$0$i = 1; else {
     $22 = HEAP32[$20 >> 2] | 0;
     if (!$22) $$0$i = 1; else {
      $24 = HEAP32[$15 >> 2] | 0;
      $25 = $22;
      $i$03$i = 0;
      while (1) {
       if (($25 | 0) == ($24 | 0)) {
        $i$03$i$lcssa = $i$03$i;
        break;
       }
       $i$03$i = $i$03$i + 1 | 0;
       $25 = HEAP32[$20 + ($i$03$i << 3) >> 2] | 0;
       if (!$25) {
        $$0$i = 1;
        break L12;
       }
      }
      $$0$i = (HEAP32[$20 + ($i$03$i$lcssa << 3) + 4 >> 2] & 401407 | 0) == 0;
     }
    }
   }
  }
 } while (0);
 $$0 = $$0$i & 1;
 return $$0 | 0;
}

function _ParseBool($doc, $entry) {
 $doc = $doc | 0;
 $entry = $entry | 0;
 var $$0$i$i = 0, $$0$i3 = 0, $0 = 0, $11 = 0, $12 = 0, $17 = 0, $config$idx$i = 0, $config$idx$val$i = 0, $flag$0$ph = 0;
 $0 = $doc + 868 | 0;
 L1 : do if (_prvTidyIsWhite(HEAP32[$0 >> 2] | 0) | 0) {
  $config$idx$i = $doc + 872 | 0;
  do {
   if (_prvTidyIsNewline(HEAP32[$0 >> 2] | 0) | 0) break L1;
   $config$idx$val$i = HEAP32[$config$idx$i >> 2] | 0;
   if (!$config$idx$val$i) $$0$i$i = -1; else $$0$i$i = _prvTidyReadChar($config$idx$val$i) | 0;
   HEAP32[$0 >> 2] = $$0$i$i;
  } while ((_prvTidyIsWhite($$0$i$i) | 0) != 0);
 } while (0);
 $11 = HEAP32[$0 >> 2] | 0;
 $12 = $11 | 32;
 L10 : do if (($11 | 0) == 49) $flag$0$ph = 1; else {
  switch ($12 | 0) {
  case 116:
  case 121:
   {
    $flag$0$ph = 1;
    break L10;
    break;
   }
  default:
   {}
  }
  if (($11 | 0) == 48) $flag$0$ph = 0; else {
   switch ($12 | 0) {
   case 102:
   case 110:
    {
     $flag$0$ph = 0;
     break L10;
     break;
    }
   default:
    {}
   }
   _prvTidyReportBadArgument($doc, HEAP32[$entry + 8 >> 2] | 0);
   $$0$i3 = 0;
   return $$0$i3 | 0;
  }
 } while (0);
 $17 = HEAP32[$entry >> 2] | 0;
 if ($17 >>> 0 >= 98) {
  $$0$i3 = 1;
  return $$0$i3 | 0;
 }
 if ((HEAP32[1892 + ($17 << 5) + 12 >> 2] | 0) != 2) ___assert_fail(224203, 223800, 409, 224244);
 HEAP32[$doc + 72 + ($17 << 2) >> 2] = $flag$0$ph;
 $$0$i3 = 1;
 return $$0$i3 | 0;
}

function _prvTidyResetConfigToDefault($doc) {
 $doc = $doc | 0;
 var $$sink$i = 0, $0 = 0, $13 = 0, $17 = 0, $3 = 0, $5 = 0, $7 = 0, $8 = 0, $9 = 0, $ixVal$02 = 0, $option$01 = 0, label = 0;
 $0 = $doc + 6856 | 0;
 $ixVal$02 = 0;
 $option$01 = 1892;
 while (1) {
  if (($ixVal$02 | 0) != (HEAP32[$option$01 >> 2] | 0)) {
   label = 3;
   break;
  }
  $3 = $option$01 + 12 | 0;
  $5 = (HEAP32[$3 >> 2] | 0) == 0;
  $7 = $option$01 + 28 | 0;
  $$sink$i = HEAP32[($5 ? $7 : $option$01 + 16 | 0) >> 2] | 0;
  $8 = $doc + 72 + ($ixVal$02 << 2) | 0;
  do if ($5) {
   $9 = HEAP32[$8 >> 2] | 0;
   if ($9 | 0) if (($9 | 0) != (HEAP32[$7 >> 2] | 0)) {
    $13 = HEAP32[$0 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$13 >> 2] | 0) + 8 >> 2] & 15]($13, $9);
    if (HEAP32[$3 >> 2] | 0) {
     label = 12;
     break;
    }
   }
   $17 = $$sink$i;
   if ($$sink$i | 0) if (($17 | 0) != (HEAP32[$7 >> 2] | 0)) {
    HEAP32[$8 >> 2] = _prvTidytmbstrdup(HEAP32[$0 >> 2] | 0, $17) | 0;
    break;
   }
   HEAP32[$8 >> 2] = $$sink$i;
  } else label = 12; while (0);
  if ((label | 0) == 12) {
   label = 0;
   HEAP32[$8 >> 2] = $$sink$i;
  }
  $ixVal$02 = $ixVal$02 + 1 | 0;
  if ($ixVal$02 >>> 0 >= 98) {
   label = 14;
   break;
  } else $option$01 = $option$01 + 32 | 0;
 }
 if ((label | 0) == 3) ___assert_fail(225459, 223800, 526, 225486); else if ((label | 0) == 14) {
  _prvTidyFreeDeclaredTags($doc, 0);
  return;
 }
}

function _prvTidyReportFatal($doc, $element, $node, $code) {
 $doc = $doc | 0;
 $element = $element | 0;
 $node = $node | 0;
 $code = $code | 0;
 var $2 = 0, $6 = 0, $nodedesc = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer8 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 288 | 0;
 $vararg_buffer8 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $nodedesc = sp + 32 | 0;
 _memset($nodedesc | 0, 0, 256) | 0;
 $2 = _tidyLocalizedString($code) | 0;
 switch ($code | 0) {
 case 218:
 case 216:
  {
   HEAP32[$vararg_buffer >> 2] = $2;
   _messageNode($doc, 4, $code, $element | 0 ? $element : $node, 223602, $vararg_buffer);
   STACKTOP = sp;
   return;
  }
 case 222:
  {
   _TagToString($node, $nodedesc, 256);
   HEAP32[$vararg_buffer1 >> 2] = $nodedesc;
   _messageNode($doc, 4, 222, $node, $2, $vararg_buffer1);
   STACKTOP = sp;
   return;
  }
 case 247:
  {
   $6 = HEAP32[$element + 32 >> 2] | 0;
   HEAP32[$vararg_buffer4 >> 2] = HEAP32[$node + 32 >> 2];
   HEAP32[$vararg_buffer4 + 4 >> 2] = $6;
   _messageNode($doc, 4, 247, $node, $2, $vararg_buffer4);
   STACKTOP = sp;
   return;
  }
 case 213:
  {
   HEAP32[$vararg_buffer8 >> 2] = HEAP32[$node + 32 >> 2];
   _messageNode($doc, 4, 213, $node, $2, $vararg_buffer8);
   STACKTOP = sp;
   return;
  }
 default:
  {
   STACKTOP = sp;
   return;
  }
 }
}

function ___shgetc($f) {
 $f = $f | 0;
 var $$0 = 0, $$phi$trans$insert3 = 0, $$pre = 0, $0 = 0, $1 = 0, $13 = 0, $18 = 0, $20 = 0, $25 = 0, $27 = 0, $29 = 0, $35 = 0, $36 = 0, $41 = 0, $6 = 0, $9 = 0, label = 0;
 $0 = $f + 104 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) label = 3; else if ((HEAP32[$f + 108 >> 2] | 0) < ($1 | 0)) label = 3; else label = 4;
 if ((label | 0) == 3) {
  $6 = ___uflow($f) | 0;
  if (($6 | 0) < 0) label = 4; else {
   $9 = HEAP32[$0 >> 2] | 0;
   $$pre = HEAP32[$f + 8 >> 2] | 0;
   if (!$9) {
    $41 = $$pre;
    label = 9;
   } else {
    $13 = HEAP32[$f + 4 >> 2] | 0;
    $18 = $9 - (HEAP32[$f + 108 >> 2] | 0) | 0;
    $20 = $$pre;
    if (($$pre - $13 | 0) < ($18 | 0)) {
     $41 = $20;
     label = 9;
    } else {
     HEAP32[$f + 100 >> 2] = $13 + ($18 + -1);
     $25 = $20;
    }
   }
   if ((label | 0) == 9) {
    HEAP32[$f + 100 >> 2] = $$pre;
    $25 = $41;
   }
   $$phi$trans$insert3 = $f + 4 | 0;
   if (!$25) $36 = HEAP32[$$phi$trans$insert3 >> 2] | 0; else {
    $27 = HEAP32[$$phi$trans$insert3 >> 2] | 0;
    $29 = $f + 108 | 0;
    HEAP32[$29 >> 2] = $25 + 1 - $27 + (HEAP32[$29 >> 2] | 0);
    $36 = $27;
   }
   $35 = $36 + -1 | 0;
   if ((HEAPU8[$35 >> 0] | 0 | 0) == ($6 | 0)) $$0 = $6; else {
    HEAP8[$35 >> 0] = $6;
    $$0 = $6;
   }
  }
 }
 if ((label | 0) == 4) {
  HEAP32[$f + 100 >> 2] = 0;
  $$0 = -1;
 }
 return $$0 | 0;
}

function _prvTidyDefineTag($doc, $tagType, $name) {
 $doc = $doc | 0;
 $tagType = $tagType | 0;
 $name = $name | 0;
 var $12 = 0, $13 = 0, $19 = 0, $2 = 0, $4 = 0, $5 = 0, $8 = 0, $cm$0 = 0, $np$0$i = 0, $parser$0 = 0;
 switch ($tagType | 0) {
 case 1:
  {
   $cm$0 = 1310721;
   $parser$0 = 25;
   break;
  }
 case 2:
  {
   $cm$0 = 1310736;
   $parser$0 = 26;
   break;
  }
 case 4:
  {
   $cm$0 = 1310728;
   $parser$0 = 25;
   break;
  }
 case 8:
  {
   $cm$0 = 1310728;
   $parser$0 = 35;
   break;
  }
 default:
  return;
 }
 if (!$name) return;
 $2 = _tagsLookup($doc, $doc + 876 | 0, $name) | 0;
 if (!$2) {
  $4 = $doc + 6856 | 0;
  $5 = HEAP32[$4 >> 2] | 0;
  $8 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$5 >> 2] >> 2] & 31]($5, 32) | 0;
  HEAP32[$8 >> 2] = 0;
  HEAP32[$8 + 4 >> 2] = _prvTidytmbstrdup(HEAP32[$4 >> 2] | 0, $name) | 0;
  $12 = $8 + 8 | 0;
  HEAP32[$12 >> 2] = 0;
  HEAP32[$12 + 4 >> 2] = 0;
  HEAP32[$12 + 8 >> 2] = 0;
  HEAP32[$12 + 12 >> 2] = 0;
  HEAP32[$12 + 16 >> 2] = 0;
  $13 = $doc + 880 | 0;
  HEAP32[$8 + 28 >> 2] = HEAP32[$13 >> 2];
  HEAP32[$13 >> 2] = $8;
  $np$0$i = $8;
 } else $np$0$i = $2;
 if (HEAP32[$np$0$i >> 2] | 0) return;
 HEAP32[$np$0$i + 8 >> 2] = 57344;
 $19 = $np$0$i + 16 | 0;
 HEAP32[$19 >> 2] = HEAP32[$19 >> 2] | $cm$0;
 HEAP32[$np$0$i + 20 >> 2] = $parser$0;
 HEAP32[$np$0$i + 24 >> 2] = 0;
 HEAP32[$np$0$i + 12 >> 2] = 0;
 return;
}

function _StripSpan($doc, $span) {
 $doc = $doc | 0;
 $span = $span | 0;
 var $0 = 0, $11 = 0, $14 = 0, $2 = 0, $4 = 0, $8 = 0, $content$0$ph = 0, $content$02 = 0, $prev$0$lcssa = 0, $prev$0$ph = 0, $prev$01 = 0, $prev$01$phi = 0, label = 0;
 $0 = $span + 12 | 0;
 _prvTidyCleanWord2000($doc, HEAP32[$0 >> 2] | 0);
 $2 = HEAP32[$0 >> 2] | 0;
 $4 = HEAP32[$span + 4 >> 2] | 0;
 if (!$4) if (!$2) $prev$0$lcssa = 0; else {
  $8 = HEAP32[$2 + 8 >> 2] | 0;
  _prvTidyRemoveNode($2) | 0;
  _prvTidyInsertNodeBeforeElement($span, $2);
  $content$0$ph = $8;
  $prev$0$ph = $2;
  label = 4;
 } else {
  $content$0$ph = $2;
  $prev$0$ph = $4;
  label = 4;
 }
 if ((label | 0) == 4) if (!$content$0$ph) $prev$0$lcssa = $prev$0$ph; else {
  $content$02 = $content$0$ph;
  $prev$01 = $prev$0$ph;
  while (1) {
   $11 = HEAP32[$content$02 + 8 >> 2] | 0;
   _prvTidyRemoveNode($content$02) | 0;
   _prvTidyInsertNodeAfterElement($prev$01, $content$02);
   if (!$11) {
    $prev$0$lcssa = $content$02;
    break;
   } else {
    $prev$01$phi = $content$02;
    $content$02 = $11;
    $prev$01 = $prev$01$phi;
   }
  }
 }
 $14 = HEAP32[$span + 8 >> 2] | 0;
 if ($14 | 0) {
  HEAP32[$0 >> 2] = 0;
  _prvTidyDiscardElement($doc, $span) | 0;
  return $14 | 0;
 }
 HEAP32[(HEAP32[$span >> 2] | 0) + 16 >> 2] = $prev$0$lcssa;
 HEAP32[$0 >> 2] = 0;
 _prvTidyDiscardElement($doc, $span) | 0;
 return $14 | 0;
}

function _prvTidyAddStringLiteral($lexer, $str) {
 $lexer = $lexer | 0;
 $str = $str | 0;
 var $$$i = 0, $$$i$lcssa = 0, $$01 = 0, $$pre$i = 0, $0 = 0, $13 = 0, $18 = 0, $2 = 0, $20 = 0, $23 = 0, $27 = 0, $3 = 0, $4 = 0, $7 = 0, $8 = 0, $allocAmt$01$i = 0;
 $0 = HEAP8[$str >> 0] | 0;
 if (!($0 << 24 >> 24)) return;
 $2 = $lexer + 92 | 0;
 $3 = $lexer + 88 | 0;
 $$pre$i = $lexer + 84 | 0;
 $4 = $lexer + 124 | 0;
 $$01 = $str;
 $27 = $0;
 do {
  $$01 = $$01 + 1 | 0;
  $7 = (HEAP32[$2 >> 2] | 0) + 2 | 0;
  $8 = HEAP32[$3 >> 2] | 0;
  if ($7 >>> 0 >= $8 >>> 0) {
   $allocAmt$01$i = $8;
   while (1) {
    $$$i = ($allocAmt$01$i | 0) == 0 ? 8192 : $allocAmt$01$i << 1;
    if ($7 >>> 0 < $$$i >>> 0) {
     $$$i$lcssa = $$$i;
     break;
    } else $allocAmt$01$i = $$$i;
   }
   $13 = HEAP32[$4 >> 2] | 0;
   $18 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$13 >> 2] | 0) + 4 >> 2] & 15]($13, HEAP32[$$pre$i >> 2] | 0, $$$i$lcssa) | 0;
   if ($18 | 0) {
    $20 = HEAP32[$3 >> 2] | 0;
    _memset($18 + $20 | 0, 0, $$$i$lcssa - $20 | 0) | 0;
    HEAP32[$$pre$i >> 2] = $18;
    HEAP32[$3 >> 2] = $$$i$lcssa;
   }
  }
  $23 = HEAP32[$2 >> 2] | 0;
  HEAP32[$2 >> 2] = $23 + 1;
  HEAP8[(HEAP32[$$pre$i >> 2] | 0) + $23 >> 0] = $27;
  HEAP8[(HEAP32[$$pre$i >> 2] | 0) + (HEAP32[$2 >> 2] | 0) >> 0] = 0;
  $27 = HEAP8[$$01 >> 0] | 0;
 } while ($27 << 24 >> 24 != 0);
 return;
}

function _CheckTABLE($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $1 = 0, $14 = 0, $2 = 0, $20 = 0, $22 = 0, $5 = 0, $7 = 0, $attval$01$i = 0, $attval$01$i$looptemp = 0;
 $1 = (_prvTidyAttrGetById($node, 144) | 0) != 0;
 $2 = _prvTidyHTMLVersion($doc) | 0;
 $5 = ($2 | 0) == 131072 | ($2 | 0) == 262144;
 $7 = HEAP32[$node + 20 >> 2] | 0;
 if ($7 | 0) {
  $attval$01$i = $7;
  do {
   $attval$01$i$looptemp = $attval$01$i;
   $attval$01$i = HEAP32[$attval$01$i >> 2] | 0;
   _prvTidyCheckAttribute($doc, $node, $attval$01$i$looptemp) | 0;
  } while (($attval$01$i | 0) != 0);
 }
 L5 : do if (!(HEAP32[$doc + 408 >> 2] | 0)) {
  if ($1 & $5) {
   _prvTidyReportWarning($doc, $node, $node, 289);
   break;
  }
  if (!$1) {
   if (($2 | 0) < 262144) switch ($2 | 0) {
   case 131072:
    {
     break L5;
     break;
    }
   default:
    {}
   } else switch ($2 | 0) {
   case 262144:
    {
     break L5;
     break;
    }
   default:
    {}
   }
   $14 = $doc + 6836 | 0;
   HEAP32[$14 >> 2] = HEAP32[$14 >> 2] | 4;
   _prvTidyReportMissingAttr($doc, $node, 312125);
  }
 } while (0);
 if (!(HEAP32[$doc + 172 >> 2] | 0)) return;
 $20 = _prvTidyAttrGetById($node, 16) | 0;
 if (!$20) return;
 $22 = $20 + 24 | 0;
 if (HEAP32[$22 >> 2] | 0) return;
 HEAP32[$22 >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, 308546) | 0;
 return;
}

function _prvTidyRemoveAttribute($doc, $node, $attr) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attr = $attr | 0;
 var $0 = 0, $10 = 0, $11 = 0, $17 = 0, $23 = 0, $5 = 0, $av$0$i = 0, $av$02$i = 0, $av$04$i = 0, $prev$03$i = 0, $prev$03$i$lcssa = 0, $prev$03$i$phi = 0;
 $0 = $node + 20 | 0;
 $av$02$i = HEAP32[$0 >> 2] | 0;
 L1 : do if ($av$02$i | 0) {
  $av$04$i = $av$02$i;
  $prev$03$i = 0;
  while (1) {
   if (($av$04$i | 0) == ($attr | 0)) {
    $prev$03$i$lcssa = $prev$03$i;
    break;
   }
   $av$0$i = HEAP32[$av$04$i >> 2] | 0;
   if (!$av$0$i) break L1; else {
    $prev$03$i$phi = $av$04$i;
    $av$04$i = $av$0$i;
    $prev$03$i = $prev$03$i$phi;
   }
  }
  $5 = HEAP32[$attr >> 2] | 0;
  if (!$prev$03$i$lcssa) {
   HEAP32[$0 >> 2] = $5;
   break;
  } else {
   HEAP32[$prev$03$i$lcssa >> 2] = $5;
   break;
  }
 } while (0);
 _prvTidyFreeNode($doc, HEAP32[$attr + 8 >> 2] | 0);
 _prvTidyFreeNode($doc, HEAP32[$attr + 12 >> 2] | 0);
 $10 = $doc + 6856 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$11 >> 2] | 0) + 8 >> 2] & 15]($11, HEAP32[$attr + 20 >> 2] | 0);
 $17 = HEAP32[$10 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$17 >> 2] | 0) + 8 >> 2] & 15]($17, HEAP32[$attr + 24 >> 2] | 0);
 $23 = HEAP32[$10 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$23 >> 2] | 0) + 8 >> 2] & 15]($23, $attr);
 return;
}

function _prvTidyFixXmlDecl($doc) {
 $doc = $doc | 0;
 var $1 = 0, $12 = 0, $2 = 0, $20 = 0, $22 = 0, $26 = 0, $28 = 0, $3 = 0, $9 = 0, $xml$0 = 0, dest = 0, label = 0, stop = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $2 = $doc + 12 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 if (!$3) label = 3; else if ((HEAP32[$3 + 44 >> 2] | 0) == 13) $xml$0 = $3; else label = 3;
 do if ((label | 0) == 3) {
  $9 = HEAP32[$1 + 124 >> 2] | 0;
  $12 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$9 >> 2] >> 2] & 31]($9, 68) | 0;
  dest = $12;
  stop = dest + 68 | 0;
  do {
   HEAP32[dest >> 2] = 0;
   dest = dest + 4 | 0;
  } while ((dest | 0) < (stop | 0));
  if ($1 | 0) {
   HEAP32[$12 + 48 >> 2] = HEAP32[$1 >> 2];
   HEAP32[$12 + 52 >> 2] = HEAP32[$1 + 4 >> 2];
  }
  HEAP32[$12 + 44 >> 2] = 13;
  $20 = HEAP32[$2 >> 2] | 0;
  if (!$20) {
   HEAP32[$2 >> 2] = $12;
   $xml$0 = $12;
   break;
  } else {
   _prvTidyInsertNodeBeforeElement($20, $12);
   $xml$0 = $12;
   break;
  }
 } while (0);
 $22 = _prvTidyGetAttrByName($xml$0, 310376) | 0;
 if (!(_prvTidyGetAttrByName($xml$0, 310384) | 0)) {
  $26 = HEAP32[$doc + 96 >> 2] | 0;
  if (($26 | 0) != 4) {
   $28 = _prvTidyGetEncodingNameFromTidyId($26) | 0;
   if ($28 | 0) _prvTidyAddAttribute($doc, $xml$0, 310384, $28) | 0;
  }
 }
 if ($22 | 0) return 1;
 _prvTidyAddAttribute($doc, $xml$0, 310376, 310393) | 0;
 return 1;
}

function _TrimSpaces($doc, $element) {
 $doc = $doc | 0;
 $element = $element | 0;
 var $1 = 0, $10 = 0, $19 = 0, $24 = 0, $25 = 0, $29 = 0, $4 = 0, $doc$idx1$val = 0, $parent$02$i = 0, $parent$03$i = 0;
 $1 = HEAP32[$element + 12 >> 2] | 0;
 if ($element | 0) {
  $4 = HEAP32[$element + 28 >> 2] | 0;
  if ($4 | 0) if ((HEAP32[$4 >> 2] | 0) == 84) return;
 }
 $parent$02$i = HEAP32[$element >> 2] | 0;
 L6 : do if ($parent$02$i | 0) {
  $parent$03$i = $parent$02$i;
  while (1) {
   $10 = HEAP32[$parent$03$i + 28 >> 2] | 0;
   if ($10 | 0) if ((HEAP32[$10 + 20 >> 2] | 0) == 35) break;
   $parent$03$i = HEAP32[$parent$03$i >> 2] | 0;
   if (!$parent$03$i) break L6;
  }
  return;
 } while (0);
 if (_prvTidynodeIsText($1) | 0) _TrimInitialSpace(HEAP32[$doc + 68 >> 2] | 0, $element, $1);
 $19 = HEAP32[$element + 16 >> 2] | 0;
 if (!(_prvTidynodeIsText($19) | 0)) return;
 $doc$idx1$val = HEAP32[$doc + 68 >> 2] | 0;
 if (!(_prvTidynodeIsText($19) | 0)) return;
 $24 = $19 + 40 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 if ($25 >>> 0 <= (HEAP32[$19 + 36 >> 2] | 0) >>> 0) return;
 $29 = $25 + -1 | 0;
 if ((HEAP8[(HEAP32[$doc$idx1$val + 84 >> 2] | 0) + $29 >> 0] | 0) != 32) return;
 HEAP32[$24 >> 2] = $29;
 if ((HEAP32[(HEAP32[$element + 28 >> 2] | 0) + 16 >> 2] & 1040 | 0) != 16) return;
 HEAP32[$doc$idx1$val + 16 >> 2] = 1;
 return;
}

function _prvTidyIsValidXMLID($id) {
 $id = $id | 0;
 var $$0 = 0, $1 = 0, $11 = 0, $13 = 0, $16 = 0, $18 = 0, $2 = 0, $3 = 0, $6 = 0, $7 = 0, $c = 0, $s$0 = 0, $s$1 = 0, $s$2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 if (!$id) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $1 = $id + 1 | 0;
 $2 = HEAP8[$id >> 0] | 0;
 $3 = $2 << 24 >> 24;
 HEAP32[$c >> 2] = $3;
 if ($2 << 24 >> 24 < 0) {
  $6 = $1 + (_prvTidyGetUTF8($1, $c) | 0) | 0;
  $7 = HEAP32[$c >> 2] | 0;
  $s$0 = $6;
 } else {
  $7 = $3;
  $s$0 = $1;
 }
 L7 : do if (!(_prvTidyIsXMLLetter($7) | 0)) {
  switch (HEAP32[$c >> 2] | 0) {
  case 58:
  case 95:
   {
    $s$1 = $s$0;
    break L7;
    break;
   }
  default:
   $$0 = 0;
  }
  STACKTOP = sp;
  return $$0 | 0;
 } else $s$1 = $s$0; while (0);
 while (1) {
  $11 = HEAP8[$s$1 >> 0] | 0;
  if (!($11 << 24 >> 24)) {
   $$0 = 1;
   label = 10;
   break;
  }
  $13 = $11 & 255;
  HEAP32[$c >> 2] = $13;
  if ($11 << 24 >> 24 < 0) {
   $16 = $s$1 + (_prvTidyGetUTF8($s$1, $c) | 0) | 0;
   $18 = HEAP32[$c >> 2] | 0;
   $s$2 = $16;
  } else {
   $18 = $13;
   $s$2 = $s$1;
  }
  if (!(_prvTidyIsXMLNamechar($18) | 0)) {
   $$0 = 0;
   label = 10;
   break;
  } else $s$1 = $s$2 + 1 | 0;
 }
 if ((label | 0) == 10) {
  STACKTOP = sp;
  return $$0 | 0;
 }
 return 0;
}

function _sift($head, $width, $cmp, $pshift, $lp) {
 $head = $head | 0;
 $width = $width | 0;
 $cmp = $cmp | 0;
 $pshift = $pshift | 0;
 $lp = $lp | 0;
 var $$0$be = 0, $$01$be = 0, $$012 = 0, $$03 = 0, $1 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $7 = 0, $8 = 0, $ar = 0, $i$0$lcssa = 0, $i$04 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 240 | 0;
 $ar = sp;
 HEAP32[$ar >> 2] = $head;
 L1 : do if (($pshift | 0) > 1) {
  $1 = 0 - $width | 0;
  $$012 = $pshift;
  $$03 = $head;
  $8 = $head;
  $i$04 = 1;
  while (1) {
   $2 = $$03 + $1 | 0;
   $3 = $$012 + -2 | 0;
   $7 = $2 + (0 - (HEAP32[$lp + ($3 << 2) >> 2] | 0)) | 0;
   if ((FUNCTION_TABLE_iii[$cmp & 31]($8, $7) | 0) > -1) if ((FUNCTION_TABLE_iii[$cmp & 31]($8, $2) | 0) > -1) {
    $i$0$lcssa = $i$04;
    break L1;
   }
   $15 = $i$04 + 1 | 0;
   $16 = $ar + ($i$04 << 2) | 0;
   if ((FUNCTION_TABLE_iii[$cmp & 31]($7, $2) | 0) > -1) {
    HEAP32[$16 >> 2] = $7;
    $$0$be = $7;
    $$01$be = $$012 + -1 | 0;
   } else {
    HEAP32[$16 >> 2] = $2;
    $$0$be = $2;
    $$01$be = $3;
   }
   if (($$01$be | 0) <= 1) {
    $i$0$lcssa = $15;
    break L1;
   }
   $$012 = $$01$be;
   $$03 = $$0$be;
   $8 = HEAP32[$ar >> 2] | 0;
   $i$04 = $15;
  }
 } else $i$0$lcssa = 1; while (0);
 _cycle($width, $ar, $i$0$lcssa);
 STACKTOP = sp;
 return;
}

function _defaultRealloc($allocator, $mem, $newsize) {
 $allocator = $allocator | 0;
 $mem = $mem | 0;
 $newsize = $newsize | 0;
 var $$0 = 0, $1 = 0, $10 = 0, $14 = 0, $16 = 0, $18 = 0, $5 = 0, $7 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 if (!$mem) {
  $1 = HEAP32[79250] | 0;
  if (!$1) $5 = _malloc($newsize) | 0; else $5 = FUNCTION_TABLE_ii[$1 & 31]($newsize) | 0;
  if ($5 | 0) {
   $$0 = $5;
   STACKTOP = sp;
   return $$0 | 0;
  }
  $7 = HEAP32[79251] | 0;
  if (!$7) {
   $9 = HEAP32[55027] | 0;
   HEAP32[$vararg_buffer >> 2] = 311680;
   _fprintf($9, 311663, $vararg_buffer) | 0;
   _exit(2);
  }
  FUNCTION_TABLE_vi[$7 & 3](311680);
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 } else {
  $10 = HEAP32[79252] | 0;
  if (!$10) $14 = _realloc($mem, $newsize) | 0; else $14 = FUNCTION_TABLE_iii[$10 & 31]($mem, $newsize) | 0;
  if ($14 | 0) {
   $$0 = $14;
   STACKTOP = sp;
   return $$0 | 0;
  }
  $16 = HEAP32[79251] | 0;
  if (!$16) {
   $18 = HEAP32[55027] | 0;
   HEAP32[$vararg_buffer1 >> 2] = 311680;
   _fprintf($18, 311663, $vararg_buffer1) | 0;
   _exit(2);
  }
  FUNCTION_TABLE_vi[$16 & 3](311680);
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 return 0;
}

function _IsValidSrcExtension($sType) {
 $sType = $sType | 0;
 var $$0 = 0, $$lcssa7 = 0, $0 = 0, $1 = 0, $ext = 0, $i$0$in$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $ext = sp;
 $0 = _prvTidytmbstrlen($sType) | 0;
 HEAP8[$ext >> 0] = 0;
 $i$0$in$i = $0;
 L1 : do {
  $i$0$in$i = $i$0$in$i + -1 | 0;
  $1 = $sType + $i$0$in$i | 0;
  switch (HEAP8[$1 >> 0] | 0) {
  case 92:
  case 47:
   {
    break L1;
    break;
   }
  case 46:
   {
    $$lcssa7 = $1;
    label = 3;
    break L1;
    break;
   }
  default:
   {}
  }
 } while (($i$0$in$i | 0) > 1);
 if ((label | 0) == 3) _prvTidytmbstrncpy($ext, $$lcssa7, 20) | 0;
 if (!(_prvTidytmbstrcasecmp($ext, 312076) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312081) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312087) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312093) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312100) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312105) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312111) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312116) | 0)) $$0 = 1; else if (!(_prvTidytmbstrcasecmp($ext, 312121) | 0)) $$0 = 1; else $$0 = (_prvTidytmbstrcasecmp($ext, 311905) | 0) == 0 & 1;
 STACKTOP = sp;
 return $$0 | 0;
}

function _AddString($pprint, $str) {
 $pprint = $pprint | 0;
 $str = $str | 0;
 var $$pre$i = 0, $0 = 0, $1 = 0, $10 = 0, $14 = 0, $17 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $buflen$0$i$i = 0, $buflen$0$i$i$lcssa = 0, $ix$01$i = 0;
 $0 = $pprint + 12 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = _prvTidytmbstrlen($str) | 0;
 $3 = $2 + $1 | 0;
 $4 = $pprint + 8 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 if ($3 >>> 0 >= $5 >>> 0) {
  $buflen$0$i$i = ($5 | 0) == 0 ? 256 : $5;
  while (1) if ($buflen$0$i$i >>> 0 > $3 >>> 0) {
   $buflen$0$i$i$lcssa = $buflen$0$i$i;
   break;
  } else $buflen$0$i$i = $buflen$0$i$i << 1;
  $10 = HEAP32[$pprint >> 2] | 0;
  $14 = $pprint + 4 | 0;
  $17 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$10 >> 2] | 0) + 4 >> 2] & 15]($10, HEAP32[$14 >> 2] | 0, $buflen$0$i$i$lcssa << 2) | 0;
  if ($17 | 0) {
   $19 = HEAP32[$4 >> 2] | 0;
   _memset($17 + ($19 << 2) | 0, 0, $buflen$0$i$i$lcssa - $19 << 2 | 0) | 0;
   HEAP32[$4 >> 2] = $buflen$0$i$i$lcssa;
   HEAP32[$14 >> 2] = $17;
  }
 }
 if (!$2) {
  HEAP32[$0 >> 2] = $3;
  return;
 }
 $$pre$i = HEAP32[$pprint + 4 >> 2] | 0;
 $ix$01$i = 0;
 do {
  HEAP32[$$pre$i + ($ix$01$i + $1 << 2) >> 2] = HEAP8[$str + $ix$01$i >> 0];
  $ix$01$i = $ix$01$i + 1 | 0;
 } while (($ix$01$i | 0) != ($2 | 0));
 HEAP32[$0 >> 2] = $3;
 return;
}

function _prvTidyUngetChar($c, $in) {
 $c = $c | 0;
 $in = $in | 0;
 var $12 = 0, $13 = 0, $14 = 0, $15 = 0, $17 = 0, $19 = 0, $2 = 0, $21 = 0, $23 = 0, $28 = 0, $29 = 0, $3 = 0, $38 = 0, $5 = 0, $6 = 0, $9 = 0;
 if (($c | 0) == -1) return;
 HEAP32[$in + 4 >> 2] = 1;
 $2 = $in + 16 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 $5 = $in + 20 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 if (($3 + 1 | 0) >>> 0 < $6 >>> 0) {
  $19 = $3;
  $21 = HEAP32[$in + 12 >> 2] | 0;
 } else {
  $9 = HEAP32[$in + 8 >> 2] | 0;
  $12 = HEAP32[(HEAP32[$9 >> 2] | 0) + 4 >> 2] | 0;
  $13 = $in + 12 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = $6 + 1 | 0;
  HEAP32[$5 >> 2] = $15;
  $17 = FUNCTION_TABLE_iiii[$12 & 15]($9, $14, $15 << 2) | 0;
  HEAP32[$13 >> 2] = $17;
  $19 = HEAP32[$2 >> 2] | 0;
  $21 = $17;
 }
 HEAP32[$2 >> 2] = $19 + 1;
 HEAP32[$21 + ($19 << 2) >> 2] = $c;
 if (($c | 0) == 10) {
  $23 = $in + 292 | 0;
  HEAP32[$23 >> 2] = (HEAP32[$23 >> 2] | 0) + -1;
 }
 $28 = $in + 284 | 0;
 $29 = HEAP16[$28 >> 1] | 0;
 if ((HEAP16[$in + 286 >> 1] | 0) == $29 << 16 >> 16) {
  HEAP32[$in + 288 >> 2] = 0;
  return;
 }
 HEAP32[$in + 288 >> 2] = HEAP32[$in + 28 + (($29 & 65535) << 2) >> 2];
 if (!($29 << 16 >> 16)) {
  HEAP16[$28 >> 1] = 64;
  $38 = 64;
 } else $38 = $29;
 HEAP16[$28 >> 1] = $38 + -1 << 16 >> 16;
 return;
}

function _CheckRDFaPrefix($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $1 = 0, $10 = 0, $12 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $26 = 0, $4 = 0, $5 = 0, $6 = 0, $isPrefix$01 = 0;
 if ($attval | 0) {
  $1 = $attval + 24 | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  if ($2 | 0) {
   $4 = _prvTidytmbstrlen($2) | 0;
   $5 = $doc + 6856 | 0;
   $6 = HEAP32[$5 >> 2] | 0;
   $10 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$6 >> 2] >> 2] & 31]($6, $4 + 1 | 0) | 0;
   HEAP8[$10 >> 0] = 0;
   _prvTidytmbstrcpy($10, HEAP32[$1 >> 2] | 0) | 0;
   $12 = _strtok($10, 307688) | 0;
   if ($12 | 0) {
    $15 = $12;
    $isPrefix$01 = 1;
    while (1) {
     $14 = ($isPrefix$01 | 0) != 0;
     do if ($14) {
      $16 = _strchr($15, 58) | 0;
      if (!$16) {
       _prvTidyReportAttrError($doc, $node, $attval, 251);
       break;
      }
      if (($16 | 0) != ($15 + (_prvTidytmbstrlen($15) | 0) + -1 | 0)) _prvTidyReportAttrError($doc, $node, $attval, 251);
     } while (0);
     $15 = _strtok(0, 307688) | 0;
     if (!$15) break; else $isPrefix$01 = $14 & 1 ^ 1;
    }
   }
   $26 = HEAP32[$5 >> 2] | 0;
   FUNCTION_TABLE_vii[HEAP32[(HEAP32[$26 >> 2] | 0) + 8 >> 2] & 15]($26, $10);
   return;
  }
 }
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 return;
}

function _IsValidColorCode($color) {
 $color = $color | 0;
 var $$0 = 0, $10 = 0, $19 = 0, $28 = 0, $37 = 0, $46 = 0;
 if ((_prvTidytmbstrlen($color) | 0) != 6) {
  $$0 = 0;
  return $$0 | 0;
 }
 if (!(_prvTidyIsDigit(HEAP8[$color >> 0] | 0) | 0)) if (!(_memchr(304595, _prvTidyToLower(HEAP8[$color >> 0] | 0) | 0, 7) | 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $10 = $color + 1 | 0;
 if (!(_prvTidyIsDigit(HEAP8[$10 >> 0] | 0) | 0)) if (!(_memchr(304595, _prvTidyToLower(HEAP8[$10 >> 0] | 0) | 0, 7) | 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $19 = $color + 2 | 0;
 if (!(_prvTidyIsDigit(HEAP8[$19 >> 0] | 0) | 0)) if (!(_memchr(304595, _prvTidyToLower(HEAP8[$19 >> 0] | 0) | 0, 7) | 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $28 = $color + 3 | 0;
 if (!(_prvTidyIsDigit(HEAP8[$28 >> 0] | 0) | 0)) if (!(_memchr(304595, _prvTidyToLower(HEAP8[$28 >> 0] | 0) | 0, 7) | 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $37 = $color + 4 | 0;
 if (!(_prvTidyIsDigit(HEAP8[$37 >> 0] | 0) | 0)) if (!(_memchr(304595, _prvTidyToLower(HEAP8[$37 >> 0] | 0) | 0, 7) | 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $46 = $color + 5 | 0;
 if (!(_prvTidyIsDigit(HEAP8[$46 >> 0] | 0) | 0)) if (!(_memchr(304595, _prvTidyToLower(HEAP8[$46 >> 0] | 0) | 0, 7) | 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = 1;
 return $$0 | 0;
}

function _prvTidyXMLPreserveWhiteSpace($doc, $element) {
 $doc = $doc | 0;
 $element = $element | 0;
 var $$0 = 0, $13 = 0, $17 = 0, $3 = 0, $8 = 0, $attribute$05 = 0, $attribute$06 = 0, $attribute$06$lcssa = 0;
 $attribute$05 = HEAP32[$element + 20 >> 2] | 0;
 L1 : do if ($attribute$05 | 0) {
  $attribute$06 = $attribute$05;
  while (1) {
   $3 = HEAP32[$attribute$06 + 4 >> 2] | 0;
   if ($3 | 0) if ((HEAP32[$3 >> 2] | 0) == 162) {
    $attribute$06$lcssa = $attribute$06;
    break;
   }
   $attribute$06 = HEAP32[$attribute$06 >> 2] | 0;
   if (!$attribute$06) break L1;
  }
  $8 = HEAP32[$attribute$06$lcssa + 24 >> 2] | 0;
  if ($8 | 0) if (!(_prvTidytmbstrcasecmp($8, 310885) | 0)) {
   $$0 = 1;
   return $$0 | 0;
  }
  $$0 = 0;
  return $$0 | 0;
 } while (0);
 $13 = $element + 32 | 0;
 if (!(HEAP32[$13 >> 2] | 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $17 = HEAP32[$element + 28 >> 2] | 0;
 L17 : do if ($17 | 0) {
  switch (HEAP32[$17 >> 2] | 0) {
  case 103:
  case 94:
  case 84:
   {
    $$0 = 1;
    break;
   }
  default:
   break L17;
  }
  return $$0 | 0;
 } while (0);
 if ((_prvTidyFindParser($doc, $element) | 0) == 35) {
  $$0 = 1;
  return $$0 | 0;
 }
 $$0 = (_prvTidytmbstrcasecmp(HEAP32[$13 >> 2] | 0, 308076) | 0) == 0 & 1;
 return $$0 | 0;
}

function _CheckIMG($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $1 = 0, $10 = 0, $15 = 0, $19 = 0, $20 = 0, $3 = 0, $5 = 0, $6 = 0, $8 = 0, $attval$01$i = 0, $attval$01$i$looptemp = 0;
 $1 = (_prvTidyAttrGetById($node, 10) | 0) == 0;
 $3 = (_prvTidyAttrGetById($node, 139) | 0) != 0;
 $5 = (_prvTidyAttrGetById($node, 152) | 0) != 0;
 $6 = _prvTidyAttrGetById($node, 64) | 0;
 $8 = (_prvTidyAttrGetById($node, 39) | 0) != 0;
 $10 = HEAP32[$node + 20 >> 2] | 0;
 if ($10 | 0) {
  $attval$01$i = $10;
  do {
   $attval$01$i$looptemp = $attval$01$i;
   $attval$01$i = HEAP32[$attval$01$i >> 2] | 0;
   _prvTidyCheckAttribute($doc, $node, $attval$01$i$looptemp) | 0;
  } while (($attval$01$i | 0) != 0);
 }
 if ($1) {
  $15 = HEAP32[$doc + 116 >> 2] | 0;
  $19 = ($15 | 0) != 0;
  if (!($19 | (HEAP32[$doc + 408 >> 2] | 0) != 0)) {
   $20 = $doc + 6836 | 0;
   HEAP32[$20 >> 2] = HEAP32[$20 >> 2] | 1;
   _prvTidyReportMissingAttr($doc, $node, 310489);
  }
  if ($19) _prvTidyReportAttrError($doc, $node, _prvTidyAddAttribute($doc, $node, 310489, $15) | 0, 250);
 }
 if (!($3 | $8)) _prvTidyReportMissingAttr($doc, $node, 308332);
 if ($5 | ($6 | 0) == 0 | (HEAP32[$doc + 408 >> 2] | 0) != 0) return;
 _prvTidyReportAttrError($doc, $node, 0, 256);
 return;
}

function _vsnprintf($s, $n, $fmt, $ap) {
 $s = $s | 0;
 $n = $n | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 var $$$02 = 0, $$0 = 0, $$01 = 0, $$02 = 0, $10 = 0, $11 = 0, $13 = 0, $15 = 0, $5 = 0, $8 = 0, $b = 0, $f = 0, dest = 0, label = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 $b = sp + 112 | 0;
 $f = sp;
 dest = $f;
 src = 220664;
 stop = dest + 112 | 0;
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2];
  dest = dest + 4 | 0;
  src = src + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 if (($n + -1 | 0) >>> 0 > 2147483646) if (!$n) {
  $$01 = $b;
  $$02 = 1;
  label = 4;
 } else {
  HEAP32[(___errno_location() | 0) >> 2] = 75;
  $$0 = -1;
 } else {
  $$01 = $s;
  $$02 = $n;
  label = 4;
 }
 if ((label | 0) == 4) {
  $5 = -2 - $$01 | 0;
  $$$02 = $$02 >>> 0 > $5 >>> 0 ? $5 : $$02;
  HEAP32[$f + 48 >> 2] = $$$02;
  $8 = $f + 20 | 0;
  HEAP32[$8 >> 2] = $$01;
  HEAP32[$f + 44 >> 2] = $$01;
  $10 = $$01 + $$$02 | 0;
  $11 = $f + 16 | 0;
  HEAP32[$11 >> 2] = $10;
  HEAP32[$f + 28 >> 2] = $10;
  $13 = _vfprintf($f, $fmt, $ap) | 0;
  if (!$$$02) $$0 = $13; else {
   $15 = HEAP32[$8 >> 2] | 0;
   HEAP8[$15 + ((($15 | 0) == (HEAP32[$11 >> 2] | 0)) << 31 >> 31) >> 0] = 0;
   $$0 = $13;
  }
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _tidyBufPutByte($buf, $bv) {
 $buf = $buf | 0;
 $bv = $bv | 0;
 var $$pre$phiZ2D = 0, $1 = 0, $13 = 0, $16 = 0, $18 = 0, $2 = 0, $20 = 0, $23 = 0, $3 = 0, $5 = 0, $6 = 0, $7 = 0, $allocAmt$0$i = 0, $allocAmt$0$i$lcssa = 0;
 if (!$buf) ___assert_fail(225860, 225754, 178, 225872);
 $1 = $buf + 8 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 $3 = HEAP32[$buf >> 2] | 0;
 if (!$3) {
  HEAP32[$buf >> 2] = 66204;
  $13 = 66204;
 } else $13 = $3;
 $5 = $2 + 2 | 0;
 $6 = $buf + 12 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 if ($5 >>> 0 > $7 >>> 0) {
  $allocAmt$0$i = ($7 | 0) == 0 ? 256 : $7;
  while (1) if ($allocAmt$0$i >>> 0 < $5 >>> 0) $allocAmt$0$i = $allocAmt$0$i << 1; else {
   $allocAmt$0$i$lcssa = $allocAmt$0$i;
   break;
  }
  $16 = $buf + 4 | 0;
  $18 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$13 >> 2] | 0) + 4 >> 2] & 15]($13, HEAP32[$16 >> 2] | 0, $allocAmt$0$i$lcssa) | 0;
  if (!$18) $$pre$phiZ2D = $16; else {
   $20 = HEAP32[$6 >> 2] | 0;
   _memset($18 + $20 | 0, 0, $allocAmt$0$i$lcssa - $20 | 0) | 0;
   HEAP32[$16 >> 2] = $18;
   HEAP32[$6 >> 2] = $allocAmt$0$i$lcssa;
   $$pre$phiZ2D = $16;
  }
 } else $$pre$phiZ2D = $buf + 4 | 0;
 $23 = HEAP32[$1 >> 2] | 0;
 HEAP32[$1 >> 2] = $23 + 1;
 HEAP8[(HEAP32[$$pre$phiZ2D >> 2] | 0) + $23 >> 0] = $bv;
 return;
}

function _prvTidyGetCharEncodingFromOptName($charenc) {
 $charenc = $charenc | 0;
 var $$0 = 0, $i$02$lcssa = 0;
 if (!(_prvTidytmbstrcasecmp($charenc, 226159) | 0)) $i$02$lcssa = 0; else if (!(_prvTidytmbstrcasecmp($charenc, 226165) | 0)) $i$02$lcssa = 1; else if (!(_prvTidytmbstrcasecmp($charenc, 226172) | 0)) $i$02$lcssa = 2; else if (!(_prvTidytmbstrcasecmp($charenc, 226179) | 0)) $i$02$lcssa = 3; else if (!(_prvTidytmbstrcasecmp($charenc, 226184) | 0)) $i$02$lcssa = 4; else if (!(_prvTidytmbstrcasecmp($charenc, 226188) | 0)) $i$02$lcssa = 5; else if (!(_prvTidytmbstrcasecmp($charenc, 226196) | 0)) $i$02$lcssa = 6; else if (!(_prvTidytmbstrcasecmp($charenc, 226203) | 0)) $i$02$lcssa = 7; else if (!(_prvTidytmbstrcasecmp($charenc, 226211) | 0)) $i$02$lcssa = 8; else if (!(_prvTidytmbstrcasecmp($charenc, 226219) | 0)) $i$02$lcssa = 9; else if (!(_prvTidytmbstrcasecmp($charenc, 226137) | 0)) $i$02$lcssa = 10; else if (!(_prvTidytmbstrcasecmp($charenc, 226225) | 0)) $i$02$lcssa = 11; else if (!(_prvTidytmbstrcasecmp($charenc, 226234) | 0)) $i$02$lcssa = 12; else if (!(_prvTidytmbstrcasecmp($charenc, 226242) | 0)) $i$02$lcssa = 13; else {
  $$0 = -1;
  return $$0 | 0;
 }
 $$0 = HEAP32[6436 + ($i$02$lcssa * 12 | 0) >> 2] | 0;
 return $$0 | 0;
}

function _getNextInstalledLanguage($iter) {
 $iter = $iter | 0;
 var $$lcssa = 0, $$lcssa10 = 0, $$pre = 0, $1 = 0, $12 = 0, $19 = 0, $23 = 0, $24 = 0, $29 = 0, $6 = 0, $7 = 0, $item$0 = 0, $itemIndex$0 = 0;
 if (!$iter) ___assert_fail(298444, 298457, 903, 298588);
 $1 = HEAP32[$iter >> 2] | 0;
 $$pre = HEAP32[79120] | 0;
 if (!$1) {
  $19 = $$pre;
  $item$0 = 0;
  $itemIndex$0 = 0;
 } else {
  if (!$$pre) if (!(HEAP32[1693] | 0)) $12 = 0; else {
   $7 = 0;
   while (1) {
    $6 = $7 + 1 | 0;
    if (!(HEAP32[6772 + ($6 << 2) >> 2] | 0)) {
     $$lcssa10 = $6;
     break;
    } else $7 = $6;
   }
   HEAP32[79120] = $$lcssa10;
   $12 = $$lcssa10;
  } else $12 = $$pre;
  if ($1 >>> 0 > $12 >>> 0) {
   $19 = $12;
   $item$0 = 0;
   $itemIndex$0 = $1;
  } else {
   $19 = $12;
   $item$0 = HEAP32[(HEAP32[6772 + ($1 + -1 << 2) >> 2] | 0) + 12 >> 2] | 0;
   $itemIndex$0 = $1 + 1 | 0;
  }
 }
 if (!$19) if (!(HEAP32[1693] | 0)) $29 = 0; else {
  $24 = 0;
  while (1) {
   $23 = $24 + 1 | 0;
   if (!(HEAP32[6772 + ($23 << 2) >> 2] | 0)) {
    $$lcssa = $23;
    break;
   } else $24 = $23;
  }
  HEAP32[79120] = $$lcssa;
  $29 = $$lcssa;
 } else $29 = $19;
 HEAP32[$iter >> 2] = $itemIndex$0 >>> 0 <= $29 >>> 0 ? $itemIndex$0 : 0;
 return $item$0 | 0;
}

function _prvTidyCheckNodeIntegrity($node) {
 $node = $node | 0;
 var $$0 = 0, $1 = 0, $13 = 0, $2 = 0, $7 = 0, $8 = 0, $child$01 = 0, $child$02 = 0, label = 0;
 $1 = HEAP32[$node + 4 >> 2] | 0;
 $2 = ($1 | 0) == 0;
 if (!$2) if ((HEAP32[$1 + 8 >> 2] | 0) != ($node | 0)) {
  $$0 = 0;
  return $$0 | 0;
 }
 $7 = HEAP32[$node + 8 >> 2] | 0;
 $8 = ($7 | 0) == 0;
 if (!$8) {
  if (($7 | 0) == ($node | 0)) {
   $$0 = 0;
   return $$0 | 0;
  }
  if ((HEAP32[$7 + 4 >> 2] | 0) != ($node | 0)) {
   $$0 = 0;
   return $$0 | 0;
  }
 }
 $13 = HEAP32[$node >> 2] | 0;
 if ($13 | 0) {
  if ($2) if ((HEAP32[$13 + 12 >> 2] | 0) != ($node | 0)) {
   $$0 = 0;
   return $$0 | 0;
  }
  if ($8) if ((HEAP32[$13 + 16 >> 2] | 0) != ($node | 0)) {
   $$0 = 0;
   return $$0 | 0;
  }
 }
 $child$01 = HEAP32[$node + 12 >> 2] | 0;
 if (!$child$01) {
  $$0 = 1;
  return $$0 | 0;
 } else $child$02 = $child$01;
 while (1) {
  if ((HEAP32[$child$02 >> 2] | 0) != ($node | 0)) {
   $$0 = 0;
   label = 15;
   break;
  }
  if (!(_prvTidyCheckNodeIntegrity($child$02) | 0)) {
   $$0 = 0;
   label = 15;
   break;
  }
  $child$02 = HEAP32[$child$02 + 8 >> 2] | 0;
  if (!$child$02) {
   $$0 = 1;
   label = 15;
   break;
  }
 }
 if ((label | 0) == 15) return $$0 | 0;
 return 0;
}

function _getNextStringKey($iter) {
 $iter = $iter | 0;
 var $$lcssa = 0, $$lcssa10 = 0, $$pre = 0, $1 = 0, $12 = 0, $17 = 0, $21 = 0, $22 = 0, $27 = 0, $6 = 0, $7 = 0, $item$0 = 0, $itemIndex$0 = 0;
 if (!$iter) ___assert_fail(298444, 298457, 803, 298548);
 $1 = HEAP32[$iter >> 2] | 0;
 $$pre = HEAP32[79118] | 0;
 if (!$1) {
  $17 = $$pre;
  $item$0 = 0;
  $itemIndex$0 = 0;
 } else {
  if (!$$pre) if (!(HEAP32[1703] | 0)) $12 = 0; else {
   $7 = 0;
   while (1) {
    $6 = $7 + 1 | 0;
    if (!(HEAP32[6804 + ($6 * 12 | 0) + 8 >> 2] | 0)) {
     $$lcssa10 = $6;
     break;
    } else $7 = $6;
   }
   HEAP32[79118] = $$lcssa10;
   $12 = $$lcssa10;
  } else $12 = $$pre;
  if ($1 >>> 0 > $12 >>> 0) {
   $17 = $12;
   $item$0 = 0;
   $itemIndex$0 = $1;
  } else {
   $17 = $12;
   $item$0 = HEAP32[6804 + (($1 + -1 | 0) * 12 | 0) >> 2] | 0;
   $itemIndex$0 = $1 + 1 | 0;
  }
 }
 if (!$17) if (!(HEAP32[1703] | 0)) $27 = 0; else {
  $22 = 0;
  while (1) {
   $21 = $22 + 1 | 0;
   if (!(HEAP32[6804 + ($21 * 12 | 0) + 8 >> 2] | 0)) {
    $$lcssa = $21;
    break;
   } else $22 = $21;
  }
  HEAP32[79118] = $$lcssa;
  $27 = $$lcssa;
 } else $27 = $17;
 HEAP32[$iter >> 2] = $itemIndex$0 >>> 0 <= $27 >>> 0 ? $itemIndex$0 : 0;
 return $item$0 | 0;
}

function _prvTidyEmFromI($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$01 = 0, $1 = 0, $11 = 0, $17 = 0, $18 = 0, $2 = 0, $22 = 0, $29 = 0, $3 = 0, $6 = 0, $7 = 0;
 if (!$node) return;
 $1 = $doc + 6856 | 0;
 $$01 = $node;
 do {
  $2 = $$01 + 28 | 0;
  $3 = HEAP32[$2 >> 2] | 0;
  L6 : do if ($3 | 0) switch (HEAP32[$3 >> 2] | 0) {
  case 49:
   {
    $6 = _prvTidyLookupTagDef(33) | 0;
    $7 = HEAP32[$1 >> 2] | 0;
    $11 = $$01 + 32 | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$7 >> 2] | 0) + 8 >> 2] & 15]($7, HEAP32[$11 >> 2] | 0);
    HEAP32[$11 >> 2] = _prvTidytmbstrdup(HEAP32[$1 >> 2] | 0, HEAP32[$6 + 4 >> 2] | 0) | 0;
    HEAP32[$2 >> 2] = $6;
    break L6;
    break;
   }
  case 8:
   {
    $17 = _prvTidyLookupTagDef(102) | 0;
    $18 = HEAP32[$1 >> 2] | 0;
    $22 = $$01 + 32 | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$18 >> 2] | 0) + 8 >> 2] & 15]($18, HEAP32[$22 >> 2] | 0);
    HEAP32[$22 >> 2] = _prvTidytmbstrdup(HEAP32[$1 >> 2] | 0, HEAP32[$17 + 4 >> 2] | 0) | 0;
    HEAP32[$2 >> 2] = $17;
    break L6;
    break;
   }
  default:
   break L6;
  } while (0);
  $29 = HEAP32[$$01 + 12 >> 2] | 0;
  if ($29 | 0) _prvTidyEmFromI($doc, $29);
  $$01 = HEAP32[$$01 + 8 >> 2] | 0;
 } while (($$01 | 0) != 0);
 return;
}

function _FindLinkA($node, $url) {
 $node = $node | 0;
 $url = $url | 0;
 var $$01 = 0, $$02 = 0, $10 = 0, $12 = 0, $22 = 0, $3 = 0, $7 = 0, $9 = 0, $cp$03$i$i = 0, $found$0$lcssa = 0, $found$1 = 0, label = 0;
 $$01 = HEAP32[$node + 12 >> 2] | 0;
 if (!$$01) {
  $found$0$lcssa = 0;
  return $found$0$lcssa | 0;
 } else $$02 = $$01;
 while (1) {
  $3 = HEAP32[$$02 + 28 >> 2] | 0;
  if (!$3) label = 10; else if ((HEAP32[$3 >> 2] | 0) == 1) {
   $7 = _prvTidyAttrGetById($$02, 59) | 0;
   L8 : do if (!$7) $22 = 0; else {
    $9 = $7 + 24 | 0;
    $10 = HEAP32[$9 >> 2] | 0;
    if (!$10) $22 = 0; else {
     $cp$03$i$i = $10;
     while (1) {
      $12 = HEAP8[$cp$03$i$i >> 0] | 0;
      if (!($12 << 24 >> 24)) {
       $22 = 0;
       break L8;
      }
      if (!(_prvTidyIsWhite($12 << 24 >> 24) | 0)) break; else $cp$03$i$i = $cp$03$i$i + 1 | 0;
     }
     $22 = (_prvTidytmbstrcmp($url, HEAP32[$9 >> 2] | 0) | 0) == 0;
    }
   } while (0);
   $found$1 = $22 & 1;
  } else label = 10;
  if ((label | 0) == 10) {
   label = 0;
   $found$1 = _FindLinkA($$02, $url) | 0;
  }
  $$02 = HEAP32[$$02 + 8 >> 2] | 0;
  if (!(($found$1 | 0) == 0 & ($$02 | 0) != 0)) {
   $found$0$lcssa = $found$1;
   break;
  }
 }
 return $found$0$lcssa | 0;
}

function _DefineStyleRules($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $1 = 0, $13 = 0, $14 = 0, $16 = 0, $17 = 0, $21 = 0, $23 = 0, $6 = 0, $8 = 0, $9 = 0, $child$01 = 0;
 $1 = HEAP32[$node + 12 >> 2] | 0;
 if ($1 | 0) {
  $child$01 = $1;
  do {
   _DefineStyleRules($doc, $child$01);
   $child$01 = HEAP32[$child$01 + 8 >> 2] | 0;
  } while (($child$01 | 0) != 0);
 }
 $6 = _prvTidyAttrGetById($node, 143) | 0;
 if (!$6) return;
 $8 = $6 + 24 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 if (!$9) {
  _prvTidyRemoveAttribute($doc, $node, $6);
  return;
 }
 $13 = _FindStyle($doc, HEAP32[$node + 32 >> 2] | 0, $9) | 0;
 $14 = _prvTidyAttrGetById($node, 26) | 0;
 if (!$14) {
  $16 = $doc + 6856 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $21 = $6 + 20 | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$17 >> 2] | 0) + 8 >> 2] & 15]($17, HEAP32[$21 >> 2] | 0);
  $23 = HEAP32[$16 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$23 >> 2] | 0) + 8 >> 2] & 15]($23, HEAP32[$8 >> 2] | 0);
  HEAP32[$21 >> 2] = _prvTidytmbstrdup(HEAP32[$16 >> 2] | 0, 310945) | 0;
  HEAP32[$8 >> 2] = _prvTidytmbstrdup(HEAP32[$16 >> 2] | 0, $13) | 0;
  return;
 } else {
  _prvTidyAppendToClassAttr($doc, $14, $13);
  _prvTidyRemoveAttribute($doc, $node, $6);
  return;
 }
}

function _tidyNormalizedLocaleName($locale) {
 $locale = $locale | 0;
 var $1 = 0, $11 = 0, $13 = 0, $16 = 0, $17 = 0, $character = 0, $i$03 = 0, $i$03$lcssa = 0, $i$12 = 0, $search$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $character = sp;
 $1 = _prvTidytmbstrtolower(___strdup($locale) | 0) | 0;
 $i$03 = 0;
 while (1) {
  if (!(_strcmp(HEAP32[50024 + ($i$03 << 3) >> 2] | 0, $1) | 0)) {
   $i$03$lcssa = $i$03;
   label = 3;
   break;
  }
  $i$03 = $i$03 + 1 | 0;
  if (($i$03 | 0) == 159) {
   $search$0 = $1;
   break;
  }
 }
 if ((label | 0) == 3) {
  _free($1);
  $search$0 = ___strdup(HEAP32[50024 + ($i$03$lcssa << 3) + 4 >> 2] | 0) | 0;
 }
 $11 = _strlen($search$0) | 0;
 $13 = $11 >>> 0 > 5 ? 5 : $11;
 $i$12 = 0;
 do {
  if (($i$12 | 0) == 2) {
   $16 = (_strlen($search$0) | 0) >>> 0 > 4;
   HEAP8[$character >> 0] = $16 ? 95 : 0;
   _strncpy(298440, $character, 1) | 0;
  } else {
   $17 = 298438 + $i$12 | 0;
   _strncpy($17, $search$0 + $i$12 | 0, 1) | 0;
   HEAP8[$17 >> 0] = _tolower(HEAP8[$17 >> 0] | 0) | 0;
  }
  $i$12 = $i$12 + 1 | 0;
 } while ($i$12 >>> 0 <= $13 >>> 0);
 if (!$search$0) {
  STACKTOP = sp;
  return 298438;
 }
 _free($search$0);
 STACKTOP = sp;
 return 298438;
}

function _prvTidyCoerceNode($doc, $node, $tid, $obsolete, $unexpected) {
 $doc = $doc | 0;
 $node = $node | 0;
 $tid = $tid | 0;
 $obsolete = $obsolete | 0;
 $unexpected = $unexpected | 0;
 var $0 = 0, $12 = 0, $16 = 0, $2 = 0, $21 = 0, $25 = 0, $5 = 0, $6 = 0;
 $0 = _prvTidyLookupTagDef($tid) | 0;
 $2 = _prvTidyInferredTag($doc, HEAP32[$0 >> 2] | 0) | 0;
 do if (!$obsolete) if (!$unexpected) {
  _prvTidyReportNotice($doc, $node, $2, 283);
  break;
 } else {
  _prvTidyReportError($doc, $node, $2, 284);
  break;
 } else _prvTidyReportWarning($doc, $node, $2, 220); while (0);
 $5 = $doc + 6856 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$6 >> 2] | 0) + 8 >> 2] & 15]($6, HEAP32[$2 + 32 >> 2] | 0);
 $12 = HEAP32[$5 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$12 >> 2] | 0) + 8 >> 2] & 15]($12, $2);
 $16 = $node + 28 | 0;
 HEAP32[$node + 24 >> 2] = HEAP32[$16 >> 2];
 HEAP32[$16 >> 2] = $0;
 HEAP32[$node + 44 >> 2] = 5;
 HEAP32[$node + 60 >> 2] = 1;
 $21 = HEAP32[$5 >> 2] | 0;
 $25 = $node + 32 | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$21 >> 2] | 0) + 8 >> 2] & 15]($21, HEAP32[$25 >> 2] | 0);
 HEAP32[$25 >> 2] = _prvTidytmbstrdup(HEAP32[$5 >> 2] | 0, HEAP32[$0 + 4 >> 2] | 0) | 0;
 return;
}

function _prvTidyDupAttrs($doc, $attrs) {
 $doc = $doc | 0;
 $attrs = $attrs | 0;
 var $$0 = 0, $1 = 0, $18 = 0, $22 = 0, $24 = 0, $28 = 0, $4 = 0;
 if (!$attrs) {
  $$0 = 0;
  return $$0 | 0;
 }
 $1 = _prvTidyNewAttribute($doc) | 0;
 HEAP32[$1 >> 2] = HEAP32[$attrs >> 2];
 HEAP32[$1 + 4 >> 2] = HEAP32[$attrs + 4 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$attrs + 8 >> 2];
 HEAP32[$1 + 12 >> 2] = HEAP32[$attrs + 12 >> 2];
 HEAP32[$1 + 16 >> 2] = HEAP32[$attrs + 16 >> 2];
 HEAP32[$1 + 20 >> 2] = HEAP32[$attrs + 20 >> 2];
 HEAP32[$1 + 24 >> 2] = HEAP32[$attrs + 24 >> 2];
 HEAP32[$1 >> 2] = _prvTidyDupAttrs($doc, HEAP32[$attrs >> 2] | 0) | 0;
 $4 = $doc + 6856 | 0;
 HEAP32[$1 + 20 >> 2] = _prvTidytmbstrdup(HEAP32[$4 >> 2] | 0, HEAP32[$attrs + 20 >> 2] | 0) | 0;
 HEAP32[$1 + 24 >> 2] = _prvTidytmbstrdup(HEAP32[$4 >> 2] | 0, HEAP32[$attrs + 24 >> 2] | 0) | 0;
 HEAP32[$1 + 4 >> 2] = _prvTidyFindAttribute($doc, $1) | 0;
 $18 = HEAP32[$attrs + 8 >> 2] | 0;
 if (!$18) $22 = 0; else $22 = _prvTidyCloneNode($doc, $18) | 0;
 HEAP32[$1 + 8 >> 2] = $22;
 $24 = HEAP32[$attrs + 12 >> 2] | 0;
 if (!$24) $28 = 0; else $28 = _prvTidyCloneNode($doc, $24) | 0;
 HEAP32[$1 + 12 >> 2] = $28;
 $$0 = $1;
 return $$0 | 0;
}

function _atoi($s) {
 $s = $s | 0;
 var $$0 = 0, $$0$lcssa = 0, $$1$ph = 0, $$13 = 0, $$lcssa9 = 0, $11 = 0, $4 = 0, $5 = 0, $8 = 0, $isdigittmp1 = 0, $isdigittmp5 = 0, $n$0$lcssa = 0, $n$04 = 0, $neg$0 = 0, $neg$1$ph = 0, label = 0;
 $$0 = $s;
 while (1) {
  $4 = $$0 + 1 | 0;
  if (!(_isspace(HEAP8[$$0 >> 0] | 0) | 0)) {
   $$0$lcssa = $$0;
   $$lcssa9 = $4;
   break;
  } else $$0 = $4;
 }
 $5 = HEAP8[$$0$lcssa >> 0] | 0;
 switch ($5 << 24 >> 24 | 0) {
 case 45:
  {
   $neg$0 = 1;
   label = 5;
   break;
  }
 case 43:
  {
   $neg$0 = 0;
   label = 5;
   break;
  }
 default:
  {
   $$1$ph = $$0$lcssa;
   $8 = $5;
   $neg$1$ph = 0;
  }
 }
 if ((label | 0) == 5) {
  $$1$ph = $$lcssa9;
  $8 = HEAP8[$$lcssa9 >> 0] | 0;
  $neg$1$ph = $neg$0;
 }
 $isdigittmp1 = ($8 << 24 >> 24) + -48 | 0;
 if ($isdigittmp1 >>> 0 < 10) {
  $$13 = $$1$ph;
  $isdigittmp5 = $isdigittmp1;
  $n$04 = 0;
  while (1) {
   $$13 = $$13 + 1 | 0;
   $11 = ($n$04 * 10 | 0) - $isdigittmp5 | 0;
   $isdigittmp5 = (HEAP8[$$13 >> 0] | 0) + -48 | 0;
   if ($isdigittmp5 >>> 0 >= 10) {
    $n$0$lcssa = $11;
    break;
   } else $n$04 = $11;
  }
 } else $n$0$lcssa = 0;
 return ($neg$1$ph | 0 ? $n$0$lcssa : 0 - $n$0$lcssa | 0) | 0;
}

function _prvTidyFileInput($doc, $fp, $encoding) {
 $doc = $doc | 0;
 $fp = $fp | 0;
 $encoding = $encoding | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $16 = 0, $23 = 0, $28 = 0, $4 = 0;
 $0 = $doc + 6856 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $4 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1 >> 2] >> 2] & 31]($1, 324) | 0;
 _memset($4 | 0, 0, 320) | 0;
 HEAP32[$4 + 292 >> 2] = 1;
 HEAP32[$4 + 288 >> 2] = 1;
 HEAP32[$4 + 296 >> 2] = $encoding;
 HEAP32[$4 >> 2] = 0;
 HEAP32[$4 + 320 >> 2] = $doc;
 HEAP32[$4 + 20 >> 2] = 5;
 $10 = HEAP32[$0 >> 2] | 0;
 $11 = $4 + 8 | 0;
 HEAP32[$11 >> 2] = $10;
 $12 = $10;
 $16 = $4 + 12 | 0;
 HEAP32[$16 >> 2] = FUNCTION_TABLE_iii[HEAP32[HEAP32[$12 >> 2] >> 2] & 31]($12, 20) | 0;
 HEAP16[$4 + 284 >> 1] = 0;
 HEAP16[$4 + 286 >> 1] = 0;
 if (!(_prvTidyinitFileSource(HEAP32[$0 >> 2] | 0, $4 + 304 | 0, $fp) | 0)) {
  HEAP32[$4 + 300 >> 2] = 0;
  $$0 = $4;
  return $$0 | 0;
 } else {
  $23 = HEAP32[$11 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$23 >> 2] | 0) + 8 >> 2] & 15]($23, HEAP32[$16 >> 2] | 0);
  $28 = HEAP32[$11 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$28 >> 2] | 0) + 8 >> 2] & 15]($28, $4);
  $$0 = 0;
  return $$0 | 0;
 }
 return 0;
}

function _CheckCaption($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$pr = 0, $$pr1$pr = 0, $1 = 0, $12 = 0, $5 = 0, $7 = 0, $8 = 0, $attval$01$i = 0, $attval$01$i$looptemp = 0;
 $1 = HEAP32[$node + 20 >> 2] | 0;
 if ($1 | 0) {
  $attval$01$i = $1;
  do {
   $attval$01$i$looptemp = $attval$01$i;
   $attval$01$i = HEAP32[$attval$01$i >> 2] | 0;
   _prvTidyCheckAttribute($doc, $node, $attval$01$i$looptemp) | 0;
  } while (($attval$01$i | 0) != 0);
 }
 $5 = _prvTidyAttrGetById($node, 7) | 0;
 if (!$5) return;
 $7 = $5 + 24 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 if (!$8) return;
 L11 : do if (_prvTidytmbstrcasecmp($8, 308192) | 0) {
  $12 = HEAP32[$7 >> 2] | 0;
  do if ($12 | 0) {
   if (!(_prvTidytmbstrcasecmp($12, 308197) | 0)) break L11;
   $$pr = HEAP32[$7 >> 2] | 0;
   if ($$pr | 0) {
    if (_prvTidytmbstrcasecmp($$pr, 308203) | 0) {
     $$pr1$pr = HEAP32[$7 >> 2] | 0;
     if (!$$pr1$pr) break;
     if (_prvTidytmbstrcasecmp($$pr1$pr, 308207) | 0) break;
    }
    _prvTidyConstrainVersion($doc, -4);
    return;
   }
  } while (0);
  _prvTidyReportAttrError($doc, $node, $5, 251);
  return;
 } while (0);
 _prvTidyConstrainVersion($doc, 584);
 return;
}

function _prvTidyFreeAttrs($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $0 = 0, $1 = 0, $21 = 0, $26 = 0, $3 = 0, $32 = 0, $4 = 0, $5 = 0, $9 = 0;
 $0 = $node + 20 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) return;
 $3 = $doc + 6856 | 0;
 $5 = $1;
 do {
  $4 = $5 + 20 | 0;
  L6 : do if (HEAP32[$4 >> 2] | 0) {
   $9 = HEAP32[$5 + 4 >> 2] | 0;
   if ($9 | 0) {
    switch (HEAP32[$9 >> 2] | 0) {
    case 85:
    case 63:
     break;
    default:
     break L6;
    }
    if (_prvTidyIsAnchorElement($doc, $node) | 0) _prvTidyRemoveAnchorByNode($doc, HEAP32[$5 + 24 >> 2] | 0, $node);
   }
  } while (0);
  HEAP32[$0 >> 2] = HEAP32[$5 >> 2];
  _prvTidyFreeNode($doc, HEAP32[$5 + 8 >> 2] | 0);
  _prvTidyFreeNode($doc, HEAP32[$5 + 12 >> 2] | 0);
  $21 = HEAP32[$3 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$21 >> 2] | 0) + 8 >> 2] & 15]($21, HEAP32[$4 >> 2] | 0);
  $26 = HEAP32[$3 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$26 >> 2] | 0) + 8 >> 2] & 15]($26, HEAP32[$5 + 24 >> 2] | 0);
  $32 = HEAP32[$3 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$32 >> 2] | 0) + 8 >> 2] & 15]($32, $5);
  $5 = HEAP32[$0 >> 2] | 0;
 } while (($5 | 0) != 0);
 return;
}

function _prvTidyInsertedToken($doc) {
 $doc = $doc | 0;
 var $$0 = 0, $1 = 0, $15 = 0, $17 = 0, $2 = 0, $26 = 0, $41 = 0, $45 = 0, $5 = 0, $6 = 0, $9 = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $2 = $1 + 100 | 0;
 $5 = $1 + 96 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 if (!(HEAP32[$2 >> 2] | 0)) {
  HEAP32[$5 >> 2] = 0;
  $$0 = $6;
  return $$0 | 0;
 }
 if (!$6) {
  $9 = HEAP32[$doc + 6776 >> 2] | 0;
  HEAP32[$1 >> 2] = HEAP32[$9 + 292 >> 2];
  HEAP32[$1 + 4 >> 2] = HEAP32[$9 + 288 >> 2];
 }
 $15 = $doc + 6856 | 0;
 $17 = _prvTidyNewNode(HEAP32[$15 >> 2] | 0, $1) | 0;
 HEAP32[$17 + 44 >> 2] = 5;
 HEAP32[$17 + 60 >> 2] = 1;
 HEAP32[$17 + 36 >> 2] = HEAP32[$1 + 48 >> 2];
 HEAP32[$17 + 40 >> 2] = HEAP32[$1 + 52 >> 2];
 $26 = HEAP32[$2 >> 2] | 0;
 HEAP32[$17 + 32 >> 2] = _prvTidytmbstrdup(HEAP32[$15 >> 2] | 0, HEAP32[$26 + 8 >> 2] | 0) | 0;
 HEAP32[$17 + 28 >> 2] = HEAP32[$26 + 4 >> 2];
 HEAP32[$17 + 20 >> 2] = _prvTidyDupAttrs($doc, HEAP32[$26 + 12 >> 2] | 0) | 0;
 $41 = HEAP32[$1 + 104 >> 2] | 0;
 $45 = ((HEAP32[$2 >> 2] | 0) - $41 >> 4) + 1 | 0;
 HEAP32[$2 >> 2] = $45 >>> 0 < (HEAP32[$1 + 112 >> 2] | 0) >>> 0 ? $41 + ($45 << 4) | 0 : 0;
 $$0 = $17;
 return $$0 | 0;
}

function _prvTidyTextNodeEndWithSpace($lexer, $node) {
 $lexer = $lexer | 0;
 $node = $node | 0;
 var $$1 = 0, $10 = 0, $14 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $5 = 0, $7 = 0, $9 = 0, $c = 0, $i$03 = 0, $i$1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 if (!(_prvTidynodeIsText($node) | 0)) {
  $$1 = 0;
  STACKTOP = sp;
  return $$1 | 0;
 }
 $2 = $node + 40 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 $5 = HEAP32[$node + 36 >> 2] | 0;
 if ($3 >>> 0 <= $5 >>> 0) {
  $$1 = 0;
  STACKTOP = sp;
  return $$1 | 0;
 }
 HEAP32[$c >> 2] = 0;
 $7 = $lexer + 84 | 0;
 $18 = $3;
 $i$03 = $5;
 while (1) {
  $9 = (HEAP32[$7 >> 2] | 0) + $i$03 | 0;
  $10 = HEAP8[$9 >> 0] | 0;
  HEAP32[$c >> 2] = $10 & 255;
  if ($10 << 24 >> 24 < 0) {
   $14 = (_prvTidyGetUTF8($9, $c) | 0) + $i$03 | 0;
   $17 = HEAP32[$2 >> 2] | 0;
   $i$1 = $14;
  } else {
   $17 = $18;
   $i$1 = $i$03;
  }
  $i$03 = $i$1 + 1 | 0;
  if ($i$03 >>> 0 >= $17 >>> 0) break; else $18 = $17;
 }
 switch (HEAP32[$c >> 2] | 0) {
 case 10:
 case 32:
  {
   $$1 = 1;
   STACKTOP = sp;
   return $$1 | 0;
  }
 default:
  {
   $$1 = 0;
   STACKTOP = sp;
   return $$1 | 0;
  }
 }
 return 0;
}

function _prvTidyIsWord2000($doc) {
 $doc = $doc | 0;
 var $$0 = 0, $0 = 0, $13 = 0, $16 = 0, $20 = 0, $23 = 0, $4 = 0, $9 = 0, $node$01 = 0, $node$02 = 0, label = 0;
 $0 = _prvTidyFindHTML($doc) | 0;
 if ($0 | 0) if (_prvTidyGetAttrByName($0, 311458) | 0) {
  $$0 = 1;
  return $$0 | 0;
 }
 $4 = _prvTidyFindHEAD($doc) | 0;
 if (!$4) {
  $$0 = 0;
  return $$0 | 0;
 }
 $node$01 = HEAP32[$4 + 12 >> 2] | 0;
 if (!$node$01) {
  $$0 = 0;
  return $$0 | 0;
 } else $node$02 = $node$01;
 while (1) {
  $9 = HEAP32[$node$02 + 28 >> 2] | 0;
  if ($9 | 0) if ((HEAP32[$9 >> 2] | 0) == 68) {
   $13 = _prvTidyAttrGetById($node$02, 85) | 0;
   if ($13 | 0) {
    $16 = HEAP32[$13 + 24 >> 2] | 0;
    if ($16 | 0) if (!(_prvTidytmbstrcasecmp($16, 311567) | 0)) {
     $20 = _prvTidyAttrGetById($node$02, 36) | 0;
     if ($20 | 0) {
      $23 = HEAP32[$20 + 24 >> 2] | 0;
      if ($23 | 0) if (_prvTidytmbsubstr($23, 311577) | 0) {
       $$0 = 1;
       label = 14;
       break;
      }
     }
    }
   }
  }
  $node$02 = HEAP32[$node$02 + 8 >> 2] | 0;
  if (!$node$02) {
   $$0 = 0;
   label = 14;
   break;
  }
 }
 if ((label | 0) == 14) return $$0 | 0;
 return 0;
}

function _CheckLength($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $11 = 0, $18 = 0, $2 = 0, $21 = 0, $5 = 0, $p$01 = 0, $p$02 = 0, label = 0;
 if ($attval | 0) {
  $2 = HEAP32[$attval + 24 >> 2] | 0;
  if ($2 | 0) {
   $5 = HEAP32[$attval + 4 >> 2] | 0;
   if ($5 | 0) if (($node | 0) != 0 & (HEAP32[$5 >> 2] | 0) == 159) {
    $11 = HEAP32[$node + 28 >> 2] | 0;
    if ($11 | 0) if (((HEAP32[$11 >> 2] | 0) + -23 | 0) >>> 0 < 2) return;
   }
   if (!(_prvTidyIsDigit(HEAP8[$2 >> 0] | 0) | 0)) {
    _prvTidyReportAttrError($doc, $node, $attval, 251);
    return;
   }
   $p$01 = $2 + 1 | 0;
   $18 = HEAP8[$p$01 >> 0] | 0;
   if (!($18 << 24 >> 24)) return; else {
    $21 = $18;
    $p$02 = $p$01;
   }
   while (1) {
    if (!(_prvTidyIsDigit($21 << 24 >> 24) | 0)) if ((HEAP8[$p$02 >> 0] | 0) != 37) break;
    $p$02 = $p$02 + 1 | 0;
    $21 = HEAP8[$p$02 >> 0] | 0;
    if (!($21 << 24 >> 24)) {
     label = 15;
     break;
    }
   }
   if ((label | 0) == 15) return;
   _prvTidyReportAttrError($doc, $node, $attval, 251);
   return;
  }
 }
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 return;
}

function _prvTidyReportMarkupVersion($doc) {
 $doc = $doc | 0;
 var $0 = 0, $11 = 0, $13 = 0, $16 = 0, $3 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vers$0 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = $doc + 6872 | 0;
 if (HEAP32[$0 >> 2] | 0) {
  $3 = _tidyLocalizedString(2054) | 0;
  HEAP32[$vararg_buffer >> 2] = HEAP32[$0 >> 2];
  _message($doc, 0, 2054, $3, $vararg_buffer);
 }
 if (HEAP32[$doc + 168 >> 2] | 0) {
  STACKTOP = sp;
  return;
 }
 $11 = HEAP32[(HEAP32[$doc + 68 >> 2] | 0) + 28 >> 2] | 0;
 $13 = _prvTidyHTMLVersionNameFromCode(_prvTidyApparentVersion($doc) | 0, $11) | 0;
 if (!$13) $vers$0 = _tidyLocalizedString(2059) | 0; else $vers$0 = $13;
 $16 = _tidyLocalizedString(2052) | 0;
 HEAP32[$vararg_buffer1 >> 2] = $vers$0;
 _message($doc, 0, 2052, $16, $vararg_buffer1);
 if (!(_prvTidyWarnMissingSIInEmittedDocType($doc) | 0)) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$vararg_buffer4 >> 2] = _tidyLocalizedString(2062) | 0;
 _message($doc, 0, 2062, 223602, $vararg_buffer4);
 STACKTOP = sp;
 return;
}

function _prvTidytmbstrncasecmp($s1, $s2, $n) {
 $s1 = $s1 | 0;
 $s2 = $s2 | 0;
 $n = $n | 0;
 var $$0 = 0, $$01$lcssa = 0, $$019 = 0, $$02$lcssa = 0, $$028 = 0, $$03$lcssa = 0, $$037 = 0, $0 = 0, $10 = 0, $11 = 0, $12 = 0, $15 = 0, $2 = 0, $7 = 0;
 $0 = HEAP8[$s1 >> 0] | 0;
 $2 = _prvTidyToLower($0 << 24 >> 24) | 0;
 L1 : do if (($2 | 0) == (_prvTidyToLower(HEAP8[$s2 >> 0] | 0) | 0)) {
  $$019 = $n;
  $$028 = $s2;
  $$037 = $s1;
  $7 = $0;
  while (1) {
   if (($$019 | 0) == 0 | $7 << 24 >> 24 == 0) {
    $$0 = 0;
    break;
   }
   $10 = $$037 + 1 | 0;
   $11 = $$028 + 1 | 0;
   $12 = $$019 + -1 | 0;
   $7 = HEAP8[$10 >> 0] | 0;
   $15 = _prvTidyToLower($7 << 24 >> 24) | 0;
   if (($15 | 0) != (_prvTidyToLower(HEAP8[$11 >> 0] | 0) | 0)) {
    $$01$lcssa = $12;
    $$02$lcssa = $11;
    $$03$lcssa = $10;
    break L1;
   } else {
    $$019 = $12;
    $$028 = $11;
    $$037 = $10;
   }
  }
  return $$0 | 0;
 } else {
  $$01$lcssa = $n;
  $$02$lcssa = $s2;
  $$03$lcssa = $s1;
 } while (0);
 if (!$$01$lcssa) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = (HEAP8[$$03$lcssa >> 0] | 0) > (HEAP8[$$02$lcssa >> 0] | 0) ? 1 : -1;
 return $$0 | 0;
}

function _AddChar($pprint, $c) {
 $pprint = $pprint | 0;
 $c = $c | 0;
 var $$pre$phi$iZ2D = 0, $0 = 0, $1 = 0, $13 = 0, $16 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $9 = 0, $buflen$0$i$i = 0, $buflen$0$i$i$lcssa = 0;
 $0 = $pprint + 12 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $1 + 1 | 0;
 $3 = $pprint + 8 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 if ($2 >>> 0 < $4 >>> 0) $$pre$phi$iZ2D = $pprint + 4 | 0; else {
  $buflen$0$i$i = ($4 | 0) == 0 ? 256 : $4;
  while (1) if ($buflen$0$i$i >>> 0 > $2 >>> 0) {
   $buflen$0$i$i$lcssa = $buflen$0$i$i;
   break;
  } else $buflen$0$i$i = $buflen$0$i$i << 1;
  $9 = HEAP32[$pprint >> 2] | 0;
  $13 = $pprint + 4 | 0;
  $16 = FUNCTION_TABLE_iiii[HEAP32[(HEAP32[$9 >> 2] | 0) + 4 >> 2] & 15]($9, HEAP32[$13 >> 2] | 0, $buflen$0$i$i$lcssa << 2) | 0;
  if (!$16) $$pre$phi$iZ2D = $13; else {
   $18 = HEAP32[$3 >> 2] | 0;
   _memset($16 + ($18 << 2) | 0, 0, $buflen$0$i$i$lcssa - $18 << 2 | 0) | 0;
   HEAP32[$3 >> 2] = $buflen$0$i$i$lcssa;
   HEAP32[$13 >> 2] = $16;
   $$pre$phi$iZ2D = $13;
  }
 }
 HEAP32[(HEAP32[$$pre$phi$iZ2D >> 2] | 0) + ($1 << 2) >> 2] = $c;
 HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + 1;
 return;
}

function _prvTidyCloneNode($doc, $element) {
 $doc = $doc | 0;
 $element = $element | 0;
 var $1 = 0, $13 = 0, $15 = 0, $3 = 0, $6 = 0, dest = 0, stop = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $3 = HEAP32[$1 + 124 >> 2] | 0;
 $6 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$3 >> 2] >> 2] & 31]($3, 68) | 0;
 dest = $6;
 stop = dest + 68 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 if ($1 | 0) {
  HEAP32[$6 + 48 >> 2] = HEAP32[$1 >> 2];
  HEAP32[$6 + 52 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 $13 = $6 + 44 | 0;
 HEAP32[$13 >> 2] = 4;
 $15 = HEAP32[$1 + 92 >> 2] | 0;
 HEAP32[$6 + 36 >> 2] = $15;
 HEAP32[$6 + 40 >> 2] = $15;
 if (!$element) return $6 | 0;
 HEAP32[$6 >> 2] = HEAP32[$element >> 2];
 HEAP32[$13 >> 2] = HEAP32[$element + 44 >> 2];
 HEAP32[$6 + 56 >> 2] = HEAP32[$element + 56 >> 2];
 HEAP32[$6 + 60 >> 2] = HEAP32[$element + 60 >> 2];
 HEAP32[$6 + 28 >> 2] = HEAP32[$element + 28 >> 2];
 HEAP32[$6 + 32 >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, HEAP32[$element + 32 >> 2] | 0) | 0;
 HEAP32[$6 + 20 >> 2] = _prvTidyDupAttrs($doc, HEAP32[$element + 20 >> 2] | 0) | 0;
 return $6 | 0;
}

function _prvTidyParseConfigValue($doc, $optId, $optval) {
 $doc = $doc | 0;
 $optId = $optId | 0;
 $optval = $optval | 0;
 var $$0$i = 0, $$sink = 0, $13 = 0, $19 = 0, $inbuf = 0, $status$0 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $inbuf = sp;
 if (!($optId >>> 0 < 98 & ($optval | 0) != 0)) {
  _prvTidyReportBadArgument($doc, HEAP32[1892 + ($optId << 5) + 8 >> 2] | 0);
  $status$0 = 0;
  STACKTOP = sp;
  return $status$0 | 0;
 }
 _tidyBufInitWithAllocator($inbuf, HEAP32[$doc + 6856 >> 2] | 0);
 _tidyBufAttach($inbuf, $optval, (_prvTidytmbstrlen($optval) | 0) + 1 | 0);
 if (($optId | 0) == 14) $$sink = _prvTidyBufferInput($doc, $inbuf, 0) | 0; else $$sink = _prvTidyBufferInput($doc, $inbuf, 1) | 0;
 $13 = $doc + 872 | 0;
 HEAP32[$13 >> 2] = $$sink;
 if (!$$sink) $$0$i = -1; else $$0$i = _prvTidyReadChar($$sink) | 0;
 HEAP32[$doc + 868 >> 2] = $$0$i;
 $19 = FUNCTION_TABLE_iii[HEAP32[1892 + ($optId << 5) + 20 >> 2] & 31]($doc, 1892 + ($optId << 5) | 0) | 0;
 _prvTidyfreeStreamIn(HEAP32[$13 >> 2] | 0);
 HEAP32[$13 >> 2] = 0;
 _tidyBufDetach($inbuf);
 $status$0 = $19;
 STACKTOP = sp;
 return $status$0 | 0;
}

function _prvTidyReportNotice($doc, $element, $node, $code) {
 $doc = $doc | 0;
 $element = $element | 0;
 $node = $node | 0;
 $code = $code | 0;
 var $2 = 0, $elemdesc = 0, $nodedesc = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 528 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $nodedesc = sp + 272 | 0;
 $elemdesc = sp + 16 | 0;
 $2 = _tidyLocalizedString($code) | 0;
 _memset($nodedesc | 0, 0, 256) | 0;
 _memset($elemdesc | 0, 0, 256) | 0;
 if (!$2) ___assert_fail(223545, 223391, 722, 223651);
 _TagToString($node, $nodedesc, 256);
 switch ($code | 0) {
 case 223:
  {
   _TagToString($element, $elemdesc, 256);
   HEAP32[$vararg_buffer >> 2] = $elemdesc;
   _messageNode($doc, 1, 223, $element, $2, $vararg_buffer);
   STACKTOP = sp;
   return;
  }
 case 283:
  {
   _TagToString($element, $elemdesc, 256);
   HEAP32[$vararg_buffer1 >> 2] = $elemdesc;
   HEAP32[$vararg_buffer1 + 4 >> 2] = $nodedesc;
   _messageNode($doc, 1, 283, $element | 0 ? $element : $node, $2, $vararg_buffer1);
   STACKTOP = sp;
   return;
  }
 default:
  {
   STACKTOP = sp;
   return;
  }
 }
}

function _strcasecmp($_l, $_r) {
 $_l = $_l | 0;
 $_r = $_r | 0;
 var $0 = 0, $14 = 0, $15 = 0, $19 = 0, $20 = 0, $3 = 0, $5 = 0, $7 = 0, $8 = 0, $l$03 = 0, $l$03$lcssa20 = 0, $r$0$lcssa = 0, $r$04 = 0, $r$04$lcssa19 = 0;
 $0 = HEAP8[$_l >> 0] | 0;
 L1 : do if (!($0 << 24 >> 24)) {
  $19 = 0;
  $r$0$lcssa = $_r;
 } else {
  $5 = $0;
  $7 = $0 & 255;
  $l$03 = $_l;
  $r$04 = $_r;
  while (1) {
   $3 = HEAP8[$r$04 >> 0] | 0;
   if (!($3 << 24 >> 24)) {
    $19 = $5;
    $r$0$lcssa = $r$04;
    break L1;
   }
   if ($5 << 24 >> 24 != $3 << 24 >> 24) {
    $8 = _tolower($7) | 0;
    if (($8 | 0) != (_tolower(HEAPU8[$r$04 >> 0] | 0) | 0)) {
     $l$03$lcssa20 = $l$03;
     $r$04$lcssa19 = $r$04;
     break;
    }
   }
   $l$03 = $l$03 + 1 | 0;
   $14 = $r$04 + 1 | 0;
   $15 = HEAP8[$l$03 >> 0] | 0;
   if (!($15 << 24 >> 24)) {
    $19 = 0;
    $r$0$lcssa = $14;
    break L1;
   } else {
    $5 = $15;
    $7 = $15 & 255;
    $r$04 = $14;
   }
  }
  $19 = HEAP8[$l$03$lcssa20 >> 0] | 0;
  $r$0$lcssa = $r$04$lcssa19;
 } while (0);
 $20 = _tolower($19 & 255) | 0;
 return $20 - (_tolower(HEAPU8[$r$0$lcssa >> 0] | 0) | 0) | 0;
}

function _fmt_u($0, $1, $s) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $s = $s | 0;
 var $$0$lcssa = 0, $$01$lcssa$off0 = 0, $$05 = 0, $$1$lcssa = 0, $$12 = 0, $$lcssa19 = 0, $13 = 0, $14 = 0, $25 = 0, $28 = 0, $7 = 0, $8 = 0, $9 = 0, $y$03 = 0;
 if ($1 >>> 0 > 0 | ($1 | 0) == 0 & $0 >>> 0 > 4294967295) {
  $$05 = $s;
  $7 = $0;
  $8 = $1;
  while (1) {
   $9 = ___uremdi3($7 | 0, $8 | 0, 10, 0) | 0;
   $13 = $$05 + -1 | 0;
   HEAP8[$13 >> 0] = $9 | 48;
   $14 = ___udivdi3($7 | 0, $8 | 0, 10, 0) | 0;
   if ($8 >>> 0 > 9 | ($8 | 0) == 9 & $7 >>> 0 > 4294967295) {
    $$05 = $13;
    $7 = $14;
    $8 = tempRet0;
   } else {
    $$lcssa19 = $13;
    $28 = $14;
    break;
   }
  }
  $$0$lcssa = $$lcssa19;
  $$01$lcssa$off0 = $28;
 } else {
  $$0$lcssa = $s;
  $$01$lcssa$off0 = $0;
 }
 if (!$$01$lcssa$off0) $$1$lcssa = $$0$lcssa; else {
  $$12 = $$0$lcssa;
  $y$03 = $$01$lcssa$off0;
  while (1) {
   $25 = $$12 + -1 | 0;
   HEAP8[$25 >> 0] = ($y$03 >>> 0) % 10 | 0 | 48;
   if ($y$03 >>> 0 < 10) {
    $$1$lcssa = $25;
    break;
   } else {
    $$12 = $25;
    $y$03 = ($y$03 >>> 0) / 10 | 0;
   }
  }
 }
 return $$1$lcssa | 0;
}

function _prvTidyinitFileSource($allocator, $inp, $fp) {
 $allocator = $allocator | 0;
 $inp = $inp | 0;
 $fp = $fp | 0;
 var $$0 = 0, $11 = 0, $2 = 0, $4 = 0, $8 = 0, $sbuf = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $sbuf = sp;
 $2 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$allocator >> 2] >> 2] & 31]($allocator, 16) | 0;
 if (!$2) {
  $$0 = -1;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $4 = _fileno($fp) | 0;
 if ((_fstat($4, $sbuf) | 0) != -1) {
  $8 = HEAP32[$sbuf + 36 >> 2] | 0;
  if ($8 | 0) {
   HEAP32[$2 + 12 >> 2] = $8;
   $11 = ___mmap(0, $8, 1, 1, $4, 0) | 0;
   HEAP32[$2 + 4 >> 2] = $11;
   if (($11 | 0) != (-1 | 0)) {
    HEAP32[$2 + 8 >> 2] = 0;
    HEAP32[$2 >> 2] = $allocator;
    _fclose($fp) | 0;
    HEAP32[$inp + 4 >> 2] = 13;
    HEAP32[$inp + 12 >> 2] = 14;
    HEAP32[$inp + 8 >> 2] = 11;
    HEAP32[$inp >> 2] = $2;
    $$0 = 0;
    STACKTOP = sp;
    return $$0 | 0;
   }
  }
 }
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$allocator >> 2] | 0) + 8 >> 2] & 15]($allocator, $2);
 $$0 = _prvTidyinitStdIOFileSource($allocator, $inp, $fp) | 0;
 STACKTOP = sp;
 return $$0 | 0;
}

function _prvTidyFindHEAD($doc) {
 $doc = $doc | 0;
 var $15 = 0, $2 = 0, $5 = 0, $node$02$i = 0, $node$02$i$lcssa = 0, $node$04 = 0, $node$05 = 0, $node$1 = 0, label = 0;
 if (!$doc) {
  $node$1 = 0;
  return $node$1 | 0;
 }
 $2 = HEAP32[$doc + 12 >> 2] | 0;
 if (!$2) {
  $node$1 = 0;
  return $node$1 | 0;
 } else $node$02$i = $2;
 while (1) {
  $5 = HEAP32[$node$02$i + 28 >> 2] | 0;
  if ($5 | 0) if ((HEAP32[$5 >> 2] | 0) == 48) {
   $node$02$i$lcssa = $node$02$i;
   break;
  }
  $node$02$i = HEAP32[$node$02$i + 8 >> 2] | 0;
  if (!$node$02$i) {
   $node$1 = 0;
   label = 10;
   break;
  }
 }
 if ((label | 0) == 10) return $node$1 | 0;
 $node$04 = HEAP32[$node$02$i$lcssa + 12 >> 2] | 0;
 if (!$node$04) {
  $node$1 = 0;
  return $node$1 | 0;
 } else $node$05 = $node$04;
 while (1) {
  $15 = HEAP32[$node$05 + 28 >> 2] | 0;
  if ($15 | 0) if ((HEAP32[$15 >> 2] | 0) == 46) {
   $node$1 = $node$05;
   label = 10;
   break;
  }
  $node$05 = HEAP32[$node$05 + 8 >> 2] | 0;
  if (!$node$05) {
   $node$1 = 0;
   label = 10;
   break;
  }
 }
 if ((label | 0) == 10) return $node$1 | 0;
 return 0;
}
function _fflush($f) {
 $f = $f | 0;
 var $$0 = 0, $$012 = 0, $$014 = 0, $23 = 0, $27 = 0, $6 = 0, $phitmp = 0, $r$0$lcssa = 0, $r$03 = 0, $r$1 = 0;
 do if (!$f) {
  if (!(HEAP32[55085] | 0)) $27 = 0; else $27 = _fflush(HEAP32[55085] | 0) | 0;
  ___lock(317044);
  $$012 = HEAP32[79260] | 0;
  if (!$$012) $r$0$lcssa = $27; else {
   $$014 = $$012;
   $r$03 = $27;
   while (1) {
    if ((HEAP32[$$014 + 76 >> 2] | 0) > -1) $23 = ___lockfile($$014) | 0; else $23 = 0;
    if ((HEAP32[$$014 + 20 >> 2] | 0) >>> 0 > (HEAP32[$$014 + 28 >> 2] | 0) >>> 0) $r$1 = ___fflush_unlocked($$014) | 0 | $r$03; else $r$1 = $r$03;
    if ($23 | 0) ___unlockfile($$014);
    $$014 = HEAP32[$$014 + 56 >> 2] | 0;
    if (!$$014) {
     $r$0$lcssa = $r$1;
     break;
    } else $r$03 = $r$1;
   }
  }
  ___unlock(317044);
  $$0 = $r$0$lcssa;
 } else {
  if ((HEAP32[$f + 76 >> 2] | 0) <= -1) {
   $$0 = ___fflush_unlocked($f) | 0;
   break;
  }
  $phitmp = (___lockfile($f) | 0) == 0;
  $6 = ___fflush_unlocked($f) | 0;
  if ($phitmp) $$0 = $6; else {
   ___unlockfile($f);
   $$0 = $6;
  }
 } while (0);
 return $$0 | 0;
}

function _tidy_out($doc, $msg, $varargs) {
 $doc = $doc | 0;
 $msg = $msg | 0;
 $varargs = $varargs | 0;
 var $10 = 0, $11 = 0, $12 = 0, $17 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $9 = 0, $args = 0, $cp$0 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $args = sp;
 if (HEAP32[$doc + 148 >> 2] | 0) {
  STACKTOP = sp;
  return;
 }
 $3 = $doc + 6784 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $doc + 6856 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $9 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$6 >> 2] >> 2] & 31]($6, 2048) | 0;
 HEAP32[$args >> 2] = $varargs;
 _prvTidytmbvsnprintf($9, 2048, $msg, $args) | 0;
 $10 = $4 + 20 | 0;
 $11 = $4 + 16 | 0;
 $cp$0 = $9;
 L4 : while (1) {
  $12 = HEAP8[$cp$0 >> 0] | 0;
  switch ($12 << 24 >> 24) {
  case 0:
   {
    break L4;
    break;
   }
  case 10:
   {
    _prvTidyWriteChar(10, HEAP32[$3 >> 2] | 0);
    break;
   }
  default:
   FUNCTION_TABLE_vii[HEAP32[$10 >> 2] & 15](HEAP32[$11 >> 2] | 0, $12);
  }
  $cp$0 = $cp$0 + 1 | 0;
 }
 $17 = HEAP32[$5 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$17 >> 2] | 0) + 8 >> 2] & 15]($17, $9);
 STACKTOP = sp;
 return;
}

function _prvTidyFreeTags($doc) {
 $doc = $doc | 0;
 var $0 = 0, $1 = 0, $12 = 0, $13 = 0, $15 = 0, $2 = 0, $21 = 0, $6 = 0, $i$02$i = 0, $next$01$i = 0, $next$01$i$looptemp = 0;
 $0 = $doc + 6856 | 0;
 $i$02$i = 0;
 do {
  $1 = $doc + 884 + ($i$02$i << 2) | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  if ($2 | 0) {
   $next$01$i = $2;
   do {
    $next$01$i$looptemp = $next$01$i;
    $next$01$i = HEAP32[$next$01$i + 4 >> 2] | 0;
    $6 = HEAP32[$0 >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$6 >> 2] | 0) + 8 >> 2] & 15]($6, $next$01$i$looptemp);
   } while (($next$01$i | 0) != 0);
  }
  HEAP32[$1 >> 2] = 0;
  $i$02$i = $i$02$i + 1 | 0;
 } while (($i$02$i | 0) != 178);
 $12 = $doc + 876 | 0;
 _prvTidyFreeDeclaredTags($doc, 0);
 $13 = HEAP32[$12 >> 2] | 0;
 if ($13 | 0) {
  $15 = HEAP32[$0 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$15 >> 2] | 0) + 8 >> 2] & 15]($15, HEAP32[$13 + 4 >> 2] | 0);
 }
 $21 = HEAP32[$0 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$21 >> 2] | 0) + 8 >> 2] & 15]($21, $13);
 _memset($12 | 0, 0, 720) | 0;
 HEAP32[$doc + 6852 >> 2] = 0;
 return;
}

function _ForEachSortedOption($tdoc, $OptionPrint) {
 $tdoc = $tdoc | 0;
 $OptionPrint = $OptionPrint | 0;
 var $0 = 0, $4 = 0, $7 = 0, $9 = 0, $i$0$lcssa$i = 0, $i$01$i = 0, $pos$i = 0, $tOption = 0, $topt$01 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 496 | 0;
 $pos$i = sp + 392 | 0;
 $tOption = sp;
 $0 = _tidyGetOptionList($tdoc) | 0;
 HEAP32[$pos$i >> 2] = $0;
 if (!$0) $i$0$lcssa$i = 0; else {
  $i$01$i = 0;
  while (1) {
   HEAP32[$tOption + ($i$01$i << 2) >> 2] = _tidyGetNextOption($tdoc, $pos$i) | 0;
   $4 = $i$01$i + 1 | 0;
   if (!(HEAP32[$pos$i >> 2] | 0)) {
    $i$0$lcssa$i = $4;
    break;
   } else $i$01$i = $4;
  }
 }
 HEAP32[$tOption + ($i$0$lcssa$i << 2) >> 2] = 0;
 _qsort($tOption, 97, 4, 15);
 $7 = HEAP32[$tOption >> 2] | 0;
 if (!$7) {
  STACKTOP = sp;
  return;
 }
 $9 = $7;
 $topt$01 = $tOption;
 do {
  _GetOption($tdoc, $9, $pos$i);
  FUNCTION_TABLE_viii[$OptionPrint & 63]($tdoc, HEAP32[$topt$01 >> 2] | 0, $pos$i);
  $topt$01 = $topt$01 + 4 | 0;
  $9 = HEAP32[$topt$01 >> 2] | 0;
 } while (($9 | 0) != 0);
 STACKTOP = sp;
 return;
}

function _prvTidyNewLiteralTextNode($lexer, $txt) {
 $lexer = $lexer | 0;
 $txt = $txt | 0;
 var $$01$i = 0, $1 = 0, $12 = 0, $13 = 0, $15 = 0, $18 = 0, $22 = 0, $23 = 0, $4 = 0, dest = 0, stop = 0;
 $1 = HEAP32[$lexer + 124 >> 2] | 0;
 $4 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1 >> 2] >> 2] & 31]($1, 68) | 0;
 dest = $4;
 stop = dest + 68 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 if ($lexer | 0) {
  HEAP32[$4 + 48 >> 2] = HEAP32[$lexer >> 2];
  HEAP32[$4 + 52 >> 2] = HEAP32[$lexer + 4 >> 2];
 }
 HEAP32[$4 + 44 >> 2] = 4;
 $12 = $lexer + 92 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 HEAP32[$4 + 36 >> 2] = $13;
 $15 = HEAP8[$txt >> 0] | 0;
 if (!($15 << 24 >> 24)) {
  $23 = $13;
  $22 = $4 + 40 | 0;
  HEAP32[$22 >> 2] = $23;
  return $4 | 0;
 } else {
  $$01$i = $txt;
  $18 = $15;
 }
 do {
  $$01$i = $$01$i + 1 | 0;
  _prvTidyAddCharToLexer($lexer, $18 & 255);
  $18 = HEAP8[$$01$i >> 0] | 0;
 } while ($18 << 24 >> 24 != 0);
 $23 = HEAP32[$12 >> 2] | 0;
 $22 = $4 + 40 | 0;
 HEAP32[$22 >> 2] = $23;
 return $4 | 0;
}

function ___mmap($start, $len, $prot, $flags, $fd, $off) {
 $start = $start | 0;
 $len = $len | 0;
 $prot = $prot | 0;
 $flags = $flags | 0;
 $fd = $fd | 0;
 $off = $off | 0;
 var $$0 = 0, $11 = 0, $15 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer = sp;
 do if (($off & 4095 | 0) == 0 & ((($off | 0) < 0) << 31 >> 31 & -4096 | 0) == 0) {
  if ($len >>> 0 > 2147483646) {
   HEAP32[(___errno_location() | 0) >> 2] = 12;
   $$0 = -1;
   break;
  }
  $11 = ($flags & 16 | 0) != 0;
  if ($11) _dummy1(-1);
  HEAP32[$vararg_buffer >> 2] = $start;
  HEAP32[$vararg_buffer + 4 >> 2] = $len;
  HEAP32[$vararg_buffer + 8 >> 2] = $prot;
  HEAP32[$vararg_buffer + 12 >> 2] = $flags;
  HEAP32[$vararg_buffer + 16 >> 2] = $fd;
  HEAP32[$vararg_buffer + 20 >> 2] = $off >> 12;
  $15 = ___syscall_ret(___syscall192(192, $vararg_buffer | 0) | 0) | 0;
  if ($11) {
   _dummy0();
   $$0 = $15;
  } else $$0 = $15;
 } else {
  HEAP32[(___errno_location() | 0) >> 2] = 22;
  $$0 = -1;
 } while (0);
 STACKTOP = sp;
 return $$0 | 0;
}

function _strlen($s) {
 $s = $s | 0;
 var $$01$lcssa = 0, $$014 = 0, $$1$lcssa = 0, $$lcssa20 = 0, $$pn = 0, $$pn15 = 0, $0 = 0, $18 = 0, $21 = 0, $5 = 0, $9 = 0, $w$0 = 0, $w$0$lcssa = 0, label = 0;
 $0 = $s;
 L1 : do if (!($0 & 3)) {
  $$01$lcssa = $s;
  label = 4;
 } else {
  $$014 = $s;
  $21 = $0;
  while (1) {
   if (!(HEAP8[$$014 >> 0] | 0)) {
    $$pn = $21;
    break L1;
   }
   $5 = $$014 + 1 | 0;
   $21 = $5;
   if (!($21 & 3)) {
    $$01$lcssa = $5;
    label = 4;
    break;
   } else $$014 = $5;
  }
 } while (0);
 if ((label | 0) == 4) {
  $w$0 = $$01$lcssa;
  while (1) {
   $9 = HEAP32[$w$0 >> 2] | 0;
   if (!(($9 & -2139062144 ^ -2139062144) & $9 + -16843009)) $w$0 = $w$0 + 4 | 0; else {
    $$lcssa20 = $9;
    $w$0$lcssa = $w$0;
    break;
   }
  }
  if (!(($$lcssa20 & 255) << 24 >> 24)) $$1$lcssa = $w$0$lcssa; else {
   $$pn15 = $w$0$lcssa;
   while (1) {
    $18 = $$pn15 + 1 | 0;
    if (!(HEAP8[$18 >> 0] | 0)) {
     $$1$lcssa = $18;
     break;
    } else $$pn15 = $18;
   }
  }
  $$pn = $$1$lcssa;
 }
 return $$pn - $0 | 0;
}

function _prvTidyResetOptionToDefault($doc, $optId) {
 $doc = $doc | 0;
 $optId = $optId | 0;
 var $$sink$i = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $16 = 0, $20 = 0, $5 = 0, $8 = 0;
 $0 = ($optId + -1 | 0) >>> 0 < 97;
 $1 = $0 & 1;
 if (!$0) return $1 | 0;
 if ((HEAP32[1892 + ($optId << 5) >> 2] | 0) != ($optId | 0)) ___assert_fail(225540, 223800, 440, 225560);
 $5 = $doc + 72 + ($optId << 2) | 0;
 $8 = (HEAP32[1892 + ($optId << 5) + 12 >> 2] | 0) == 0;
 $10 = 1892 + ($optId << 5) + 28 | 0;
 $$sink$i = HEAP32[($8 ? $10 : 1892 + ($optId << 5) + 16 | 0) >> 2] | 0;
 if (!$8) {
  HEAP32[$5 >> 2] = $$sink$i;
  return $1 | 0;
 }
 $11 = HEAP32[$5 >> 2] | 0;
 if ($11 | 0) if (($11 | 0) != (HEAP32[$10 >> 2] | 0)) {
  $16 = HEAP32[$doc + 6856 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$16 >> 2] | 0) + 8 >> 2] & 15]($16, $11);
 }
 $20 = $$sink$i;
 if ($$sink$i | 0) if (($20 | 0) != (HEAP32[$10 >> 2] | 0)) {
  HEAP32[$5 >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, $20) | 0;
  return $1 | 0;
 }
 HEAP32[$5 >> 2] = $$sink$i;
 return $1 | 0;
}

function _tidyRelease($tdoc) {
 $tdoc = $tdoc | 0;
 var $$pre$i = 0, $10 = 0, $12 = 0, $16 = 0, $7 = 0, dest = 0, stop = 0;
 if (!$tdoc) return;
 if (HEAP32[$tdoc + 6776 >> 2] | 0) ___assert_fail(226416, 226435, 167, 226525);
 if (HEAP32[$tdoc + 6780 >> 2] | 0) ___assert_fail(226540, 226435, 168, 226525);
 $7 = $tdoc + 6784 | 0;
 _prvTidyReleaseStreamOut($tdoc, HEAP32[$7 >> 2] | 0);
 HEAP32[$7 >> 2] = 0;
 _prvTidyFreePrintBuf($tdoc);
 _prvTidyFreeNode($tdoc, $tdoc);
 dest = $tdoc;
 stop = dest + 68 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 $10 = HEAP32[$tdoc + 6872 >> 2] | 0;
 $$pre$i = $tdoc + 6856 | 0;
 if ($10 | 0) {
  $12 = HEAP32[$$pre$i >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$12 >> 2] | 0) + 8 >> 2] & 15]($12, $10);
 }
 _prvTidyFreeConfig($tdoc);
 _prvTidyFreeAttrTable($tdoc);
 _prvTidyFreeTags($tdoc);
 _prvTidyFreeLexer($tdoc);
 $16 = HEAP32[$$pre$i >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$16 >> 2] | 0) + 8 >> 2] & 15]($16, $tdoc);
 return;
}

function _prvTidytmbstrncmp($s1, $s2, $n) {
 $s1 = $s1 | 0;
 $s2 = $s2 | 0;
 $n = $n | 0;
 var $$0 = 0, $$01$lcssa = 0, $$0110 = 0, $$029 = 0, $$038 = 0, $$lcssa = 0, $$lcssa6 = 0, $0 = 0, $1 = 0, $10 = 0, $3 = 0, $8 = 0, $9 = 0;
 $0 = HEAP8[$s1 >> 0] | 0;
 $1 = HEAP8[$s2 >> 0] | 0;
 L1 : do if ($0 << 24 >> 24 == $1 << 24 >> 24) {
  $$0110 = $n;
  $$029 = $s2;
  $$038 = $s1;
  $3 = $0;
  while (1) {
   if (($$0110 | 0) == 0 | $3 << 24 >> 24 == 0) {
    $$0 = 0;
    break;
   }
   $$038 = $$038 + 1 | 0;
   $$029 = $$029 + 1 | 0;
   $8 = $$0110 + -1 | 0;
   $9 = HEAP8[$$038 >> 0] | 0;
   $10 = HEAP8[$$029 >> 0] | 0;
   if ($9 << 24 >> 24 != $10 << 24 >> 24) {
    $$01$lcssa = $8;
    $$lcssa = $9;
    $$lcssa6 = $10;
    break L1;
   } else {
    $$0110 = $8;
    $3 = $9;
   }
  }
  return $$0 | 0;
 } else {
  $$01$lcssa = $n;
  $$lcssa = $0;
  $$lcssa6 = $1;
 } while (0);
 if (!$$01$lcssa) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = $$lcssa << 24 >> 24 > $$lcssa6 << 24 >> 24 ? 1 : -1;
 return $$0 | 0;
}

function _prvTidyParseScript($doc, $script, $mode) {
 $doc = $doc | 0;
 $script = $script | 0;
 $mode = $mode | 0;
 var $0 = 0, $14 = 0, $20 = 0, $3 = 0, $7 = 0, $8 = 0;
 $0 = $doc + 68 | 0;
 HEAP32[(HEAP32[$0 >> 2] | 0) + 72 >> 2] = $script;
 $3 = _prvTidyGetToken($doc, 5) | 0;
 HEAP32[(HEAP32[$0 >> 2] | 0) + 72 >> 2] = 0;
 if (!$3) {
  _prvTidyReportError($doc, $script, 0, 206);
  return;
 }
 HEAP32[$3 >> 2] = $script;
 $7 = $script + 16 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 HEAP32[$3 + 4 >> 2] = $8;
 if (!$8) HEAP32[$script + 12 >> 2] = $3; else HEAP32[$8 + 8 >> 2] = $3;
 HEAP32[$7 >> 2] = $3;
 $14 = _prvTidyGetToken($doc, 0) | 0;
 if (!$14) {
  _prvTidyReportError($doc, $script, 0, 206);
  return;
 }
 if ((HEAP32[$14 + 44 >> 2] | 0) == 6) {
  $20 = HEAP32[$14 + 28 >> 2] | 0;
  if ($20 | 0) if ((HEAP32[$20 >> 2] | 0) == (HEAP32[HEAP32[$script + 28 >> 2] >> 2] | 0)) {
   _prvTidyFreeNode($doc, $14);
   return;
  }
 }
 _prvTidyReportError($doc, $script, $14, 206);
 _prvTidyUngetToken($doc);
 return;
}

function _tidyOptGetCurrPick($tdoc, $optId) {
 $tdoc = $tdoc | 0;
 $optId = $optId | 0;
 var $$1 = 0, $$lcssa = 0, $$lcssa3 = 0, $0 = 0, $10 = 0, $11 = 0, $12 = 0, $16 = 0, $17 = 0, $3 = 0, $6 = 0, $ix$06 = 0, $pL$07 = 0;
 $0 = _prvTidygetOption($optId) | 0;
 do if ($0 | 0) {
  $3 = HEAP32[$0 + 24 >> 2] | 0;
  if ($3 | 0) {
   if (!$tdoc) {
    $6 = HEAP32[$3 >> 2] | 0;
    if (!$6) break; else $$1 = $6;
    return $$1 | 0;
   }
   $10 = HEAP32[$tdoc + 72 + ($optId << 2) >> 2] | 0;
   $11 = HEAP32[$3 >> 2] | 0;
   $12 = ($11 | 0) == 0;
   if (($10 | 0) != 0 & ($12 ^ 1)) {
    $ix$06 = 0;
    $pL$07 = $3;
    do {
     $pL$07 = $pL$07 + 4 | 0;
     $ix$06 = $ix$06 + 1 | 0;
     $16 = HEAP32[$pL$07 >> 2] | 0;
     $17 = ($16 | 0) == 0;
    } while ($ix$06 >>> 0 < $10 >>> 0 & ($17 ^ 1));
    $$lcssa = $16;
    $$lcssa3 = $17;
   } else {
    $$lcssa = $11;
    $$lcssa3 = $12;
   }
   if (!$$lcssa3) {
    $$1 = $$lcssa;
    return $$1 | 0;
   }
  }
 } while (0);
 $$1 = 0;
 return $$1 | 0;
}

function _prvTidyInlineDup1($doc, $node, $element) {
 $doc = $doc | 0;
 $node = $node | 0;
 $element = $element | 0;
 var $$0 = 0, $$lcssa = 0, $1 = 0, $10 = 0, $12 = 0, $14 = 0, $4 = 0, $i$0 = 0, $i$0$in = 0, $i$0$lcssa6 = 0, label = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 if (!$element) {
  $$0 = 0;
  return $$0 | 0;
 }
 $4 = HEAP32[$element + 28 >> 2] | 0;
 if (!$4) {
  $$0 = 0;
  return $$0 | 0;
 }
 $10 = (HEAP32[$1 + 112 >> 2] | 0) - (HEAP32[$1 + 116 >> 2] | 0) | 0;
 if (($10 | 0) <= 0) {
  $$0 = 0;
  return $$0 | 0;
 }
 $12 = $1 + 104 | 0;
 $i$0$in = $10;
 while (1) {
  $i$0 = $i$0$in + -1 | 0;
  if (($i$0$in | 0) <= 0) {
   $$0 = 0;
   label = 8;
   break;
  }
  $14 = HEAP32[$12 >> 2] | 0;
  if ((HEAP32[$14 + ($i$0 << 4) + 4 >> 2] | 0) == ($4 | 0)) {
   $$lcssa = $14;
   $i$0$lcssa6 = $i$0;
   break;
  } else $i$0$in = $i$0;
 }
 if ((label | 0) == 8) return $$0 | 0;
 HEAP32[$1 + 100 >> 2] = $$lcssa + ($i$0$lcssa6 << 4);
 HEAP32[$1 + 96 >> 2] = $node;
 $$0 = 1;
 return $$0 | 0;
}

function ___remdi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $rem = 0, $1$0 = 0, $1$1 = 0, $2$0 = 0, $2$1 = 0, $4$0 = 0, $4$1 = 0, $10$0 = 0, $10$1 = 0, __stackBase__ = 0;
 __stackBase__ = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $rem = __stackBase__ | 0;
 $1$0 = $a$1 >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1;
 $1$1 = (($a$1 | 0) < 0 ? -1 : 0) >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1;
 $2$0 = $b$1 >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1;
 $2$1 = (($b$1 | 0) < 0 ? -1 : 0) >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1;
 $4$0 = _i64Subtract($1$0 ^ $a$0 | 0, $1$1 ^ $a$1 | 0, $1$0 | 0, $1$1 | 0) | 0;
 $4$1 = tempRet0;
 ___udivmoddi4($4$0, $4$1, _i64Subtract($2$0 ^ $b$0 | 0, $2$1 ^ $b$1 | 0, $2$0 | 0, $2$1 | 0) | 0, tempRet0, $rem) | 0;
 $10$0 = _i64Subtract(HEAP32[$rem >> 2] ^ $1$0 | 0, HEAP32[$rem + 4 >> 2] ^ $1$1 | 0, $1$0 | 0, $1$1 | 0) | 0;
 $10$1 = tempRet0;
 STACKTOP = __stackBase__;
 return (tempRet0 = $10$1, $10$0) | 0;
}

function _prvTidyFreeLexer($doc) {
 $doc = $doc | 0;
 var $0 = 0, $1 = 0, $11 = 0, $16 = 0, $17 = 0, $23 = 0, $29 = 0, $7 = 0, label = 0;
 $0 = $doc + 68 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) return;
 _prvTidyFreeStyles($doc);
 $7 = HEAP32[$1 + 64 >> 2] | 0;
 if (!(HEAP32[$1 + 12 >> 2] | 0)) {
  if ($7 | 0) label = 5;
 } else {
  _prvTidyFreeNode($doc, $7);
  label = 5;
 }
 if ((label | 0) == 5) _prvTidyFreeNode($doc, HEAP32[$1 + 60 >> 2] | 0);
 $11 = $1 + 112 | 0;
 if (HEAP32[$11 >> 2] | 0) do _prvTidyPopInline($doc, 0); while ((HEAP32[$11 >> 2] | 0) != 0);
 $16 = $doc + 6856 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$17 >> 2] | 0) + 8 >> 2] & 15]($17, HEAP32[$1 + 104 >> 2] | 0);
 $23 = HEAP32[$16 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$23 >> 2] | 0) + 8 >> 2] & 15]($23, HEAP32[$1 + 84 >> 2] | 0);
 $29 = HEAP32[$16 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$29 >> 2] | 0) + 8 >> 2] & 15]($29, $1);
 HEAP32[$0 >> 2] = 0;
 return;
}

function _prvTidyTraverseNodeTree($doc, $node, $cb, $propagate) {
 $doc = $doc | 0;
 $node = $node | 0;
 $cb = $cb | 0;
 $propagate = $propagate | 0;
 var $$03$be$in = 0, $$036 = 0, $$2 = 0, $$2$ph = 0, $1 = 0, $3 = 0, $s$0 = 0, label = 0;
 if (!$node) {
  $$2 = 0;
  return $$2 | 0;
 } else $$036 = $node;
 L3 : while (1) {
  $1 = FUNCTION_TABLE_iiii[$cb & 15]($doc, $$036, $propagate) | 0;
  $3 = HEAP32[$$036 + 12 >> 2] | 0;
  if (($3 | 0) != 0 & ($1 | 2 | 0) == 2) $s$0 = _prvTidyTraverseNodeTree($doc, $3, $cb, $propagate) | 0; else $s$0 = $1;
  switch ($s$0 | 0) {
  case 5:
   {
    $$2$ph = 5;
    break L3;
    break;
   }
  case 3:
  case 2:
   {
    $$2 = 0;
    label = 9;
    break L3;
    break;
   }
  case 4:
   {
    $$03$be$in = $$036;
    break;
   }
  default:
   $$03$be$in = $$036 + 8 | 0;
  }
  $$036 = HEAP32[$$03$be$in >> 2] | 0;
  if (!$$036) {
   $$2$ph = 0;
   break;
  }
 }
 if ((label | 0) == 9) return $$2 | 0;
 $$2 = $$2$ph;
 return $$2 | 0;
}

function _prvTidyFreeStyles($doc) {
 $doc = $doc | 0;
 var $1 = 0, $14 = 0, $20 = 0, $26 = 0, $4 = 0, $6 = 0, $9 = 0, $style$01 = 0, $style$01$looptemp = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 if (!$1) return;
 $4 = HEAP32[$1 + 120 >> 2] | 0;
 if (!$4) return;
 $6 = $doc + 6856 | 0;
 $style$01 = $4;
 do {
  $style$01$looptemp = $style$01;
  $style$01 = HEAP32[$style$01 + 12 >> 2] | 0;
  $9 = HEAP32[$6 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$9 >> 2] | 0) + 8 >> 2] & 15]($9, HEAP32[$style$01$looptemp >> 2] | 0);
  $14 = HEAP32[$6 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$14 >> 2] | 0) + 8 >> 2] & 15]($14, HEAP32[$style$01$looptemp + 4 >> 2] | 0);
  $20 = HEAP32[$6 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$20 >> 2] | 0) + 8 >> 2] & 15]($20, HEAP32[$style$01$looptemp + 8 >> 2] | 0);
  $26 = HEAP32[$6 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$26 >> 2] | 0) + 8 >> 2] & 15]($26, $style$01$looptemp);
 } while (($style$01 | 0) != 0);
 return;
}

function _prvTidyInferredTag($doc, $id) {
 $doc = $doc | 0;
 $id = $id | 0;
 var $1 = 0, $13 = 0, $14 = 0, $3 = 0, $6 = 0, dest = 0, stop = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $3 = HEAP32[$1 + 124 >> 2] | 0;
 $6 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$3 >> 2] >> 2] & 31]($3, 68) | 0;
 dest = $6;
 stop = dest + 68 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 if ($1 | 0) {
  HEAP32[$6 + 48 >> 2] = HEAP32[$1 >> 2];
  HEAP32[$6 + 52 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 $13 = $6 + 44 | 0;
 HEAP32[$13 >> 2] = 4;
 $14 = _prvTidyLookupTagDef($id) | 0;
 if (!$14) ___assert_fail(310218, 310231, 2095, 310319); else {
  HEAP32[$13 >> 2] = 5;
  HEAP32[$6 + 60 >> 2] = 1;
  HEAP32[$6 + 32 >> 2] = _prvTidytmbstrdup(HEAP32[$doc + 6856 >> 2] | 0, HEAP32[$14 + 4 >> 2] | 0) | 0;
  HEAP32[$6 + 28 >> 2] = $14;
  HEAP32[$6 + 36 >> 2] = HEAP32[$1 + 48 >> 2];
  HEAP32[$6 + 40 >> 2] = HEAP32[$1 + 52 >> 2];
  return $6 | 0;
 }
 return 0;
}

function _pad($f, $c, $w, $l, $fl) {
 $f = $f | 0;
 $c = $c | 0;
 $w = $w | 0;
 $l = $l | 0;
 $fl = $fl | 0;
 var $$0$lcssa6 = 0, $$02 = 0, $10 = 0, $14 = 0, $17 = 0, $18 = 0, $3 = 0, $7 = 0, $9 = 0, $pad = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 256 | 0;
 $pad = sp;
 do if (($w | 0) > ($l | 0) & ($fl & 73728 | 0) == 0) {
  $3 = $w - $l | 0;
  _memset($pad | 0, $c | 0, ($3 >>> 0 > 256 ? 256 : $3) | 0) | 0;
  $7 = HEAP32[$f >> 2] | 0;
  $9 = ($7 & 32 | 0) == 0;
  if ($3 >>> 0 > 255) {
   $10 = $w - $l | 0;
   $$02 = $3;
   $17 = $7;
   $18 = $9;
   while (1) {
    if ($18) {
     ___fwritex($pad, 256, $f) | 0;
     $14 = HEAP32[$f >> 2] | 0;
    } else $14 = $17;
    $$02 = $$02 + -256 | 0;
    $18 = ($14 & 32 | 0) == 0;
    if ($$02 >>> 0 <= 255) break; else $17 = $14;
   }
   if ($18) $$0$lcssa6 = $10 & 255; else break;
  } else if ($9) $$0$lcssa6 = $3; else break;
  ___fwritex($pad, $$0$lcssa6, $f) | 0;
 } while (0);
 STACKTOP = sp;
 return;
}

function _fputc($c, $f) {
 $c = $c | 0;
 $f = $f | 0;
 var $$0 = 0, $10 = 0, $22 = 0, $23 = 0, $31 = 0, $9 = 0, label = 0;
 if ((HEAP32[$f + 76 >> 2] | 0) < 0) label = 3; else if (!(___lockfile($f) | 0)) label = 3; else {
  if ((HEAP8[$f + 75 >> 0] | 0) == ($c | 0)) label = 10; else {
   $22 = $f + 20 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   if ($23 >>> 0 < (HEAP32[$f + 16 >> 2] | 0) >>> 0) {
    HEAP32[$22 >> 2] = $23 + 1;
    HEAP8[$23 >> 0] = $c;
    $31 = $c & 255;
   } else label = 10;
  }
  if ((label | 0) == 10) $31 = ___overflow($f, $c) | 0;
  ___unlockfile($f);
  $$0 = $31;
 }
 do if ((label | 0) == 3) {
  if ((HEAP8[$f + 75 >> 0] | 0) != ($c | 0)) {
   $9 = $f + 20 | 0;
   $10 = HEAP32[$9 >> 2] | 0;
   if ($10 >>> 0 < (HEAP32[$f + 16 >> 2] | 0) >>> 0) {
    HEAP32[$9 >> 2] = $10 + 1;
    HEAP8[$10 >> 0] = $c;
    $$0 = $c & 255;
    break;
   }
  }
  $$0 = ___overflow($f, $c) | 0;
 } while (0);
 return $$0 | 0;
}

function _CheckTarget($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $$pre = 0, $$pre4 = 0, $$pre5 = 0, $1 = 0, $2 = 0, $8 = 0;
 if ($attval | 0) {
  $1 = $attval + 24 | 0;
  $2 = HEAP32[$1 >> 2] | 0;
  if ($2 | 0) {
   if (_prvTidyIsLetter(HEAP8[$2 >> 0] | 0) | 0) return;
   $8 = HEAP32[$1 >> 2] | 0;
   if ($8 | 0) {
    if (!(_prvTidytmbstrcasecmp($8, 311963) | 0)) return;
    $$pre = HEAP32[$1 >> 2] | 0;
    if ($$pre | 0) {
     if (!(_prvTidytmbstrcasecmp($$pre, 305857) | 0)) return;
     $$pre4 = HEAP32[$1 >> 2] | 0;
     if ($$pre4 | 0) {
      if (!(_prvTidytmbstrcasecmp($$pre4, 305863) | 0)) return;
      $$pre5 = HEAP32[$1 >> 2] | 0;
      if ($$pre5 | 0) if (!(_prvTidytmbstrcasecmp($$pre5, 305871) | 0)) return;
     }
    }
   }
   _prvTidyReportAttrError($doc, $node, $attval, 251);
   return;
  }
 }
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 return;
}

function _prvTidytmbstrcasecmp($s1, $s2) {
 $s1 = $s1 | 0;
 $s2 = $s2 | 0;
 var $$0 = 0, $$01$lcssa = 0, $$016 = 0, $$02$lcssa = 0, $$025 = 0, $0 = 0, $10 = 0, $13 = 0, $2 = 0, $7 = 0, $9 = 0;
 $0 = HEAP8[$s1 >> 0] | 0;
 $2 = _prvTidyToLower($0 << 24 >> 24) | 0;
 L1 : do if (($2 | 0) == (_prvTidyToLower(HEAP8[$s2 >> 0] | 0) | 0)) {
  $$016 = $s2;
  $$025 = $s1;
  $7 = $0;
  while (1) {
   if (!($7 << 24 >> 24)) {
    $$0 = 0;
    break;
   }
   $9 = $$025 + 1 | 0;
   $10 = $$016 + 1 | 0;
   $7 = HEAP8[$9 >> 0] | 0;
   $13 = _prvTidyToLower($7 << 24 >> 24) | 0;
   if (($13 | 0) != (_prvTidyToLower(HEAP8[$10 >> 0] | 0) | 0)) {
    $$01$lcssa = $10;
    $$02$lcssa = $9;
    break L1;
   } else {
    $$016 = $10;
    $$025 = $9;
   }
  }
  return $$0 | 0;
 } else {
  $$01$lcssa = $s2;
  $$02$lcssa = $s1;
 } while (0);
 $$0 = (HEAP8[$$02$lcssa >> 0] | 0) > (HEAP8[$$01$lcssa >> 0] | 0) ? 1 : -1;
 return $$0 | 0;
}

function _CheckBool($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $1 = 0, $10 = 0, $15 = 0, $2 = 0, $4 = 0, $p$01$i = 0, label = 0;
 if (!$attval) return;
 $1 = $attval + 24 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 if (!$2) return;
 $4 = HEAP8[$2 >> 0] | 0;
 if (!($4 << 24 >> 24)) return; else {
  $10 = $4;
  $p$01$i = $2;
 }
 while (1) {
  $p$01$i = $p$01$i + 1 | 0;
  if (_prvTidyIsUpper($10 << 24 >> 24) | 0) break;
  $10 = HEAP8[$p$01$i >> 0] | 0;
  if (!($10 << 24 >> 24)) {
   label = 10;
   break;
  }
 }
 if ((label | 0) == 10) return;
 $15 = (HEAP32[$doc + 68 >> 2] | 0) + 28 | 0;
 if (!(HEAP32[$15 >> 2] | 0)) label = 8; else {
  _prvTidyReportAttrError($doc, $node, $attval, 269);
  if (!(HEAP32[$15 >> 2] | 0)) label = 8;
 }
 if ((label | 0) == 8) if (!(HEAP32[$doc + 336 >> 2] | 0)) return;
 HEAP32[$1 >> 2] = _prvTidytmbstrtolower(HEAP32[$1 >> 2] | 0) | 0;
 return;
}

function _fstat($fd, $st) {
 $fd = $fd | 0;
 $st = $st | 0;
 var $$0 = 0, $0 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_buffer6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer6 = sp + 40 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = $fd;
 HEAP32[$vararg_buffer + 4 >> 2] = $st;
 $0 = ___syscall197(197, $vararg_buffer | 0) | 0;
 if (($0 | 0) == -9) {
  HEAP32[$vararg_buffer2 >> 2] = $fd;
  HEAP32[$vararg_buffer2 + 4 >> 2] = 1;
  if ((___syscall221(221, $vararg_buffer2 | 0) | 0) < 0) label = 3; else {
   ___procfdname($vararg_buffer2, $fd);
   HEAP32[$vararg_buffer6 >> 2] = $vararg_buffer2;
   HEAP32[$vararg_buffer6 + 4 >> 2] = $st;
   $$0 = ___syscall_ret(___syscall195(195, $vararg_buffer6 | 0) | 0) | 0;
  }
 } else label = 3;
 if ((label | 0) == 3) $$0 = ___syscall_ret($0) | 0;
 STACKTOP = sp;
 return $$0 | 0;
}

function _prvTidyDropAttrByName($doc, $node, $name) {
 $doc = $doc | 0;
 $node = $node | 0;
 $name = $name | 0;
 var $$lcssa = 0, $0 = 0, $1 = 0, $3 = 0, $5 = 0, $attr$04 = 0, $attr$04$lcssa = 0, $prev$03 = 0, $prev$03$lcssa = 0, $prev$03$phi = 0, label = 0;
 $0 = $node + 20 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) return; else {
  $attr$04 = $1;
  $prev$03 = 0;
 }
 while (1) {
  $3 = HEAP32[$attr$04 >> 2] | 0;
  $5 = HEAP32[$attr$04 + 20 >> 2] | 0;
  if ($5 | 0) if (!(_prvTidytmbstrcmp($5, $name) | 0)) {
   $$lcssa = $3;
   $attr$04$lcssa = $attr$04;
   $prev$03$lcssa = $prev$03;
   break;
  }
  if (!$3) {
   label = 9;
   break;
  } else {
   $prev$03$phi = $attr$04;
   $attr$04 = $3;
   $prev$03 = $prev$03$phi;
  }
 }
 if ((label | 0) == 9) return;
 if (!$prev$03$lcssa) HEAP32[$0 >> 2] = $$lcssa; else HEAP32[$prev$03$lcssa >> 2] = $$lcssa;
 _prvTidyFreeAttribute($doc, $attr$04$lcssa);
 return;
}

function _scalbn($x, $n) {
 $x = +$x;
 $n = $n | 0;
 var $$0 = 0, $1 = 0.0, $12 = 0, $15 = 0, $16 = 0, $2 = 0, $5 = 0, $8 = 0.0, $9 = 0, $y$0 = 0.0;
 if (($n | 0) > 1023) {
  $1 = $x * 8988465674311579538646525.0e283;
  $2 = $n + -1023 | 0;
  if (($2 | 0) > 1023) {
   $5 = $n + -2046 | 0;
   $$0 = ($5 | 0) > 1023 ? 1023 : $5;
   $y$0 = $1 * 8988465674311579538646525.0e283;
  } else {
   $$0 = $2;
   $y$0 = $1;
  }
 } else if (($n | 0) < -1022) {
  $8 = $x * 2.2250738585072014e-308;
  $9 = $n + 1022 | 0;
  if (($9 | 0) < -1022) {
   $12 = $n + 2044 | 0;
   $$0 = ($12 | 0) < -1022 ? -1022 : $12;
   $y$0 = $8 * 2.2250738585072014e-308;
  } else {
   $$0 = $9;
   $y$0 = $8;
  }
 } else {
  $$0 = $n;
  $y$0 = $x;
 }
 $15 = _bitshift64Shl($$0 + 1023 | 0, 0, 52) | 0;
 $16 = tempRet0;
 HEAP32[tempDoublePtr >> 2] = $15;
 HEAP32[tempDoublePtr + 4 >> 2] = $16;
 return +($y$0 * +HEAPF64[tempDoublePtr >> 3]);
}

function _getTextNode($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$013 = 0, $$014 = 0, $15 = 0, $3 = 0, $4 = 0, $7 = 0, $8 = 0, $9 = 0, $i$05 = 0;
 if (!(_prvTidynodeIsText($node) | 0)) return;
 $3 = HEAP32[$node + 36 >> 2] | 0;
 $4 = $node + 40 | 0;
 L4 : do if ($3 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {
  $7 = $doc + 6400 | 0;
  $8 = $doc + 68 | 0;
  $i$05 = $3;
  while (1) {
   $9 = HEAP32[$7 >> 2] | 0;
   if (($9 | 0) > 126) break;
   $15 = HEAP8[(HEAP32[(HEAP32[$8 >> 2] | 0) + 84 >> 2] | 0) + $i$05 >> 0] | 0;
   HEAP32[$7 >> 2] = $9 + 1;
   HEAP8[$doc + 6404 + $9 >> 0] = $15;
   $i$05 = $i$05 + 1 | 0;
   if ($i$05 >>> 0 >= (HEAP32[$4 >> 2] | 0) >>> 0) break L4;
  }
  return;
 } while (0);
 $$013 = HEAP32[$node + 12 >> 2] | 0;
 if (!$$013) return; else $$014 = $$013;
 do {
  _getTextNode($doc, $$014);
  $$014 = HEAP32[$$014 + 8 >> 2] | 0;
 } while (($$014 | 0) != 0);
 return;
}

function _FindDescendant_cb($doc, $node, $propagate) {
 $doc = $doc | 0;
 $node = $node | 0;
 $propagate = $propagate | 0;
 var $$0 = 0, $11 = 0, $14 = 0, $17 = 0, $2 = 0, $22 = 0, $7 = 0;
 if (!$node) $7 = 0; else {
  $2 = HEAP32[$node + 28 >> 2] | 0;
  if (!$2) $7 = 0; else $7 = HEAP32[$2 >> 2] | 0;
 }
 do if (($7 | 0) == (HEAP32[$propagate + 8 >> 2] | 0)) {
  if (!$7) {
   $11 = HEAP32[$node + 32 >> 2] | 0;
   if (!$11) break;
   $14 = HEAP32[$propagate + 12 >> 2] | 0;
   if (!$14) break;
   $17 = HEAP32[$14 + 32 >> 2] | 0;
   if (!$17) break;
   if (_prvTidytmbstrcmp($17, $11) | 0) break;
  }
  HEAP32[$propagate >> 2] = $node;
  $$0 = 5;
  return $$0 | 0;
 } while (0);
 $22 = HEAP32[$propagate + 4 >> 2] | 0;
 if (!$22) {
  $$0 = 4;
  return $$0 | 0;
 }
 if ((HEAP32[$propagate + 16 >> 2] | 0) != ($node | 0)) {
  $$0 = 4;
  return $$0 | 0;
 }
 HEAP32[$22 >> 2] = 1;
 $$0 = 4;
 return $$0 | 0;
}

function _strncmp($_l, $_r, $n) {
 $_l = $_l | 0;
 $_r = $_r | 0;
 $n = $n | 0;
 var $$03 = 0, $$08$in = 0, $1 = 0, $13 = 0, $3 = 0, $6 = 0, $9 = 0, $l$06 = 0, $r$0$lcssa = 0, $r$07 = 0;
 if (!$n) $$03 = 0; else {
  $1 = HEAP8[$_l >> 0] | 0;
  L3 : do if (!($1 << 24 >> 24)) {
   $13 = 0;
   $r$0$lcssa = $_r;
  } else {
   $$08$in = $n;
   $6 = $1;
   $l$06 = $_l;
   $r$07 = $_r;
   while (1) {
    $$08$in = $$08$in + -1 | 0;
    $3 = HEAP8[$r$07 >> 0] | 0;
    if (!($6 << 24 >> 24 == $3 << 24 >> 24 & (($$08$in | 0) != 0 & $3 << 24 >> 24 != 0))) {
     $13 = $6;
     $r$0$lcssa = $r$07;
     break L3;
    }
    $l$06 = $l$06 + 1 | 0;
    $9 = $r$07 + 1 | 0;
    $6 = HEAP8[$l$06 >> 0] | 0;
    if (!($6 << 24 >> 24)) {
     $13 = 0;
     $r$0$lcssa = $9;
     break;
    } else $r$07 = $9;
   }
  } while (0);
  $$03 = ($13 & 255) - (HEAPU8[$r$0$lcssa >> 0] | 0) | 0;
 }
 return $$03 | 0;
}

function _wcrtomb($s, $wc, $st) {
 $s = $s | 0;
 $wc = $wc | 0;
 $st = $st | 0;
 var $$0 = 0;
 do if (!$s) $$0 = 1; else {
  if ($wc >>> 0 < 128) {
   HEAP8[$s >> 0] = $wc;
   $$0 = 1;
   break;
  }
  if ($wc >>> 0 < 2048) {
   HEAP8[$s >> 0] = $wc >>> 6 | 192;
   HEAP8[$s + 1 >> 0] = $wc & 63 | 128;
   $$0 = 2;
   break;
  }
  if ($wc >>> 0 < 55296 | ($wc & -8192 | 0) == 57344) {
   HEAP8[$s >> 0] = $wc >>> 12 | 224;
   HEAP8[$s + 1 >> 0] = $wc >>> 6 & 63 | 128;
   HEAP8[$s + 2 >> 0] = $wc & 63 | 128;
   $$0 = 3;
   break;
  }
  if (($wc + -65536 | 0) >>> 0 < 1048576) {
   HEAP8[$s >> 0] = $wc >>> 18 | 240;
   HEAP8[$s + 1 >> 0] = $wc >>> 12 & 63 | 128;
   HEAP8[$s + 2 >> 0] = $wc >>> 6 & 63 | 128;
   HEAP8[$s + 3 >> 0] = $wc & 63 | 128;
   $$0 = 4;
   break;
  } else {
   HEAP32[(___errno_location() | 0) >> 2] = 84;
   $$0 = -1;
   break;
  }
 } while (0);
 return $$0 | 0;
}

function _prvTidyAppendToClassAttr($doc, $classattr, $classname) {
 $doc = $doc | 0;
 $classattr = $classattr | 0;
 $classname = $classname | 0;
 var $0 = 0, $10 = 0, $11 = 0, $13 = 0, $15 = 0, $2 = 0, $5 = 0, $6 = 0, $7 = 0;
 $0 = $classattr + 24 | 0;
 $2 = _prvTidytmbstrlen(HEAP32[$0 >> 2] | 0) | 0;
 $5 = $2 + 2 + (_prvTidytmbstrlen($classname) | 0) | 0;
 $6 = $doc + 6856 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $10 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$7 >> 2] >> 2] & 31]($7, $5) | 0;
 HEAP8[$10 >> 0] = 0;
 $11 = HEAP32[$0 >> 2] | 0;
 if ($11 | 0) {
  _prvTidytmbstrcpy($10, $11) | 0;
  _prvTidytmbstrcat($10, 307688) | 0;
 }
 _prvTidytmbstrcat($10, $classname) | 0;
 $13 = HEAP32[$0 >> 2] | 0;
 if (!$13) {
  HEAP32[$0 >> 2] = $10;
  return;
 }
 $15 = HEAP32[$6 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$15 >> 2] | 0) + 8 >> 2] & 15]($15, $13);
 HEAP32[$0 >> 2] = $10;
 return;
}

function _CheckForStyleAttribute($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $1 = 0, $4 = 0, $6 = 0, $content$01 = 0, $content$02 = 0, $cp$03$i$i = 0;
 L1 : do if (((HEAP32[$doc + 6396 >> 2] | 0) + -1 | 0) >>> 0 < 3) {
  $1 = _prvTidyAttrGetById($node, 143) | 0;
  if ($1 | 0) {
   $4 = HEAP32[$1 + 24 >> 2] | 0;
   if ($4 | 0) {
    $cp$03$i$i = $4;
    while (1) {
     $6 = HEAP8[$cp$03$i$i >> 0] | 0;
     if (!($6 << 24 >> 24)) break L1;
     if (!(_prvTidyIsWhite($6 << 24 >> 24) | 0)) break; else $cp$03$i$i = $cp$03$i$i + 1 | 0;
    }
    _prvTidyReportAccessWarning($doc, $node, 366);
   }
  }
 } while (0);
 $content$01 = HEAP32[$node + 12 >> 2] | 0;
 if (!$content$01) return; else $content$02 = $content$01;
 do {
  _CheckForStyleAttribute($doc, $content$02);
  $content$02 = HEAP32[$content$02 + 8 >> 2] | 0;
 } while (($content$02 | 0) != 0);
 return;
}

function _prvTidyDiscardElement($doc, $element) {
 $doc = $doc | 0;
 $element = $element | 0;
 var $1 = 0, $11 = 0, $13 = 0, $15 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $9 = 0, $next$0 = 0;
 if (!$element) {
  $next$0 = 0;
  return $next$0 | 0;
 }
 $1 = $element + 8 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 $3 = $element + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 if (!$4) $9 = $2; else {
  HEAP32[$4 + 8 >> 2] = $2;
  $9 = HEAP32[$1 >> 2] | 0;
 }
 $11 = $9;
 if ($9 | 0) HEAP32[$9 + 4 >> 2] = $4;
 $13 = HEAP32[$element >> 2] | 0;
 if ($13 | 0) {
  $15 = $13 + 12 | 0;
  if ((HEAP32[$15 >> 2] | 0) == ($element | 0)) HEAP32[$15 >> 2] = $11;
  $18 = $13 + 16 | 0;
  if ((HEAP32[$18 >> 2] | 0) == ($element | 0)) HEAP32[$18 >> 2] = HEAP32[$3 >> 2];
 }
 HEAP32[$1 >> 2] = 0;
 HEAP32[$3 >> 2] = 0;
 HEAP32[$element >> 2] = 0;
 _prvTidyFreeNode($doc, $element);
 $next$0 = $2;
 return $next$0 | 0;
}

function _prvTidytmbstrdup($allocator, $str) {
 $allocator = $allocator | 0;
 $str = $str | 0;
 var $$0 = 0, $$01$i = 0, $11 = 0, $9 = 0, $cp$0 = 0, $len$02$i = 0, $len$02$i$lcssa = 0, $len$1$i = 0, $s$0 = 0;
 if (!$str) {
  $s$0 = 0;
  return $s$0 | 0;
 }
 if (!(HEAP8[$str >> 0] | 0)) $len$1$i = 1; else {
  $$01$i = $str;
  $len$02$i = 0;
  while (1) {
   $$01$i = $$01$i + 1 | 0;
   if (!(HEAP8[$$01$i >> 0] | 0)) {
    $len$02$i$lcssa = $len$02$i;
    break;
   } else $len$02$i = $len$02$i + 1 | 0;
  }
  $len$1$i = $len$02$i$lcssa + 2 | 0;
 }
 $9 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$allocator >> 2] >> 2] & 31]($allocator, $len$1$i) | 0;
 $$0 = $str;
 $cp$0 = $9;
 while (1) {
  $11 = HEAP8[$$0 >> 0] | 0;
  HEAP8[$cp$0 >> 0] = $11;
  if (!($11 << 24 >> 24)) {
   $s$0 = $9;
   break;
  } else {
   $$0 = $$0 + 1 | 0;
   $cp$0 = $cp$0 + 1 | 0;
  }
 }
 return $s$0 | 0;
}

function _cycle($width, $ar, $n) {
 $width = $width | 0;
 $ar = $ar | 0;
 $n = $n | 0;
 var $$02 = 0, $1 = 0, $4 = 0, $6 = 0, $7 = 0, $i$01 = 0, $tmp = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 256 | 0;
 $tmp = sp;
 L1 : do if (($n | 0) >= 2) {
  $1 = $ar + ($n << 2) | 0;
  HEAP32[$1 >> 2] = $tmp;
  if ($width | 0) {
   $$02 = $width;
   $6 = $tmp;
   while (1) {
    $4 = $$02 >>> 0 > 256 ? 256 : $$02;
    _memcpy($6 | 0, HEAP32[$ar >> 2] | 0, $4 | 0) | 0;
    $i$01 = 0;
    do {
     $7 = $ar + ($i$01 << 2) | 0;
     $i$01 = $i$01 + 1 | 0;
     _memcpy(HEAP32[$7 >> 2] | 0, HEAP32[$ar + ($i$01 << 2) >> 2] | 0, $4 | 0) | 0;
     HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + $4;
    } while (($i$01 | 0) != ($n | 0));
    if (($$02 | 0) == ($4 | 0)) break L1;
    $$02 = $$02 - $4 | 0;
    $6 = HEAP32[$1 >> 2] | 0;
   }
  }
 } while (0);
 STACKTOP = sp;
 return;
}

function _tidySaveFile($tdoc, $filnam) {
 $tdoc = $tdoc | 0;
 $filnam = $filnam | 0;
 var $15 = 0, $16 = 0, $18 = 0, $9 = 0, $status$11$i = 0, $status$12$i = 0;
 if (HEAP32[$tdoc + 6812 >> 2] | 0) if (HEAP32[$tdoc + 132 >> 2] | 0) if (!(HEAP32[$tdoc + 348 >> 2] | 0)) {
  $status$11$i = 2;
  return $status$11$i | 0;
 }
 $9 = _fopen($filnam, 226574) | 0;
 if (!$9) $status$12$i = -2; else {
  $15 = _prvTidyFileOutput($tdoc, $9, HEAP32[$tdoc + 96 >> 2] | 0, HEAP32[$tdoc + 100 >> 2] | 0) | 0;
  $16 = _tidyDocSaveStream($tdoc, $15) | 0;
  _fclose($9) | 0;
  $18 = HEAP32[$tdoc + 6856 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$18 >> 2] | 0) + 8 >> 2] & 15]($18, $15);
  if (($16 | 0) < 0) $status$12$i = $16; else {
   $status$11$i = $16;
   return $status$11$i | 0;
  }
 }
 _prvTidyFileError($tdoc, $filnam, 4);
 $status$11$i = $status$12$i;
 return $status$11$i | 0;
}

function _prvTidyOptGetDocDesc($optId) {
 $optId = $optId | 0;
 var $$0 = 0;
 if (($optId | 0) == 71) $$0 = 1520; else if (($optId | 0) == 81) $$0 = 1528; else if (($optId | 0) == 4) $$0 = 1536; else if (($optId | 0) == 10) $$0 = 1544; else if (($optId | 0) == 82) $$0 = 1552; else if (($optId | 0) == 13) $$0 = 1560; else if (($optId | 0) == 5) $$0 = 1568; else if (($optId | 0) == 20) $$0 = 1576; else if (($optId | 0) == 1) $$0 = 1584; else if (($optId | 0) == 80) $$0 = 1592; else if (($optId | 0) == 88) $$0 = 1600; else if (($optId | 0) == 92) $$0 = 1608; else if (($optId | 0) == 42) $$0 = 1616; else if (($optId | 0) == 6) $$0 = 1624; else if (($optId | 0) == 14) $$0 = 1632; else if (($optId | 0) == 83) $$0 = 1640; else if (($optId | 0) == 46) $$0 = 1648; else if (($optId | 0) == 47) $$0 = 1656; else return (($optId | 0) == 28 ? 1664 : 0) | 0;
 return $$0 | 0;
}

function ___procfdname($buf, $fd) {
 $buf = $buf | 0;
 $fd = $fd | 0;
 var $$01 = 0, $$lcssa = 0, $3 = 0, $i$13 = 0, $i$22 = 0, $j$04 = 0, dest = 0, src = 0, stop = 0;
 dest = $buf;
 src = 316158;
 stop = dest + 15 | 0;
 do {
  HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
  dest = dest + 1 | 0;
  src = src + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 if (!$fd) {
  HEAP8[$buf + 14 >> 0] = 48;
  HEAP8[$buf + 15 >> 0] = 0;
 } else {
  $i$13 = 14;
  $j$04 = $fd;
  while (1) {
   $3 = $i$13 + 1 | 0;
   if ($j$04 >>> 0 < 10) {
    $$lcssa = $3;
    break;
   } else {
    $i$13 = $3;
    $j$04 = ($j$04 >>> 0) / 10 | 0;
   }
  }
  HEAP8[$buf + $$lcssa >> 0] = 0;
  $$01 = $fd;
  $i$22 = $$lcssa;
  while (1) {
   $i$22 = $i$22 + -1 | 0;
   HEAP8[$buf + $i$22 >> 0] = ($$01 >>> 0) % 10 | 0 | 48;
   if ($$01 >>> 0 < 10) break; else $$01 = ($$01 >>> 0) / 10 | 0;
  }
 }
 return;
}

function _fopen($filename, $mode) {
 $filename = $filename | 0;
 $mode = $mode | 0;
 var $$0 = 0, $5 = 0, $7 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 if (!(_memchr(316173, HEAP8[$mode >> 0] | 0, 4) | 0)) {
  HEAP32[(___errno_location() | 0) >> 2] = 22;
  $$0 = 0;
 } else {
  $5 = ___fmodeflags($mode) | 0 | 32768;
  HEAP32[$vararg_buffer >> 2] = $filename;
  HEAP32[$vararg_buffer + 4 >> 2] = $5;
  HEAP32[$vararg_buffer + 8 >> 2] = 438;
  $7 = ___syscall_ret(___syscall5(5, $vararg_buffer | 0) | 0) | 0;
  if (($7 | 0) < 0) $$0 = 0; else {
   $9 = ___fdopen($7, $mode) | 0;
   if (!$9) {
    HEAP32[$vararg_buffer3 >> 2] = $7;
    ___syscall6(6, $vararg_buffer3 | 0) | 0;
    $$0 = 0;
   } else $$0 = $9;
  }
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _strerror($e) {
 $e = $e | 0;
 var $$lcssa = 0, $9 = 0, $i$03 = 0, $i$03$lcssa = 0, $i$12 = 0, $s$0$lcssa = 0, $s$01 = 0, $s$1 = 0, label = 0;
 $i$03 = 0;
 while (1) {
  if ((HEAPU8[314226 + $i$03 >> 0] | 0) == ($e | 0)) {
   $i$03$lcssa = $i$03;
   label = 2;
   break;
  }
  $i$03 = $i$03 + 1 | 0;
  if (($i$03 | 0) == 87) {
   $i$12 = 87;
   $s$01 = 314314;
   label = 5;
   break;
  }
 }
 if ((label | 0) == 2) if (!$i$03$lcssa) $s$0$lcssa = 314314; else {
  $i$12 = $i$03$lcssa;
  $s$01 = 314314;
  label = 5;
 }
 if ((label | 0) == 5) while (1) {
  label = 0;
  $s$1 = $s$01;
  while (1) {
   $9 = $s$1 + 1 | 0;
   if (!(HEAP8[$s$1 >> 0] | 0)) {
    $$lcssa = $9;
    break;
   } else $s$1 = $9;
  }
  $i$12 = $i$12 + -1 | 0;
  if (!$i$12) {
   $s$0$lcssa = $$lcssa;
   break;
  } else {
   $s$01 = $$lcssa;
   label = 5;
  }
 }
 return $s$0$lcssa | 0;
}

function _prvTidytmbstrncpy($s1, $s2, $size) {
 $s1 = $s1 | 0;
 $s2 = $s2 | 0;
 $size = $size | 0;
 var $$023 = 0, $$04 = 0, $$1 = 0, $$2 = 0, $2 = 0, $4 = 0, $7 = 0, $8 = 0, $cp$0$lcssa = 0, $cp$05 = 0;
 if (!(($s1 | 0) != 0 & ($s2 | 0) != 0)) {
  $$2 = $size;
  return $$2 | 0;
 }
 $2 = HEAP8[$s2 >> 0] | 0;
 L4 : do if (!($2 << 24 >> 24)) {
  $$1 = $size;
  $cp$0$lcssa = $s1;
 } else {
  $$023 = $s2;
  $$04 = $size;
  $8 = $2;
  $cp$05 = $s1;
  while (1) {
   $4 = $$04 + -1 | 0;
   if (!$4) {
    $$1 = 0;
    $cp$0$lcssa = $cp$05;
    break L4;
   }
   $$023 = $$023 + 1 | 0;
   $7 = $cp$05 + 1 | 0;
   HEAP8[$cp$05 >> 0] = $8;
   $8 = HEAP8[$$023 >> 0] | 0;
   if (!($8 << 24 >> 24)) {
    $$1 = $4;
    $cp$0$lcssa = $7;
    break;
   } else {
    $$04 = $4;
    $cp$05 = $7;
   }
  }
 } while (0);
 HEAP8[$cp$0$lcssa >> 0] = 0;
 $$2 = $$1;
 return $$2 | 0;
}

function ___overflow($f, $_c) {
 $f = $f | 0;
 $_c = $_c | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $2 = 0, $6 = 0, $7 = 0, $9 = 0, $c = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 $0 = $_c & 255;
 HEAP8[$c >> 0] = $0;
 $1 = $f + 16 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 if (!$2) if (!(___towrite($f) | 0)) {
  $9 = HEAP32[$1 >> 2] | 0;
  label = 4;
 } else $$0 = -1; else {
  $9 = $2;
  label = 4;
 }
 do if ((label | 0) == 4) {
  $6 = $f + 20 | 0;
  $7 = HEAP32[$6 >> 2] | 0;
  if ($7 >>> 0 < $9 >>> 0) {
   $10 = $_c & 255;
   if (($10 | 0) != (HEAP8[$f + 75 >> 0] | 0)) {
    HEAP32[$6 >> 2] = $7 + 1;
    HEAP8[$7 >> 0] = $0;
    $$0 = $10;
    break;
   }
  }
  if ((FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 15]($f, $c, 1) | 0) == 1) $$0 = HEAPU8[$c >> 0] | 0; else $$0 = -1;
 } while (0);
 STACKTOP = sp;
 return $$0 | 0;
}

function _frexp($x, $e) {
 $x = +$x;
 $e = $e | 0;
 var $$0 = 0.0, $$01 = 0.0, $0 = 0, $1 = 0, $2 = 0, $4 = 0, $7 = 0.0, $storemerge = 0;
 HEAPF64[tempDoublePtr >> 3] = $x;
 $0 = HEAP32[tempDoublePtr >> 2] | 0;
 $1 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $2 = _bitshift64Lshr($0 | 0, $1 | 0, 52) | 0;
 $4 = $2 & 2047;
 switch ($4 | 0) {
 case 0:
  {
   if ($x != 0.0) {
    $7 = +_frexp($x * 18446744073709551616.0, $e);
    $$01 = $7;
    $storemerge = (HEAP32[$e >> 2] | 0) + -64 | 0;
   } else {
    $$01 = $x;
    $storemerge = 0;
   }
   HEAP32[$e >> 2] = $storemerge;
   $$0 = $$01;
   break;
  }
 case 2047:
  {
   $$0 = $x;
   break;
  }
 default:
  {
   HEAP32[$e >> 2] = $4 + -1022;
   HEAP32[tempDoublePtr >> 2] = $0;
   HEAP32[tempDoublePtr + 4 >> 2] = $1 & -2146435073 | 1071644672;
   $$0 = +HEAPF64[tempDoublePtr >> 3];
  }
 }
 return +$$0;
}

function _AttributeChecks($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0 = 0, $12 = 0, $6 = 0, $9 = 0, label = 0, $$0$looptemp = 0;
 $$0 = $node;
 while (1) {
  if (!$$0) {
   label = 12;
   break;
  }
  $$0$looptemp = $$0;
  $$0 = HEAP32[$$0 + 8 >> 2] | 0;
  do if (_prvTidynodeIsElement($$0$looptemp) | 0) {
   $6 = HEAP32[$$0$looptemp + 28 >> 2] | 0;
   if ($6 | 0) {
    $9 = HEAP32[$6 + 24 >> 2] | 0;
    if ($9 | 0) {
     FUNCTION_TABLE_vii[$9 & 15]($doc, $$0$looptemp);
     break;
    }
   }
   _prvTidyCheckAttributes($doc, $$0$looptemp);
  } while (0);
  $12 = HEAP32[$$0$looptemp + 12 >> 2] | 0;
  if ($12 | 0) _AttributeChecks($doc, $12);
  if (($$0 | 0) == ($$0$looptemp | 0)) {
   label = 11;
   break;
  }
 }
 if ((label | 0) == 11) ___assert_fail(308047, 307744, 4718, 308060); else if ((label | 0) == 12) return;
}

function _prvTidyParseConfigOption($doc, $optnam, $optval) {
 $doc = $doc | 0;
 $optnam = $optnam | 0;
 $optval = $optval | 0;
 var $7 = 0, $9 = 0, $np$01$i = 0, $np$01$i$lcssa = 0, $status$1 = 0, label = 0;
 $np$01$i = 1892;
 do {
  if (!(_prvTidytmbstrcasecmp($optnam, HEAP32[$np$01$i + 8 >> 2] | 0) | 0)) {
   $np$01$i$lcssa = $np$01$i;
   label = 7;
   break;
  }
  $np$01$i = $np$01$i + 32 | 0;
 } while ($np$01$i >>> 0 < 5028 >>> 0);
 if ((label | 0) == 7) {
  $status$1 = _prvTidyParseConfigValue($doc, HEAP32[$np$01$i$lcssa >> 2] | 0, $optval) | 0;
  return $status$1 | 0;
 }
 $7 = HEAP32[$doc + 6800 >> 2] | 0;
 if ($7 | 0) {
  $9 = FUNCTION_TABLE_iii[$7 & 31]($optnam, $optval) | 0;
  if ($9 | 0) {
   $status$1 = $9;
   return $status$1 | 0;
  }
 }
 _prvTidyReportUnknownOption($doc, $optnam);
 $status$1 = 0;
 return $status$1 | 0;
}

function _CheckAREA($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $1 = 0, $14 = 0, $3 = 0, $5 = 0, $7 = 0, $attval$01$i = 0, $attval$01$i$looptemp = 0;
 $1 = (_prvTidyAttrGetById($node, 10) | 0) == 0;
 $3 = (_prvTidyAttrGetById($node, 59) | 0) != 0;
 $5 = (_prvTidyAttrGetById($node, 86) | 0) != 0;
 $7 = HEAP32[$node + 20 >> 2] | 0;
 if ($7 | 0) {
  $attval$01$i = $7;
  do {
   $attval$01$i$looptemp = $attval$01$i;
   $attval$01$i = HEAP32[$attval$01$i >> 2] | 0;
   _prvTidyCheckAttribute($doc, $node, $attval$01$i$looptemp) | 0;
  } while (($attval$01$i | 0) != 0);
 }
 if ($1) if (!(HEAP32[$doc + 408 >> 2] | 0)) {
  $14 = $doc + 6836 | 0;
  HEAP32[$14 >> 2] = HEAP32[$14 >> 2] | 2;
  _prvTidyReportMissingAttr($doc, $node, 310489);
 }
 if ($3 | $5) return;
 _prvTidyReportMissingAttr($doc, $node, 308129);
 return;
}

function _prvTidyDropSections($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0$be = 0, $$01 = 0, $22 = 0, $3 = 0, $8 = 0;
 if (!$node) return;
 $3 = (HEAP32[$doc + 68 >> 2] | 0) + 84 | 0;
 $$01 = $node;
 while (1) {
  do if ((HEAP32[$$01 + 44 >> 2] | 0) == 9) {
   $8 = $$01 + 36 | 0;
   if (!(_prvTidytmbstrncmp((HEAP32[$3 >> 2] | 0) + (HEAP32[$8 >> 2] | 0) | 0, 311417, 2) | 0)) if (_prvTidytmbstrncmp((HEAP32[$3 >> 2] | 0) + (HEAP32[$8 >> 2] | 0) | 0, 311420, 7) | 0) {
    $$0$be = _PruneSection($doc, $$01) | 0;
    break;
   }
   $$0$be = _prvTidyDiscardElement($doc, $$01) | 0;
  } else {
   $22 = HEAP32[$$01 + 12 >> 2] | 0;
   if ($22 | 0) _prvTidyDropSections($doc, $22);
   $$0$be = HEAP32[$$01 + 8 >> 2] | 0;
  } while (0);
  if (!$$0$be) break; else $$01 = $$0$be;
 }
 return;
}

function _getNextWindowsLanguage($iter) {
 $iter = $iter | 0;
 var $$pre = 0, $1 = 0, $10 = 0, $3 = 0, $5 = 0, $item$03 = 0, $itemIndex$04 = 0;
 if (!$iter) ___assert_fail(298444, 298457, 854, 298565);
 $1 = HEAP32[$iter >> 2] | 0;
 $$pre = HEAP32[79119] | 0;
 $3 = ($$pre | 0) == 0;
 if (!$1) if ($3) {
  HEAP32[79119] = 159;
  $10 = 159;
  $item$03 = 0;
  $itemIndex$04 = 0;
 } else {
  $10 = $$pre;
  $item$03 = 0;
  $itemIndex$04 = 0;
 } else {
  if ($3) {
   HEAP32[79119] = 159;
   $5 = 159;
  } else $5 = $$pre;
  if ($1 >>> 0 > $5 >>> 0) {
   $10 = $5;
   $item$03 = 0;
   $itemIndex$04 = $1;
  } else {
   $10 = $5;
   $item$03 = 50024 + ($1 + -1 << 3) | 0;
   $itemIndex$04 = $1 + 1 | 0;
  }
 }
 HEAP32[$iter >> 2] = $itemIndex$04 >>> 0 <= $10 >>> 0 ? $itemIndex$04 : 0;
 return $item$03 | 0;
}

function _prvTidyGetEncodingOptNameFromTidyId($id) {
 $id = $id | 0;
 var $$0 = 0, $i$02$lcssa = 0;
 if (($id | 0) == 1) $i$02$lcssa = 0; else if (($id | 0) == 2) $i$02$lcssa = 1; else if (($id | 0) == 3) $i$02$lcssa = 2; else if (($id | 0) == 4) $i$02$lcssa = 3; else if (($id | 0) == 6) $i$02$lcssa = 4; else if (($id | 0) == 7) $i$02$lcssa = 5; else if (($id | 0) == 8) $i$02$lcssa = 6; else if (($id | 0) == 9) $i$02$lcssa = 7; else if (($id | 0) == 10) $i$02$lcssa = 8; else if (($id | 0) == 11) $i$02$lcssa = 9; else if (($id | 0) == 12) $i$02$lcssa = 10; else if (($id | 0) == 13) $i$02$lcssa = 11; else if (($id | 0) == 5) $i$02$lcssa = 12; else if (!$id) $i$02$lcssa = 13; else {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = HEAP32[6436 + ($i$02$lcssa * 12 | 0) + 8 >> 2] | 0;
 return $$0 | 0;
}

function _getNextErrorCode($iter) {
 $iter = $iter | 0;
 var $$pre = 0, $1 = 0, $10 = 0, $3 = 0, $5 = 0, $item$03 = 0, $itemIndex$04 = 0;
 if (!$iter) ___assert_fail(298444, 298457, 953, 298613);
 $1 = HEAP32[$iter >> 2] | 0;
 $$pre = HEAP32[79121] | 0;
 $3 = ($$pre | 0) == 0;
 if (!$1) if ($3) {
  HEAP32[79121] = 235;
  $10 = 235;
  $item$03 = 0;
  $itemIndex$04 = 0;
 } else {
  $10 = $$pre;
  $item$03 = 0;
  $itemIndex$04 = 0;
 } else {
  if ($3) {
   HEAP32[79121] = 235;
   $5 = 235;
  } else $5 = $$pre;
  if ($1 >>> 0 > $5 >>> 0) {
   $10 = $5;
   $item$03 = 0;
   $itemIndex$04 = $1;
  } else {
   $10 = $5;
   $item$03 = 51304 + ($1 + -1 << 3) | 0;
   $itemIndex$04 = $1 + 1 | 0;
  }
 }
 HEAP32[$iter >> 2] = $itemIndex$04 >>> 0 <= $10 >>> 0 ? $itemIndex$04 : 0;
 return $item$03 | 0;
}

function _prvTidyBufferInput($doc, $buf, $encoding) {
 $doc = $doc | 0;
 $buf = $buf | 0;
 $encoding = $encoding | 0;
 var $0 = 0, $1 = 0, $10 = 0, $12 = 0, $4 = 0;
 $0 = $doc + 6856 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $4 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1 >> 2] >> 2] & 31]($1, 324) | 0;
 _memset($4 | 0, 0, 320) | 0;
 HEAP32[$4 + 292 >> 2] = 1;
 HEAP32[$4 + 288 >> 2] = 1;
 HEAP32[$4 + 296 >> 2] = $encoding;
 HEAP32[$4 >> 2] = 0;
 HEAP32[$4 + 320 >> 2] = $doc;
 HEAP32[$4 + 20 >> 2] = 5;
 $10 = HEAP32[$0 >> 2] | 0;
 HEAP32[$4 + 8 >> 2] = $10;
 $12 = $10;
 HEAP32[$4 + 12 >> 2] = FUNCTION_TABLE_iii[HEAP32[HEAP32[$12 >> 2] >> 2] & 31]($12, 20) | 0;
 HEAP16[$4 + 284 >> 1] = 0;
 HEAP16[$4 + 286 >> 1] = 0;
 _tidyInitInputBuffer($4 + 304 | 0, $buf);
 HEAP32[$4 + 300 >> 2] = 1;
 return $4 | 0;
}

function ___divdi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $1$0 = 0, $1$1 = 0, $2$0 = 0, $2$1 = 0, $4$0 = 0, $4$1 = 0, $7$0 = 0, $7$1 = 0;
 $1$0 = $a$1 >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1;
 $1$1 = (($a$1 | 0) < 0 ? -1 : 0) >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1;
 $2$0 = $b$1 >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1;
 $2$1 = (($b$1 | 0) < 0 ? -1 : 0) >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1;
 $4$0 = _i64Subtract($1$0 ^ $a$0 | 0, $1$1 ^ $a$1 | 0, $1$0 | 0, $1$1 | 0) | 0;
 $4$1 = tempRet0;
 $7$0 = $2$0 ^ $1$0;
 $7$1 = $2$1 ^ $1$1;
 return _i64Subtract((___udivmoddi4($4$0, $4$1, _i64Subtract($2$0 ^ $b$0 | 0, $2$1 ^ $b$1 | 0, $2$0 | 0, $2$1 | 0) | 0, tempRet0, 0) | 0) ^ $7$0 | 0, tempRet0 ^ $7$1 | 0, $7$0 | 0, $7$1 | 0) | 0;
}

function _realloc($oldmem, $bytes) {
 $oldmem = $oldmem | 0;
 $bytes = $bytes | 0;
 var $12 = 0, $15 = 0, $20 = 0, $9 = 0, $mem$1 = 0;
 if (!$oldmem) {
  $mem$1 = _malloc($bytes) | 0;
  return $mem$1 | 0;
 }
 if ($bytes >>> 0 > 4294967231) {
  HEAP32[(___errno_location() | 0) >> 2] = 12;
  $mem$1 = 0;
  return $mem$1 | 0;
 }
 $9 = _try_realloc_chunk($oldmem + -8 | 0, $bytes >>> 0 < 11 ? 16 : $bytes + 11 & -8) | 0;
 if ($9 | 0) {
  $mem$1 = $9 + 8 | 0;
  return $mem$1 | 0;
 }
 $12 = _malloc($bytes) | 0;
 if (!$12) {
  $mem$1 = 0;
  return $mem$1 | 0;
 }
 $15 = HEAP32[$oldmem + -4 >> 2] | 0;
 $20 = ($15 & -8) - (($15 & 3 | 0) == 0 ? 8 : 4) | 0;
 _memcpy($12 | 0, $oldmem | 0, ($20 >>> 0 < $bytes >>> 0 ? $20 : $bytes) | 0) | 0;
 _free($oldmem);
 $mem$1 = $12;
 return $mem$1 | 0;
}

function _prvTidyHTMLVersionNameFromCode($vers, $isXhtml) {
 $vers = $vers | 0;
 $isXhtml = $isXhtml | 0;
 var $15 = 0;
 if (($vers | 0) == 1) $15 = 308925; else if (($vers | 0) == 2) $15 = 309007; else if (($vers | 0) == 4) $15 = 309103; else if (($vers | 0) == 8) $15 = 309187; else if (($vers | 0) == 16) $15 = 309289; else if (($vers | 0) == 32) $15 = 309386; else if (($vers | 0) == 64) $15 = 309467; else if (($vers | 0) == 128) $15 = 309566; else if (($vers | 0) == 256) $15 = 309660; else if (($vers | 0) == 512) $15 = 309760; else if (($vers | 0) == 1024) $15 = 309878; else if (($vers | 0) == 2048) $15 = 309984; else if (($vers | 0) == 4096) $15 = 310065; else if (($vers | 0) == 131072) $15 = 310164; else $15 = ($vers | 0) == 262144 ? 310170 : 0;
 return $15 | 0;
}

function _prvTidytmbstrcmp($s1, $s2) {
 $s1 = $s1 | 0;
 $s2 = $s2 | 0;
 var $$0 = 0, $$017 = 0, $$026 = 0, $$lcssa = 0, $$lcssa4 = 0, $0 = 0, $1 = 0, $3 = 0, $7 = 0, $8 = 0;
 $0 = HEAP8[$s1 >> 0] | 0;
 $1 = HEAP8[$s2 >> 0] | 0;
 L1 : do if ($0 << 24 >> 24 == $1 << 24 >> 24) {
  $$017 = $s2;
  $$026 = $s1;
  $3 = $0;
  while (1) {
   if (!($3 << 24 >> 24)) {
    $$0 = 0;
    break;
   }
   $$026 = $$026 + 1 | 0;
   $$017 = $$017 + 1 | 0;
   $7 = HEAP8[$$026 >> 0] | 0;
   $8 = HEAP8[$$017 >> 0] | 0;
   if ($7 << 24 >> 24 != $8 << 24 >> 24) {
    $$lcssa = $7;
    $$lcssa4 = $8;
    break L1;
   } else $3 = $7;
  }
  return $$0 | 0;
 } else {
  $$lcssa = $0;
  $$lcssa4 = $1;
 } while (0);
 $$0 = $$lcssa << 24 >> 24 > $$lcssa4 << 24 >> 24 ? 1 : -1;
 return $$0 | 0;
}

function _prvTidyDetachAttribute($node, $attr) {
 $node = $node | 0;
 $attr = $attr | 0;
 var $0 = 0, $5 = 0, $av$0 = 0, $av$02 = 0, $av$04 = 0, $prev$03 = 0, $prev$03$lcssa = 0, $prev$03$phi = 0, label = 0;
 $0 = $node + 20 | 0;
 $av$02 = HEAP32[$0 >> 2] | 0;
 if (!$av$02) return; else {
  $av$04 = $av$02;
  $prev$03 = 0;
 }
 while (1) {
  if (($av$04 | 0) == ($attr | 0)) {
   $prev$03$lcssa = $prev$03;
   break;
  }
  $av$0 = HEAP32[$av$04 >> 2] | 0;
  if (!$av$0) {
   label = 7;
   break;
  } else {
   $prev$03$phi = $av$04;
   $av$04 = $av$0;
   $prev$03 = $prev$03$phi;
  }
 }
 if ((label | 0) == 7) return;
 $5 = HEAP32[$attr >> 2] | 0;
 if (!$prev$03$lcssa) {
  HEAP32[$0 >> 2] = $5;
  return;
 } else {
  HEAP32[$prev$03$lcssa >> 2] = $5;
  return;
 }
}

function _prvTidyNodeAttributeVersions($node, $id) {
 $node = $node | 0;
 $id = $id | 0;
 var $$0 = 0, $2 = 0, $5 = 0, $7 = 0, $9 = 0, $i$03 = 0, $i$03$lcssa = 0;
 L1 : do if (!$node) $$0 = 0; else {
  $2 = HEAP32[$node + 28 >> 2] | 0;
  if (!$2) $$0 = 0; else {
   $5 = HEAP32[$2 + 12 >> 2] | 0;
   if (!$5) $$0 = 0; else {
    $7 = HEAP32[$5 >> 2] | 0;
    if (!$7) $$0 = 0; else {
     $9 = $7;
     $i$03 = 0;
     while (1) {
      if (($9 | 0) == ($id | 0)) {
       $i$03$lcssa = $i$03;
       break;
      }
      $i$03 = $i$03 + 1 | 0;
      $9 = HEAP32[$5 + ($i$03 << 3) >> 2] | 0;
      if (!$9) {
       $$0 = 0;
       break L1;
      }
     }
     $$0 = HEAP32[$5 + ($i$03$lcssa << 3) + 4 >> 2] | 0;
    }
   }
  }
 } while (0);
 return $$0 | 0;
}

function _prvTidyIsPushedLast($doc, $element, $node) {
 $doc = $doc | 0;
 $element = $element | 0;
 $node = $node | 0;
 var $$0 = 0, $1 = 0, $12 = 0, $4 = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 L1 : do if ($element | 0) {
  $4 = HEAP32[$element + 28 >> 2] | 0;
  if (!$4) {
   $$0 = 0;
   return $$0 | 0;
  }
  if ((HEAP32[$4 + 16 >> 2] & 2064 | 0) != 16) {
   $$0 = 0;
   return $$0 | 0;
  }
  switch (HEAP32[$4 >> 2] | 0) {
  case 27:
  case 54:
   {
    $$0 = 0;
    break;
   }
  default:
   break L1;
  }
  return $$0 | 0;
 } while (0);
 $12 = HEAP32[$1 + 112 >> 2] | 0;
 if ($12 | 0) if ((HEAP32[(HEAP32[$1 + 104 >> 2] | 0) + ($12 + -1 << 4) + 4 >> 2] | 0) == (HEAP32[$node + 28 >> 2] | 0)) {
  $$0 = 1;
  return $$0 | 0;
 }
 $$0 = 0;
 return $$0 | 0;
}

function _tidyDefaultString($messageType) {
 $messageType = $messageType | 0;
 var $$0$i = 0, $$lcssa = 0, $1 = 0, $14 = 0, $2 = 0, $i$02$i = 0, label = 0;
 $1 = FUNCTION_TABLE_ii[HEAP32[1700] & 31](1) | 0;
 $2 = HEAP32[1703] | 0;
 if (!$2) {
  $$0$i = 0;
  return $$0$i | 0;
 } else {
  $14 = $2;
  $i$02$i = 0;
 }
 while (1) {
  if ((HEAP32[6804 + ($i$02$i * 12 | 0) >> 2] | 0) == ($messageType | 0)) if ((HEAP32[6804 + ($i$02$i * 12 | 0) + 4 >> 2] | 0) == ($1 | 0)) {
   $$lcssa = $14;
   break;
  }
  $i$02$i = $i$02$i + 1 | 0;
  $14 = HEAP32[6804 + ($i$02$i * 12 | 0) + 8 >> 2] | 0;
  if (!$14) {
   $$0$i = 0;
   label = 6;
   break;
  }
 }
 if ((label | 0) == 6) return $$0$i | 0;
 HEAP32[79117] = $messageType;
 $$0$i = $$lcssa;
 return $$0$i | 0;
}

function ___fflush_unlocked($f) {
 $f = $f | 0;
 var $$0 = 0, $0 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $9 = 0, label = 0;
 $0 = $f + 20 | 0;
 $2 = $f + 28 | 0;
 if ((HEAP32[$0 >> 2] | 0) >>> 0 > (HEAP32[$2 >> 2] | 0) >>> 0) {
  FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 15]($f, 0, 0) | 0;
  if (!(HEAP32[$0 >> 2] | 0)) $$0 = -1; else label = 3;
 } else label = 3;
 if ((label | 0) == 3) {
  $9 = $f + 4 | 0;
  $10 = HEAP32[$9 >> 2] | 0;
  $11 = $f + 8 | 0;
  $12 = HEAP32[$11 >> 2] | 0;
  if ($10 >>> 0 < $12 >>> 0) FUNCTION_TABLE_iiii[HEAP32[$f + 40 >> 2] & 15]($f, $10 - $12 | 0, 1) | 0;
  HEAP32[$f + 16 >> 2] = 0;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$11 >> 2] = 0;
  HEAP32[$9 >> 2] = 0;
  $$0 = 0;
 }
 return $$0 | 0;
}

function _prvTidytmbstrndup($allocator, $str, $len) {
 $allocator = $allocator | 0;
 $str = $str | 0;
 $len = $len | 0;
 var $$0 = 0, $$02 = 0, $10 = 0, $5 = 0, $9 = 0, $cp$0 = 0, $cp$1 = 0, $s$0 = 0;
 if (!(($str | 0) != 0 & ($len | 0) != 0)) {
  $s$0 = 0;
  return $s$0 | 0;
 }
 $5 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$allocator >> 2] >> 2] & 31]($allocator, $len + 1 | 0) | 0;
 $$0 = $len;
 $$02 = $str;
 $cp$0 = $5;
 while (1) {
  if (!$$0) {
   $cp$1 = $cp$0;
   break;
  }
  $9 = HEAP8[$$02 >> 0] | 0;
  $10 = $cp$0 + 1 | 0;
  HEAP8[$cp$0 >> 0] = $9;
  if (!($9 << 24 >> 24)) {
   $cp$1 = $10;
   break;
  } else {
   $$0 = $$0 + -1 | 0;
   $$02 = $$02 + 1 | 0;
   $cp$0 = $10;
  }
 }
 HEAP8[$cp$1 >> 0] = 0;
 $s$0 = $5;
 return $s$0 | 0;
}

function _prvTidytmbstrcat($s1, $s2) {
 $s1 = $s1 | 0;
 $s2 = $s2 | 0;
 var $$01 = 0, $$01$lcssa = 0, $$03 = 0, $$12 = 0, $3 = 0, $7 = 0, $8 = 0, $ncpy$0$lcssa = 0, $ncpy$04 = 0;
 $$01 = $s1;
 while (1) if (!(HEAP8[$$01 >> 0] | 0)) {
  $$01$lcssa = $$01;
  break;
 } else $$01 = $$01 + 1 | 0;
 $3 = HEAP8[$s2 >> 0] | 0;
 HEAP8[$$01$lcssa >> 0] = $3;
 if (!($3 << 24 >> 24)) {
  $ncpy$0$lcssa = 0;
  return $ncpy$0$lcssa | 0;
 } else {
  $$03 = $s2;
  $$12 = $$01$lcssa;
  $ncpy$04 = 0;
 }
 while (1) {
  $$12 = $$12 + 1 | 0;
  $$03 = $$03 + 1 | 0;
  $7 = $ncpy$04 + 1 | 0;
  $8 = HEAP8[$$03 >> 0] | 0;
  HEAP8[$$12 >> 0] = $8;
  if (!($8 << 24 >> 24)) {
   $ncpy$0$lcssa = $7;
   break;
  } else $ncpy$04 = $7;
 }
 return $ncpy$0$lcssa | 0;
}

function _prvTidygetNextOptionPick($option, $iter) {
 $option = $option | 0;
 $iter = $iter | 0;
 var $$off = 0, $14 = 0, $2 = 0, $5 = 0, $8 = 0, $val$04 = 0;
 if (!(($option | 0) != 0 & ($iter | 0) != 0)) ___assert_fail(225673, 223800, 1629, 225702);
 $2 = HEAP32[$iter >> 2] | 0;
 $$off = $2 + -1 | 0;
 if ($$off >>> 0 < 15) {
  $5 = HEAP32[$option + 24 >> 2] | 0;
  if (!$5) {
   $14 = 0;
   $val$04 = 0;
  } else {
   $8 = HEAP32[$5 + ($$off << 2) >> 2] | 0;
   if (!$8) {
    $14 = 0;
    $val$04 = 0;
   } else if (!(HEAP32[$5 + ($2 << 2) >> 2] | 0)) {
    $14 = 0;
    $val$04 = $8;
   } else {
    $14 = $2 + 1 | 0;
    $val$04 = $8;
   }
  }
 } else {
  $14 = 0;
  $val$04 = 0;
 }
 HEAP32[$iter >> 2] = $14;
 return $val$04 | 0;
}

function _prvTidyNewAttributeEx($doc, $name, $value, $delim) {
 $doc = $doc | 0;
 $name = $name | 0;
 $value = $value | 0;
 $delim = $delim | 0;
 var $0 = 0, $1 = 0, $4 = 0;
 $0 = $doc + 6856 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $4 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1 >> 2] >> 2] & 31]($1, 28) | 0;
 HEAP32[$4 >> 2] = 0;
 HEAP32[$4 + 4 >> 2] = 0;
 HEAP32[$4 + 8 >> 2] = 0;
 HEAP32[$4 + 12 >> 2] = 0;
 HEAP32[$4 + 16 >> 2] = 0;
 HEAP32[$4 + 20 >> 2] = 0;
 HEAP32[$4 + 24 >> 2] = 0;
 HEAP32[$4 + 20 >> 2] = _prvTidytmbstrdup(HEAP32[$0 >> 2] | 0, $name) | 0;
 HEAP32[$4 + 24 >> 2] = _prvTidytmbstrdup(HEAP32[$0 >> 2] | 0, $value) | 0;
 HEAP32[$4 + 16 >> 2] = $delim;
 HEAP32[$4 + 4 >> 2] = _prvTidyFindAttribute($doc, $4) | 0;
 return $4 | 0;
}

function _prvTidyFindNodeWithId($node, $tid) {
 $node = $node | 0;
 $tid = $tid | 0;
 var $$0 = 0, $$01$pn = 0, $$013 = 0, $2 = 0, label = 0;
 if (!$node) {
  $$0 = 0;
  return $$0 | 0;
 } else $$013 = $node;
 L3 : while (1) {
  $2 = HEAP32[$$013 + 28 >> 2] | 0;
  if (!$2) $$01$pn = $$013; else if ((HEAP32[$2 >> 2] | 0) == ($tid | 0)) {
   $$0 = 1;
   label = 7;
   break;
  } else $$01$pn = $$013;
  while (1) {
   $$01$pn = HEAP32[$$01$pn + 12 >> 2] | 0;
   if (!$$01$pn) break;
   if (_prvTidyFindNodeWithId($$01$pn, $tid) | 0) {
    $$0 = 1;
    label = 7;
    break L3;
   }
  }
  $$013 = HEAP32[$$013 + 8 >> 2] | 0;
  if (!$$013) {
   $$0 = 0;
   label = 7;
   break;
  }
 }
 if ((label | 0) == 7) return $$0 | 0;
 return 0;
}

function _CheckForListElements($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$04 = 0, $$05 = 0, $2 = 0, $5 = 0, $8 = 0;
 L1 : do if ($node | 0) {
  $2 = HEAP32[$node + 28 >> 2] | 0;
  if ($2 | 0) switch (HEAP32[$2 >> 2] | 0) {
  case 61:
   {
    $5 = $doc + 6672 | 0;
    HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + 1;
    break L1;
    break;
   }
  case 118:
  case 77:
   {
    $8 = $doc + 6676 | 0;
    HEAP32[$8 >> 2] = (HEAP32[$8 >> 2] | 0) + 1;
    break L1;
    break;
   }
  default:
   break L1;
  }
 } while (0);
 $$04 = HEAP32[$node + 12 >> 2] | 0;
 if (!$$04) return; else $$05 = $$04;
 do {
  _CheckForListElements($doc, $$05);
  $$05 = HEAP32[$$05 + 8 >> 2] | 0;
 } while (($$05 | 0) != 0);
 return;
}

function _prvTidyIsJavaScript($node) {
 $node = $node | 0;
 var $$0 = 0, $1 = 0, $4 = 0, $8 = 0, $attr$02 = 0, label = 0;
 $1 = HEAP32[$node + 20 >> 2] | 0;
 if (!$1) {
  $$0 = 1;
  return $$0 | 0;
 } else $attr$02 = $1;
 L3 : while (1) {
  $4 = HEAP32[$attr$02 + 4 >> 2] | 0;
  L5 : do if ($4 | 0) {
   switch (HEAP32[$4 >> 2] | 0) {
   case 151:
   case 72:
    break;
   default:
    break L5;
   }
   $8 = HEAP32[$attr$02 + 24 >> 2] | 0;
   if ($8 | 0) if (_prvTidytmbsubstr($8, 308021) | 0) {
    $$0 = 1;
    label = 7;
    break L3;
   }
  } while (0);
  $attr$02 = HEAP32[$attr$02 >> 2] | 0;
  if (!$attr$02) {
   $$0 = 0;
   label = 7;
   break;
  }
 }
 if ((label | 0) == 7) return $$0 | 0;
 return 0;
}

function _prvTidyReportEncodingWarning($doc, $code, $encoding) {
 $doc = $doc | 0;
 $code = $code | 0;
 $encoding = $encoding | 0;
 var $0 = 0, $5 = 0, $6 = 0, $7 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 if (($code | 0) != 295) {
  STACKTOP = sp;
  return;
 }
 $0 = _tidyLocalizedString(295) | 0;
 $5 = _prvTidyCharEncodingName(HEAP32[(HEAP32[$doc + 6776 >> 2] | 0) + 296 >> 2] | 0) | 0;
 $6 = _prvTidyCharEncodingName($encoding) | 0;
 HEAP32[$vararg_buffer >> 2] = $5;
 HEAP32[$vararg_buffer + 4 >> 2] = $6;
 _messageLexer($doc, 0, 295, $0, $vararg_buffer);
 $7 = $doc + 6844 | 0;
 HEAP32[$7 >> 2] = HEAP32[$7 >> 2] | 16;
 STACKTOP = sp;
 return;
}

function _prvTidyFreePrintBuf($doc) {
 $doc = $doc | 0;
 var $0 = 0, $1 = 0, $7 = 0, $8 = 0;
 $0 = $doc + 6856 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$1 >> 2] | 0) + 8 >> 2] & 15]($1, HEAP32[$doc + 6728 >> 2] | 0);
 $7 = $doc + 6724 | 0;
 HEAP32[$7 >> 2] = 0;
 HEAP32[$7 + 4 >> 2] = 0;
 HEAP32[$7 + 8 >> 2] = 0;
 HEAP32[$7 + 12 >> 2] = 0;
 HEAP32[$7 + 16 >> 2] = 0;
 HEAP32[$7 + 20 >> 2] = 0;
 HEAP32[$7 + 24 >> 2] = 0;
 $8 = $doc + 6752 | 0;
 HEAP32[$8 >> 2] = -1;
 HEAP32[$8 + 4 >> 2] = -1;
 HEAP32[$8 + 8 >> 2] = -1;
 HEAP32[$8 + 12 >> 2] = -1;
 HEAP32[$8 + 16 >> 2] = -1;
 HEAP32[$8 + 20 >> 2] = -1;
 HEAP32[$7 >> 2] = HEAP32[$0 >> 2];
 HEAP32[$doc + 6744 >> 2] = 0;
 return;
}

function _prvTidyInsertNodeAfterElement($element, $node) {
 $element = $element | 0;
 $node = $node | 0;
 var $$pre$phiZ2D = 0, $0 = 0, $2 = 0, $5 = 0, $6 = 0, label = 0;
 $0 = HEAP32[$element >> 2] | 0;
 HEAP32[$node >> 2] = $0;
 if (!$0) label = 4; else {
  $2 = $0 + 16 | 0;
  if ((HEAP32[$2 >> 2] | 0) == ($element | 0)) {
   HEAP32[$2 >> 2] = $node;
   $$pre$phiZ2D = $element + 8 | 0;
  } else label = 4;
 }
 if ((label | 0) == 4) {
  $5 = $element + 8 | 0;
  $6 = HEAP32[$5 >> 2] | 0;
  HEAP32[$node + 8 >> 2] = $6;
  if (!$6) $$pre$phiZ2D = $5; else {
   HEAP32[$6 + 4 >> 2] = $node;
   $$pre$phiZ2D = $5;
  }
 }
 HEAP32[$$pre$phiZ2D >> 2] = $node;
 HEAP32[$node + 4 >> 2] = $element;
 return;
}

function _prvTidyAdjustCharEncoding($doc, $encoding) {
 $doc = $doc | 0;
 $encoding = $encoding | 0;
 var $$0 = 0, $inenc$0$ph = 0, $outenc$0$ph = 0;
 switch ($encoding | 0) {
 case 2:
 case 8:
 case 7:
 case 6:
  {
   $inenc$0$ph = $encoding;
   $outenc$0$ph = 1;
   break;
  }
 case 1:
  {
   $inenc$0$ph = 3;
   $outenc$0$ph = 1;
   break;
  }
 case 12:
 case 13:
 case 11:
 case 10:
 case 9:
 case 5:
 case 4:
 case 3:
 case 0:
  {
   $inenc$0$ph = $encoding;
   $outenc$0$ph = $encoding;
   break;
  }
 default:
  {
   $$0 = 0;
   return $$0 | 0;
  }
 }
 HEAP32[$doc + 88 >> 2] = $encoding;
 HEAP32[$doc + 92 >> 2] = $inenc$0$ph;
 HEAP32[$doc + 96 >> 2] = $outenc$0$ph;
 $$0 = 1;
 return $$0 | 0;
}

function _prvTidynodeHeaderLevel($node) {
 $node = $node | 0;
 var $$0 = 0, $2 = 0, label = 0;
 L1 : do if (!$node) label = 9; else {
  $2 = HEAP32[$node + 28 >> 2] | 0;
  if (!$2) label = 9; else switch (HEAP32[$2 >> 2] | 0) {
  case 40:
   {
    $$0 = 1;
    break L1;
    break;
   }
  case 41:
   {
    $$0 = 2;
    break L1;
    break;
   }
  case 42:
   {
    $$0 = 3;
    break L1;
    break;
   }
  case 43:
   {
    $$0 = 4;
    break L1;
    break;
   }
  case 44:
   {
    $$0 = 5;
    break L1;
    break;
   }
  case 45:
   {
    $$0 = 6;
    break L1;
    break;
   }
  default:
   {
    label = 9;
    break L1;
   }
  }
 } while (0);
 if ((label | 0) == 9) $$0 = 0;
 return $$0 | 0;
}

function _fgetc($f) {
 $f = $f | 0;
 var $$0 = 0, $14 = 0, $15 = 0, $23 = 0, $5 = 0, $6 = 0, label = 0;
 if ((HEAP32[$f + 76 >> 2] | 0) < 0) label = 3; else if (!(___lockfile($f) | 0)) label = 3; else {
  $14 = $f + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  if ($15 >>> 0 < (HEAP32[$f + 8 >> 2] | 0) >>> 0) {
   HEAP32[$14 >> 2] = $15 + 1;
   $23 = HEAPU8[$15 >> 0] | 0;
  } else $23 = ___uflow($f) | 0;
  $$0 = $23;
 }
 do if ((label | 0) == 3) {
  $5 = $f + 4 | 0;
  $6 = HEAP32[$5 >> 2] | 0;
  if ($6 >>> 0 < (HEAP32[$f + 8 >> 2] | 0) >>> 0) {
   HEAP32[$5 >> 2] = $6 + 1;
   $$0 = HEAPU8[$6 >> 0] | 0;
   break;
  } else {
   $$0 = ___uflow($f) | 0;
   break;
  }
 } while (0);
 return $$0 | 0;
}

function _memcpy(dest, src, num) {
 dest = dest | 0;
 src = src | 0;
 num = num | 0;
 var ret = 0;
 if ((num | 0) >= 4096) return _emscripten_memcpy_big(dest | 0, src | 0, num | 0) | 0;
 ret = dest | 0;
 if ((dest & 3) == (src & 3)) {
  while (dest & 3) {
   if (!num) return ret | 0;
   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
   dest = dest + 1 | 0;
   src = src + 1 | 0;
   num = num - 1 | 0;
  }
  while ((num | 0) >= 4) {
   HEAP32[dest >> 2] = HEAP32[src >> 2];
   dest = dest + 4 | 0;
   src = src + 4 | 0;
   num = num - 4 | 0;
  }
 }
 while ((num | 0) > 0) {
  HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
  dest = dest + 1 | 0;
  src = src + 1 | 0;
  num = num - 1 | 0;
 }
 return ret | 0;
}

function _prvTidyDropEmptyElements($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0$be = 0, $$01 = 0, $2 = 0, $4 = 0, label = 0;
 if (!$node) return 0; else $$01 = $node;
 while (1) {
  $2 = HEAP32[$$01 + 8 >> 2] | 0;
  $4 = HEAP32[$$01 + 12 >> 2] | 0;
  if ($4 | 0) _prvTidyDropEmptyElements($doc, $4) | 0;
  if (!(_prvTidynodeIsElement($$01) | 0)) if (!(_prvTidynodeIsText($$01) | 0)) $$0$be = $2; else if ((HEAP32[$$01 + 36 >> 2] | 0) >>> 0 < (HEAP32[$$01 + 40 >> 2] | 0) >>> 0) $$0$be = $2; else label = 7; else label = 7;
  if ((label | 0) == 7) {
   label = 0;
   $$0$be = _prvTidyTrimEmptyElement($doc, $$01) | 0;
  }
  if (!$$0$be) break; else $$01 = $$0$be;
 }
 return 0;
}

function _prvTidyFreeAnchors($doc) {
 $doc = $doc | 0;
 var $$pre$i = 0, $0 = 0, $1 = 0, $11 = 0, $4 = 0, $5 = 0, $h$01 = 0;
 $$pre$i = $doc + 6856 | 0;
 $h$01 = 0;
 do {
  $0 = $doc + 1596 + ($h$01 << 2) | 0;
  $1 = HEAP32[$0 >> 2] | 0;
  if ($1 | 0) {
   $4 = $1;
   do {
    HEAP32[$0 >> 2] = HEAP32[$4 >> 2];
    $5 = HEAP32[$$pre$i >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$5 >> 2] | 0) + 8 >> 2] & 15]($5, HEAP32[$4 + 8 >> 2] | 0);
    $11 = HEAP32[$$pre$i >> 2] | 0;
    FUNCTION_TABLE_vii[HEAP32[(HEAP32[$11 >> 2] | 0) + 8 >> 2] & 15]($11, $4);
    $4 = HEAP32[$0 >> 2] | 0;
   } while (($4 | 0) != 0);
  }
  $h$01 = $h$01 + 1 | 0;
 } while (($h$01 | 0) != 1021);
 return;
}

function _prvTidyReplacePreformattedSpaces($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$01 = 0, $1 = 0, $15 = 0, $5 = 0, label = 0, $$01$looptemp = 0;
 if (!$node) return;
 $1 = $doc + 68 | 0;
 $$01 = $node;
 do {
  $$01$looptemp = $$01;
  $$01 = HEAP32[$$01 + 8 >> 2] | 0;
  $5 = HEAP32[$$01$looptemp + 28 >> 2] | 0;
  if (!$5) label = 7; else if ((HEAP32[$5 + 20 >> 2] | 0) == 35) _prvTidyNormalizeSpaces(HEAP32[$1 >> 2] | 0, HEAP32[$$01$looptemp + 12 >> 2] | 0); else label = 7;
  if ((label | 0) == 7) {
   label = 0;
   $15 = HEAP32[$$01$looptemp + 12 >> 2] | 0;
   if ($15 | 0) _prvTidyReplacePreformattedSpaces($doc, $15);
  }
 } while (($$01 | 0) != 0);
 return;
}

function _CheckColorAvailable($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $3 = 0;
 if (!($node | 0 ? ((HEAP32[$doc + 6396 >> 2] | 0) + -1 | 0) >>> 0 < 3 : 0)) return;
 $3 = HEAP32[$node + 28 >> 2] | 0;
 if (!$3) return;
 switch (HEAP32[$3 >> 2] | 0) {
 case 52:
  {
   _prvTidyReportAccessWarning($doc, $node, 327);
   return;
  }
 case 6:
  {
   _prvTidyReportAccessWarning($doc, $node, 328);
   return;
  }
 case 76:
  {
   _prvTidyReportAccessWarning($doc, $node, 329);
   return;
  }
 case 94:
  {
   _prvTidyReportAccessWarning($doc, $node, 330);
   return;
  }
 case 53:
  {
   _prvTidyReportAccessWarning($doc, $node, 331);
   return;
  }
 default:
  return;
 }
}

function _memset(ptr, value, num) {
 ptr = ptr | 0;
 value = value | 0;
 num = num | 0;
 var stop = 0, value4 = 0, stop4 = 0, unaligned = 0;
 stop = ptr + num | 0;
 if ((num | 0) >= 20) {
  value = value & 255;
  unaligned = ptr & 3;
  value4 = value | value << 8 | value << 16 | value << 24;
  stop4 = stop & ~3;
  if (unaligned) {
   unaligned = ptr + 4 - unaligned | 0;
   while ((ptr | 0) < (unaligned | 0)) {
    HEAP8[ptr >> 0] = value;
    ptr = ptr + 1 | 0;
   }
  }
  while ((ptr | 0) < (stop4 | 0)) {
   HEAP32[ptr >> 2] = value4;
   ptr = ptr + 4 | 0;
  }
 }
 while ((ptr | 0) < (stop | 0)) {
  HEAP8[ptr >> 0] = value;
  ptr = ptr + 1 | 0;
 }
 return ptr - num | 0;
}

function _tidyRunDiagnostics($tdoc) {
 $tdoc = $tdoc | 0;
 var $$0 = 0, $10 = 0, $2 = 0, $4 = 0, $6 = 0, $7 = 0;
 if (!$tdoc) {
  $$0 = -22;
  return $$0 | 0;
 }
 $2 = HEAP32[$tdoc + 148 >> 2] | 0;
 $4 = HEAP32[$tdoc + 348 >> 2] | 0;
 _prvTidyReportNumWarnings($tdoc);
 if (!$2) _prvTidyReportMarkupVersion($tdoc);
 $6 = $tdoc + 6812 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 if (($4 | 0) != 0 | ($7 | 0) == 0) $10 = $7; else {
  _prvTidyNeedsAuthorIntervention($tdoc);
  $10 = HEAP32[$6 >> 2] | 0;
 }
 if ($10 | 0) {
  $$0 = 2;
  return $$0 | 0;
 }
 if (HEAP32[$tdoc + 6816 >> 2] | 0) {
  $$0 = 1;
  return $$0 | 0;
 }
 $$0 = (HEAP32[$tdoc + 6820 >> 2] | 0) != 0 & 1;
 return $$0 | 0;
}

function _fclose($f) {
 $f = $f | 0;
 var $$pre = 0, $12 = 0, $18 = 0, $22 = 0, $24 = 0, $5 = 0, $7 = 0;
 if ((HEAP32[$f + 76 >> 2] | 0) > -1) {}
 $5 = (HEAP32[$f >> 2] & 1 | 0) != 0;
 if (!$5) {
  ___lock(317044);
  $7 = HEAP32[$f + 52 >> 2] | 0;
  $$pre = $f + 56 | 0;
  if ($7 | 0) HEAP32[$7 + 56 >> 2] = HEAP32[$$pre >> 2];
  $12 = HEAP32[$$pre >> 2] | 0;
  if ($12 | 0) HEAP32[$12 + 52 >> 2] = $7;
  if ((HEAP32[79260] | 0) == ($f | 0)) HEAP32[79260] = $12;
  ___unlock(317044);
 }
 $18 = _fflush($f) | 0;
 $22 = FUNCTION_TABLE_ii[HEAP32[$f + 12 >> 2] & 31]($f) | 0 | $18;
 $24 = HEAP32[$f + 92 >> 2] | 0;
 if ($24 | 0) _free($24);
 if (!$5) _free($f);
 return $22 | 0;
}

function _prvTidyRemoveNode($node) {
 $node = $node | 0;
 var $$pre = 0, $0 = 0, $1 = 0, $10 = 0, $12 = 0, $15 = 0, $6 = 0, $8 = 0;
 $0 = $node + 4 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $$pre = $node + 8 | 0;
 if ($1 | 0) HEAP32[$1 + 8 >> 2] = HEAP32[$$pre >> 2];
 $6 = HEAP32[$$pre >> 2] | 0;
 $8 = $6;
 if ($6 | 0) HEAP32[$6 + 4 >> 2] = $1;
 $10 = HEAP32[$node >> 2] | 0;
 if ($10 | 0) {
  $12 = $10 + 12 | 0;
  if ((HEAP32[$12 >> 2] | 0) == ($node | 0)) HEAP32[$12 >> 2] = $8;
  $15 = $10 + 16 | 0;
  if ((HEAP32[$15 >> 2] | 0) == ($node | 0)) HEAP32[$15 >> 2] = HEAP32[$0 >> 2];
 }
 HEAP32[$$pre >> 2] = 0;
 HEAP32[$0 >> 2] = 0;
 HEAP32[$node >> 2] = 0;
 return $node | 0;
}

function _messageNode($doc, $level, $code, $node, $msg, $varargs) {
 $doc = $doc | 0;
 $level = $level | 0;
 $code = $code | 0;
 $node = $node | 0;
 $msg = $msg | 0;
 $varargs = $varargs | 0;
 var $11 = 0, $12 = 0, $2 = 0, $args = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $args = sp;
 if (!$node) {
  $2 = HEAP32[$doc + 68 >> 2] | 0;
  if (!$2) {
   $11 = 0;
   $12 = 0;
  } else {
   $11 = HEAP32[$2 >> 2] | 0;
   $12 = HEAP32[$2 + 4 >> 2] | 0;
  }
 } else {
  $11 = HEAP32[$node + 48 >> 2] | 0;
  $12 = HEAP32[$node + 52 >> 2] | 0;
 }
 HEAP32[$args >> 2] = $varargs;
 _messagePos($doc, $level, $code, $11, $12, $msg, $args);
 STACKTOP = sp;
 return;
}

function ___toread($f) {
 $f = $f | 0;
 var $$0 = 0, $0 = 0, $15 = 0, $2 = 0, $21 = 0, $6 = 0, $8 = 0;
 $0 = $f + 74 | 0;
 $2 = HEAP8[$0 >> 0] | 0;
 HEAP8[$0 >> 0] = $2 + 255 | $2;
 $6 = $f + 20 | 0;
 $8 = $f + 44 | 0;
 if ((HEAP32[$6 >> 2] | 0) >>> 0 > (HEAP32[$8 >> 2] | 0) >>> 0) FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 15]($f, 0, 0) | 0;
 HEAP32[$f + 16 >> 2] = 0;
 HEAP32[$f + 28 >> 2] = 0;
 HEAP32[$6 >> 2] = 0;
 $15 = HEAP32[$f >> 2] | 0;
 if (!($15 & 20)) {
  $21 = HEAP32[$8 >> 2] | 0;
  HEAP32[$f + 8 >> 2] = $21;
  HEAP32[$f + 4 >> 2] = $21;
  $$0 = 0;
 } else if (!($15 & 4)) $$0 = -1; else {
  HEAP32[$f >> 2] = $15 | 32;
  $$0 = -1;
 }
 return $$0 | 0;
}

function _strtok($s, $sep) {
 $s = $s | 0;
 $sep = $sep | 0;
 var $$0 = 0, $$01 = 0, $1 = 0, $4 = 0, $8 = 0, label = 0;
 if (!$s) {
  $1 = HEAP32[79267] | 0;
  if (!$1) $$0 = 0; else {
   $$01 = $1;
   label = 3;
  }
 } else {
  $$01 = $s;
  label = 3;
 }
 do if ((label | 0) == 3) {
  $4 = $$01 + (_strspn($$01, $sep) | 0) | 0;
  if (!(HEAP8[$4 >> 0] | 0)) {
   HEAP32[79267] = 0;
   $$0 = 0;
   break;
  }
  $8 = $4 + (_strcspn($4, $sep) | 0) | 0;
  HEAP32[79267] = $8;
  if (!(HEAP8[$8 >> 0] | 0)) {
   HEAP32[79267] = 0;
   $$0 = $4;
   break;
  } else {
   HEAP32[79267] = $8 + 1;
   HEAP8[$8 >> 0] = 0;
   $$0 = $4;
   break;
  }
 } while (0);
 return $$0 | 0;
}

function _prvTidyNewLineNode($lexer) {
 $lexer = $lexer | 0;
 var $1 = 0, $12 = 0, $4 = 0, dest = 0, stop = 0;
 $1 = HEAP32[$lexer + 124 >> 2] | 0;
 $4 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1 >> 2] >> 2] & 31]($1, 68) | 0;
 dest = $4;
 stop = dest + 68 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 if ($lexer | 0) {
  HEAP32[$4 + 48 >> 2] = HEAP32[$lexer >> 2];
  HEAP32[$4 + 52 >> 2] = HEAP32[$lexer + 4 >> 2];
 }
 HEAP32[$4 + 44 >> 2] = 4;
 $12 = $lexer + 92 | 0;
 HEAP32[$4 + 36 >> 2] = HEAP32[$12 >> 2];
 _prvTidyAddCharToLexer($lexer, 10);
 HEAP32[$4 + 40 >> 2] = HEAP32[$12 >> 2];
 return $4 | 0;
}

function _memcmp($vl, $vr, $n) {
 $vl = $vl | 0;
 $vr = $vr | 0;
 $n = $n | 0;
 var $$03 = 0, $$lcssa = 0, $$lcssa19 = 0, $1 = 0, $11 = 0, $2 = 0, $l$04 = 0, $r$05 = 0;
 L1 : do if (!$n) $11 = 0; else {
  $$03 = $n;
  $l$04 = $vl;
  $r$05 = $vr;
  while (1) {
   $1 = HEAP8[$l$04 >> 0] | 0;
   $2 = HEAP8[$r$05 >> 0] | 0;
   if ($1 << 24 >> 24 != $2 << 24 >> 24) {
    $$lcssa = $1;
    $$lcssa19 = $2;
    break;
   }
   $$03 = $$03 + -1 | 0;
   if (!$$03) {
    $11 = 0;
    break L1;
   } else {
    $l$04 = $l$04 + 1 | 0;
    $r$05 = $r$05 + 1 | 0;
   }
  }
  $11 = ($$lcssa & 255) - ($$lcssa19 & 255) | 0;
 } while (0);
 return $11 | 0;
}

function ___stdio_seek($f, $off, $whence) {
 $f = $f | 0;
 $off = $off | 0;
 $whence = $whence | 0;
 var $5 = 0, $ret = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer = sp;
 $ret = sp + 20 | 0;
 HEAP32[$vararg_buffer >> 2] = HEAP32[$f + 60 >> 2];
 HEAP32[$vararg_buffer + 4 >> 2] = 0;
 HEAP32[$vararg_buffer + 8 >> 2] = $off;
 HEAP32[$vararg_buffer + 12 >> 2] = $ret;
 HEAP32[$vararg_buffer + 16 >> 2] = $whence;
 if ((___syscall_ret(___syscall140(140, $vararg_buffer | 0) | 0) | 0) < 0) {
  HEAP32[$ret >> 2] = -1;
  $5 = -1;
 } else $5 = HEAP32[$ret >> 2] | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function ___fmodeflags($mode) {
 $mode = $mode | 0;
 var $1 = 0, $2 = 0, $4 = 0, $7 = 0, $flags$0 = 0, $flags$0$ = 0, $flags$2 = 0, $flags$2$ = 0, $flags$4 = 0;
 $1 = (_strchr($mode, 43) | 0) == 0;
 $2 = HEAP8[$mode >> 0] | 0;
 $flags$0 = $1 ? $2 << 24 >> 24 != 114 & 1 : 2;
 $4 = (_strchr($mode, 120) | 0) == 0;
 $flags$0$ = $4 ? $flags$0 : $flags$0 | 128;
 $7 = (_strchr($mode, 101) | 0) == 0;
 $flags$2 = $7 ? $flags$0$ : $flags$0$ | 524288;
 $flags$2$ = $2 << 24 >> 24 == 114 ? $flags$2 : $flags$2 | 64;
 $flags$4 = $2 << 24 >> 24 == 119 ? $flags$2$ | 512 : $flags$2$;
 return ($2 << 24 >> 24 == 97 ? $flags$4 | 1024 : $flags$4) | 0;
}

function _prvTidyinitStdIOFileSource($allocator, $inp, $fp) {
 $allocator = $allocator | 0;
 $inp = $inp | 0;
 $fp = $fp | 0;
 var $$0 = 0, $2 = 0;
 $2 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$allocator >> 2] >> 2] & 31]($allocator, 24) | 0;
 if (!$2) {
  $$0 = -1;
  return $$0 | 0;
 };
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = $allocator;
 HEAP32[$2 >> 2] = $fp;
 HEAP32[$inp + 4 >> 2] = 15;
 HEAP32[$inp + 12 >> 2] = 16;
 HEAP32[$inp + 8 >> 2] = 12;
 HEAP32[$inp >> 2] = $2;
 $$0 = 0;
 return $$0 | 0;
}

function _prvTidyGetAttrByName($node, $name) {
 $node = $node | 0;
 $name = $name | 0;
 var $3 = 0, $attr$0$lcssa = 0, $attr$01 = 0, $attr$02 = 0, label = 0;
 $attr$01 = HEAP32[$node + 20 >> 2] | 0;
 if (!$attr$01) {
  $attr$0$lcssa = 0;
  return $attr$0$lcssa | 0;
 } else $attr$02 = $attr$01;
 while (1) {
  $3 = HEAP32[$attr$02 + 20 >> 2] | 0;
  if ($3 | 0) if (!(_prvTidytmbstrcmp($3, $name) | 0)) {
   $attr$0$lcssa = $attr$02;
   label = 5;
   break;
  }
  $attr$02 = HEAP32[$attr$02 >> 2] | 0;
  if (!$attr$02) {
   $attr$0$lcssa = 0;
   label = 5;
   break;
  }
 }
 if ((label | 0) == 5) return $attr$0$lcssa | 0;
 return 0;
}

function _prvTidyFileOutput($doc, $fp, $encoding, $nl) {
 $doc = $doc | 0;
 $fp = $fp | 0;
 $encoding = $encoding | 0;
 $nl = $nl | 0;
 var $2 = 0, $doc$idx$val = 0;
 $doc$idx$val = HEAP32[$doc + 6856 >> 2] | 0;
 $2 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$doc$idx$val >> 2] >> 2] & 31]($doc$idx$val, 24) | 0;
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 >> 2] = $encoding;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = $nl;
 _prvTidyinitFileSink($2 + 16 | 0, $fp);
 HEAP32[$2 + 12 >> 2] = 0;
 return $2 | 0;
}

function _prvTidyInitTags($doc) {
 $doc = $doc | 0;
 var $0 = 0, $2 = 0, $5 = 0;
 $0 = $doc + 876 | 0;
 _memset($0 | 0, 0, 720) | 0;
 $2 = HEAP32[$doc + 6856 >> 2] | 0;
 $5 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$2 >> 2] >> 2] & 31]($2, 32) | 0;
 HEAP32[$5 >> 2] = 0;
 HEAP32[$5 + 4 >> 2] = 0;
 HEAP32[$5 + 8 >> 2] = 0;
 HEAP32[$5 + 12 >> 2] = 0;
 HEAP32[$5 + 16 >> 2] = 0;
 HEAP32[$5 + 20 >> 2] = 0;
 HEAP32[$5 + 24 >> 2] = 0;
 HEAP32[$5 + 28 >> 2] = 0;
 HEAP32[$5 + 8 >> 2] = 65536;
 HEAP32[$5 + 16 >> 2] = 8;
 HEAP32[$5 + 20 >> 2] = 0;
 HEAP32[$5 + 24 >> 2] = 0;
 HEAP32[$5 + 12 >> 2] = 0;
 HEAP32[$0 >> 2] = $5;
 return;
}

function _defaultAlloc($allocator, $size) {
 $allocator = $allocator | 0;
 $size = $size | 0;
 var $0 = 0, $4 = 0, $6 = 0, $8 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[79250] | 0;
 if (!$0) $4 = _malloc($size) | 0; else $4 = FUNCTION_TABLE_ii[$0 & 31]($size) | 0;
 if ($4 | 0) {
  STACKTOP = sp;
  return $4 | 0;
 }
 $6 = HEAP32[79251] | 0;
 if (!$6) {
  $8 = HEAP32[55027] | 0;
  HEAP32[$vararg_buffer >> 2] = 311680;
  _fprintf($8, 311663, $vararg_buffer) | 0;
  _exit(2);
 }
 FUNCTION_TABLE_vi[$6 & 3](311680);
 STACKTOP = sp;
 return $4 | 0;
}

function _prvTidyFreeAttribute($doc, $av) {
 $doc = $doc | 0;
 $av = $av | 0;
 var $11 = 0, $17 = 0, $4 = 0, $5 = 0;
 _prvTidyFreeNode($doc, HEAP32[$av + 8 >> 2] | 0);
 _prvTidyFreeNode($doc, HEAP32[$av + 12 >> 2] | 0);
 $4 = $doc + 6856 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$5 >> 2] | 0) + 8 >> 2] & 15]($5, HEAP32[$av + 20 >> 2] | 0);
 $11 = HEAP32[$4 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$11 >> 2] | 0) + 8 >> 2] & 15]($11, HEAP32[$av + 24 >> 2] | 0);
 $17 = HEAP32[$4 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$17 >> 2] | 0) + 8 >> 2] & 15]($17, $av);
 return;
}

function _strcmp($l, $r) {
 $l = $l | 0;
 $r = $r | 0;
 var $$014 = 0, $$05 = 0, $$lcssa = 0, $$lcssa2 = 0, $0 = 0, $1 = 0, $6 = 0, $7 = 0;
 $0 = HEAP8[$l >> 0] | 0;
 $1 = HEAP8[$r >> 0] | 0;
 if ($0 << 24 >> 24 == 0 ? 1 : $0 << 24 >> 24 != $1 << 24 >> 24) {
  $$lcssa = $0;
  $$lcssa2 = $1;
 } else {
  $$014 = $l;
  $$05 = $r;
  do {
   $$014 = $$014 + 1 | 0;
   $$05 = $$05 + 1 | 0;
   $6 = HEAP8[$$014 >> 0] | 0;
   $7 = HEAP8[$$05 >> 0] | 0;
  } while (!($6 << 24 >> 24 == 0 ? 1 : $6 << 24 >> 24 != $7 << 24 >> 24));
  $$lcssa = $6;
  $$lcssa2 = $7;
 }
 return ($$lcssa & 255) - ($$lcssa2 & 255) | 0;
}

function _tidyOptGetNextDeclTag($tdoc, $optId, $iter) {
 $tdoc = $tdoc | 0;
 $optId = $optId | 0;
 $iter = $iter | 0;
 var $tagnam$1 = 0, $tagtyp$0$ph = 0;
 L1 : do if (!$tdoc) $tagnam$1 = 0; else {
  switch ($optId | 0) {
  case 80:
   {
    $tagtyp$0$ph = 2;
    break;
   }
  case 81:
   {
    $tagtyp$0$ph = 4;
    break;
   }
  case 82:
   {
    $tagtyp$0$ph = 1;
    break;
   }
  default:
   if (($optId | 0) == 83) $tagtyp$0$ph = 8; else {
    $tagnam$1 = 0;
    break L1;
   }
  }
  $tagnam$1 = _prvTidyGetNextDeclaredTag($tdoc, $tagtyp$0$ph, $iter) | 0;
 } while (0);
 return $tagnam$1 | 0;
}

function _prvTidyNewLexer($doc) {
 $doc = $doc | 0;
 var $0 = 0, $1 = 0, $4 = 0, dest = 0, stop = 0;
 $0 = $doc + 6856 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $4 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1 >> 2] >> 2] & 31]($1, 128) | 0;
 if (!$4) return $4 | 0;
 dest = $4;
 stop = dest + 124 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 HEAP32[$4 + 124 >> 2] = HEAP32[$0 >> 2];
 HEAP32[$4 >> 2] = 1;
 HEAP32[$4 + 4 >> 2] = 1;
 HEAP32[$4 + 56 >> 2] = 0;
 HEAP32[$4 + 32 >> 2] = 458751;
 HEAP32[$4 + 36 >> 2] = 0;
 HEAP32[$4 + 68 >> 2] = $doc;
 return $4 | 0;
}

function _prvTidyTextToken($lexer) {
 $lexer = $lexer | 0;
 var $1 = 0, $4 = 0, dest = 0, stop = 0;
 $1 = HEAP32[$lexer + 124 >> 2] | 0;
 $4 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1 >> 2] >> 2] & 31]($1, 68) | 0;
 dest = $4;
 stop = dest + 68 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 if ($lexer | 0) {
  HEAP32[$4 + 48 >> 2] = HEAP32[$lexer >> 2];
  HEAP32[$4 + 52 >> 2] = HEAP32[$lexer + 4 >> 2];
 }
 HEAP32[$4 + 44 >> 2] = 4;
 HEAP32[$4 + 36 >> 2] = HEAP32[$lexer + 48 >> 2];
 HEAP32[$4 + 40 >> 2] = HEAP32[$lexer + 52 >> 2];
 return $4 | 0;
}

function _puts($s) {
 $s = $s | 0;
 var $0 = 0, $10 = 0, $11 = 0, $18 = 0, $19 = 0;
 $0 = HEAP32[55056] | 0;
 if ((HEAP32[$0 + 76 >> 2] | 0) > -1) $19 = ___lockfile($0) | 0; else $19 = 0;
 do if ((_fputs($s, $0) | 0) < 0) $18 = 1; else {
  if ((HEAP8[$0 + 75 >> 0] | 0) != 10) {
   $10 = $0 + 20 | 0;
   $11 = HEAP32[$10 >> 2] | 0;
   if ($11 >>> 0 < (HEAP32[$0 + 16 >> 2] | 0) >>> 0) {
    HEAP32[$10 >> 2] = $11 + 1;
    HEAP8[$11 >> 0] = 10;
    $18 = 0;
    break;
   }
  }
  $18 = (___overflow($0, 10) | 0) < 0;
 } while (0);
 if ($19 | 0) ___unlockfile($0);
 return $18 << 31 >> 31 | 0;
}

function _prvTidyFixNodeLinks($node) {
 $node = $node | 0;
 var $1 = 0, $7 = 0, $child$01 = 0, $child$02 = 0;
 $1 = HEAP32[$node + 4 >> 2] | 0;
 if (!$1) HEAP32[(HEAP32[$node >> 2] | 0) + 12 >> 2] = $node; else HEAP32[$1 + 8 >> 2] = $node;
 $7 = HEAP32[$node + 8 >> 2] | 0;
 if (!$7) HEAP32[(HEAP32[$node >> 2] | 0) + 16 >> 2] = $node; else HEAP32[$7 + 4 >> 2] = $node;
 $child$01 = HEAP32[$node + 12 >> 2] | 0;
 if (!$child$01) return; else $child$02 = $child$01;
 do {
  HEAP32[$child$02 >> 2] = $node;
  $child$02 = HEAP32[$child$02 + 8 >> 2] | 0;
 } while (($child$02 | 0) != 0);
 return;
}

function _prvTidytmbstrcpy($s1, $s2) {
 $s1 = $s1 | 0;
 $s2 = $s2 | 0;
 var $$012 = 0, $$03 = 0, $0 = 0, $4 = 0, $5 = 0, $ncpy$0$lcssa = 0, $ncpy$04 = 0;
 $0 = HEAP8[$s2 >> 0] | 0;
 HEAP8[$s1 >> 0] = $0;
 if (!($0 << 24 >> 24)) {
  $ncpy$0$lcssa = 0;
  return $ncpy$0$lcssa | 0;
 } else {
  $$012 = $s1;
  $$03 = $s2;
  $ncpy$04 = 0;
 }
 while (1) {
  $$012 = $$012 + 1 | 0;
  $$03 = $$03 + 1 | 0;
  $4 = $ncpy$04 + 1 | 0;
  $5 = HEAP8[$$03 >> 0] | 0;
  HEAP8[$$012 >> 0] = $5;
  if (!($5 << 24 >> 24)) {
   $ncpy$0$lcssa = $4;
   break;
  } else $ncpy$04 = $4;
 }
 return $ncpy$0$lcssa | 0;
}

function _prvTidyAddAttribute($doc, $node, $name, $value) {
 $doc = $doc | 0;
 $node = $node | 0;
 $name = $name | 0;
 $value = $value | 0;
 var $$sink = 0, $0 = 0, $2 = 0;
 $0 = _prvTidyNewAttribute($doc) | 0;
 HEAP32[$0 + 16 >> 2] = 34;
 $2 = $doc + 6856 | 0;
 HEAP32[$0 + 20 >> 2] = _prvTidytmbstrdup(HEAP32[$2 >> 2] | 0, $name) | 0;
 if (!$value) $$sink = 0; else $$sink = _prvTidytmbstrdup(HEAP32[$2 >> 2] | 0, $value) | 0;
 HEAP32[$0 + 24 >> 2] = $$sink;
 HEAP32[$0 + 4 >> 2] = _attrsLookup($doc, $doc + 1596 | 0, $name) | 0;
 _prvTidyInsertAttributeAtEnd($node, $0);
 return $0 | 0;
}

function _prvTidyEntityName($ch, $versions) {
 $ch = $ch | 0;
 $versions = $versions | 0;
 var $$lcssa = 0, $10 = 0, $ep$03 = 0, $ep$03$lcssa = 0, label = 0;
 $10 = 312315;
 $ep$03 = 217060;
 while (1) {
  if ((HEAP32[$ep$03 + 8 >> 2] | 0) == ($ch | 0)) {
   $$lcssa = $10;
   $ep$03$lcssa = $ep$03;
   label = 3;
   break;
  }
  $ep$03 = $ep$03 + 12 | 0;
  $10 = HEAP32[$ep$03 >> 2] | 0;
  if (!$10) {
   label = 5;
   break;
  }
 }
 if ((label | 0) == 3) return ((HEAP32[$ep$03$lcssa + 4 >> 2] & $versions | 0) == 0 ? 0 : $$lcssa) | 0; else if ((label | 0) == 5) return 0;
 return 0;
}

function _tidySetErrorFile($tdoc, $errfilnam) {
 $tdoc = $tdoc | 0;
 $errfilnam = $errfilnam | 0;
 var $$1 = 0, $1 = 0, $4 = 0, $6 = 0, $7 = 0;
 if (!$tdoc) {
  $$1 = 0;
  return $$1 | 0;
 }
 $1 = _fopen($errfilnam, 226574) | 0;
 if (!$1) {
  _prvTidyFileError($tdoc, $errfilnam, 4);
  $$1 = 0;
  return $$1 | 0;
 } else {
  $4 = HEAP32[$tdoc + 96 >> 2] | 0;
  $6 = HEAP32[$tdoc + 100 >> 2] | 0;
  $7 = $tdoc + 6784 | 0;
  _prvTidyReleaseStreamOut($tdoc, HEAP32[$7 >> 2] | 0);
  HEAP32[$7 >> 2] = _prvTidyFileOutput($tdoc, $1, $4, $6) | 0;
  $$1 = $1;
  return $$1 | 0;
 }
 return 0;
}

function _prvTidyNewNode($allocator, $lexer) {
 $allocator = $allocator | 0;
 $lexer = $lexer | 0;
 var $2 = 0, $9 = 0, dest = 0, stop = 0;
 $2 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$allocator >> 2] >> 2] & 31]($allocator, 68) | 0;
 dest = $2;
 stop = dest + 68 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 if (!$lexer) {
  $9 = $2 + 44 | 0;
  HEAP32[$9 >> 2] = 4;
  return $2 | 0;
 }
 HEAP32[$2 + 48 >> 2] = HEAP32[$lexer >> 2];
 HEAP32[$2 + 52 >> 2] = HEAP32[$lexer + 4 >> 2];
 $9 = $2 + 44 | 0;
 HEAP32[$9 >> 2] = 4;
 return $2 | 0;
}

function _prvTidyReportMissingAttr($doc, $node, $name) {
 $doc = $doc | 0;
 $node = $node | 0;
 $name = $name | 0;
 var $0 = 0, $tagdesc = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $vararg_buffer = sp;
 $tagdesc = sp + 8 | 0;
 $0 = _tidyLocalizedString(286) | 0;
 if (!$0) ___assert_fail(223545, 223391, 643, 223605); else {
  _TagToString($node, $tagdesc, 64);
  HEAP32[$vararg_buffer >> 2] = $tagdesc;
  HEAP32[$vararg_buffer + 4 >> 2] = $name;
  _messageNode($doc, 1, 286, $node, $0, $vararg_buffer);
  STACKTOP = sp;
  return;
 }
}

function _prvTidyFindHTML($doc) {
 $doc = $doc | 0;
 var $2 = 0, $5 = 0, $node$0$lcssa = 0, $node$02 = 0;
 L1 : do if (!$doc) $node$0$lcssa = 0; else {
  $2 = HEAP32[$doc + 12 >> 2] | 0;
  if (!$2) $node$0$lcssa = 0; else {
   $node$02 = $2;
   while (1) {
    $5 = HEAP32[$node$02 + 28 >> 2] | 0;
    if ($5 | 0) if ((HEAP32[$5 >> 2] | 0) == 48) {
     $node$0$lcssa = $node$02;
     break L1;
    }
    $node$02 = HEAP32[$node$02 + 8 >> 2] | 0;
    if (!$node$02) {
     $node$0$lcssa = 0;
     break;
    }
   }
  }
 } while (0);
 return $node$0$lcssa | 0;
}

function _tidyParseFile($tdoc, $filnam) {
 $tdoc = $tdoc | 0;
 $filnam = $filnam | 0;
 var $$1$i = 0, $0 = 0, $4 = 0, $6 = 0;
 $0 = _fopen($filnam, 308474) | 0;
 if (!$0) {
  _prvTidyFileError($tdoc, $filnam, 4);
  $$1$i = -2;
  return $$1$i | 0;
 }
 $4 = _prvTidyFileInput($tdoc, $0, HEAP32[$tdoc + 92 >> 2] | 0) | 0;
 if (!$4) {
  _fclose($0) | 0;
  $$1$i = -2;
  return $$1$i | 0;
 } else {
  $6 = _prvTidyDocParseStream($tdoc, $4) | 0;
  _prvTidyfreeFileSource($4 + 304 | 0, 1);
  _prvTidyfreeStreamIn($4);
  $$1$i = $6;
  return $$1$i | 0;
 }
 return 0;
}

function _prvTidyIsPushed($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0 = 0, $1 = 0, $4 = 0, $5 = 0, $i$0$in = 0, label = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $4 = $1 + 104 | 0;
 $5 = $node + 28 | 0;
 $i$0$in = HEAP32[$1 + 112 >> 2] | 0;
 while (1) {
  $i$0$in = $i$0$in + -1 | 0;
  if (($i$0$in | 0) <= -1) {
   $$0 = 0;
   label = 4;
   break;
  }
  if ((HEAP32[(HEAP32[$4 >> 2] | 0) + ($i$0$in << 4) + 4 >> 2] | 0) == (HEAP32[$5 >> 2] | 0)) {
   $$0 = 1;
   label = 4;
   break;
  }
 }
 if ((label | 0) == 4) return $$0 | 0;
 return 0;
}

function ___stdout_write($f, $buf, $len) {
 $f = $f | 0;
 $buf = $buf | 0;
 $len = $len | 0;
 var $9 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $vararg_buffer = sp;
 HEAP32[$f + 36 >> 2] = 2;
 if (!(HEAP32[$f >> 2] & 64)) {
  HEAP32[$vararg_buffer >> 2] = HEAP32[$f + 60 >> 2];
  HEAP32[$vararg_buffer + 4 >> 2] = 21505;
  HEAP32[$vararg_buffer + 8 >> 2] = sp + 12;
  if (___syscall54(54, $vararg_buffer | 0) | 0) HEAP8[$f + 75 >> 0] = -1;
 }
 $9 = ___stdio_write($f, $buf, $len) | 0;
 STACKTOP = sp;
 return $9 | 0;
}

function _prvTidyPutUTF8($buf, $c) {
 $buf = $buf | 0;
 $c = $c | 0;
 var $4 = 0, $5 = 0, $count = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $count = sp;
 HEAP32[$count >> 2] = 0;
 if (!(_prvTidyEncodeCharToUTF8Bytes($c, $buf, 0, $count) | 0)) {
  $5 = HEAP32[$count >> 2] | 0;
  $4 = $buf + $5 | 0;
  STACKTOP = sp;
  return $4 | 0;
 } else {
  HEAP8[$buf >> 0] = -17;
  HEAP8[$buf + 1 >> 0] = -65;
  HEAP8[$buf + 2 >> 0] = -67;
  HEAP32[$count >> 2] = 3;
  $5 = 3;
  $4 = $buf + $5 | 0;
  STACKTOP = sp;
  return $4 | 0;
 }
 return 0;
}

function _prvTidyInitPrintBuf($doc) {
 $doc = $doc | 0;
 var $0 = 0, $1 = 0;
 $0 = $doc + 6724 | 0;
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 $1 = $doc + 6752 | 0;
 HEAP32[$1 >> 2] = -1;
 HEAP32[$1 + 4 >> 2] = -1;
 HEAP32[$1 + 8 >> 2] = -1;
 HEAP32[$1 + 12 >> 2] = -1;
 HEAP32[$1 + 16 >> 2] = -1;
 HEAP32[$1 + 20 >> 2] = -1;
 HEAP32[$0 >> 2] = HEAP32[$doc + 6856 >> 2];
 HEAP32[$doc + 6744 >> 2] = 0;
 return;
}

function _prvTidyAttrGetById($node, $id) {
 $node = $node | 0;
 $id = $id | 0;
 var $$0 = 0, $3 = 0, $av$01 = 0, $av$02 = 0, label = 0;
 $av$01 = HEAP32[$node + 20 >> 2] | 0;
 if (!$av$01) {
  $$0 = 0;
  return $$0 | 0;
 } else $av$02 = $av$01;
 while (1) {
  $3 = HEAP32[$av$02 + 4 >> 2] | 0;
  if ($3 | 0) if ((HEAP32[$3 >> 2] | 0) == ($id | 0)) {
   $$0 = $av$02;
   label = 5;
   break;
  }
  $av$02 = HEAP32[$av$02 >> 2] | 0;
  if (!$av$02) {
   $$0 = 0;
   label = 5;
   break;
  }
 }
 if ((label | 0) == 5) return $$0 | 0;
 return 0;
}

function _fwrite($src, $size, $nmemb, $f) {
 $src = $src | 0;
 $size = $size | 0;
 $nmemb = $nmemb | 0;
 $f = $f | 0;
 var $0 = 0, $10 = 0, $6 = 0, $7 = 0, $phitmp = 0;
 $0 = Math_imul($nmemb, $size) | 0;
 if ((HEAP32[$f + 76 >> 2] | 0) > -1) {
  $phitmp = (___lockfile($f) | 0) == 0;
  $6 = ___fwritex($src, $0, $f) | 0;
  if ($phitmp) $7 = $6; else {
   ___unlockfile($f);
   $7 = $6;
  }
 } else $7 = ___fwritex($src, $0, $f) | 0;
 if (($7 | 0) == ($0 | 0)) $10 = $nmemb; else $10 = ($7 >>> 0) / ($size >>> 0) | 0;
 return $10 | 0;
}

function ___string_read($f, $buf, $len) {
 $f = $f | 0;
 $buf = $buf | 0;
 $len = $len | 0;
 var $0 = 0, $1 = 0, $11 = 0, $2 = 0, $3 = 0, $k$0 = 0, $k$0$len = 0;
 $0 = $f + 84 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $len + 256 | 0;
 $3 = _memchr($1, 0, $2) | 0;
 $k$0 = ($3 | 0) == 0 ? $2 : $3 - $1 | 0;
 $k$0$len = $k$0 >>> 0 < $len >>> 0 ? $k$0 : $len;
 _memcpy($buf | 0, $1 | 0, $k$0$len | 0) | 0;
 HEAP32[$f + 4 >> 2] = $1 + $k$0$len;
 $11 = $1 + $k$0 | 0;
 HEAP32[$f + 8 >> 2] = $11;
 HEAP32[$0 >> 2] = $11;
 return $k$0$len | 0;
}

function _prvTidyInsertNodeBeforeElement($element, $node) {
 $element = $element | 0;
 $node = $node | 0;
 var $0 = 0, $2 = 0, $4 = 0, $5 = 0, $8 = 0;
 $0 = HEAP32[$element >> 2] | 0;
 HEAP32[$node >> 2] = $0;
 HEAP32[$node + 8 >> 2] = $element;
 $2 = $element + 4 | 0;
 $4 = $node + 4 | 0;
 HEAP32[$4 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$2 >> 2] = $node;
 $5 = HEAP32[$4 >> 2] | 0;
 if ($5 | 0) HEAP32[$5 + 8 >> 2] = $node;
 $8 = $0 + 12 | 0;
 if ((HEAP32[$8 >> 2] | 0) != ($element | 0)) return;
 HEAP32[$8 >> 2] = $node;
 return;
}

function _calloc($n_elements, $elem_size) {
 $n_elements = $n_elements | 0;
 $elem_size = $elem_size | 0;
 var $1 = 0, $6 = 0, $req$0 = 0;
 if (!$n_elements) $req$0 = 0; else {
  $1 = Math_imul($elem_size, $n_elements) | 0;
  if (($elem_size | $n_elements) >>> 0 > 65535) $req$0 = (($1 >>> 0) / ($n_elements >>> 0) | 0 | 0) == ($elem_size | 0) ? $1 : -1; else $req$0 = $1;
 }
 $6 = _malloc($req$0) | 0;
 if (!$6) return $6 | 0;
 if (!(HEAP32[$6 + -4 >> 2] & 3)) return $6 | 0;
 _memset($6 | 0, 0, $req$0 | 0) | 0;
 return $6 | 0;
}

function ___muldi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $x_sroa_0_0_extract_trunc = 0, $y_sroa_0_0_extract_trunc = 0, $1$0 = 0, $1$1 = 0;
 $x_sroa_0_0_extract_trunc = $a$0;
 $y_sroa_0_0_extract_trunc = $b$0;
 $1$0 = ___muldsi3($x_sroa_0_0_extract_trunc, $y_sroa_0_0_extract_trunc) | 0;
 $1$1 = tempRet0;
 return (tempRet0 = (Math_imul($a$1, $y_sroa_0_0_extract_trunc) | 0) + (Math_imul($b$1, $x_sroa_0_0_extract_trunc) | 0) + $1$1 | $1$1 & 0, $1$0 | 0 | 0) | 0;
}

function _prvTidyFixXhtmlNamespace($doc, $wantXmlns) {
 $doc = $doc | 0;
 $wantXmlns = $wantXmlns | 0;
 var $0 = 0, $2 = 0, $4 = 0, $6 = 0;
 $0 = _prvTidyFindHTML($doc) | 0;
 if (!$0) return;
 $2 = _prvTidyAttrGetById($0, 163) | 0;
 $4 = ($2 | 0) != 0;
 if (!$wantXmlns) {
  if (!$4) return;
  _prvTidyRemoveAttribute($doc, $0, $2);
  return;
 }
 if ($4) {
  $6 = HEAP32[$2 + 24 >> 2] | 0;
  if ($6 | 0) if (!(_prvTidytmbstrcasecmp($6, 311626) | 0)) return;
 }
 _prvTidyRepairAttrValue($doc, $0, 311466, 311626) | 0;
 return;
}

function _prvTidySplitSurrogatePair($utf16, $low, $high) {
 $utf16 = $utf16 | 0;
 $low = $low | 0;
 $high = $high | 0;
 var $$ = 0, $13 = 0, $7 = 0, $8 = 0;
 if ($utf16 >>> 0 < 65536 | ($utf16 & 65534 | 0) == 65534) {
  $13 = 0;
  return $13 | 0;
 }
 $$ = ($low | 0) != 0 & (($utf16 & 65535 | 0) != 65535 & ($high | 0) != 0);
 $7 = $$ & 1;
 if (!$$) {
  $13 = $7;
  return $13 | 0;
 }
 $8 = $utf16 + -65536 | 0;
 HEAP32[$low >> 2] = ($8 >>> 10) + 55296;
 HEAP32[$high >> 2] = $8 & 1023 | 56320;
 $13 = $7;
 return $13 | 0;
}

function _messageLexer($doc, $level, $code, $msg, $varargs) {
 $doc = $doc | 0;
 $level = $level | 0;
 $code = $code | 0;
 $msg = $msg | 0;
 $varargs = $varargs | 0;
 var $1 = 0, $6 = 0, $7 = 0, $args = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $args = sp;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 if (!$1) {
  $6 = 0;
  $7 = 0;
 } else {
  $6 = HEAP32[$1 >> 2] | 0;
  $7 = HEAP32[$1 + 4 >> 2] | 0;
 }
 HEAP32[$args >> 2] = $varargs;
 _messagePos($doc, 1, $code, $6, $7, $msg, $args);
 STACKTOP = sp;
 return;
}

function _prvTidyGeneralInfo($doc) {
 $doc = $doc | 0;
 var $vararg_buffer = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 if (!(HEAP32[$doc + 140 >> 2] | 0)) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$vararg_buffer >> 2] = _tidyLocalizedString(2075) | 0;
 _tidy_out($doc, 223602, $vararg_buffer);
 HEAP32[$vararg_buffer1 >> 2] = _tidyLocalizedString(2076) | 0;
 _tidy_out($doc, 223602, $vararg_buffer1);
 STACKTOP = sp;
 return;
}

function _prvTidyFindXmlDecl($doc) {
 $doc = $doc | 0;
 var $2 = 0, $node$0$lcssa = 0, $node$01 = 0;
 L1 : do if (!$doc) $node$0$lcssa = 0; else {
  $2 = HEAP32[$doc + 12 >> 2] | 0;
  if (!$2) $node$0$lcssa = 0; else {
   $node$01 = $2;
   while (1) {
    if ((HEAP32[$node$01 + 44 >> 2] | 0) == 13) {
     $node$0$lcssa = $node$01;
     break L1;
    }
    $node$01 = HEAP32[$node$01 + 8 >> 2] | 0;
    if (!$node$01) {
     $node$0$lcssa = 0;
     break;
    }
   }
  }
 } while (0);
 return $node$0$lcssa | 0;
}

function _prvTidyFindDocType($doc) {
 $doc = $doc | 0;
 var $2 = 0, $node$0$lcssa = 0, $node$01 = 0;
 L1 : do if (!$doc) $node$0$lcssa = 0; else {
  $2 = HEAP32[$doc + 12 >> 2] | 0;
  if (!$2) $node$0$lcssa = 0; else {
   $node$01 = $2;
   while (1) {
    if ((HEAP32[$node$01 + 44 >> 2] | 0) == 1) {
     $node$0$lcssa = $node$01;
     break L1;
    }
    $node$01 = HEAP32[$node$01 + 8 >> 2] | 0;
    if (!$node$01) {
     $node$0$lcssa = 0;
     break;
    }
   }
  }
 } while (0);
 return $node$0$lcssa | 0;
}

function _prvTidyDropComments($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$01 = 0, $8 = 0, $$01$looptemp = 0;
 if (!$node) return; else $$01 = $node;
 do {
  $$01$looptemp = $$01;
  $$01 = HEAP32[$$01 + 8 >> 2] | 0;
  if ((HEAP32[$$01$looptemp + 44 >> 2] | 0) == 2) {
   _prvTidyRemoveNode($$01$looptemp) | 0;
   _prvTidyFreeNode($doc, $$01$looptemp);
  } else {
   $8 = HEAP32[$$01$looptemp + 12 >> 2] | 0;
   if ($8 | 0) _prvTidyDropComments($doc, $8);
  }
 } while (($$01 | 0) != 0);
 return;
}

function _prvTidyGetEncodingNameFromTidyId($id) {
 $id = $id | 0;
 var $$0 = 0;
 if (($id | 0) == 1) $$0 = 226067; else if (($id | 0) == 2) $$0 = 226076; else if (($id | 0) == 3) $$0 = 226088; else if (($id | 0) == 4) $$0 = 226099; else if (($id | 0) == 6) $$0 = 226105; else if (($id | 0) == 7) $$0 = 226115; else if (($id | 0) == 8) $$0 = 226128; else if (($id + -9 | 0) >>> 0 < 3) $$0 = 226142; else if (($id | 0) == 12) $$0 = 226137; else return (($id | 0) == 13 ? 226149 : 0) | 0;
 return $$0 | 0;
}

function ___towrite($f) {
 $f = $f | 0;
 var $$0 = 0, $0 = 0, $13 = 0, $2 = 0, $6 = 0;
 $0 = $f + 74 | 0;
 $2 = HEAP8[$0 >> 0] | 0;
 HEAP8[$0 >> 0] = $2 + 255 | $2;
 $6 = HEAP32[$f >> 2] | 0;
 if (!($6 & 8)) {
  HEAP32[$f + 8 >> 2] = 0;
  HEAP32[$f + 4 >> 2] = 0;
  $13 = HEAP32[$f + 44 >> 2] | 0;
  HEAP32[$f + 28 >> 2] = $13;
  HEAP32[$f + 20 >> 2] = $13;
  HEAP32[$f + 16 >> 2] = $13 + (HEAP32[$f + 48 >> 2] | 0);
  $$0 = 0;
 } else {
  HEAP32[$f >> 2] = $6 | 32;
  $$0 = -1;
 }
 return $$0 | 0;
}

function _vsscanf($s, $fmt, $ap) {
 $s = $s | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 var $4 = 0, $f = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $f = sp;
 dest = $f;
 stop = dest + 112 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 HEAP32[$f + 32 >> 2] = 8;
 HEAP32[$f + 44 >> 2] = $s;
 HEAP32[$f + 76 >> 2] = -1;
 HEAP32[$f + 84 >> 2] = $s;
 $4 = _vfscanf($f, $fmt, $ap) | 0;
 STACKTOP = sp;
 return $4 | 0;
}

function _tidyBufFree($buf) {
 $buf = $buf | 0;
 var $1 = 0, $7 = 0;
 if (!$buf) ___assert_fail(225860, 225754, 86, 225912); else {
  $1 = HEAP32[$buf >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$1 >> 2] | 0) + 8 >> 2] & 15]($1, HEAP32[$buf + 4 >> 2] | 0);
  $7 = HEAP32[$buf >> 2] | 0;
  HEAP32[$buf >> 2] = 0;
  HEAP32[$buf + 4 >> 2] = 0;
  HEAP32[$buf + 8 >> 2] = 0;
  HEAP32[$buf + 12 >> 2] = 0;
  HEAP32[$buf + 16 >> 2] = 0;
  HEAP32[$buf >> 2] = $7 | 0 ? $7 : 66204;
  return;
 }
}

function _prvTidyIsBlank($lexer, $node) {
 $lexer = $lexer | 0;
 $node = $node | 0;
 var $15 = 0, $3 = 0, $5 = 0, $isBlank$0 = 0;
 if (!(_prvTidynodeIsText($node) | 0)) {
  $isBlank$0 = 0;
  return $isBlank$0 | 0;
 }
 $3 = HEAP32[$node + 40 >> 2] | 0;
 $5 = HEAP32[$node + 36 >> 2] | 0;
 if (($3 | 0) == ($5 | 0)) $15 = 1; else if (($3 | 0) == ($5 + 1 | 0)) $15 = (HEAP8[(HEAP32[$lexer + 84 >> 2] | 0) + $5 >> 0] | 0) == 32; else $15 = 0;
 $isBlank$0 = $15 & 1;
 return $isBlank$0 | 0;
}

function _prvTidyGetUTF8($str, $ch) {
 $str = $str | 0;
 $ch = $ch | 0;
 var $5 = 0, $bytes = 0, $n = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $n = sp + 4 | 0;
 $bytes = sp;
 HEAP32[$bytes >> 2] = 0;
 if (!(_prvTidyDecodeUTF8BytesToChar($n, HEAP8[$str >> 0] | 0, $str + 1 | 0, 0, $bytes) | 0)) $5 = HEAP32[$n >> 2] | 0; else {
  HEAP32[$n >> 2] = 65533;
  $5 = 65533;
 }
 HEAP32[$ch >> 2] = $5;
 STACKTOP = sp;
 return (HEAP32[$bytes >> 2] | 0) + -1 | 0;
}

function copyTempDouble(ptr) {
 ptr = ptr | 0;
 HEAP8[tempDoublePtr >> 0] = HEAP8[ptr >> 0];
 HEAP8[tempDoublePtr + 1 >> 0] = HEAP8[ptr + 1 >> 0];
 HEAP8[tempDoublePtr + 2 >> 0] = HEAP8[ptr + 2 >> 0];
 HEAP8[tempDoublePtr + 3 >> 0] = HEAP8[ptr + 3 >> 0];
 HEAP8[tempDoublePtr + 4 >> 0] = HEAP8[ptr + 4 >> 0];
 HEAP8[tempDoublePtr + 5 >> 0] = HEAP8[ptr + 5 >> 0];
 HEAP8[tempDoublePtr + 6 >> 0] = HEAP8[ptr + 6 >> 0];
 HEAP8[tempDoublePtr + 7 >> 0] = HEAP8[ptr + 7 >> 0];
}

function _prvTidyReportEntityError($doc, $code, $entity, $c) {
 $doc = $doc | 0;
 $code = $code | 0;
 $entity = $entity | 0;
 $c = $c | 0;
 var $0 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = _tidyLocalizedString($code) | 0;
 if (!$0) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$vararg_buffer >> 2] = $entity | 0 ? $entity : 223540;
 _messageLexer($doc, 0, $code, $0, $vararg_buffer);
 STACKTOP = sp;
 return;
}

function _prvTidyReportAccessWarning($doc, $node, $code) {
 $doc = $doc | 0;
 $node = $node | 0;
 $code = $code | 0;
 var $0 = 0, $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = _tidyLocalizedString($code) | 0;
 $1 = $doc + 6836 | 0;
 HEAP32[$1 >> 2] = HEAP32[$1 >> 2] | -2147483648;
 HEAP32[$vararg_buffer >> 2] = $0;
 _messageNode($doc, 3, $code, $node, 223602, $vararg_buffer);
 STACKTOP = sp;
 return;
}

function _prvTidyReportAccessError($doc, $node, $code) {
 $doc = $doc | 0;
 $node = $node | 0;
 $code = $code | 0;
 var $0 = 0, $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = _tidyLocalizedString($code) | 0;
 $1 = $doc + 6836 | 0;
 HEAP32[$1 >> 2] = HEAP32[$1 >> 2] | -2147483648;
 HEAP32[$vararg_buffer >> 2] = $0;
 _messageNode($doc, 3, $code, $node, 223602, $vararg_buffer);
 STACKTOP = sp;
 return;
}

function _stringWithFormat($fmt, $varargs) {
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $1 = 0, $2 = 0, $argList = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $argList = sp;
 HEAP32[$argList >> 2] = $varargs;
 $1 = (_vsnprintf(0, 0, $fmt, $argList) | 0) + 1 | 0;
 $2 = _malloc($1) | 0;
 if (!$2) _outOfMemory(); else {
  HEAP32[$argList >> 2] = $varargs;
  _vsnprintf($2, $1, $fmt, $argList) | 0;
  STACKTOP = sp;
  return $2 | 0;
 }
 return 0;
}

function _prvTidyFindTag($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0 = 0, $10 = 0, $7 = 0;
 if (HEAP32[$doc + 168 >> 2] | 0) {
  HEAP32[$node + 28 >> 2] = HEAP32[$doc + 876 >> 2];
  $$0 = 1;
  return $$0 | 0;
 }
 $7 = HEAP32[$node + 32 >> 2] | 0;
 if (!$7) {
  $$0 = 0;
  return $$0 | 0;
 }
 $10 = _tagsLookup($doc, $doc + 876 | 0, $7) | 0;
 if (!$10) {
  $$0 = 0;
  return $$0 | 0;
 }
 HEAP32[$node + 28 >> 2] = $10;
 $$0 = 1;
 return $$0 | 0;
}

function _prvTidyConvertCDATANodes($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$01 = 0, $3 = 0, $7 = 0, $$01$looptemp = 0;
 if (!$node) return; else $$01 = $node;
 do {
  $$01$looptemp = $$01;
  $$01 = HEAP32[$$01 + 8 >> 2] | 0;
  $3 = $$01$looptemp + 44 | 0;
  if ((HEAP32[$3 >> 2] | 0) == 8) HEAP32[$3 >> 2] = 4;
  $7 = HEAP32[$$01$looptemp + 12 >> 2] | 0;
  if ($7 | 0) _prvTidyConvertCDATANodes($doc, $7);
 } while (($$01 | 0) != 0);
 return;
}

function _prvTidyFindContainer($node) {
 $node = $node | 0;
 var $$0$lcssa = 0, $$01 = 0, $1 = 0;
 L1 : do if (!$node) $$0$lcssa = 0; else {
  $1 = HEAP32[$node >> 2] | 0;
  if (!$1) $$0$lcssa = 0; else {
   $$01 = $1;
   while (1) {
    if (!(_prvTidynodeHasCM($$01, 16) | 0)) {
     $$0$lcssa = $$01;
     break L1;
    }
    $$01 = HEAP32[$$01 >> 2] | 0;
    if (!$$01) {
     $$0$lcssa = 0;
     break;
    }
   }
  }
 } while (0);
 return $$0$lcssa | 0;
}

function _prvTidyParseEmpty($doc, $element, $mode) {
 $doc = $doc | 0;
 $element = $element | 0;
 $mode = $mode | 0;
 var $5 = 0;
 if (!(HEAP32[(HEAP32[$doc + 68 >> 2] | 0) + 28 >> 2] | 0)) return;
 $5 = _prvTidyGetToken($doc, $mode) | 0;
 if (!$5) return;
 if ((HEAP32[$5 + 44 >> 2] | 0) == 6) if ((HEAP32[$5 + 28 >> 2] | 0) == (HEAP32[$element + 28 >> 2] | 0)) {
  _prvTidyFreeNode($doc, $5);
  return;
 }
 _prvTidyUngetToken($doc);
 return;
}

function _defaultPanic($allocator, $msg) {
 $allocator = $allocator | 0;
 $msg = $msg | 0;
 var $0 = 0, $2 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[79251] | 0;
 if (!$0) {
  $2 = HEAP32[55027] | 0;
  HEAP32[$vararg_buffer >> 2] = $msg;
  _fprintf($2, 311663, $vararg_buffer) | 0;
  _exit(2);
 } else {
  FUNCTION_TABLE_vi[$0 & 3]($msg);
  STACKTOP = sp;
  return;
 }
}

function _prvTidyIsValidHTMLID($id) {
 $id = $id | 0;
 var $$0 = 0, $1 = 0, $s$0 = 0, label = 0;
 if (!$id) {
  $$0 = 0;
  return $$0 | 0;
 } else $s$0 = $id;
 while (1) {
  $1 = HEAP8[$s$0 >> 0] | 0;
  if (!($1 << 24 >> 24)) {
   $$0 = 1;
   label = 4;
   break;
  }
  if (!(_prvTidyIsHTMLSpace($1 << 24 >> 24) | 0)) $s$0 = $s$0 + 1 | 0; else {
   $$0 = 0;
   label = 4;
   break;
  }
 }
 if ((label | 0) == 4) return $$0 | 0;
 return 0;
}

function ___muldsi3($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $1 = 0, $2 = 0, $3 = 0, $6 = 0, $8 = 0, $11 = 0, $12 = 0;
 $1 = $a & 65535;
 $2 = $b & 65535;
 $3 = Math_imul($2, $1) | 0;
 $6 = $a >>> 16;
 $8 = ($3 >>> 16) + (Math_imul($2, $6) | 0) | 0;
 $11 = $b >>> 16;
 $12 = Math_imul($11, $1) | 0;
 return (tempRet0 = ($8 >>> 16) + (Math_imul($11, $6) | 0) + ((($8 & 65535) + $12 | 0) >>> 16) | 0, $8 + $12 << 16 | $3 & 65535 | 0) | 0;
}

function _prvTidyfreeFileSource($inp, $closeIt) {
 $inp = $inp | 0;
 $closeIt = $closeIt | 0;
 var $3 = 0, $8 = 0;
 if ((HEAP32[$inp + 4 >> 2] | 0) == 13) {
  $3 = HEAP32[$inp >> 2] | 0;
  ___munmap(HEAP32[$3 + 4 >> 2] | 0, HEAP32[$3 + 12 >> 2] | 0) | 0;
  $8 = HEAP32[$3 >> 2] | 0;
  FUNCTION_TABLE_vii[HEAP32[(HEAP32[$8 >> 2] | 0) + 8 >> 2] & 15]($8, $3);
  return;
 } else {
  _prvTidyfreeStdIOFileSource($inp, $closeIt);
  return;
 }
}

function _message($doc, $level, $code, $msg, $varargs) {
 $doc = $doc | 0;
 $level = $level | 0;
 $code = $code | 0;
 $msg = $msg | 0;
 $varargs = $varargs | 0;
 var $args = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $args = sp;
 if (!$level) if (!(HEAP32[$doc + 140 >> 2] | 0)) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$args >> 2] = $varargs;
 _messagePos($doc, $level, $code, 0, 0, $msg, $args);
 STACKTOP = sp;
 return;
}

function _tidySaveStdout($tdoc) {
 $tdoc = $tdoc | 0;
 var $4 = 0, $5 = 0, $6 = 0, $9 = 0;
 $4 = HEAP32[55056] | 0;
 $5 = _prvTidyFileOutput($tdoc, $4, HEAP32[$tdoc + 96 >> 2] | 0, HEAP32[$tdoc + 100 >> 2] | 0) | 0;
 $6 = _tidyDocSaveStream($tdoc, $5) | 0;
 _fflush($4) | 0;
 _fflush(HEAP32[55027] | 0) | 0;
 $9 = HEAP32[$tdoc + 6856 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$9 >> 2] | 0) + 8 >> 2] & 15]($9, $5);
 return $6 | 0;
}

function _prvTidyIsAnchorElement($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0 = 0, $2 = 0;
 L1 : do if ($node | 0) {
  $2 = HEAP32[$node + 28 >> 2] | 0;
  if ($2 | 0) {
   switch (HEAP32[$2 >> 2] | 0) {
   case 1:
   case 6:
   case 37:
   case 38:
   case 50:
   case 52:
   case 64:
    {
     $$0 = 1;
     break;
    }
   default:
    break L1;
   }
   return $$0 | 0;
  }
 } while (0);
 $$0 = 0;
 return $$0 | 0;
}

function _prvTidytmbsnprintf($buffer, $count, $format, $varargs) {
 $buffer = $buffer | 0;
 $count = $count | 0;
 $format = $format | 0;
 $varargs = $varargs | 0;
 var $0 = 0, $1 = 0, $args = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $args = sp;
 HEAP32[$args >> 2] = $varargs;
 $0 = $count + -1 | 0;
 $1 = _vsnprintf($buffer, $0, $format, $args) | 0;
 HEAP8[$buffer + $0 >> 0] = 0;
 STACKTOP = sp;
 return $1 | 0;
}

function _prvTidyReportUnknownOption($doc, $option) {
 $doc = $doc | 0;
 $option = $option | 0;
 var $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 if (!$option) ___assert_fail(223376, 223391, 439, 223481); else {
  $1 = _tidyLocalizedString(2068) | 0;
  HEAP32[$vararg_buffer >> 2] = $option;
  _message($doc, 2, 2068, $1, $vararg_buffer);
  STACKTOP = sp;
  return;
 }
}

function _tidyOptGetNextDocLinks($tdoc, $pos) {
 $tdoc = $tdoc | 0;
 $pos = $pos | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $3 = 0, $4 = 0, $storemerge = 0;
 $0 = HEAP32[$pos >> 2] | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) {
  $$0 = 0;
  $storemerge = 0;
 } else {
  $3 = _prvTidygetOption($1) | 0;
  $4 = $0 + 4 | 0;
  $$0 = $3;
  $storemerge = (HEAP32[$4 >> 2] | 0) == 0 ? 0 : $4;
 }
 HEAP32[$pos >> 2] = $storemerge;
 return $$0 | 0;
}

function _prvTidyReportBadArgument($doc, $option) {
 $doc = $doc | 0;
 $option = $option | 0;
 var $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 if (!$option) ___assert_fail(223376, 223391, 446, 223508); else {
  $1 = _tidyLocalizedString(2060) | 0;
  HEAP32[$vararg_buffer >> 2] = $option;
  _message($doc, 2, 2060, $1, $vararg_buffer);
  STACKTOP = sp;
  return;
 }
}

function _prvTidyInsertAttributeAtEnd($node, $av) {
 $node = $node | 0;
 $av = $av | 0;
 var $$lcssa = 0, $0 = 0, $1 = 0, $3 = 0, $here$0$i = 0;
 $0 = $node + 20 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) {
  HEAP32[$0 >> 2] = $av;
  return;
 } else $here$0$i = $1;
 while (1) {
  $3 = HEAP32[$here$0$i >> 2] | 0;
  if (!$3) {
   $$lcssa = $here$0$i;
   break;
  } else $here$0$i = $3;
 }
 HEAP32[$$lcssa >> 2] = $av;
 return;
}

function _copysign($x, $y) {
 $x = +$x;
 $y = +$y;
 var $1 = 0, $5 = 0, $fabs = 0.0;
 HEAPF64[tempDoublePtr >> 3] = $y;
 $1 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $fabs = +Math_abs(+$x);
 HEAPF64[tempDoublePtr >> 3] = $fabs;
 $5 = $1 & -2147483648 | HEAP32[tempDoublePtr + 4 >> 2];
 HEAP32[tempDoublePtr >> 2] = HEAP32[tempDoublePtr >> 2];
 HEAP32[tempDoublePtr + 4 >> 2] = $5;
 return +(+HEAPF64[tempDoublePtr >> 3]);
}

function _prvTidyfreeStdIOFileSource($inp, $closeIt) {
 $inp = $inp | 0;
 $closeIt = $closeIt | 0;
 var $0 = 0, $3 = 0, $5 = 0, $6 = 0;
 $0 = HEAP32[$inp >> 2] | 0;
 if (($closeIt | 0) != 0 & ($0 | 0) != 0) {
  $3 = HEAP32[$0 >> 2] | 0;
  if ($3 | 0) _fclose($3) | 0;
 }
 $5 = $0 + 4 | 0;
 _tidyBufFree($5);
 $6 = HEAP32[$5 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$6 >> 2] | 0) + 8 >> 2] & 15]($6, $0);
 return;
}

function _CheckHTML($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $1 = 0, $attval$01$i = 0, $attval$01$i$looptemp = 0;
 $1 = HEAP32[$node + 20 >> 2] | 0;
 if (!$1) return; else $attval$01$i = $1;
 do {
  $attval$01$i$looptemp = $attval$01$i;
  $attval$01$i = HEAP32[$attval$01$i >> 2] | 0;
  _prvTidyCheckAttribute($doc, $node, $attval$01$i$looptemp) | 0;
 } while (($attval$01$i | 0) != 0);
 return;
}

function ___uflow($f) {
 $f = $f | 0;
 var $$0 = 0, $c = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 if (!(HEAP32[$f + 8 >> 2] | 0)) if (!(___toread($f) | 0)) label = 3; else $$0 = -1; else label = 3;
 if ((label | 0) == 3) if ((FUNCTION_TABLE_iiii[HEAP32[$f + 32 >> 2] & 15]($f, $c, 1) | 0) == 1) $$0 = HEAPU8[$c >> 0] | 0; else $$0 = -1;
 STACKTOP = sp;
 return $$0 | 0;
}

function _prvTidyCheckAttributes($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $1 = 0, $attval$01 = 0, $attval$01$looptemp = 0;
 $1 = HEAP32[$node + 20 >> 2] | 0;
 if (!$1) return; else $attval$01 = $1;
 do {
  $attval$01$looptemp = $attval$01;
  $attval$01 = HEAP32[$attval$01 >> 2] | 0;
  _prvTidyCheckAttribute($doc, $node, $attval$01$looptemp) | 0;
 } while (($attval$01 | 0) != 0);
 return;
}

function _prvTidyAddStyleAsClass($doc, $node, $stylevalue) {
 $doc = $doc | 0;
 $node = $node | 0;
 $stylevalue = $stylevalue | 0;
 var $2 = 0, $3 = 0;
 $2 = _FindStyle($doc, HEAP32[$node + 32 >> 2] | 0, $stylevalue) | 0;
 $3 = _prvTidyAttrGetById($node, 26) | 0;
 if (!$3) {
  _prvTidyAddAttribute($doc, $node, 310945, $2) | 0;
  return;
 } else {
  _prvTidyAppendToClassAttr($doc, $3, $2);
  return;
 }
}

function _prvTidyReportNumWarnings($doc) {
 $doc = $doc | 0;
 var $0 = 0, $4 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[55027] | 0;
 $4 = HEAP32[$doc + 6816 >> 2] | 0;
 HEAP32[$vararg_buffer >> 2] = HEAP32[$doc + 6812 >> 2];
 HEAP32[$vararg_buffer + 4 >> 2] = $4;
 _fprintf($0, 223721, $vararg_buffer) | 0;
 STACKTOP = sp;
 return;
}

function _prvTidyPFlushLine($doc, $indent) {
 $doc = $doc | 0;
 $indent = $indent | 0;
 var $5 = 0, $8 = 0;
 if (HEAP32[$doc + 6736 >> 2] | 0) _PFlushLineImpl($doc);
 _prvTidyWriteChar(10, HEAP32[$doc + 6780 >> 2] | 0);
 $5 = $doc + 6744 | 0;
 HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + 1;
 $8 = $doc + 6752 | 0;
 if ((HEAP32[$8 >> 2] | 0) == ($indent | 0)) return;
 HEAP32[$8 >> 2] = $indent;
 return;
}

function _prvTidyInsertNodeAtEnd($element, $node) {
 $element = $element | 0;
 $node = $node | 0;
 var $0 = 0, $1 = 0;
 HEAP32[$node >> 2] = $element;
 $0 = $element + 16 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 HEAP32[$node + 4 >> 2] = $1;
 if (!$1) {
  HEAP32[$element + 12 >> 2] = $node;
  HEAP32[$0 >> 2] = $node;
  return;
 } else {
  HEAP32[$1 + 8 >> 2] = $node;
  HEAP32[$0 >> 2] = $node;
  return;
 }
}

function _prvTidygetNextOption($doc, $iter) {
 $doc = $doc | 0;
 $iter = $iter | 0;
 var $1 = 0, $2 = 0, $optId$0 = 0;
 if (!$iter) ___assert_fail(298444, 223800, 1603, 225652); else {
  $1 = HEAP32[$iter >> 2] | 0;
  $2 = ($1 + -1 | 0) >>> 0 < 97;
  $optId$0 = ($2 & 1) + $1 | 0;
  HEAP32[$iter >> 2] = $optId$0 >>> 0 < 98 ? $optId$0 : 0;
  return ($2 ? 1892 + ($1 << 5) | 0 : 0) | 0;
 }
 return 0;
}

function ___munmap($start, $len) {
 $start = $start | 0;
 $len = $len | 0;
 var $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 _dummy1(-1);
 HEAP32[$vararg_buffer >> 2] = $start;
 HEAP32[$vararg_buffer + 4 >> 2] = $len;
 $1 = ___syscall_ret(___syscall91(91, $vararg_buffer | 0) | 0) | 0;
 _dummy0();
 STACKTOP = sp;
 return $1 | 0;
}

function _prvTidylookupOption($s) {
 $s = $s | 0;
 var $$0 = 0, $np$01 = 0, label = 0;
 $np$01 = 1892;
 while (1) {
  if (!(_prvTidytmbstrcasecmp($s, HEAP32[$np$01 + 8 >> 2] | 0) | 0)) {
   $$0 = $np$01;
   label = 4;
   break;
  }
  $np$01 = $np$01 + 32 | 0;
  if ($np$01 >>> 0 >= 5028 >>> 0) {
   $$0 = 0;
   label = 4;
   break;
  }
 }
 if ((label | 0) == 4) return $$0 | 0;
 return 0;
}

function ___uremdi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $rem = 0, __stackBase__ = 0;
 __stackBase__ = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $rem = __stackBase__ | 0;
 ___udivmoddi4($a$0, $a$1, $b$0, $b$1, $rem) | 0;
 STACKTOP = __stackBase__;
 return (tempRet0 = HEAP32[$rem + 4 >> 2] | 0, HEAP32[$rem >> 2] | 0) | 0;
}

function _CheckLINK($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $1 = 0, $3 = 0, $5 = 0;
 $1 = (_prvTidyAttrGetById($node, 59) | 0) == 0;
 $3 = (_prvTidyAttrGetById($node, 122) | 0) != 0;
 $5 = (_prvTidyAttrGetById($node, 66) | 0) != 0;
 if ($1) _prvTidyReportMissingAttr($doc, $node, 308129);
 if ($3 | $5) return;
 _prvTidyReportMissingAttr($doc, $node, 308379);
 return;
}

function _tidySetCharEncoding($tdoc, $encnam) {
 $tdoc = $tdoc | 0;
 $encnam = $encnam | 0;
 var $$1 = 0, $1 = 0;
 if (!$tdoc) {
  $$1 = -22;
  return $$1 | 0;
 }
 $1 = _prvTidyCharEncodingId($tdoc, $encnam) | 0;
 if (($1 | 0) > -1) if (_prvTidyAdjustCharEncoding($tdoc, $1) | 0) {
  $$1 = 0;
  return $$1 | 0;
 }
 _prvTidyReportBadArgument($tdoc, 226560);
 $$1 = -22;
 return $$1 | 0;
}

function _CleanTree($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $1 = 0, $3 = 0, $child$01 = 0;
 $1 = HEAP32[$node + 12 >> 2] | 0;
 L1 : do if ($1 | 0) {
  $child$01 = $1;
  do {
   $3 = _CleanTree($doc, $child$01) | 0;
   if (!$3) break L1;
   $child$01 = HEAP32[$3 + 8 >> 2] | 0;
  } while (($child$01 | 0) != 0);
 } while (0);
 return _CleanNode_1662($doc, $node) | 0;
}

function _prvTidytmbstrlen($str) {
 $str = $str | 0;
 var $$01 = 0, $4 = 0, $len$02 = 0, $len$1 = 0;
 if (!$str) $len$1 = 0; else if (!(HEAP8[$str >> 0] | 0)) $len$1 = 0; else {
  $$01 = $str;
  $len$02 = 0;
  while (1) {
   $$01 = $$01 + 1 | 0;
   $4 = $len$02 + 1 | 0;
   if (!(HEAP8[$$01 >> 0] | 0)) {
    $len$1 = $4;
    break;
   } else $len$02 = $4;
  }
 }
 return $len$1 | 0;
}

function _prvTidyNewAttribute($doc) {
 $doc = $doc | 0;
 var $1 = 0, $4 = 0;
 $1 = HEAP32[$doc + 6856 >> 2] | 0;
 $4 = FUNCTION_TABLE_iii[HEAP32[HEAP32[$1 >> 2] >> 2] & 31]($1, 28) | 0;
 HEAP32[$4 >> 2] = 0;
 HEAP32[$4 + 4 >> 2] = 0;
 HEAP32[$4 + 8 >> 2] = 0;
 HEAP32[$4 + 12 >> 2] = 0;
 HEAP32[$4 + 16 >> 2] = 0;
 HEAP32[$4 + 20 >> 2] = 0;
 HEAP32[$4 + 24 >> 2] = 0;
 return $4 | 0;
}

function _CheckLang($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 var $5 = 0;
 if ($attval | 0) {
  if (HEAP32[$attval + 24 >> 2] | 0) return;
  $5 = HEAP32[$attval + 4 >> 2] | 0;
  if ($5 | 0) if ((HEAP32[$5 >> 2] | 0) == 161) return;
 }
 if (HEAP32[$doc + 408 >> 2] | 0) return;
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 return;
}

function _tidyBufInitWithAllocator($buf, $allocator) {
 $buf = $buf | 0;
 $allocator = $allocator | 0;
 if (!$buf) ___assert_fail(225860, 225754, 70, 225887); else {
  HEAP32[$buf >> 2] = 0;
  HEAP32[$buf + 4 >> 2] = 0;
  HEAP32[$buf + 8 >> 2] = 0;
  HEAP32[$buf + 12 >> 2] = 0;
  HEAP32[$buf + 16 >> 2] = 0;
  HEAP32[$buf >> 2] = $allocator | 0 ? $allocator : 66204;
  return;
 }
}

function _prvTidyInsertNodeAtStart($element, $node) {
 $element = $element | 0;
 $node = $node | 0;
 var $0 = 0, $1 = 0;
 HEAP32[$node >> 2] = $element;
 $0 = $element + 12 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) HEAP32[$element + 16 >> 2] = $node; else HEAP32[$1 + 4 >> 2] = $node;
 HEAP32[$node + 8 >> 2] = $1;
 HEAP32[$node + 4 >> 2] = 0;
 HEAP32[$0 >> 2] = $node;
 return;
}

function _prvTidyLookupTagDef($tid) {
 $tid = $tid | 0;
 var $$0 = 0, $np$01 = 0, label = 0;
 $np$01 = 58824;
 while (1) {
  if ((HEAP32[$np$01 >> 2] | 0) == ($tid | 0)) {
   $$0 = $np$01;
   label = 4;
   break;
  }
  $np$01 = $np$01 + 32 | 0;
  if ($np$01 >>> 0 >= 63624 >>> 0) {
   $$0 = 0;
   label = 4;
   break;
  }
 }
 if ((label | 0) == 4) return $$0 | 0;
 return 0;
}

function _prvTidyReleaseStreamOut($doc, $out) {
 $doc = $doc | 0;
 $out = $out | 0;
 var $9 = 0;
 if (!(($out | 0) != 5260 & (($out | 0) != 0 & ($out | 0) != 5236))) return;
 if (!(HEAP32[$out + 12 >> 2] | 0)) _fclose(HEAP32[$out + 16 >> 2] | 0) | 0;
 $9 = HEAP32[$doc + 6856 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$9 >> 2] | 0) + 8 >> 2] & 15]($9, $out);
 return;
}

function _prvTidyFileError($doc, $file, $level) {
 $doc = $doc | 0;
 $file = $file | 0;
 $level = $level | 0;
 var $0 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = _tidyLocalizedString(2050) | 0;
 HEAP32[$vararg_buffer >> 2] = $file;
 _message($doc, $level, 2050, $0, $vararg_buffer);
 STACKTOP = sp;
 return;
}

function _llvm_cttz_i32(x) {
 x = x | 0;
 var ret = 0;
 ret = HEAP8[cttz_i8 + (x & 255) >> 0] | 0;
 if ((ret | 0) < 8) return ret | 0;
 ret = HEAP8[cttz_i8 + (x >> 8 & 255) >> 0] | 0;
 if ((ret | 0) < 8) return ret + 8 | 0;
 ret = HEAP8[cttz_i8 + (x >> 16 & 255) >> 0] | 0;
 if ((ret | 0) < 8) return ret + 16 | 0;
 return (HEAP8[cttz_i8 + (x >>> 24) >> 0] | 0) + 24 | 0;
}

function _prvTidyPrintBody($doc) {
 $doc = $doc | 0;
 var $0 = 0, $node$01 = 0, $node$02 = 0;
 $0 = _prvTidyFindBody($doc) | 0;
 if (!$0) return;
 $node$01 = HEAP32[$0 + 12 >> 2] | 0;
 if (!$node$01) return; else $node$02 = $node$01;
 do {
  _prvTidyPPrintTree($doc, 0, 0, $node$02);
  $node$02 = HEAP32[$node$02 + 8 >> 2] | 0;
 } while (($node$02 | 0) != 0);
 return;
}

function _prvTidyInlineDup($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $1 = 0, $5 = 0, $6 = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $5 = HEAP32[$1 + 116 >> 2] | 0;
 $6 = (HEAP32[$1 + 112 >> 2] | 0) - $5 | 0;
 if (($6 | 0) <= 0) return $6 | 0;
 HEAP32[$1 + 100 >> 2] = (HEAP32[$1 + 104 >> 2] | 0) + ($5 << 4);
 HEAP32[$1 + 96 >> 2] = $node;
 return $6 | 0;
}

function _prvTidyApparentVersion($doc) {
 $doc = $doc | 0;
 var $$0 = 0, $1 = 0, $3 = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 $3 = HEAP32[$1 + 36 >> 2] | 0;
 switch ($3 | 0) {
 case 4096:
 case 2048:
  {
   if ($3 & HEAP32[$1 + 32 >> 2] | 0) {
    $$0 = $3;
    return $$0 | 0;
   }
   break;
  }
 default:
  {}
 }
 $$0 = _prvTidyHTMLVersion($doc) | 0;
 return $$0 | 0;
}

function _tidyCreate() {
 var $2 = 0;
 $2 = FUNCTION_TABLE_iii[HEAP32[HEAP32[16551] >> 2] & 31](66204, 6876) | 0;
 _memset($2 | 0, 0, 6876) | 0;
 HEAP32[$2 + 6856 >> 2] = 66204;
 _prvTidyInitMap();
 _prvTidyInitTags($2);
 _prvTidyInitAttrs($2);
 _prvTidyInitConfig($2);
 _prvTidyInitPrintBuf($2);
 HEAP32[$2 + 6784 >> 2] = _prvTidyStdErrOutput() | 0;
 return $2 | 0;
}

function _tidyBufPopByte($buf) {
 $buf = $buf | 0;
 var $1 = 0, $2 = 0, $4 = 0, $bv$0 = 0;
 if (!$buf) ___assert_fail(225860, 225754, 187, 225938);
 $1 = $buf + 8 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 if (!$2) {
  $bv$0 = -1;
  return $bv$0 | 0;
 }
 $4 = $2 + -1 | 0;
 HEAP32[$1 >> 2] = $4;
 $bv$0 = HEAPU8[(HEAP32[$buf + 4 >> 2] | 0) + $4 >> 0] | 0;
 return $bv$0 | 0;
}

function _insrc_ungetByte($appData, $bv) {
 $appData = $appData | 0;
 $bv = $bv | 0;
 var $0 = 0, $1 = 0, $3 = 0;
 $0 = $appData + 16 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) return;
 $3 = $1 + -1 | 0;
 HEAP32[$0 >> 2] = $3;
 if ((HEAP8[(HEAP32[$appData + 4 >> 2] | 0) + $3 >> 0] | 0) == $bv << 24 >> 24) return; else ___assert_fail(225727, 225754, 215, 225843);
}

function _prvTidySetOptionBool($doc, $optId, $val) {
 $doc = $doc | 0;
 $optId = $optId | 0;
 $val = $val | 0;
 var $0 = 0, $1 = 0;
 $0 = $optId >>> 0 < 98;
 $1 = $0 & 1;
 if (!$0) return $1 | 0;
 if ((HEAP32[1892 + ($optId << 5) + 12 >> 2] | 0) != 2) ___assert_fail(224203, 223800, 409, 224244);
 HEAP32[$doc + 72 + ($optId << 2) >> 2] = $val;
 return $1 | 0;
}

function _insrc_getByte($appData) {
 $appData = $appData | 0;
 var $0 = 0, $1 = 0, $bv$0$i = 0;
 $0 = $appData + 16 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if ($1 >>> 0 >= (HEAP32[$appData + 8 >> 2] | 0) >>> 0) {
  $bv$0$i = -1;
  return $bv$0$i | 0;
 }
 HEAP32[$0 >> 2] = $1 + 1;
 $bv$0$i = HEAPU8[(HEAP32[$appData + 4 >> 2] | 0) + $1 >> 0] | 0;
 return $bv$0$i | 0;
}

function _prvTidySetOptionInt($doc, $optId, $val) {
 $doc = $doc | 0;
 $optId = $optId | 0;
 $val = $val | 0;
 var $0 = 0, $1 = 0;
 $0 = $optId >>> 0 < 98;
 $1 = $0 & 1;
 if (!$0) return $1 | 0;
 if ((HEAP32[1892 + ($optId << 5) + 12 >> 2] | 0) != 1) ___assert_fail(223759, 223800, 398, 223889);
 HEAP32[$doc + 72 + ($optId << 2) >> 2] = $val;
 return $1 | 0;
}

function _prvTidytmbstrtoupper($s) {
 $s = $s | 0;
 var $0 = 0, $3 = 0, $cp$01 = 0;
 $0 = HEAP8[$s >> 0] | 0;
 if (!($0 << 24 >> 24)) return $s | 0; else {
  $3 = $0;
  $cp$01 = $s;
 }
 do {
  HEAP8[$cp$01 >> 0] = _prvTidyToUpper($3 << 24 >> 24) | 0;
  $cp$01 = $cp$01 + 1 | 0;
  $3 = HEAP8[$cp$01 >> 0] | 0;
 } while ($3 << 24 >> 24 != 0);
 return $s | 0;
}

function _prvTidytmbstrtolower($s) {
 $s = $s | 0;
 var $0 = 0, $3 = 0, $cp$01 = 0;
 $0 = HEAP8[$s >> 0] | 0;
 if (!($0 << 24 >> 24)) return $s | 0; else {
  $3 = $0;
  $cp$01 = $s;
 }
 do {
  HEAP8[$cp$01 >> 0] = _prvTidyToLower($3 << 24 >> 24) | 0;
  $cp$01 = $cp$01 + 1 | 0;
  $3 = HEAP8[$cp$01 >> 0] | 0;
 } while ($3 << 24 >> 24 != 0);
 return $s | 0;
}

function ___shlim($f, $lim) {
 $f = $f | 0;
 $lim = $lim | 0;
 var $2 = 0, $4 = 0, $5 = 0;
 HEAP32[$f + 104 >> 2] = $lim;
 $2 = HEAP32[$f + 8 >> 2] | 0;
 $4 = HEAP32[$f + 4 >> 2] | 0;
 $5 = $2 - $4 | 0;
 HEAP32[$f + 108 >> 2] = $5;
 if (($lim | 0) != 0 & ($5 | 0) > ($lim | 0)) HEAP32[$f + 100 >> 2] = $4 + $lim; else HEAP32[$f + 100 >> 2] = $2;
 return;
}

function _tidyBufDetach($buf) {
 $buf = $buf | 0;
 var $0 = 0;
 $0 = HEAP32[$buf >> 2] | 0;
 if (!$buf) ___assert_fail(225860, 225754, 70, 225887); else {
  HEAP32[$buf >> 2] = 0;
  HEAP32[$buf + 4 >> 2] = 0;
  HEAP32[$buf + 8 >> 2] = 0;
  HEAP32[$buf + 12 >> 2] = 0;
  HEAP32[$buf + 16 >> 2] = 0;
  HEAP32[$buf >> 2] = $0 | 0 ? $0 : 66204;
  return;
 }
}

function _prvTidyCleanGoogleDocument($doc) {
 $doc = $doc | 0;
 var $0 = 0, $2 = 0;
 _CleanNode($doc, $doc);
 $0 = _prvTidyFindHEAD($doc) | 0;
 if (!$0) return;
 $2 = _prvTidyInferredTag($doc, 68) | 0;
 _prvTidyAddAttribute($doc, $2, 305124, 311587) | 0;
 _prvTidyAddAttribute($doc, $2, 310338, 226704) | 0;
 _prvTidyInsertNodeAtStart($0, $2);
 return;
}

function _tidyBufAttach($buf, $bp, $size) {
 $buf = $buf | 0;
 $bp = $bp | 0;
 $size = $size | 0;
 if (!$buf) ___assert_fail(225860, 225754, 146, 225924);
 HEAP32[$buf + 4 >> 2] = $bp;
 HEAP32[$buf + 12 >> 2] = $size;
 HEAP32[$buf + 8 >> 2] = $size;
 HEAP32[$buf + 16 >> 2] = 0;
 if (HEAP32[$buf >> 2] | 0) return;
 HEAP32[$buf >> 2] = 66204;
 return;
}

function _sn_write($f, $s, $l) {
 $f = $f | 0;
 $s = $s | 0;
 $l = $l | 0;
 var $2 = 0, $3 = 0, $4 = 0, $l$ = 0;
 $2 = $f + 20 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = (HEAP32[$f + 16 >> 2] | 0) - $3 | 0;
 $l$ = $4 >>> 0 > $l >>> 0 ? $l : $4;
 _memcpy($3 | 0, $s | 0, $l$ | 0) | 0;
 HEAP32[$2 >> 2] = (HEAP32[$2 >> 2] | 0) + $l$;
 return $l | 0;
}

function _feof($f) {
 $f = $f | 0;
 var $$lobit = 0, $$lobit2 = 0, $phitmp = 0;
 if ((HEAP32[$f + 76 >> 2] | 0) > -1) {
  $phitmp = (___lockfile($f) | 0) == 0;
  $$lobit = (HEAP32[$f >> 2] | 0) >>> 4 & 1;
  if ($phitmp) $$lobit2 = $$lobit; else $$lobit2 = $$lobit;
 } else $$lobit2 = (HEAP32[$f >> 2] | 0) >>> 4 & 1;
 return $$lobit2 | 0;
}

function _prvTidyfreeStreamIn($in) {
 $in = $in | 0;
 var $0 = 0, $1 = 0, $7 = 0;
 $0 = $in + 8 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$1 >> 2] | 0) + 8 >> 2] & 15]($1, HEAP32[$in + 12 >> 2] | 0);
 $7 = HEAP32[$0 >> 2] | 0;
 FUNCTION_TABLE_vii[HEAP32[(HEAP32[$7 >> 2] | 0) + 8 >> 2] & 15]($7, $in);
 return;
}

function _prvTidynodeIsHeader($node) {
 $node = $node | 0;
 var $12 = 0, $2 = 0, $4 = 0;
 if (!$node) $12 = 0; else {
  $2 = HEAP32[$node + 28 >> 2] | 0;
  if (!$2) $12 = 0; else {
   $4 = HEAP32[$2 >> 2] | 0;
   if (!$4) $12 = 0; else $12 = ($4 | 1 | 0) == 45 | ($4 | 3 | 0) == 43;
  }
 }
 return $12 & 1 | 0;
}

function ___stdio_close($f) {
 $f = $f | 0;
 var $3 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = HEAP32[$f + 60 >> 2];
 $3 = ___syscall_ret(___syscall6(6, $vararg_buffer | 0) | 0) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _prvTidyIsScript($doc, $attrname) {
 $doc = $doc | 0;
 $attrname = $attrname | 0;
 var $1 = 0, $6 = 0, $7 = 0;
 $1 = _attrsLookup($doc, $doc + 1596 | 0, $attrname) | 0;
 if (!$1) {
  $7 = 0;
  $6 = $7 & 1;
  return $6 | 0;
 }
 $7 = (HEAP32[$1 + 8 >> 2] | 0) == 14;
 $6 = $7 & 1;
 return $6 | 0;
}

function _filesrc_getByte($sourceData) {
 $sourceData = $sourceData | 0;
 var $bv$0 = 0;
 if (!(HEAP32[$sourceData + 12 >> 2] | 0)) {
  $bv$0 = _fgetc(HEAP32[$sourceData >> 2] | 0) | 0;
  return $bv$0 | 0;
 } else {
  $bv$0 = _tidyBufPopByte($sourceData + 4 | 0) | 0;
  return $bv$0 | 0;
 }
 return 0;
}

function _prvTidyDisplayHTMLTableAlgorithm($doc) {
 $doc = $doc | 0;
 var $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = _tidyLocalizedString(2077) | 0;
 _tidy_out($doc, 223602, $vararg_buffer);
 STACKTOP = sp;
 return;
}

function _prvTidyAccessibilityHelloMessage($doc) {
 $doc = $doc | 0;
 var $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = _tidyLocalizedString(2058) | 0;
 _tidy_out($doc, 223715, $vararg_buffer);
 STACKTOP = sp;
 return;
}

function _prvTidyIsUrl($doc, $attrname) {
 $doc = $doc | 0;
 $attrname = $attrname | 0;
 var $1 = 0, $6 = 0, $7 = 0;
 $1 = _attrsLookup($doc, $doc + 1596 | 0, $attrname) | 0;
 if (!$1) {
  $7 = 0;
  $6 = $7 & 1;
  return $6 | 0;
 }
 $7 = (HEAP32[$1 + 8 >> 2] | 0) == 5;
 $6 = $7 & 1;
 return $6 | 0;
}

function _prvTidyNeedsAuthorIntervention($doc) {
 $doc = $doc | 0;
 var $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = _tidyLocalizedString(2085) | 0;
 _tidy_out($doc, 223602, $vararg_buffer);
 STACKTOP = sp;
 return;
}

function _prvTidytmbvsnprintf($buffer, $count, $format, $args) {
 $buffer = $buffer | 0;
 $count = $count | 0;
 $format = $format | 0;
 $args = $args | 0;
 var $0 = 0, $1 = 0;
 $0 = $count + -1 | 0;
 $1 = _vsnprintf($buffer, $0, $format, $args) | 0;
 HEAP8[$buffer + $0 >> 0] = 0;
 return $1 | 0;
}

function _prvTidynodeHasCM($node, $contentModel) {
 $node = $node | 0;
 $contentModel = $contentModel | 0;
 var $2 = 0, $9 = 0;
 if (!$node) $9 = 0; else {
  $2 = HEAP32[$node + 28 >> 2] | 0;
  if (!$2) $9 = 0; else $9 = (HEAP32[$2 + 16 >> 2] & $contentModel | 0) != 0;
 }
 return $9 & 1 | 0;
}

function _filesrc_eof($sourceData) {
 $sourceData = $sourceData | 0;
 var $2 = 0, $isEOF$0 = 0;
 $2 = (HEAP32[$sourceData + 12 >> 2] | 0) == 0;
 if (!$2) {
  $isEOF$0 = $2 & 1;
  return $isEOF$0 | 0;
 }
 $isEOF$0 = (_feof(HEAP32[$sourceData >> 2] | 0) | 0) != 0 & 1;
 return $isEOF$0 | 0;
}

function _sprintf($s, $fmt, $varargs) {
 $s = $s | 0;
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $0 = 0, $ap = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 HEAP32[$ap >> 2] = $varargs;
 $0 = _vsprintf($s, $fmt, $ap) | 0;
 STACKTOP = sp;
 return $0 | 0;
}

function _fprintf($f, $fmt, $varargs) {
 $f = $f | 0;
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $0 = 0, $ap = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 HEAP32[$ap >> 2] = $varargs;
 $0 = _vfprintf($f, $fmt, $ap) | 0;
 STACKTOP = sp;
 return $0 | 0;
}

function _sscanf($s, $fmt, $varargs) {
 $s = $s | 0;
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $0 = 0, $ap = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 HEAP32[$ap >> 2] = $varargs;
 $0 = _vsscanf($s, $fmt, $ap) | 0;
 STACKTOP = sp;
 return $0 | 0;
}

function _bitshift64Ashr(low, high, bits) {
 low = low | 0;
 high = high | 0;
 bits = bits | 0;
 if ((bits | 0) < 32) {
  tempRet0 = high >> bits;
  return low >>> bits | (high & (1 << bits) - 1) << 32 - bits;
 }
 tempRet0 = (high | 0) < 0 ? -1 : 0;
 return high >> bits - 32 | 0;
}

function _printf($fmt, $varargs) {
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $1 = 0, $ap = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 HEAP32[$ap >> 2] = $varargs;
 $1 = _vfprintf(HEAP32[55056] | 0, $fmt, $ap) | 0;
 STACKTOP = sp;
 return $1 | 0;
}

function _tidyOptGetDocLinksList($tdoc, $opt) {
 $tdoc = $tdoc | 0;
 $opt = $opt | 0;
 var $$0$i = 0, $2 = 0;
 if (!$opt) $$0$i = 98; else $$0$i = HEAP32[$opt >> 2] | 0;
 $2 = _prvTidyOptGetDocDesc($$0$i) | 0;
 if (!$2) return 0; else return HEAP32[$2 + 4 >> 2] | 0;
 return 0;
}

function _tidyGetNextOption($tdoc, $pos) {
 $tdoc = $tdoc | 0;
 $pos = $pos | 0;
 var $option$0 = 0;
 if (!$tdoc) if (!$pos) $option$0 = 0; else {
  HEAP32[$pos >> 2] = 0;
  $option$0 = 0;
 } else $option$0 = _prvTidygetNextOption($tdoc, $pos) | 0;
 return $option$0 | 0;
}

function _prvTidyFindParser($doc, $node) {
 $doc = $doc | 0;
 $node = $node | 0;
 var $$0 = 0, $3 = 0;
 $3 = _tagsLookup($doc, $doc + 876 | 0, HEAP32[$node + 32 >> 2] | 0) | 0;
 if (!$3) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = HEAP32[$3 + 20 >> 2] | 0;
 return $$0 | 0;
}

function _tidyOptGetBool($tdoc, $optId) {
 $tdoc = $tdoc | 0;
 $optId = $optId | 0;
 var $optb$1 = 0;
 if (!$tdoc) $optb$1 = 0; else if (!(_prvTidygetOption($optId) | 0)) $optb$1 = 0; else $optb$1 = HEAP32[$tdoc + 72 + ($optId << 2) >> 2] | 0;
 return $optb$1 | 0;
}

function _bitshift64Shl(low, high, bits) {
 low = low | 0;
 high = high | 0;
 bits = bits | 0;
 if ((bits | 0) < 32) {
  tempRet0 = high << bits | (low & (1 << bits) - 1 << 32 - bits) >>> 32 - bits;
  return low << bits;
 }
 tempRet0 = low << bits - 32;
 return 0;
}

function _prvTidyIsBoolAttribute($attval) {
 $attval = $attval | 0;
 var $$0 = 0, $2 = 0;
 if ($attval | 0) {
  $2 = HEAP32[$attval + 4 >> 2] | 0;
  if ($2 | 0) if ((HEAP32[$2 + 8 >> 2] | 0) == 4) {
   $$0 = 1;
   return $$0 | 0;
  }
 }
 $$0 = 0;
 return $$0 | 0;
}

function _prvTidyCombineSurrogatePair($high, $low) {
 $high = $high | 0;
 $low = $low | 0;
 if (($high & -1024 | 0) == 56320 & ($low & -1024 | 0) == 55296) return $high + -56613888 + ($low << 10) | 0; else ___assert_fail(226246, 226301, 498, 226388);
 return 0;
}

function _bitshift64Lshr(low, high, bits) {
 low = low | 0;
 high = high | 0;
 bits = bits | 0;
 if ((bits | 0) < 32) {
  tempRet0 = high >>> bits;
  return low >>> bits | (high & (1 << bits) - 1) << 32 - bits;
 }
 tempRet0 = 0;
 return high >>> bits - 32 | 0;
}

function _prvTidyIsNewNode($node) {
 $node = $node | 0;
 var $$0 = 0, $2 = 0;
 if (!$node) {
  $$0 = 1;
  return $$0 | 0;
 }
 $2 = HEAP32[$node + 28 >> 2] | 0;
 if (!$2) {
  $$0 = 1;
  return $$0 | 0;
 }
 $$0 = HEAP32[$2 + 16 >> 2] & 1048576;
 return $$0 | 0;
}

function dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 a5 = a5 | 0;
 a6 = a6 | 0;
 return FUNCTION_TABLE_iiiiiii[index & 0](a1 | 0, a2 | 0, a3 | 0, a4 | 0, a5 | 0, a6 | 0) | 0;
}

function copyTempFloat(ptr) {
 ptr = ptr | 0;
 HEAP8[tempDoublePtr >> 0] = HEAP8[ptr >> 0];
 HEAP8[tempDoublePtr + 1 >> 0] = HEAP8[ptr + 1 >> 0];
 HEAP8[tempDoublePtr + 2 >> 0] = HEAP8[ptr + 2 >> 0];
 HEAP8[tempDoublePtr + 3 >> 0] = HEAP8[ptr + 3 >> 0];
}

function _tidyOptParseValue($tdoc, $optnam, $val) {
 $tdoc = $tdoc | 0;
 $optnam = $optnam | 0;
 $val = $val | 0;
 var $$0 = 0;
 if (!$tdoc) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = _prvTidyParseConfigOption($tdoc, $optnam, $val) | 0;
 return $$0 | 0;
}

function _prvTidyattrIsEvent($attval) {
 $attval = $attval | 0;
 var $2 = 0, $6 = 0;
 if (!$attval) $6 = 0; else {
  $2 = HEAP32[$attval + 4 >> 2] | 0;
  if (!$2) $6 = 0; else $6 = ((HEAP32[$2 >> 2] | 0) + -91 | 0) >>> 0 < 27;
 }
 return $6 & 1 | 0;
}

function _tidyOptGetEncName($tdoc, $optId) {
 $tdoc = $tdoc | 0;
 $optId = $optId | 0;
 var $opti$0$i = 0;
 if (!$tdoc) $opti$0$i = 0; else $opti$0$i = HEAP32[$tdoc + 72 + ($optId << 2) >> 2] | 0;
 return _prvTidyCharEncodingOptName($opti$0$i) | 0;
}

function _prvTidyFindAttribute($doc, $attval) {
 $doc = $doc | 0;
 $attval = $attval | 0;
 var $$0 = 0;
 if (!$attval) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = _attrsLookup($doc, $doc + 1596 | 0, HEAP32[$attval + 20 >> 2] | 0) | 0;
 return $$0 | 0;
}

function _tidyParseStdin($tdoc) {
 $tdoc = $tdoc | 0;
 var $3 = 0, $4 = 0;
 $3 = _prvTidyFileInput($tdoc, HEAP32[55086] | 0, HEAP32[$tdoc + 92 >> 2] | 0) | 0;
 $4 = _prvTidyDocParseStream($tdoc, $3) | 0;
 _prvTidyfreeStreamIn($3);
 return $4 | 0;
}

function _tidyOptSetValue($tdoc, $optId, $val) {
 $tdoc = $tdoc | 0;
 $optId = $optId | 0;
 $val = $val | 0;
 var $$0 = 0;
 if (!$tdoc) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = _prvTidyParseConfigValue($tdoc, $optId, $val) | 0;
 return $$0 | 0;
}

function _tidyOptGetValue($tdoc, $optId) {
 $tdoc = $tdoc | 0;
 $optId = $optId | 0;
 var $optval$0 = 0;
 if (!$tdoc) {
  $optval$0 = 0;
  return $optval$0 | 0;
 }
 $optval$0 = HEAP32[$tdoc + 72 + ($optId << 2) >> 2] | 0;
 return $optval$0 | 0;
}

function _prvTidyIsValidCombinedChar($ch) {
 $ch = $ch | 0;
 var $5 = 0, $6 = 0;
 if ($ch >>> 0 < 65536 | ($ch & 65534 | 0) == 65534) {
  $6 = 0;
  $5 = $6 & 1;
  return $5 | 0;
 }
 $6 = ($ch & 65535 | 0) != 65535;
 $5 = $6 & 1;
 return $5 | 0;
}

function _mapped_getByte($sourceData) {
 $sourceData = $sourceData | 0;
 var $0 = 0, $1 = 0;
 $0 = $sourceData + 8 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 HEAP32[$0 >> 2] = $1 + 1;
 return HEAPU8[(HEAP32[$sourceData + 4 >> 2] | 0) + $1 >> 0] | 0 | 0;
}

function _defaultFree($allocator, $mem) {
 $allocator = $allocator | 0;
 $mem = $mem | 0;
 var $1 = 0;
 if (!$mem) return;
 $1 = HEAP32[79253] | 0;
 if (!$1) {
  _free($mem);
  return;
 } else {
  FUNCTION_TABLE_vi[$1 & 3]($mem);
  return;
 }
}

function _tidyOptSetBool($tdoc, $optId, $val) {
 $tdoc = $tdoc | 0;
 $optId = $optId | 0;
 $val = $val | 0;
 var $$0 = 0;
 if (!$tdoc) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = _prvTidySetOptionBool($tdoc, $optId, $val) | 0;
 return $$0 | 0;
}

function _tidyOptSetInt($tdoc, $optId, $val) {
 $tdoc = $tdoc | 0;
 $optId = $optId | 0;
 $val = $val | 0;
 var $$0 = 0;
 if (!$tdoc) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = _prvTidySetOptionInt($tdoc, $optId, $val) | 0;
 return $$0 | 0;
}

function _CheckRDFaSafeCURIE($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 if ($attval | 0) if (HEAP32[$attval + 24 >> 2] | 0) return;
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 return;
}

function _prvTidyIsHTMLSpace($c) {
 $c = $c | 0;
 var $1 = 0, $switch$cast = 0;
 $switch$cast = $c + -9 | 0;
 if ($switch$cast >>> 0 >= 24) {
  $1 = 0;
  return $1 | 0;
 }
 $1 = 8388635 >>> ($switch$cast & 16777215) & 1;
 return $1 | 0;
}

function _prvTidynodeCMIsInline($node) {
 $node = $node | 0;
 var $2 = 0, $9 = 0;
 if (!$node) $9 = 0; else {
  $2 = HEAP32[$node + 28 >> 2] | 0;
  if (!$2) $9 = 0; else $9 = (HEAP32[$2 + 16 >> 2] & 16 | 0) != 0;
 }
 return $9 & 1 | 0;
}

function _prvTidynodeCMIsEmpty($node) {
 $node = $node | 0;
 var $2 = 0, $9 = 0;
 if (!$node) $9 = 0; else {
  $2 = HEAP32[$node + 28 >> 2] | 0;
  if (!$2) $9 = 0; else $9 = (HEAP32[$2 + 16 >> 2] & 1 | 0) != 0;
 }
 return $9 & 1 | 0;
}

function _tidyOptGetInt($tdoc, $optId) {
 $tdoc = $tdoc | 0;
 $optId = $optId | 0;
 var $opti$0 = 0;
 if (!$tdoc) {
  $opti$0 = 0;
  return $opti$0 | 0;
 }
 $opti$0 = HEAP32[$tdoc + 72 + ($optId << 2) >> 2] | 0;
 return $opti$0 | 0;
}

function _CheckRDFaTerm($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 if ($attval | 0) if (HEAP32[$attval + 24 >> 2] | 0) return;
 _prvTidyReportAttrError($doc, $node, $attval, 702);
 return;
}

function runPostSets() {}
function _i64Subtract(a, b, c, d) {
 a = a | 0;
 b = b | 0;
 c = c | 0;
 d = d | 0;
 var h = 0;
 h = b - d >>> 0;
 h = b - d - (c >>> 0 > a >>> 0 | 0) >>> 0;
 return (tempRet0 = h, a - c >>> 0 | 0) | 0;
}

function dynCall_iiiiii(index, a1, a2, a3, a4, a5) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 a5 = a5 | 0;
 return FUNCTION_TABLE_iiiiii[index & 0](a1 | 0, a2 | 0, a3 | 0, a4 | 0, a5 | 0) | 0;
}

function _CheckAction($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 if (!$attval) return;
 if (!(HEAP32[$attval + 24 >> 2] | 0)) return;
 _prvTidyCheckUrl($doc, $node, $attval);
 return;
}

function _tidyOptResetToDefault($tdoc, $optId) {
 $tdoc = $tdoc | 0;
 $optId = $optId | 0;
 var $$0 = 0;
 if (!$tdoc) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = _prvTidyResetOptionToDefault($tdoc, $optId) | 0;
 return $$0 | 0;
}

function _prvTidyIsNewline($c) {
 $c = $c | 0;
 var $3 = 0, $4 = 0;
 if ($c >>> 0 >= 128) {
  $4 = 0;
  $3 = $4 & 1;
  return $3 | 0;
 }
 $4 = (HEAP32[316488 + ($c << 2) >> 2] & 16 | 0) != 0;
 $3 = $4 & 1;
 return $3 | 0;
}

function _prvTidyIsNamechar($c) {
 $c = $c | 0;
 var $3 = 0, $4 = 0;
 if ($c >>> 0 >= 128) {
  $4 = 0;
  $3 = $4 & 1;
  return $3 | 0;
 }
 $4 = (HEAP32[316488 + ($c << 2) >> 2] & 4 | 0) != 0;
 $3 = $4 & 1;
 return $3 | 0;
}

function ___strdup($s) {
 $s = $s | 0;
 var $$0 = 0, $1 = 0, $2 = 0;
 $1 = (_strlen($s) | 0) + 1 | 0;
 $2 = _malloc($1) | 0;
 if (!$2) $$0 = 0; else {
  _memcpy($2 | 0, $s | 0, $1 | 0) | 0;
  $$0 = $2;
 }
 return $$0 | 0;
}

function _tidySystemLocale($result) {
 $result = $result | 0;
 var $0 = 0, $3 = 0;
 $0 = _setlocale(6, 0) | 0;
 $3 = _malloc((_strlen($0) | 0) + 1 | 0) | 0;
 if (!$3) return $3 | 0;
 _strcpy($3, $0) | 0;
 return $3 | 0;
}

function _prvTidyIsUpper($c) {
 $c = $c | 0;
 var $3 = 0, $4 = 0;
 if ($c >>> 0 >= 128) {
  $4 = 0;
  $3 = $4 & 1;
  return $3 | 0;
 }
 $4 = (HEAP32[316488 + ($c << 2) >> 2] & 64 | 0) != 0;
 $3 = $4 & 1;
 return $3 | 0;
}

function _prvTidyIsLetter($c) {
 $c = $c | 0;
 var $3 = 0, $4 = 0;
 if ($c >>> 0 >= 128) {
  $4 = 0;
  $3 = $4 & 1;
  return $3 | 0;
 }
 $4 = (HEAP32[316488 + ($c << 2) >> 2] & 2 | 0) != 0;
 $3 = $4 & 1;
 return $3 | 0;
}

function _tidyLoadConfig($tdoc, $cfgfil) {
 $tdoc = $tdoc | 0;
 $cfgfil = $cfgfil | 0;
 var $$0 = 0;
 if (!$tdoc) {
  $$0 = -22;
  return $$0 | 0;
 }
 $$0 = _prvTidyParseConfigFile($tdoc, $cfgfil) | 0;
 return $$0 | 0;
}

function _prvTidyIsWhite($c) {
 $c = $c | 0;
 var $3 = 0, $4 = 0;
 if ($c >>> 0 >= 128) {
  $4 = 0;
  $3 = $4 & 1;
  return $3 | 0;
 }
 $4 = (HEAP32[316488 + ($c << 2) >> 2] & 8 | 0) != 0;
 $3 = $4 & 1;
 return $3 | 0;
}

function _prvTidyIsDigit($c) {
 $c = $c | 0;
 var $3 = 0, $4 = 0;
 if ($c >>> 0 >= 128) {
  $4 = 0;
  $3 = $4 & 1;
  return $3 | 0;
 }
 $4 = (HEAP32[316488 + ($c << 2) >> 2] & 1 | 0) != 0;
 $3 = $4 & 1;
 return $3 | 0;
}

function _tidyOptGetIdForName($optnam) {
 $optnam = $optnam | 0;
 var $$0 = 0, $0 = 0;
 $0 = _prvTidylookupOption($optnam) | 0;
 if (!$0) {
  $$0 = 98;
  return $$0 | 0;
 }
 $$0 = HEAP32[$0 >> 2] | 0;
 return $$0 | 0;
}

function _IsDigitHex($c) {
 $c = $c | 0;
 var $3 = 0, $4 = 0;
 if ($c >>> 0 >= 128) {
  $4 = 0;
  $3 = $4 & 1;
  return $3 | 0;
 }
 $4 = (HEAP32[316488 + ($c << 2) >> 2] & 128 | 0) != 0;
 $3 = $4 & 1;
 return $3 | 0;
}

function _tidyOptGetNextPick($topt, $pos) {
 $topt = $topt | 0;
 $pos = $pos | 0;
 var $$0 = 0;
 if (!$topt) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = _prvTidygetNextOptionPick($topt, $pos) | 0;
 return $$0 | 0;
}

function _prvTidyConstrainVersion($doc, $vers) {
 $doc = $doc | 0;
 $vers = $vers | 0;
 var $3 = 0;
 $3 = (HEAP32[$doc + 68 >> 2] | 0) + 32 | 0;
 HEAP32[$3 >> 2] = HEAP32[$3 >> 2] & ($vers | 57344);
 return;
}

function _tidyInitInputBuffer($inp, $buf) {
 $inp = $inp | 0;
 $buf = $buf | 0;
 HEAP32[$inp + 4 >> 2] = 11;
 HEAP32[$inp + 12 >> 2] = 12;
 HEAP32[$inp + 8 >> 2] = 10;
 HEAP32[$inp >> 2] = $buf;
 return;
}

function _cmpOpt($e1_, $e2_) {
 $e1_ = $e1_ | 0;
 $e2_ = $e2_ | 0;
 var $1 = 0;
 $1 = _tidyOptGetName(HEAP32[$e1_ >> 2] | 0) | 0;
 return _strcmp($1, _tidyOptGetName(HEAP32[$e2_ >> 2] | 0) | 0) | 0;
}

function _tidyOptGetDeclTagList($tdoc) {
 $tdoc = $tdoc | 0;
 var $declIter$0 = 0;
 if (!$tdoc) $declIter$0 = 0; else $declIter$0 = _prvTidyGetDeclaredTagList($tdoc) | 0;
 return $declIter$0 | 0;
}

function _prvTidyoutBOM($out) {
 $out = $out | 0;
 switch (HEAP32[$out >> 2] | 0) {
 case 11:
 case 10:
 case 9:
 case 4:
  break;
 default:
  return;
 }
 _prvTidyWriteChar(65279, $out);
 return;
}

function _prvTidyInsertAttributeAtStart($node, $av) {
 $node = $node | 0;
 $av = $av | 0;
 var $0 = 0;
 $0 = $node + 20 | 0;
 HEAP32[$av >> 2] = HEAP32[$0 >> 2];
 HEAP32[$0 >> 2] = $av;
 return;
}

function _tidyOptGetDoc($tdoc, $opt) {
 $tdoc = $tdoc | 0;
 $opt = $opt | 0;
 var $$0$i = 0;
 if (!$opt) $$0$i = 98; else $$0$i = HEAP32[$opt >> 2] | 0;
 return _tidyLocalizedString($$0$i) | 0;
}

function _prvTidyDecodeWin1252($c) {
 $c = $c | 0;
 var $$0 = 0;
 if (($c & -32 | 0) != 128) {
  $$0 = $c;
  return $$0 | 0;
 }
 $$0 = HEAP32[6308 + ($c + -128 << 2) >> 2] | 0;
 return $$0 | 0;
}

function _mapped_ungetByte($sourceData, $bv) {
 $sourceData = $sourceData | 0;
 $bv = $bv | 0;
 var $0 = 0;
 $0 = $sourceData + 8 | 0;
 HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;
 return;
}

function dynCall_viiii(index, a1, a2, a3, a4) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 FUNCTION_TABLE_viiii[index & 0](a1 | 0, a2 | 0, a3 | 0, a4 | 0);
}

function _tidyReportDoctype($tdoc) {
 $tdoc = $tdoc | 0;
 var $iret$0 = 0;
 if (!$tdoc) $iret$0 = -22; else {
  _prvTidyReportMarkupVersion($tdoc);
  $iret$0 = 0;
 }
 return $iret$0 | 0;
}

function _prvTidyCharEncodingOptName($encoding) {
 $encoding = $encoding | 0;
 var $0 = 0;
 $0 = _prvTidyGetEncodingOptNameFromTidyId($encoding) | 0;
 return ($0 | 0 ? $0 : 225644) | 0;
}

function ___syscall_ret($r) {
 $r = $r | 0;
 var $$0 = 0;
 if ($r >>> 0 > 4294963200) {
  HEAP32[(___errno_location() | 0) >> 2] = 0 - $r;
  $$0 = -1;
 } else $$0 = $r;
 return $$0 | 0;
}

function _tidyOptIsReadOnly($topt) {
 $topt = $topt | 0;
 var $$0 = 0;
 if (!$topt) {
  $$0 = 1;
  return $$0 | 0;
 }
 $$0 = (HEAP32[$topt + 20 >> 2] | 0) == 0 & 1;
 return $$0 | 0;
}

function _tidyOptGetPickList($topt) {
 $topt = $topt | 0;
 var $$0 = 0;
 if (!$topt) {
  $$0 = -1;
  return $$0 | 0;
 }
 $$0 = _prvTidygetOptionPickList($topt) | 0;
 return $$0 | 0;
}

function _prvTidyCharEncodingName($encoding) {
 $encoding = $encoding | 0;
 var $0 = 0;
 $0 = _prvTidyGetEncodingNameFromTidyId($encoding) | 0;
 return ($0 | 0 ? $0 : 225644) | 0;
}

function _i64Add(a, b, c, d) {
 a = a | 0;
 b = b | 0;
 c = c | 0;
 d = d | 0;
 var l = 0;
 l = a + c >>> 0;
 return (tempRet0 = b + d + (l >>> 0 < a >>> 0 | 0) >>> 0, l | 0) | 0;
}

function _tidyAccessWarningCount($tdoc) {
 $tdoc = $tdoc | 0;
 var $count$0 = 0;
 if (!$tdoc) $count$0 = -1; else $count$0 = HEAP32[$tdoc + 6820 >> 2] | 0;
 return $count$0 | 0;
}

function dynCall_iiii(index, a1, a2, a3) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return FUNCTION_TABLE_iiii[index & 15](a1 | 0, a2 | 0, a3 | 0) | 0;
}

function _tidyWarningCount($tdoc) {
 $tdoc = $tdoc | 0;
 var $count$0 = 0;
 if (!$tdoc) $count$0 = -1; else $count$0 = HEAP32[$tdoc + 6816 >> 2] | 0;
 return $count$0 | 0;
}

function _tidyOptGetCategory($topt) {
 $topt = $topt | 0;
 var $$0 = 0;
 if (!$topt) {
  $$0 = -1;
  return $$0 | 0;
 }
 $$0 = HEAP32[$topt + 4 >> 2] | 0;
 return $$0 | 0;
}

function _prvTidyToUpper($c) {
 $c = $c | 0;
 if ($c >>> 0 < 128) return (HEAP32[316488 + ($c << 2) >> 2] & 32 | 0 ? $c + -32 | 0 : $c) | 0; else return $c | 0;
 return 0;
}

function ___udivdi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 return ___udivmoddi4($a$0, $a$1, $b$0, $b$1, 0) | 0;
}

function _strchr($s, $c) {
 $s = $s | 0;
 $c = $c | 0;
 var $0 = 0;
 $0 = ___strchrnul($s, $c) | 0;
 return ((HEAP8[$0 >> 0] | 0) == ($c & 255) << 24 >> 24 ? $0 : 0) | 0;
}

function _prvTidyToLower($c) {
 $c = $c | 0;
 if ($c >>> 0 < 128) return (HEAP32[316488 + ($c << 2) >> 2] & 64 | 0 ? $c + 32 | 0 : $c) | 0; else return $c | 0;
 return 0;
}

function _tidyErrorCount($tdoc) {
 $tdoc = $tdoc | 0;
 var $count$0 = 0;
 if (!$tdoc) $count$0 = -1; else $count$0 = HEAP32[$tdoc + 6812 >> 2] | 0;
 return $count$0 | 0;
}

function _prvTidygetOptionPickList($option) {
 $option = $option | 0;
 if (!$option) return 0; else return ((HEAP32[$option + 24 >> 2] | 0) == 0 ? 0 : 1) | 0;
 return 0;
}

function _tidyOptGetType($topt) {
 $topt = $topt | 0;
 var $$0 = 0;
 if (!$topt) {
  $$0 = -1;
  return $$0 | 0;
 }
 $$0 = HEAP32[$topt + 12 >> 2] | 0;
 return $$0 | 0;
}

function _CheckTextDir($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 _CheckAttrValidity($doc, $node, $attval, 58552);
 return;
}

function _CheckFsubmit($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 _CheckAttrValidity($doc, $node, $attval, 58564);
 return;
}

function _tidyOptGetName($topt) {
 $topt = $topt | 0;
 var $$0 = 0;
 if (!$topt) {
  $$0 = 0;
  return $$0 | 0;
 }
 $$0 = HEAP32[$topt + 8 >> 2] | 0;
 return $$0 | 0;
}

function _mapped_eof($sourceData) {
 $sourceData = $sourceData | 0;
 return (HEAP32[$sourceData + 8 >> 2] | 0) >>> 0 >= (HEAP32[$sourceData + 12 >> 2] | 0) >>> 0 | 0;
}

function _CheckScroll($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 _CheckAttrValidity($doc, $node, $attval, 58596);
 return;
}

function _CheckVType($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 _CheckAttrValidity($doc, $node, $attval, 58776);
 return;
}

function _CheckShape($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 _CheckAttrValidity($doc, $node, $attval, 58612);
 return;
}

function _CheckScope($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 _CheckAttrValidity($doc, $node, $attval, 58576);
 return;
}

function _prvTidynodeIsElement($node) {
 $node = $node | 0;
 var $6 = 0;
 if (!$node) $6 = 0; else $6 = (HEAP32[$node + 44 >> 2] | 2 | 0) == 7;
 return $6 & 1 | 0;
}

function dynCall_viii(index, a1, a2, a3) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 FUNCTION_TABLE_viii[index & 63](a1 | 0, a2 | 0, a3 | 0);
}

function _prvTidyDeferDup($doc) {
 $doc = $doc | 0;
 var $1 = 0;
 $1 = HEAP32[$doc + 68 >> 2] | 0;
 HEAP32[$1 + 100 >> 2] = 0;
 HEAP32[$1 + 96 >> 2] = 0;
 return;
}

function _AlphaComparator($one, $two) {
 $one = $one | 0;
 $two = $two | 0;
 return _prvTidytmbstrcmp(HEAP32[$one + 20 >> 2] | 0, HEAP32[$two + 20 >> 2] | 0) | 0;
}
function stackAlloc(size) {
 size = size | 0;
 var ret = 0;
 ret = STACKTOP;
 STACKTOP = STACKTOP + size | 0;
 STACKTOP = STACKTOP + 15 & -16;
 return ret | 0;
}

function ___errno_location() {
 var $$0 = 0;
 if (!(HEAP32[79254] | 0)) $$0 = 317060; else $$0 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
 return $$0 | 0;
}

function _prvTidynodeIsText($node) {
 $node = $node | 0;
 var $5 = 0;
 if (!$node) $5 = 0; else $5 = (HEAP32[$node + 44 >> 2] | 0) == 4;
 return $5 & 1 | 0;
}

function _tidyGetOptionList($tdoc) {
 $tdoc = $tdoc | 0;
 var $$0 = 0;
 if (!$tdoc) $$0 = -1; else $$0 = _prvTidygetOptionList($tdoc) | 0;
 return $$0 | 0;
}

function establishStackSpace(stackBase, stackMax) {
 stackBase = stackBase | 0;
 stackMax = stackMax | 0;
 STACKTOP = stackBase;
 STACK_MAX = stackMax;
}

function _prvTidyCharEncodingId($doc, $charenc) {
 $doc = $doc | 0;
 $charenc = $charenc | 0;
 return _prvTidyGetCharEncodingFromOptName($charenc) | 0;
}

function _insrc_eof($appData) {
 $appData = $appData | 0;
 return (HEAP32[$appData + 16 >> 2] | 0) >>> 0 >= (HEAP32[$appData + 8 >> 2] | 0) >>> 0 | 0;
}

function _filesrc_ungetByte($sourceData, $bv) {
 $sourceData = $sourceData | 0;
 $bv = $bv | 0;
 _tidyBufPutByte($sourceData + 4 | 0, $bv);
 return;
}

function _prvTidyParseConfigFile($doc, $file) {
 $doc = $doc | 0;
 $file = $file | 0;
 return _prvTidyParseConfigFileEnc($doc, $file, 226159) | 0;
}

function dynCall_iii(index, a1, a2) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 return FUNCTION_TABLE_iii[index & 31](a1 | 0, a2 | 0) | 0;
}

function _wctomb($s, $wc) {
 $s = $s | 0;
 $wc = $wc | 0;
 var $$0 = 0;
 if (!$s) $$0 = 0; else $$0 = _wcrtomb($s, $wc, 0) | 0;
 return $$0 | 0;
}

function _prvTidyinitFileSink($outp, $fp) {
 $outp = $outp | 0;
 $fp = $fp | 0;
 HEAP32[$outp + 4 >> 2] = 1;
 HEAP32[$outp >> 2] = $fp;
 return;
}

function b3(p0, p1, p2, p3, p4, p5) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 p4 = p4 | 0;
 p5 = p5 | 0;
 abort(3);
 return 0;
}

function _strcat($dest, $src) {
 $dest = $dest | 0;
 $src = $src | 0;
 _strcpy($dest + (_strlen($dest) | 0) | 0, $src) | 0;
 return $dest | 0;
}

function _tidyOptGetId($topt) {
 $topt = $topt | 0;
 var $$0 = 0;
 if (!$topt) $$0 = 98; else $$0 = HEAP32[$topt >> 2] | 0;
 return $$0 | 0;
}

function _prvTidyfilesink_putByte($sinkData, $bv) {
 $sinkData = $sinkData | 0;
 $bv = $bv | 0;
 _fputc($bv & 255, $sinkData) | 0;
 return;
}

function setThrew(threw, value) {
 threw = threw | 0;
 value = value | 0;
 if (!__THREW__) {
  __THREW__ = threw;
  threwValue = value;
 }
}

function _prvTidyInitConfig($doc) {
 $doc = $doc | 0;
 _memset($doc + 72 | 0, 0, 804) | 0;
 _prvTidyResetConfigToDefault($doc);
 return;
}

function _fileno($f) {
 $f = $f | 0;
 if ((HEAP32[$f + 76 >> 2] | 0) > -1) if (___lockfile($f) | 0) {}
 return HEAP32[$f + 60 >> 2] | 0;
}

function dynCall_vii(index, a1, a2) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 FUNCTION_TABLE_vii[index & 15](a1 | 0, a2 | 0);
}

function _vsprintf($s, $fmt, $ap) {
 $s = $s | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 return _vsnprintf($s, 2147483647, $fmt, $ap) | 0;
}

function _prvTidyFreeConfig($doc) {
 $doc = $doc | 0;
 _prvTidyResetConfigToDefault($doc);
 _prvTidyTakeConfigSnapshot($doc);
 return;
}

function _prvTidyIsEOF($in) {
 $in = $in | 0;
 return FUNCTION_TABLE_ii[HEAP32[$in + 316 >> 2] & 31](HEAP32[$in + 304 >> 2] | 0) | 0;
}

function _tidyLocalizedString($messageType) {
 $messageType = $messageType | 0;
 return _tidyLocalizedStringN($messageType, 1) | 0;
}

function _mbsinit($st) {
 $st = $st | 0;
 var $4 = 0;
 if (!$st) $4 = 1; else $4 = (HEAP32[$st >> 2] | 0) == 0;
 return $4 & 1 | 0;
}

function _do_read($f, $buf, $len) {
 $f = $f | 0;
 $buf = $buf | 0;
 $len = $len | 0;
 return ___string_read($f, $buf, $len) | 0;
}

function b8(p0, p1, p2, p3, p4) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 p4 = p4 | 0;
 abort(8);
 return 0;
}

function _outOfMemory() {
 var $0 = 0;
 $0 = HEAP32[55027] | 0;
 _fputs(_tidyLocalizedString(4160) | 0, $0) | 0;
 _exit(1);
}

function _tidyErrorCodeAsString($code) {
 $code = $code | 0;
 if (($code | 0) == 200) HEAP32[79117] = 200;
 return 226729;
}

function _prvTidygetOption($optId) {
 $optId = $optId | 0;
 return ($optId >>> 0 < 98 ? 1892 + ($optId << 5) | 0 : 0) | 0;
}

function _tidyGetOption($tdoc, $optId) {
 $tdoc = $tdoc | 0;
 $optId = $optId | 0;
 return _prvTidygetOption($optId) | 0;
}

function _strncpy($d, $s, $n) {
 $d = $d | 0;
 $s = $s | 0;
 $n = $n | 0;
 ___stpncpy($d, $s, $n) | 0;
 return $d | 0;
}

function dynCall_ii(index, a1) {
 index = index | 0;
 a1 = a1 | 0;
 return FUNCTION_TABLE_ii[index & 31](a1 | 0) | 0;
}

function _strcpy($dest, $src) {
 $dest = $dest | 0;
 $src = $src | 0;
 ___stpcpy($dest, $src) | 0;
 return $dest | 0;
}

function _CheckScript($doc, $node, $attval) {
 $doc = $doc | 0;
 $node = $node | 0;
 $attval = $attval | 0;
 return;
}

function _tidyErrorSummary($tdoc) {
 $tdoc = $tdoc | 0;
 if (!$tdoc) return;
 _prvTidyErrorSummary($tdoc);
 return;
}

function _prvTidyUngetToken($doc) {
 $doc = $doc | 0;
 HEAP32[(HEAP32[$doc + 68 >> 2] | 0) + 12 >> 2] = 1;
 return;
}

function _tolower($c) {
 $c = $c | 0;
 var $1 = 0;
 $1 = (_isupper($c) | 0) == 0;
 return ($1 ? $c : $c | 32) | 0;
}

function _prvTidyStdErrOutput() {
 if (HEAP32[1313] | 0) return 5236;
 HEAP32[1313] = HEAP32[55027];
 return 5236;
}

function _tidyGeneralInfo($tdoc) {
 $tdoc = $tdoc | 0;
 if (!$tdoc) return;
 _prvTidyGeneralInfo($tdoc);
 return;
}

function _fputs($s, $f) {
 $s = $s | 0;
 $f = $f | 0;
 return (_fwrite($s, _strlen($s) | 0, 1, $f) | 0) + -1 | 0;
}

function _setlocale($category, $locale) {
 $category = $category | 0;
 $locale = $locale | 0;
 return 316456;
}

function dynCall_vi(index, a1) {
 index = index | 0;
 a1 = a1 | 0;
 FUNCTION_TABLE_vi[index & 3](a1 | 0);
}

function _cleanup_394($p) {
 $p = $p | 0;
 if (!(HEAP32[$p + 68 >> 2] | 0)) ___unlockfile($p);
 return;
}

function _cleanup_383($p) {
 $p = $p | 0;
 if (!(HEAP32[$p + 68 >> 2] | 0)) ___unlockfile($p);
 return;
}

function _prvTidyIsValidUTF16FromUCS4($ucs4) {
 $ucs4 = $ucs4 | 0;
 return $ucs4 >>> 0 < 1114112 | 0;
}

function _prvTidyInitAttrs($doc) {
 $doc = $doc | 0;
 _memset($doc + 1596 | 0, 0, 4800) | 0;
 return;
}

function _prvTidyGetDeclaredTagList($doc) {
 $doc = $doc | 0;
 return HEAP32[$doc + 880 >> 2] | 0;
}

function _isspace($c) {
 $c = $c | 0;
 return (($c | 0) == 32 | ($c + -9 | 0) >>> 0 < 5) & 1 | 0;
}

function b9(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 abort(9);
}

function _prvTidyIsHighSurrogate($ch) {
 $ch = $ch | 0;
 return ($ch & -1024 | 0) == 56320 | 0;
}

function _prvTidyIsLowSurrogate($ch) {
 $ch = $ch | 0;
 return ($ch & -1024 | 0) == 55296 | 0;
}

function _prvTidyIsHTML5Mode($doc) {
 $doc = $doc | 0;
 return HEAP32[$doc + 6852 >> 2] | 0;
}

function b0(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 abort(0);
 return 0;
}

function _prvTidyIsCombinedChar($ch) {
 $ch = $ch | 0;
 return $ch >>> 0 > 65535 | 0;
}

function _isalpha($c) {
 $c = $c | 0;
 return (($c | 32) + -97 | 0) >>> 0 < 26 | 0;
}

function _copysignl($x, $y) {
 $x = +$x;
 $y = +$y;
 return +(+_copysign($x, $y));
}

function _scalbnl($x, $n) {
 $x = +$x;
 $n = $n | 0;
 return +(+_scalbn($x, $n));
}

function _putchar($c) {
 $c = $c | 0;
 return _fputc($c, HEAP32[55056] | 0) | 0;
}

function dynCall_v(index) {
 index = index | 0;
 FUNCTION_TABLE_v[index & 1]();
}

function _tidyGetLanguage() {
 return HEAP32[(HEAP32[1691] | 0) + 12 >> 2] | 0;
}

function _frexpl($x, $e) {
 $x = +$x;
 $e = $e | 0;
 return +(+_frexp($x, $e));
}

function b5(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 abort(5);
}

function _whichPluralForm_es_mx($n) {
 $n = $n | 0;
 return ($n | 0) != 1 | 0;
}

function _whichPluralForm_en_gb($n) {
 $n = $n | 0;
 return ($n | 0) != 1 | 0;
}

function _isupper($c) {
 $c = $c | 0;
 return ($c + -65 | 0) >>> 0 < 26 | 0;
}

function _whichPluralForm_es($n) {
 $n = $n | 0;
 return ($n | 0) != 1 | 0;
}

function _whichPluralForm_en($n) {
 $n = $n | 0;
 return ($n | 0) != 1 | 0;
}

function _whichPluralForm_fr($n) {
 $n = $n | 0;
 return $n >>> 0 > 1 | 0;
}

function _fmodl($x, $y) {
 $x = +$x;
 $y = +$y;
 return +(+_fmod($x, $y));
}

function b7(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 abort(7);
 return 0;
}

function setTempRet0(value) {
 value = value | 0;
 tempRet0 = value;
}

function _prvTidygetOptionList($doc) {
 $doc = $doc | 0;
 return 1;
}

function _prvTidyPPrintSpaces() {
 HEAP32[16017] = 32;
 return;
}

function _whichPluralForm_zh_cn($n) {
 $n = $n | 0;
 return 0;
}

function stackRestore(top) {
 top = top | 0;
 STACKTOP = top;
}

function b2(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 abort(2);
}

function _prvTidyPPrintTabs() {
 HEAP32[16017] = 9;
 return;
}

function b4(p0) {
 p0 = p0 | 0;
 abort(4);
 return 0;
}

function ___unlockfile($f) {
 $f = $f | 0;
 return;
}

function ___lockfile($f) {
 $f = $f | 0;
 return 0;
}

function _getInstalledLanguageList() {
 return 1;
}

function _tidyLibraryVersion() {
 return 223346;
}

function _getWindowsLanguageList() {
 return 1;
}

function getTempRet0() {
 return tempRet0 | 0;
}

function _dummy1($x) {
 $x = $x | 0;
 return;
}

function stackSave() {
 return STACKTOP | 0;
}

function b1(p0) {
 p0 = p0 | 0;
 abort(1);
}

function _getStringKeyList() {
 return 1;
}

function _getErrorCodeList() {
 return 1;
}

function _tidy_cleanup() {
 return;
}

function _dummy0() {
 return;
}

function b6() {
 abort(6);
}

// EMSCRIPTEN_END_FUNCS
var FUNCTION_TABLE_iiii = [b0,_defaultRealloc,___stdio_write,___stdio_seek,___stdout_write,___stdio_read,_sn_write,_FindDescendant_cb,_do_read,b0,b0,b0,b0,b0,b0,b0];
var FUNCTION_TABLE_vi = [b1,_cleanup_383,_cleanup_394,b1];
var FUNCTION_TABLE_vii = [b2,_prvTidyfilesink_putByte,_CheckAREA,_CheckCaption,_CheckHTML,_CheckIMG,_CheckLINK,_CheckTABLE,_defaultFree,_defaultPanic,_insrc_ungetByte,_mapped_ungetByte,_filesrc_ungetByte,b2,b2,b2];
var FUNCTION_TABLE_iiiiiii = [b3];
var FUNCTION_TABLE_ii = [b4,_whichPluralForm_en,_whichPluralForm_en_gb,_whichPluralForm_es,_whichPluralForm_es_mx,_whichPluralForm_zh_cn,_whichPluralForm_fr,_prvTidyIsNamechar,_prvTidyIsDigit,_IsDigitHex,___stdio_close,_insrc_getByte,_insrc_eof,_mapped_getByte,_mapped_eof,_filesrc_getByte,_filesrc_eof,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4];
var FUNCTION_TABLE_viii = [b5,_CheckAction,_CheckAlign,_CheckColor,_CheckBool,_prvTidyCheckUrl,_CheckNumber,_CheckLength,_CheckClear,_CheckTextDir,_CheckLang,_CheckId,_CheckFsubmit,_CheckName,_CheckScript,_CheckScope,_CheckScroll,_CheckShape,_CheckTarget,_CheckType,_CheckValign,_CheckVType,_CheckRDFaSafeCURIE,_CheckRDFaTerm,_CheckRDFaPrefix,_prvTidyParseBlock,_prvTidyParseInline,_prvTidyParseEmpty,_prvTidyParseBody
,_prvTidyParseColGroup,_prvTidyParseList,_prvTidyParseDefList,_prvTidyParseFrameSet,_prvTidyParseHead,_prvTidyParseHTML,_prvTidyParsePre,_prvTidyParseNamespace,_prvTidyParseNoFrames,_prvTidyParseOptGroup,_prvTidyParseText,_prvTidyParseScript,_prvTidyParseSelect,_prvTidyParseTableTag,_prvTidyParseRowGroup,_prvTidyParseTitle,_prvTidyParseRow,_prvTidyParseDatalist,_printOption,_printOptionValues,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5];
var FUNCTION_TABLE_v = [b6,_tidy_cleanup];
var FUNCTION_TABLE_iii = [b7,_ParseInt,_ParseCharEnc,_ParseNewline,_ParseDocType,_ParseRepeatAttr,_ParseString,_ParseName,_ParseBool,_ParseAutoBool,_ParseCSS1Selector,_ParseTagNames,_ParseSorter,_ParseTabs,_defaultAlloc,_cmpOpt,_AlphaComparator,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7];
var FUNCTION_TABLE_iiiiii = [b8];
var FUNCTION_TABLE_viiii = [b9];

  return { _i64Subtract: _i64Subtract, _free: _free, _main: _main, _i64Add: _i64Add, _memset: _memset, _malloc: _malloc, _memcpy: _memcpy, _bitshift64Lshr: _bitshift64Lshr, _fflush: _fflush, ___errno_location: ___errno_location, _bitshift64Shl: _bitshift64Shl, runPostSets: runPostSets, stackAlloc: stackAlloc, stackSave: stackSave, stackRestore: stackRestore, establishStackSpace: establishStackSpace, setThrew: setThrew, setTempRet0: setTempRet0, getTempRet0: getTempRet0, dynCall_iiii: dynCall_iiii, dynCall_vi: dynCall_vi, dynCall_vii: dynCall_vii, dynCall_iiiiiii: dynCall_iiiiiii, dynCall_ii: dynCall_ii, dynCall_viii: dynCall_viii, dynCall_v: dynCall_v, dynCall_iii: dynCall_iii, dynCall_iiiiii: dynCall_iiiiii, dynCall_viiii: dynCall_viiii };
})
// EMSCRIPTEN_END_ASM
(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
var _free = Module["_free"] = asm["_free"];
var _main = Module["_main"] = asm["_main"];
var _i64Add = Module["_i64Add"] = asm["_i64Add"];
var _memset = Module["_memset"] = asm["_memset"];
var runPostSets = Module["runPostSets"] = asm["runPostSets"];
var _malloc = Module["_malloc"] = asm["_malloc"];
var _memcpy = Module["_memcpy"] = asm["_memcpy"];
var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
var _fflush = Module["_fflush"] = asm["_fflush"];
var ___errno_location = Module["___errno_location"] = asm["___errno_location"];
var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
var dynCall_iiii = Module["dynCall_iiii"] = asm["dynCall_iiii"];
var dynCall_vi = Module["dynCall_vi"] = asm["dynCall_vi"];
var dynCall_vii = Module["dynCall_vii"] = asm["dynCall_vii"];
var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = asm["dynCall_iiiiiii"];
var dynCall_ii = Module["dynCall_ii"] = asm["dynCall_ii"];
var dynCall_viii = Module["dynCall_viii"] = asm["dynCall_viii"];
var dynCall_v = Module["dynCall_v"] = asm["dynCall_v"];
var dynCall_iii = Module["dynCall_iii"] = asm["dynCall_iii"];
var dynCall_iiiiii = Module["dynCall_iiiiii"] = asm["dynCall_iiiiii"];
var dynCall_viiii = Module["dynCall_viiii"] = asm["dynCall_viiii"];
;

Runtime.stackAlloc = asm['stackAlloc'];
Runtime.stackSave = asm['stackSave'];
Runtime.stackRestore = asm['stackRestore'];
Runtime.establishStackSpace = asm['establishStackSpace'];

Runtime.setTempRet0 = asm['setTempRet0'];
Runtime.getTempRet0 = asm['getTempRet0'];



// === Auto-generated postamble setup entry stuff ===



if (memoryInitializer) {
  if (typeof Module['locateFile'] === 'function') {
    memoryInitializer = Module['locateFile'](memoryInitializer);
  } else if (Module['memoryInitializerPrefixURL']) {
    memoryInitializer = Module['memoryInitializerPrefixURL'] + memoryInitializer;
  }
  if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
    var data = Module['readBinary'](memoryInitializer);
    HEAPU8.set(data, Runtime.GLOBAL_BASE);
  } else {
    addRunDependency('memory initializer');
    var applyMemoryInitializer = function(data) {
      if (data.byteLength) data = new Uint8Array(data);
      HEAPU8.set(data, Runtime.GLOBAL_BASE);
      // Delete the typed array that contains the large blob of the memory initializer request response so that
      // we won't keep unnecessary memory lying around. However, keep the XHR object itself alive so that e.g.
      // its .status field can still be accessed later.
      if (Module['memoryInitializerRequest']) delete Module['memoryInitializerRequest'].response;
      removeRunDependency('memory initializer');
    }
    function doBrowserLoad() {
      Module['readAsync'](memoryInitializer, applyMemoryInitializer, function() {
        throw 'could not load memory initializer ' + memoryInitializer;
      });
    }
    if (Module['memoryInitializerRequest']) {
      // a network request has already been created, just use that
      function useRequest() {
        var request = Module['memoryInitializerRequest'];
        if (request.status !== 200 && request.status !== 0) {
          // If you see this warning, the issue may be that you are using locateFile or memoryInitializerPrefixURL, and defining them in JS. That
          // means that the HTML file doesn't know about them, and when it tries to create the mem init request early, does it to the wrong place.
          // Look in your browser's devtools network console to see what's going on.
          console.warn('a problem seems to have happened with Module.memoryInitializerRequest, status: ' + request.status + ', retrying ' + memoryInitializer);
          doBrowserLoad();
          return;
        }
        applyMemoryInitializer(request.response);
      }
      if (Module['memoryInitializerRequest'].response) {
        setTimeout(useRequest, 0); // it's already here; but, apply it asynchronously
      } else {
        Module['memoryInitializerRequest'].addEventListener('load', useRequest); // wait for it
      }
    } else {
      // fetch it from the network ourselves
      doBrowserLoad();
    }
  }
}

function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;

var initialStackTop;
var preloadStartTime = null;
var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!Module['calledRun']) run();
  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
}

Module['callMain'] = Module.callMain = function callMain(args) {

  args = args || [];

  ensureInitRuntime();

  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString(Module['thisProgram']), 'i8', ALLOC_NORMAL) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_NORMAL));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_NORMAL);


  try {

    var ret = Module['_main'](argc, argv, 0);


    // if we're not running an evented main loop, it's time to exit
    exit(ret, /* implicit = */ true);
  }
  catch(e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'SimulateInfiniteLoop') {
      // running an evented main loop, don't immediately exit
      Module['noExitRuntime'] = true;
      return;
    } else {
      if (e && typeof e === 'object' && e.stack) Module.printErr('exception thrown: ' + [e, e.stack]);
      throw e;
    }
  } finally {
    calledMain = true;
  }
}




function run(args) {
  args = args || Module['arguments'];

  if (preloadStartTime === null) preloadStartTime = Date.now();

  if (runDependencies > 0) {
    return;
  }

  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function doRun() {
    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
    Module['calledRun'] = true;

    if (ABORT) return;

    ensureInitRuntime();

    preMain();


    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (Module['_main'] && shouldRunNow) Module['callMain'](args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module['run'] = Module.run = run;

function exit(status, implicit) {
  if (implicit && Module['noExitRuntime']) {
    return;
  }

  if (Module['noExitRuntime']) {
  } else {

    ABORT = true;
    EXITSTATUS = status;
    STACKTOP = initialStackTop;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  if (ENVIRONMENT_IS_NODE) {
    process['exit'](status);
  } else if (ENVIRONMENT_IS_SHELL && typeof quit === 'function') {
    quit(status);
  }
  // if we reach here, we must throw an exception to halt the current execution
  throw new ExitStatus(status);
}
Module['exit'] = Module.exit = exit;

var abortDecorators = [];

function abort(what) {
  if (what !== undefined) {
    Module.print(what);
    Module.printErr(what);
    what = JSON.stringify(what)
  } else {
    what = '';
  }

  ABORT = true;
  EXITSTATUS = 1;

  var extra = '\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.';

  var output = 'abort(' + what + ') at ' + stackTrace() + extra;
  if (abortDecorators) {
    abortDecorators.forEach(function(decorator) {
      output = decorator(output, what);
    });
  }
  throw output;
}
Module['abort'] = Module.abort = abort;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}


run();

// {{POST_RUN_ADDITIONS}}






// {{MODULE_ADDITIONS}}
